'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var EE = require('events');

var Stream = require('stream');

var Yallist = require('yallist');

var SD = require('string_decoder').StringDecoder;

var EOF = Symbol('EOF');
var MAYBE_EMIT_END = Symbol('maybeEmitEnd');
var EMITTED_END = Symbol('emittedEnd');
var EMITTING_END = Symbol('emittingEnd');
var CLOSED = Symbol('closed');
var READ = Symbol('read');
var FLUSH = Symbol('flush');
var FLUSHCHUNK = Symbol('flushChunk');
var ENCODING = Symbol('encoding');
var DECODER = Symbol('decoder');
var FLOWING = Symbol('flowing');
var PAUSED = Symbol('paused');
var RESUME = Symbol('resume');
var BUFFERLENGTH = Symbol('bufferLength');
var BUFFERPUSH = Symbol('bufferPush');
var BUFFERSHIFT = Symbol('bufferShift');
var OBJECTMODE = Symbol('objectMode');
var DESTROYED = Symbol('destroyed'); // TODO remove when Node v8 support drops

var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';
var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');
var ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.

var isEndish = function isEndish(ev) {
  return ev === 'end' || ev === 'finish' || ev === 'prefinish';
};

var isArrayBuffer = function isArrayBuffer(b) {
  return b instanceof ArrayBuffer || _typeof(b) === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;
};

var isArrayBufferView = function isArrayBufferView(b) {
  return !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
};

module.exports =
/*#__PURE__*/
function (_Stream) {
  _inherits(Minipass, _Stream);

  function Minipass(options) {
    var _this;

    _classCallCheck(this, Minipass);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Minipass).call(this));
    _this[FLOWING] = false; // whether we're explicitly paused

    _this[PAUSED] = false;
    _this.pipes = new Yallist();
    _this.buffer = new Yallist();
    _this[OBJECTMODE] = options && options.objectMode || false;
    if (_this[OBJECTMODE]) _this[ENCODING] = null;else _this[ENCODING] = options && options.encoding || null;
    if (_this[ENCODING] === 'buffer') _this[ENCODING] = null;
    _this[DECODER] = _this[ENCODING] ? new SD(_this[ENCODING]) : null;
    _this[EOF] = false;
    _this[EMITTED_END] = false;
    _this[EMITTING_END] = false;
    _this[CLOSED] = false;
    _this.writable = true;
    _this.readable = true;
    _this[BUFFERLENGTH] = 0;
    _this[DESTROYED] = false;
    return _this;
  }

  _createClass(Minipass, [{
    key: "setEncoding",
    value: function setEncoding(enc) {
      this.encoding = enc;
    }
  }, {
    key: "write",
    value: function write(chunk, encoding, cb) {
      if (this[EOF]) throw new Error('write after end');

      if (this[DESTROYED]) {
        this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {
          code: 'ERR_STREAM_DESTROYED'
        }));
        return true;
      }

      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
      if (!encoding) encoding = 'utf8'; // convert array buffers and typed array views into buffers
      // at some point in the future, we may want to do the opposite!
      // leave strings and buffers as-is
      // anything else switches us into object mode

      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set
          this.objectMode = true;
      } // this ensures at this point that the chunk is a buffer or string
      // don't buffer it up or send it to the decoder


      if (!this.objectMode && !chunk.length) {
        if (this[BUFFERLENGTH] !== 0) this.emit('readable');
        if (cb) cb();
        return this.flowing;
      } // fast-path writing strings of same encoding to a stream with
      // an empty buffer, skipping the buffer/decoder dance


      if (typeof chunk === 'string' && !this[OBJECTMODE] && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }

      if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);

      if (this.flowing) {
        // if we somehow have something in the buffer, but we think we're
        // flowing, then we need to flush all that out first, or we get
        // chunks coming in out of order.  Can't emit 'drain' here though,
        // because we're mid-write, so that'd be bad.
        if (this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        this.emit('data', chunk);
      } else this[BUFFERPUSH](chunk);

      if (this[BUFFERLENGTH] !== 0) this.emit('readable');
      if (cb) cb();
      return this.flowing;
    }
  }, {
    key: "read",
    value: function read(n) {
      if (this[DESTROYED]) return null;

      try {
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;
        if (this[OBJECTMODE]) n = null;

        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);
        }

        return this[READ](n || null, this.buffer.head.value);
      } finally {
        this[MAYBE_EMIT_END]();
      }
    }
  }, {
    key: READ,
    value: function value(n, chunk) {
      if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {
        this.buffer.head.value = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit('data', chunk);
      if (!this.buffer.length && !this[EOF]) this.emit('drain');
      return chunk;
    }
  }, {
    key: "end",
    value: function end(chunk, encoding, cb) {
      if (typeof chunk === 'function') cb = chunk, chunk = null;
      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
      if (chunk) this.write(chunk, encoding);
      if (cb) this.once('end', cb);
      this[EOF] = true;
      this.writable = false; // if we haven't written anything, then go ahead and emit,
      // even if we're not reading.
      // we'll re-emit if a new 'end' listener is added anyway.
      // This makes MP more suitable to write-only use cases.

      if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
      return this;
    } // don't let the internal resume be overwritten

  }, {
    key: RESUME,
    value: function value() {
      if (this[DESTROYED]) return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit('resume');
      if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');
    }
  }, {
    key: "resume",
    value: function resume() {
      return this[RESUME]();
    }
  }, {
    key: "pause",
    value: function pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
  }, {
    key: BUFFERPUSH,
    value: function value(chunk) {
      if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;
      return this.buffer.push(chunk);
    }
  }, {
    key: BUFFERSHIFT,
    value: function value() {
      if (this.buffer.length) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;
      }

      return this.buffer.shift();
    }
  }, {
    key: FLUSH,
    value: function value(noDrain) {
      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));

      if (!noDrain && !this.buffer.length && !this[EOF]) this.emit('drain');
    }
  }, {
    key: FLUSHCHUNK,
    value: function value(chunk) {
      return chunk ? (this.emit('data', chunk), this.flowing) : false;
    }
  }, {
    key: "pipe",
    value: function pipe(dest, opts) {
      var _this2 = this;

      if (this[DESTROYED]) return;
      var ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === process.stdout || dest === process.stderr) opts.end = false;else opts.end = opts.end !== false;
      var p = {
        dest: dest,
        opts: opts,
        ondrain: function ondrain(_) {
          return _this2[RESUME]();
        }
      };
      this.pipes.push(p);
      dest.on('drain', p.ondrain);
      this[RESUME](); // piping an ended stream ends immediately

      if (ended && p.opts.end) p.dest.end();
      return dest;
    }
  }, {
    key: "addListener",
    value: function addListener(ev, fn) {
      return this.on(ev, fn);
    }
  }, {
    key: "on",
    value: function on(ev, fn) {
      try {
        return _get(_getPrototypeOf(Minipass.prototype), "on", this).call(this, ev, fn);
      } finally {
        if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (isEndish(ev) && this[EMITTED_END]) {
          _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, ev);

          this.removeAllListeners(ev);
        }
      }
    }
  }, {
    key: MAYBE_EMIT_END,
    value: function value() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit('end');
        this.emit('prefinish');
        this.emit('finish');
        if (this[CLOSED]) this.emit('close');
        this[EMITTING_END] = false;
      }
    }
  }, {
    key: "emit",
    value: function emit(ev, data) {
      var _this3 = this;

      // error and close are only events allowed after calling destroy()
      if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {
        if (!data) return;
        if (this.pipes.length) this.pipes.forEach(function (p) {
          return p.dest.write(data) === false && _this3.pause();
        });
      } else if (ev === 'end') {
        // only actual end gets this treatment
        if (this[EMITTED_END] === true) return;
        this[EMITTED_END] = true;
        this.readable = false;

        if (this[DECODER]) {
          data = this[DECODER].end();

          if (data) {
            this.pipes.forEach(function (p) {
              return p.dest.write(data);
            });

            _get(_getPrototypeOf(Minipass.prototype), "emit", this).call(this, 'data', data);
          }
        }

        this.pipes.forEach(function (p) {
          p.dest.removeListener('drain', p.ondrain);
          if (p.opts.end) p.dest.end();
        });
      } else if (ev === 'close') {
        this[CLOSED] = true; // don't emit close before 'end' and 'finish'

        if (!this[EMITTED_END] && !this[DESTROYED]) return;
      } // TODO: replace with a spread operator when Node v4 support drops

      var args = new Array(arguments.length);
      args[0] = ev;
      args[1] = data;

      if (arguments.length > 2) {
        for (var i = 2; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
      }

      try {
        return _get(_getPrototypeOf(Minipass.prototype), "emit", this).apply(this, args);
      } finally {
        if (!isEndish(ev)) this[MAYBE_EMIT_END]();else this.removeAllListeners(ev);
      }
    } // const all = await stream.collect()

  }, {
    key: "collect",
    value: function collect() {
      var _this4 = this;

      var buf = [];
      if (!this[OBJECTMODE]) buf.dataLength = 0; // set the promise first, in case an error is raised
      // by triggering the flow here.

      var p = this.promise();
      this.on('data', function (c) {
        buf.push(c);
        if (!_this4[OBJECTMODE]) buf.dataLength += c.length;
      });
      return p.then(function () {
        return buf;
      });
    } // const data = await stream.concat()

  }, {
    key: "concat",
    value: function concat() {
      var _this5 = this;

      return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(function (buf) {
        return _this5[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : _this5[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength);
      });
    } // stream.promise().then(() => done, er => emitted error)

  }, {
    key: "promise",
    value: function promise() {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        _this6.on(DESTROYED, function () {
          return reject(new Error('stream destroyed'));
        });

        _this6.on('end', function () {
          return resolve();
        });

        _this6.on('error', function (er) {
          return reject(er);
        });
      });
    } // for await (let chunk of stream)

  }, {
    key: ASYNCITERATOR,
    value: function value() {
      var _this7 = this;

      var next = function next() {
        var res = _this7.read();

        if (res !== null) return Promise.resolve({
          done: false,
          value: res
        });
        if (_this7[EOF]) return Promise.resolve({
          done: true
        });
        var resolve = null;
        var reject = null;

        var onerr = function onerr(er) {
          _this7.removeListener('data', ondata);

          _this7.removeListener('end', onend);

          reject(er);
        };

        var ondata = function ondata(value) {
          _this7.removeListener('error', onerr);

          _this7.removeListener('end', onend);

          _this7.pause();

          resolve({
            value: value,
            done: !!_this7[EOF]
          });
        };

        var onend = function onend() {
          _this7.removeListener('error', onerr);

          _this7.removeListener('data', ondata);

          resolve({
            done: true
          });
        };

        var ondestroy = function ondestroy() {
          return onerr(new Error('stream destroyed'));
        };

        return new Promise(function (res, rej) {
          reject = rej;
          resolve = res;

          _this7.once(DESTROYED, ondestroy);

          _this7.once('error', onerr);

          _this7.once('end', onend);

          _this7.once('data', ondata);
        });
      };

      return {
        next: next
      };
    } // for (let chunk of stream)

  }, {
    key: ITERATOR,
    value: function value() {
      var _this8 = this;

      var next = function next() {
        var value = _this8.read();

        var done = value === null;
        return {
          value: value,
          done: done
        };
      };

      return {
        next: next
      };
    }
  }, {
    key: "destroy",
    value: function destroy(er) {
      if (this[DESTROYED]) {
        if (er) this.emit('error', er);else this.emit(DESTROYED);
        return this;
      }

      this[DESTROYED] = true; // throw away all buffered data, it's never coming out

      this.buffer = new Yallist();
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === 'function' && !this[CLOSED]) this.close();
      if (er) this.emit('error', er);else // if no error to emit, still reject pending promises
        this.emit(DESTROYED);
      return this;
    }
  }, {
    key: "bufferLength",
    get: function get() {
      return this[BUFFERLENGTH];
    }
  }, {
    key: "encoding",
    get: function get() {
      return this[ENCODING];
    },
    set: function set(enc) {
      var _this9 = this;

      if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');

      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length) this.buffer = this.buffer.map(function (chunk) {
          return _this9[DECODER].write(chunk);
        });
      }

      this[ENCODING] = enc;
    }
  }, {
    key: "objectMode",
    get: function get() {
      return this[OBJECTMODE];
    },
    set: function set(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
  }, {
    key: "destroyed",
    get: function get() {
      return this[DESTROYED];
    }
  }, {
    key: "flowing",
    get: function get() {
      return this[FLOWING];
    }
  }, {
    key: "paused",
    get: function get() {
      return this[PAUSED];
    }
  }, {
    key: "emittedEnd",
    get: function get() {
      return this[EMITTED_END];
    }
  }], [{
    key: "isStream",
    value: function isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === 'function' || // readable
      typeof s.write === 'function' && typeof s.end === 'function' // writable
      ));
    }
  }]);

  return Minipass;
}(Stream);