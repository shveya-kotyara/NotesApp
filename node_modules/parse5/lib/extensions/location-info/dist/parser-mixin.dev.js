'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Mixin = require('../../utils/mixin');

var Tokenizer = require('../../tokenizer');

var LocationInfoTokenizerMixin = require('./tokenizer-mixin');

var LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');

var HTML = require('../../common/html'); //Aliases


var $ = HTML.TAG_NAMES;

var LocationInfoParserMixin =
/*#__PURE__*/
function (_Mixin) {
  _inherits(LocationInfoParserMixin, _Mixin);

  function LocationInfoParserMixin(parser) {
    var _this;

    _classCallCheck(this, LocationInfoParserMixin);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LocationInfoParserMixin).call(this, parser));
    _this.parser = parser;
    _this.treeAdapter = _this.parser.treeAdapter;
    _this.posTracker = null;
    _this.lastStartTagToken = null;
    _this.lastFosterParentingLocation = null;
    _this.currentToken = null;
    return _this;
  }

  _createClass(LocationInfoParserMixin, [{
    key: "_setStartLocation",
    value: function _setStartLocation(element) {
      var loc = null;

      if (this.lastStartTagToken) {
        loc = Object.assign({}, this.lastStartTagToken.location);
        loc.startTag = this.lastStartTagToken.location;
      }

      this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }
  }, {
    key: "_setEndLocation",
    value: function _setEndLocation(element, closingToken) {
      var loc = this.treeAdapter.getNodeSourceCodeLocation(element);

      if (loc) {
        if (closingToken.location) {
          var ctLoc = closingToken.location;
          var tn = this.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
          // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.

          var isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;

          if (isClosingEndTag) {
            loc.endTag = Object.assign({}, ctLoc);
            loc.endLine = ctLoc.endLine;
            loc.endCol = ctLoc.endCol;
            loc.endOffset = ctLoc.endOffset;
          } else {
            loc.endLine = ctLoc.startLine;
            loc.endCol = ctLoc.startCol;
            loc.endOffset = ctLoc.startOffset;
          }
        }
      }
    }
  }, {
    key: "_getOverriddenMethods",
    value: function _getOverriddenMethods(mxn, orig) {
      return {
        _bootstrap: function _bootstrap(document, fragmentContext) {
          orig._bootstrap.call(this, document, fragmentContext);

          mxn.lastStartTagToken = null;
          mxn.lastFosterParentingLocation = null;
          mxn.currentToken = null;
          var tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
          mxn.posTracker = tokenizerMixin.posTracker;
          Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {
            onItemPop: function onItemPop(element) {
              mxn._setEndLocation(element, mxn.currentToken);
            }
          });
        },
        _runParsingLoop: function _runParsingLoop(scriptHandler) {
          orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements
          // that remains on open element stack


          for (var i = this.openElements.stackTop; i >= 0; i--) {
            mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
          }
        },
        //Token processing
        _processTokenInForeignContent: function _processTokenInForeignContent(token) {
          mxn.currentToken = token;

          orig._processTokenInForeignContent.call(this, token);
        },
        _processToken: function _processToken(token) {
          mxn.currentToken = token;

          orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated
          //their end location explicitly.


          var requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));

          if (requireExplicitUpdate) {
            for (var i = this.openElements.stackTop; i >= 0; i--) {
              var element = this.openElements.items[i];

              if (this.treeAdapter.getTagName(element) === token.tagName) {
                mxn._setEndLocation(element, token);

                break;
              }
            }
          }
        },
        //Doctype
        _setDocumentType: function _setDocumentType(token) {
          orig._setDocumentType.call(this, token);

          var documentChildren = this.treeAdapter.getChildNodes(this.document);
          var cnLength = documentChildren.length;

          for (var i = 0; i < cnLength; i++) {
            var node = documentChildren[i];

            if (this.treeAdapter.isDocumentTypeNode(node)) {
              this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
              break;
            }
          }
        },
        //Elements
        _attachElementToTree: function _attachElementToTree(element) {
          //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
          //So we will use token location stored in this methods for the element.
          mxn._setStartLocation(element);

          mxn.lastStartTagToken = null;

          orig._attachElementToTree.call(this, element);
        },
        _appendElement: function _appendElement(token, namespaceURI) {
          mxn.lastStartTagToken = token;

          orig._appendElement.call(this, token, namespaceURI);
        },
        _insertElement: function _insertElement(token, namespaceURI) {
          mxn.lastStartTagToken = token;

          orig._insertElement.call(this, token, namespaceURI);
        },
        _insertTemplate: function _insertTemplate(token) {
          mxn.lastStartTagToken = token;

          orig._insertTemplate.call(this, token);

          var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
          this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
        },
        _insertFakeRootElement: function _insertFakeRootElement() {
          orig._insertFakeRootElement.call(this);

          this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
        },
        //Comments
        _appendCommentNode: function _appendCommentNode(token, parent) {
          orig._appendCommentNode.call(this, token, parent);

          var children = this.treeAdapter.getChildNodes(parent);
          var commentNode = children[children.length - 1];
          this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
        },
        //Text
        _findFosterParentingLocation: function _findFosterParentingLocation() {
          //NOTE: store last foster parenting location, so we will be able to find inserted text
          //in case of foster parenting
          mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
          return mxn.lastFosterParentingLocation;
        },
        _insertCharacters: function _insertCharacters(token) {
          orig._insertCharacters.call(this, token);

          var hasFosterParent = this._shouldFosterParentOnInsertion();

          var parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;
          var siblings = this.treeAdapter.getChildNodes(parent);
          var textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;
          var textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position

          var tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);

          if (tnLoc) {
            tnLoc.endLine = token.location.endLine;
            tnLoc.endCol = token.location.endCol;
            tnLoc.endOffset = token.location.endOffset;
          } else {
            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
          }
        }
      };
    }
  }]);

  return LocationInfoParserMixin;
}(Mixin);

module.exports = LocationInfoParserMixin;