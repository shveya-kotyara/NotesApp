'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var defaultTreeAdapter = require('../tree-adapters/default');

var mergeOptions = require('../utils/merge-options');

var doctype = require('../common/doctype');

var HTML = require('../common/html'); //Aliases


var $ = HTML.TAG_NAMES;
var NS = HTML.NAMESPACES; //Default serializer options

var DEFAULT_OPTIONS = {
  treeAdapter: defaultTreeAdapter
}; //Escaping regexes

var AMP_REGEX = /&/g;
var NBSP_REGEX = /\u00a0/g;
var DOUBLE_QUOTE_REGEX = /"/g;
var LT_REGEX = /</g;
var GT_REGEX = />/g; //Serializer

var Serializer =
/*#__PURE__*/
function () {
  function Serializer(node, options) {
    _classCallCheck(this, Serializer);

    this.options = mergeOptions(DEFAULT_OPTIONS, options);
    this.treeAdapter = this.options.treeAdapter;
    this.html = '';
    this.startNode = node;
  } //API


  _createClass(Serializer, [{
    key: "serialize",
    value: function serialize() {
      this._serializeChildNodes(this.startNode);

      return this.html;
    } //Internals

  }, {
    key: "_serializeChildNodes",
    value: function _serializeChildNodes(parentNode) {
      var childNodes = this.treeAdapter.getChildNodes(parentNode);

      if (childNodes) {
        for (var i = 0, cnLength = childNodes.length; i < cnLength; i++) {
          var currentNode = childNodes[i];

          if (this.treeAdapter.isElementNode(currentNode)) {
            this._serializeElement(currentNode);
          } else if (this.treeAdapter.isTextNode(currentNode)) {
            this._serializeTextNode(currentNode);
          } else if (this.treeAdapter.isCommentNode(currentNode)) {
            this._serializeCommentNode(currentNode);
          } else if (this.treeAdapter.isDocumentTypeNode(currentNode)) {
            this._serializeDocumentTypeNode(currentNode);
          }
        }
      }
    }
  }, {
    key: "_serializeElement",
    value: function _serializeElement(node) {
      var tn = this.treeAdapter.getTagName(node);
      var ns = this.treeAdapter.getNamespaceURI(node);
      this.html += '<' + tn;

      this._serializeAttributes(node);

      this.html += '>';

      if (tn !== $.AREA && tn !== $.BASE && tn !== $.BASEFONT && tn !== $.BGSOUND && tn !== $.BR && tn !== $.COL && tn !== $.EMBED && tn !== $.FRAME && tn !== $.HR && tn !== $.IMG && tn !== $.INPUT && tn !== $.KEYGEN && tn !== $.LINK && tn !== $.META && tn !== $.PARAM && tn !== $.SOURCE && tn !== $.TRACK && tn !== $.WBR) {
        var childNodesHolder = tn === $.TEMPLATE && ns === NS.HTML ? this.treeAdapter.getTemplateContent(node) : node;

        this._serializeChildNodes(childNodesHolder);

        this.html += '</' + tn + '>';
      }
    }
  }, {
    key: "_serializeAttributes",
    value: function _serializeAttributes(node) {
      var attrs = this.treeAdapter.getAttrList(node);

      for (var i = 0, attrsLength = attrs.length; i < attrsLength; i++) {
        var attr = attrs[i];
        var value = Serializer.escapeString(attr.value, true);
        this.html += ' ';

        if (!attr.namespace) {
          this.html += attr.name;
        } else if (attr.namespace === NS.XML) {
          this.html += 'xml:' + attr.name;
        } else if (attr.namespace === NS.XMLNS) {
          if (attr.name !== 'xmlns') {
            this.html += 'xmlns:';
          }

          this.html += attr.name;
        } else if (attr.namespace === NS.XLINK) {
          this.html += 'xlink:' + attr.name;
        } else {
          this.html += attr.prefix + ':' + attr.name;
        }

        this.html += '="' + value + '"';
      }
    }
  }, {
    key: "_serializeTextNode",
    value: function _serializeTextNode(node) {
      var content = this.treeAdapter.getTextNodeContent(node);
      var parent = this.treeAdapter.getParentNode(node);
      var parentTn = void 0;

      if (parent && this.treeAdapter.isElementNode(parent)) {
        parentTn = this.treeAdapter.getTagName(parent);
      }

      if (parentTn === $.STYLE || parentTn === $.SCRIPT || parentTn === $.XMP || parentTn === $.IFRAME || parentTn === $.NOEMBED || parentTn === $.NOFRAMES || parentTn === $.PLAINTEXT || parentTn === $.NOSCRIPT) {
        this.html += content;
      } else {
        this.html += Serializer.escapeString(content, false);
      }
    }
  }, {
    key: "_serializeCommentNode",
    value: function _serializeCommentNode(node) {
      this.html += '<!--' + this.treeAdapter.getCommentNodeContent(node) + '-->';
    }
  }, {
    key: "_serializeDocumentTypeNode",
    value: function _serializeDocumentTypeNode(node) {
      var name = this.treeAdapter.getDocumentTypeNodeName(node);
      this.html += '<' + doctype.serializeContent(name, null, null) + '>';
    }
  }]);

  return Serializer;
}(); // NOTE: used in tests and by rewriting stream


Serializer.escapeString = function (str, attrMode) {
  str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');

  if (attrMode) {
    str = str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
  } else {
    str = str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
  }

  return str;
};

module.exports = Serializer;