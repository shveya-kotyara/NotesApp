'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var crypto = require('crypto');

var figgyPudding = require('figgy-pudding');

var Transform = require('stream').Transform;

var SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];
var BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;
var SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/;
var STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)*$/;
var VCHAR_REGEX = /^[\x21-\x7E]+$/;
var SsriOpts = figgyPudding({
  algorithms: {
    "default": ['sha512']
  },
  error: {
    "default": false
  },
  integrity: {},
  options: {
    "default": []
  },
  pickAlgorithm: {
    "default": function _default() {
      return getPrioritizedHash;
    }
  },
  Promise: {
    "default": function _default() {
      return Promise;
    }
  },
  sep: {
    "default": ' '
  },
  single: {
    "default": false
  },
  size: {},
  strict: {
    "default": false
  }
});

var Hash =
/*#__PURE__*/
function () {
  _createClass(Hash, [{
    key: "isHash",
    get: function get() {
      return true;
    }
  }]);

  function Hash(hash, opts) {
    _classCallCheck(this, Hash);

    opts = SsriOpts(opts);
    var strict = !!opts.strict;
    this.source = hash.trim(); // 3.1. Integrity metadata (called "Hash" by ssri)
    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description

    var match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);

    if (!match) {
      return;
    }

    if (strict && !SPEC_ALGORITHMS.some(function (a) {
      return a === match[1];
    })) {
      return;
    }

    this.algorithm = match[1];
    this.digest = match[2];
    var rawOpts = match[3];
    this.options = rawOpts ? rawOpts.slice(1).split('?') : [];
  }

  _createClass(Hash, [{
    key: "hexDigest",
    value: function hexDigest() {
      return this.digest && Buffer.from(this.digest, 'base64').toString('hex');
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "toString",
    value: function toString(opts) {
      var _this = this;

      opts = SsriOpts(opts);

      if (opts.strict) {
        // Strict mode enforces the standard as close to the foot of the
        // letter as it can.
        if (!( // The spec has very restricted productions for algorithms.
        // https://www.w3.org/TR/CSP2/#source-list-syntax
        SPEC_ALGORITHMS.some(function (x) {
          return x === _this.algorithm;
        }) && // Usually, if someone insists on using a "different" base64, we
        // leave it as-is, since there's multiple standards, and the
        // specified is not a URL-safe variant.
        // https://www.w3.org/TR/CSP2/#base64_value
        this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.
        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression
        // https://tools.ietf.org/html/rfc5234#appendix-B.1
        (this.options || []).every(function (opt) {
          return opt.match(VCHAR_REGEX);
        }))) {
          return '';
        }
      }

      var options = this.options && this.options.length ? "?".concat(this.options.join('?')) : '';
      return "".concat(this.algorithm, "-").concat(this.digest).concat(options);
    }
  }]);

  return Hash;
}();

var Integrity =
/*#__PURE__*/
function () {
  function Integrity() {
    _classCallCheck(this, Integrity);
  }

  _createClass(Integrity, [{
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "toString",
    value: function toString(opts) {
      var _this2 = this;

      opts = SsriOpts(opts);
      var sep = opts.sep || ' ';

      if (opts.strict) {
        // Entries must be separated by whitespace, according to spec.
        sep = sep.replace(/\S+/g, ' ');
      }

      return Object.keys(this).map(function (k) {
        return _this2[k].map(function (hash) {
          return Hash.prototype.toString.call(hash, opts);
        }).filter(function (x) {
          return x.length;
        }).join(sep);
      }).filter(function (x) {
        return x.length;
      }).join(sep);
    }
  }, {
    key: "concat",
    value: function concat(integrity, opts) {
      opts = SsriOpts(opts);
      var other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);
      return parse("".concat(this.toString(opts), " ").concat(other), opts);
    }
  }, {
    key: "hexDigest",
    value: function hexDigest() {
      return parse(this, {
        single: true
      }).hexDigest();
    }
  }, {
    key: "match",
    value: function match(integrity, opts) {
      opts = SsriOpts(opts);
      var other = parse(integrity, opts);
      var algo = other.pickAlgorithm(opts);
      return this[algo] && other[algo] && this[algo].find(function (hash) {
        return other[algo].find(function (otherhash) {
          return hash.digest === otherhash.digest;
        });
      }) || false;
    }
  }, {
    key: "pickAlgorithm",
    value: function pickAlgorithm(opts) {
      opts = SsriOpts(opts);
      var pickAlgorithm = opts.pickAlgorithm;
      var keys = Object.keys(this);

      if (!keys.length) {
        throw new Error("No algorithms available for ".concat(JSON.stringify(this.toString())));
      }

      return keys.reduce(function (acc, algo) {
        return pickAlgorithm(acc, algo) || acc;
      });
    }
  }, {
    key: "isIntegrity",
    get: function get() {
      return true;
    }
  }]);

  return Integrity;
}();

module.exports.parse = parse;

function parse(sri, opts) {
  opts = SsriOpts(opts);

  if (typeof sri === 'string') {
    return _parse(sri, opts);
  } else if (sri.algorithm && sri.digest) {
    var fullSri = new Integrity();
    fullSri[sri.algorithm] = [sri];
    return _parse(stringify(fullSri, opts), opts);
  } else {
    return _parse(stringify(sri, opts), opts);
  }
}

function _parse(integrity, opts) {
  // 3.4.3. Parse metadata
  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
  if (opts.single) {
    return new Hash(integrity, opts);
  }

  return integrity.trim().split(/\s+/).reduce(function (acc, string) {
    var hash = new Hash(string, opts);

    if (hash.algorithm && hash.digest) {
      var algo = hash.algorithm;

      if (!acc[algo]) {
        acc[algo] = [];
      }

      acc[algo].push(hash);
    }

    return acc;
  }, new Integrity());
}

module.exports.stringify = stringify;

function stringify(obj, opts) {
  opts = SsriOpts(opts);

  if (obj.algorithm && obj.digest) {
    return Hash.prototype.toString.call(obj, opts);
  } else if (typeof obj === 'string') {
    return stringify(parse(obj, opts), opts);
  } else {
    return Integrity.prototype.toString.call(obj, opts);
  }
}

module.exports.fromHex = fromHex;

function fromHex(hexDigest, algorithm, opts) {
  opts = SsriOpts(opts);
  var optString = opts.options && opts.options.length ? "?".concat(opts.options.join('?')) : '';
  return parse("".concat(algorithm, "-").concat(Buffer.from(hexDigest, 'hex').toString('base64')).concat(optString), opts);
}

module.exports.fromData = fromData;

function fromData(data, opts) {
  opts = SsriOpts(opts);
  var algorithms = opts.algorithms;
  var optString = opts.options && opts.options.length ? "?".concat(opts.options.join('?')) : '';
  return algorithms.reduce(function (acc, algo) {
    var digest = crypto.createHash(algo).update(data).digest('base64');
    var hash = new Hash("".concat(algo, "-").concat(digest).concat(optString), opts);

    if (hash.algorithm && hash.digest) {
      var _algo = hash.algorithm;

      if (!acc[_algo]) {
        acc[_algo] = [];
      }

      acc[_algo].push(hash);
    }

    return acc;
  }, new Integrity());
}

module.exports.fromStream = fromStream;

function fromStream(stream, opts) {
  opts = SsriOpts(opts);
  var P = opts.Promise || Promise;
  var istream = integrityStream(opts);
  return new P(function (resolve, reject) {
    stream.pipe(istream);
    stream.on('error', reject);
    istream.on('error', reject);
    var sri;
    istream.on('integrity', function (s) {
      sri = s;
    });
    istream.on('end', function () {
      return resolve(sri);
    });
    istream.on('data', function () {});
  });
}

module.exports.checkData = checkData;

function checkData(data, sri, opts) {
  opts = SsriOpts(opts);
  sri = parse(sri, opts);

  if (!Object.keys(sri).length) {
    if (opts.error) {
      throw Object.assign(new Error('No valid integrity hashes to check against'), {
        code: 'EINTEGRITY'
      });
    } else {
      return false;
    }
  }

  var algorithm = sri.pickAlgorithm(opts);
  var digest = crypto.createHash(algorithm).update(data).digest('base64');
  var newSri = parse({
    algorithm: algorithm,
    digest: digest
  });
  var match = newSri.match(sri, opts);

  if (match || !opts.error) {
    return match;
  } else if (typeof opts.size === 'number' && data.length !== opts.size) {
    var err = new Error("data size mismatch when checking ".concat(sri, ".\n  Wanted: ").concat(opts.size, "\n  Found: ").concat(data.length));
    err.code = 'EBADSIZE';
    err.found = data.length;
    err.expected = opts.size;
    err.sri = sri;
    throw err;
  } else {
    var _err = new Error("Integrity checksum failed when using ".concat(algorithm, ": Wanted ").concat(sri, ", but got ").concat(newSri, ". (").concat(data.length, " bytes)"));

    _err.code = 'EINTEGRITY';
    _err.found = newSri;
    _err.expected = sri;
    _err.algorithm = algorithm;
    _err.sri = sri;
    throw _err;
  }
}

module.exports.checkStream = checkStream;

function checkStream(stream, sri, opts) {
  opts = SsriOpts(opts);
  var P = opts.Promise || Promise;
  var checker = integrityStream(opts.concat({
    integrity: sri
  }));
  return new P(function (resolve, reject) {
    stream.pipe(checker);
    stream.on('error', reject);
    checker.on('error', reject);
    var sri;
    checker.on('verified', function (s) {
      sri = s;
    });
    checker.on('end', function () {
      return resolve(sri);
    });
    checker.on('data', function () {});
  });
}

module.exports.integrityStream = integrityStream;

function integrityStream(opts) {
  opts = SsriOpts(opts); // For verification

  var sri = opts.integrity && parse(opts.integrity, opts);
  var goodSri = sri && Object.keys(sri).length;
  var algorithm = goodSri && sri.pickAlgorithm(opts);
  var digests = goodSri && sri[algorithm]; // Calculating stream

  var algorithms = Array.from(new Set(opts.algorithms.concat(algorithm ? [algorithm] : [])));
  var hashes = algorithms.map(crypto.createHash);
  var streamSize = 0;
  var stream = new Transform({
    transform: function transform(chunk, enc, cb) {
      streamSize += chunk.length;
      hashes.forEach(function (h) {
        return h.update(chunk, enc);
      });
      cb(null, chunk, enc);
    }
  }).on('end', function () {
    var optString = opts.options && opts.options.length ? "?".concat(opts.options.join('?')) : '';
    var newSri = parse(hashes.map(function (h, i) {
      return "".concat(algorithms[i], "-").concat(h.digest('base64')).concat(optString);
    }).join(' '), opts); // Integrity verification mode

    var match = goodSri && newSri.match(sri, opts);

    if (typeof opts.size === 'number' && streamSize !== opts.size) {
      var err = new Error("stream size mismatch when checking ".concat(sri, ".\n  Wanted: ").concat(opts.size, "\n  Found: ").concat(streamSize));
      err.code = 'EBADSIZE';
      err.found = streamSize;
      err.expected = opts.size;
      err.sri = sri;
      stream.emit('error', err);
    } else if (opts.integrity && !match) {
      var _err2 = new Error("".concat(sri, " integrity checksum failed when using ").concat(algorithm, ": wanted ").concat(digests, " but got ").concat(newSri, ". (").concat(streamSize, " bytes)"));

      _err2.code = 'EINTEGRITY';
      _err2.found = newSri;
      _err2.expected = digests;
      _err2.algorithm = algorithm;
      _err2.sri = sri;
      stream.emit('error', _err2);
    } else {
      stream.emit('size', streamSize);
      stream.emit('integrity', newSri);
      match && stream.emit('verified', match);
    }
  });
  return stream;
}

module.exports.create = createIntegrity;

function createIntegrity(opts) {
  opts = SsriOpts(opts);
  var algorithms = opts.algorithms;
  var optString = opts.options.length ? "?".concat(opts.options.join('?')) : '';
  var hashes = algorithms.map(crypto.createHash);
  return {
    update: function update(chunk, enc) {
      hashes.forEach(function (h) {
        return h.update(chunk, enc);
      });
      return this;
    },
    digest: function digest(enc) {
      var integrity = algorithms.reduce(function (acc, algo) {
        var digest = hashes.shift().digest('base64');
        var hash = new Hash("".concat(algo, "-").concat(digest).concat(optString), opts);

        if (hash.algorithm && hash.digest) {
          var _algo2 = hash.algorithm;

          if (!acc[_algo2]) {
            acc[_algo2] = [];
          }

          acc[_algo2].push(hash);
        }

        return acc;
      }, new Integrity());
      return integrity;
    }
  };
}

var NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos

var DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name
//        for the algorithm, so we guesswork it based on the OpenSSL names.
'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(function (algo) {
  return NODE_HASHES.has(algo);
});

function getPrioritizedHash(algo1, algo2) {
  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;
}