"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require("fs");

var path = require("path");

var mkdirp = require("mkdirp");

var _require = require("chrome-trace-event"),
    Tracer = _require.Tracer;

var validateOptions = require("schema-utils");

var schema = require("../../schemas/plugins/debug/ProfilingPlugin.json");
/** @typedef {import("../../declarations/plugins/debug/ProfilingPlugin").ProfilingPluginOptions} ProfilingPluginOptions */


var inspector = undefined;

try {
  // eslint-disable-next-line node/no-unsupported-features/node-builtins
  inspector = require("inspector");
} catch (e) {
  console.log("Unable to CPU profile in < node 8.0");
}

var Profiler =
/*#__PURE__*/
function () {
  function Profiler(inspector) {
    _classCallCheck(this, Profiler);

    this.session = undefined;
    this.inspector = inspector;
  }

  _createClass(Profiler, [{
    key: "hasSession",
    value: function hasSession() {
      return this.session !== undefined;
    }
  }, {
    key: "startProfiling",
    value: function startProfiling() {
      if (this.inspector === undefined) {
        return Promise.resolve();
      }

      try {
        this.session = new inspector.Session();
        this.session.connect();
      } catch (_) {
        this.session = undefined;
        return Promise.resolve();
      }

      return Promise.all([this.sendCommand("Profiler.setSamplingInterval", {
        interval: 100
      }), this.sendCommand("Profiler.enable"), this.sendCommand("Profiler.start")]);
    }
  }, {
    key: "sendCommand",
    value: function sendCommand(method, params) {
      var _this = this;

      if (this.hasSession()) {
        return new Promise(function (res, rej) {
          return _this.session.post(method, params, function (err, params) {
            if (err !== null) {
              rej(err);
            } else {
              res(params);
            }
          });
        });
      } else {
        return Promise.resolve();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.hasSession()) {
        this.session.disconnect();
      }

      return Promise.resolve();
    }
  }, {
    key: "stopProfiling",
    value: function stopProfiling() {
      return this.sendCommand("Profiler.stop");
    }
  }]);

  return Profiler;
}();
/**
 * an object that wraps Tracer and Profiler with a counter
 * @typedef {Object} Trace
 * @property {Tracer} trace instance of Tracer
 * @property {number} counter Counter
 * @property {Profiler} profiler instance of Profiler
 * @property {Function} end the end function
 */

/**
 * @param {string} outputPath The location where to write the log.
 * @returns {Trace} The trace object
 */


var createTrace = function createTrace(outputPath) {
  var trace = new Tracer({
    noStream: true
  });
  var profiler = new Profiler(inspector);

  if (/\/|\\/.test(outputPath)) {
    var dirPath = path.dirname(outputPath);
    mkdirp.sync(dirPath);
  }

  var fsStream = fs.createWriteStream(outputPath);
  var counter = 0;
  trace.pipe(fsStream); // These are critical events that need to be inserted so that tools like
  // chrome dev tools can load the profile.

  trace.instantEvent({
    name: "TracingStartedInPage",
    id: ++counter,
    cat: ["disabled-by-default-devtools.timeline"],
    args: {
      data: {
        sessionId: "-1",
        page: "0xfff",
        frames: [{
          frame: "0xfff",
          url: "webpack",
          name: ""
        }]
      }
    }
  });
  trace.instantEvent({
    name: "TracingStartedInBrowser",
    id: ++counter,
    cat: ["disabled-by-default-devtools.timeline"],
    args: {
      data: {
        sessionId: "-1"
      }
    }
  });
  return {
    trace: trace,
    counter: counter,
    profiler: profiler,
    end: function end(callback) {
      // Wait until the write stream finishes.
      fsStream.on("finish", function () {
        callback();
      }); // Tear down the readable trace stream.

      trace.push(null);
    }
  };
};

var pluginName = "ProfilingPlugin";

var ProfilingPlugin =
/*#__PURE__*/
function () {
  /**
   * @param {ProfilingPluginOptions=} opts options object
   */
  function ProfilingPlugin(opts) {
    _classCallCheck(this, ProfilingPlugin);

    validateOptions(schema, opts || {}, "Profiling plugin");
    opts = opts || {};
    this.outputPath = opts.outputPath || "events.json";
  }

  _createClass(ProfilingPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var tracer = createTrace(this.outputPath);
      tracer.profiler.startProfiling(); // Compiler Hooks

      Object.keys(compiler.hooks).forEach(function (hookName) {
        compiler.hooks[hookName].intercept(makeInterceptorFor("Compiler", tracer)(hookName));
      });
      Object.keys(compiler.resolverFactory.hooks).forEach(function (hookName) {
        compiler.resolverFactory.hooks[hookName].intercept(makeInterceptorFor("Resolver", tracer)(hookName));
      });
      compiler.hooks.compilation.tap(pluginName, function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory,
            contextModuleFactory = _ref.contextModuleFactory;
        interceptAllHooksFor(compilation, tracer, "Compilation");
        interceptAllHooksFor(normalModuleFactory, tracer, "Normal Module Factory");
        interceptAllHooksFor(contextModuleFactory, tracer, "Context Module Factory");
        interceptAllParserHooks(normalModuleFactory, tracer);
        interceptTemplateInstancesFrom(compilation, tracer);
      }); // We need to write out the CPU profile when we are all done.

      compiler.hooks.done.tapAsync({
        name: pluginName,
        stage: Infinity
      }, function (stats, callback) {
        tracer.profiler.stopProfiling().then(function (parsedResults) {
          if (parsedResults === undefined) {
            tracer.profiler.destroy();
            tracer.trace.flush();
            tracer.end(callback);
            return;
          }

          var cpuStartTime = parsedResults.profile.startTime;
          var cpuEndTime = parsedResults.profile.endTime;
          tracer.trace.completeEvent({
            name: "TaskQueueManager::ProcessTaskFromWorkQueue",
            id: ++tracer.counter,
            cat: ["toplevel"],
            ts: cpuStartTime,
            args: {
              src_file: "../../ipc/ipc_moji_bootstrap.cc",
              src_func: "Accept"
            }
          });
          tracer.trace.completeEvent({
            name: "EvaluateScript",
            id: ++tracer.counter,
            cat: ["devtools.timeline"],
            ts: cpuStartTime,
            dur: cpuEndTime - cpuStartTime,
            args: {
              data: {
                url: "webpack",
                lineNumber: 1,
                columnNumber: 1,
                frame: "0xFFF"
              }
            }
          });
          tracer.trace.instantEvent({
            name: "CpuProfile",
            id: ++tracer.counter,
            cat: ["disabled-by-default-devtools.timeline"],
            ts: cpuEndTime,
            args: {
              data: {
                cpuProfile: parsedResults.profile
              }
            }
          });
          tracer.profiler.destroy();
          tracer.trace.flush();
          tracer.end(callback);
        });
      });
    }
  }]);

  return ProfilingPlugin;
}();

var interceptTemplateInstancesFrom = function interceptTemplateInstancesFrom(compilation, tracer) {
  var mainTemplate = compilation.mainTemplate,
      chunkTemplate = compilation.chunkTemplate,
      hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate,
      moduleTemplates = compilation.moduleTemplates;
  var javascript = moduleTemplates.javascript,
      webassembly = moduleTemplates.webassembly;
  [{
    instance: mainTemplate,
    name: "MainTemplate"
  }, {
    instance: chunkTemplate,
    name: "ChunkTemplate"
  }, {
    instance: hotUpdateChunkTemplate,
    name: "HotUpdateChunkTemplate"
  }, {
    instance: javascript,
    name: "JavaScriptModuleTemplate"
  }, {
    instance: webassembly,
    name: "WebAssemblyModuleTemplate"
  }].forEach(function (templateObject) {
    Object.keys(templateObject.instance.hooks).forEach(function (hookName) {
      templateObject.instance.hooks[hookName].intercept(makeInterceptorFor(templateObject.name, tracer)(hookName));
    });
  });
};

var interceptAllHooksFor = function interceptAllHooksFor(instance, tracer, logLabel) {
  if (Reflect.has(instance, "hooks")) {
    Object.keys(instance.hooks).forEach(function (hookName) {
      instance.hooks[hookName].intercept(makeInterceptorFor(logLabel, tracer)(hookName));
    });
  }
};

var interceptAllParserHooks = function interceptAllParserHooks(moduleFactory, tracer) {
  var moduleTypes = ["javascript/auto", "javascript/dynamic", "javascript/esm", "json", "webassembly/experimental"];
  moduleTypes.forEach(function (moduleType) {
    moduleFactory.hooks.parser["for"](moduleType).tap("ProfilingPlugin", function (parser, parserOpts) {
      interceptAllHooksFor(parser, tracer, "Parser");
    });
  });
};

var makeInterceptorFor = function makeInterceptorFor(instance, tracer) {
  return function (hookName) {
    return {
      register: function register(_ref2) {
        var name = _ref2.name,
            type = _ref2.type,
            context = _ref2.context,
            fn = _ref2.fn;
        var newFn = makeNewProfiledTapFn(hookName, tracer, {
          name: name,
          type: type,
          fn: fn
        });
        return {
          name: name,
          type: type,
          context: context,
          fn: newFn
        };
      }
    };
  };
}; // TODO improve typing

/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */

/**
 * @param {string} hookName Name of the hook to profile.
 * @param {Trace} tracer The trace object.
 * @param {object} options Options for the profiled fn.
 * @param {string} options.name Plugin name
 * @param {string} options.type Plugin type (sync | async | promise)
 * @param {PluginFunction} options.fn Plugin function
 * @returns {PluginFunction} Chainable hooked function.
 */


var makeNewProfiledTapFn = function makeNewProfiledTapFn(hookName, tracer, _ref3) {
  var name = _ref3.name,
      type = _ref3.type,
      fn = _ref3.fn;
  var defaultCategory = ["blink.user_timing"];

  switch (type) {
    case "promise":
      return function () {
        var id = ++tracer.counter;
        tracer.trace.begin({
          name: name,
          id: id,
          cat: defaultCategory
        });
        var promise =
        /** @type {Promise<*>} */
        fn.apply(void 0, arguments);
        return promise.then(function (r) {
          tracer.trace.end({
            name: name,
            id: id,
            cat: defaultCategory
          });
          return r;
        });
      };

    case "async":
      return function () {
        var id = ++tracer.counter;
        tracer.trace.begin({
          name: name,
          id: id,
          cat: defaultCategory
        });

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var callback = args.pop();
        fn.apply(void 0, args.concat([function () {
          tracer.trace.end({
            name: name,
            id: id,
            cat: defaultCategory
          });
          callback.apply(void 0, arguments);
        }]));
      };

    case "sync":
      return function () {
        var id = ++tracer.counter; // Do not instrument ourself due to the CPU
        // profile needing to be the last event in the trace.

        if (name === pluginName) {
          return fn.apply(void 0, arguments);
        }

        tracer.trace.begin({
          name: name,
          id: id,
          cat: defaultCategory
        });
        var r;

        try {
          r = fn.apply(void 0, arguments);
        } catch (error) {
          tracer.trace.end({
            name: name,
            id: id,
            cat: defaultCategory
          });
          throw error;
        }

        tracer.trace.end({
          name: name,
          id: id,
          cat: defaultCategory
        });
        return r;
      };

    default:
      break;
  }
};

module.exports = ProfilingPlugin;
module.exports.Profiler = Profiler;