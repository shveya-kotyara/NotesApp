/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var identifierUtils = require("../util/identifier");

var _require = require("../util/SetHelpers"),
    intersect = _require.intersect;

var validateOptions = require("schema-utils");

var schema = require("../../schemas/plugins/optimize/AggressiveSplittingPlugin.json");
/** @typedef {import("../../declarations/plugins/optimize/AggressiveSplittingPlugin").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */


var moveModuleBetween = function moveModuleBetween(oldChunk, newChunk) {
  return function (module) {
    oldChunk.moveModule(module, newChunk);
  };
};

var isNotAEntryModule = function isNotAEntryModule(entryModule) {
  return function (module) {
    return entryModule !== module;
  };
};

var AggressiveSplittingPlugin =
/*#__PURE__*/
function () {
  /**
   * @param {AggressiveSplittingPluginOptions=} options options object
   */
  function AggressiveSplittingPlugin(options) {
    _classCallCheck(this, AggressiveSplittingPlugin);

    if (!options) options = {};
    validateOptions(schema, options, "Aggressive Splitting Plugin");
    this.options = options;

    if (typeof this.options.minSize !== "number") {
      this.options.minSize = 30 * 1024;
    }

    if (typeof this.options.maxSize !== "number") {
      this.options.maxSize = 50 * 1024;
    }

    if (typeof this.options.chunkOverhead !== "number") {
      this.options.chunkOverhead = 0;
    }

    if (typeof this.options.entryChunkMultiplicator !== "number") {
      this.options.entryChunkMultiplicator = 1;
    }
  }

  _createClass(AggressiveSplittingPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      compiler.hooks.thisCompilation.tap("AggressiveSplittingPlugin", function (compilation) {
        var needAdditionalSeal = false;
        var newSplits;
        var fromAggressiveSplittingSet;
        var chunkSplitDataMap;
        compilation.hooks.optimize.tap("AggressiveSplittingPlugin", function () {
          newSplits = [];
          fromAggressiveSplittingSet = new Set();
          chunkSplitDataMap = new Map();
        });
        compilation.hooks.optimizeChunksAdvanced.tap("AggressiveSplittingPlugin", function (chunks) {
          // Precompute stuff
          var nameToModuleMap = new Map();
          var moduleToNameMap = new Map();
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = compilation.modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var m = _step.value;
              var name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);
              nameToModuleMap.set(name, m);
              moduleToNameMap.set(m, name);
            } // Check used chunk ids

          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var usedIds = new Set();
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = chunks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var chunk = _step2.value;
              usedIds.add(chunk.id);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          var recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];
          var usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;
          var minSize = _this.options.minSize;
          var maxSize = _this.options.maxSize;

          var applySplit = function applySplit(splitData) {
            // Cannot split if id is already taken
            if (splitData.id !== undefined && usedIds.has(splitData.id)) {
              return false;
            } // Get module objects from names


            var selectedModules = splitData.modules.map(function (name) {
              return nameToModuleMap.get(name);
            }); // Does the modules exist at all?

            if (!selectedModules.every(Boolean)) return false; // Check if size matches (faster than waiting for hash)

            var size = selectedModules.reduce(function (sum, m) {
              return sum + m.size();
            }, 0);
            if (size !== splitData.size) return false; // get chunks with all modules

            var selectedChunks = intersect(selectedModules.map(function (m) {
              return new Set(m.chunksIterable);
            })); // No relevant chunks found

            if (selectedChunks.size === 0) return false; // The found chunk is already the split or similar

            if (selectedChunks.size === 1 && Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length) {
              var chunk = Array.from(selectedChunks)[0];
              if (fromAggressiveSplittingSet.has(chunk)) return false;
              fromAggressiveSplittingSet.add(chunk);
              chunkSplitDataMap.set(chunk, splitData);
              return true;
            } // split the chunk into two parts


            var newChunk = compilation.addChunk();
            newChunk.chunkReason = "aggressive splitted";
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = selectedChunks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _chunk = _step3.value;
                selectedModules.forEach(moveModuleBetween(_chunk, newChunk));

                _chunk.split(newChunk);

                _chunk.name = null;
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            fromAggressiveSplittingSet.add(newChunk);
            chunkSplitDataMap.set(newChunk, splitData);

            if (splitData.id !== null && splitData.id !== undefined) {
              newChunk.id = splitData.id;
            }

            return true;
          }; // try to restore to recorded splitting


          var changed = false;

          for (var j = 0; j < usedSplits.length; j++) {
            var splitData = usedSplits[j];
            if (applySplit(splitData)) changed = true;
          } // for any chunk which isn't splitted yet, split it and create a new entry
          // start with the biggest chunk


          var sortedChunks = chunks.slice().sort(function (a, b) {
            var diff1 = b.modulesSize() - a.modulesSize();
            if (diff1) return diff1;
            var diff2 = a.getNumberOfModules() - b.getNumberOfModules();
            if (diff2) return diff2;
            var modulesA = Array.from(a.modulesIterable);
            var modulesB = Array.from(b.modulesIterable);
            modulesA.sort();
            modulesB.sort();
            var aI = modulesA[Symbol.iterator]();
            var bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition

            while (true) {
              var aItem = aI.next();
              var bItem = bI.next();
              if (aItem.done) return 0;
              var aModuleIdentifier = aItem.value.identifier();
              var bModuleIdentifier = bItem.value.identifier();
              if (aModuleIdentifier > bModuleIdentifier) return -1;
              if (aModuleIdentifier < bModuleIdentifier) return 1;
            }
          });
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = sortedChunks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _chunk2 = _step4.value;
              if (fromAggressiveSplittingSet.has(_chunk2)) continue;

              var size = _chunk2.modulesSize();

              if (size > maxSize && _chunk2.getNumberOfModules() > 1) {
                var modules = _chunk2.getModules().filter(isNotAEntryModule(_chunk2.entryModule)).sort(function (a, b) {
                  a = a.identifier();
                  b = b.identifier();
                  if (a > b) return 1;
                  if (a < b) return -1;
                  return 0;
                });

                var selectedModules = [];
                var selectedModulesSize = 0;

                for (var k = 0; k < modules.length; k++) {
                  var _module = modules[k];

                  var newSize = selectedModulesSize + _module.size();

                  if (newSize > maxSize && selectedModulesSize >= minSize) {
                    break;
                  }

                  selectedModulesSize = newSize;
                  selectedModules.push(_module);
                }

                if (selectedModules.length === 0) continue;
                var _splitData = {
                  modules: selectedModules.map(function (m) {
                    return moduleToNameMap.get(m);
                  }).sort(),
                  size: selectedModulesSize
                };

                if (applySplit(_splitData)) {
                  newSplits = (newSplits || []).concat(_splitData);
                  changed = true;
                }
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          if (changed) return true;
        });
        compilation.hooks.recordHash.tap("AggressiveSplittingPlugin", function (records) {
          // 4. save made splittings to records
          var allSplits = new Set();
          var invalidSplits = new Set(); // Check if some splittings are invalid
          // We remove invalid splittings and try again

          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = compilation.chunks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _chunk3 = _step5.value;

              var _splitData3 = chunkSplitDataMap.get(_chunk3);

              if (_splitData3 !== undefined) {
                if (_splitData3.hash && _chunk3.hash !== _splitData3.hash) {
                  // Split was successful, but hash doesn't equal
                  // We can throw away the split since it's useless now
                  invalidSplits.add(_splitData3);
                }
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          if (invalidSplits.size > 0) {
            records.aggressiveSplits = records.aggressiveSplits.filter(function (splitData) {
              return !invalidSplits.has(splitData);
            });
            needAdditionalSeal = true;
          } else {
            // set hash and id values on all (new) splittings
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              for (var _iterator6 = compilation.chunks[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var chunk = _step6.value;

                var _splitData2 = chunkSplitDataMap.get(chunk);

                if (_splitData2 !== undefined) {
                  _splitData2.hash = chunk.hash;
                  _splitData2.id = chunk.id;
                  allSplits.add(_splitData2); // set flag for stats

                  chunk.recorded = true;
                }
              } // Also add all unused historial splits (after the used ones)
              // They can still be used in some future compilation

            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                  _iterator6["return"]();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }

            var recordedSplits = compilation.records && compilation.records.aggressiveSplits;

            if (recordedSplits) {
              var _iteratorNormalCompletion7 = true;
              var _didIteratorError7 = false;
              var _iteratorError7 = undefined;

              try {
                for (var _iterator7 = recordedSplits[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                  var splitData = _step7.value;
                  if (!invalidSplits.has(splitData)) allSplits.add(splitData);
                }
              } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                    _iterator7["return"]();
                  }
                } finally {
                  if (_didIteratorError7) {
                    throw _iteratorError7;
                  }
                }
              }
            } // record all splits


            records.aggressiveSplits = Array.from(allSplits);
            needAdditionalSeal = false;
          }
        });
        compilation.hooks.needAdditionalSeal.tap("AggressiveSplittingPlugin", function () {
          if (needAdditionalSeal) {
            needAdditionalSeal = false;
            return true;
          }
        });
      });
    }
  }]);

  return AggressiveSplittingPlugin;
}();

module.exports = AggressiveSplittingPlugin;