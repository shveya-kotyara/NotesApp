/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var validateOptions = require("schema-utils");

var schema = require("../../schemas/plugins/optimize/MinChunkSizePlugin.json");
/** @typedef {import("../../declarations/plugins/optimize/MinChunkSizePlugin").MinChunkSizePluginOptions} MinChunkSizePluginOptions */


var MinChunkSizePlugin =
/*#__PURE__*/
function () {
  /**
   * @param {MinChunkSizePluginOptions} options options object
   */
  function MinChunkSizePlugin(options) {
    _classCallCheck(this, MinChunkSizePlugin);

    validateOptions(schema, options, "Min Chunk Size Plugin");
    this.options = options;
  }

  _createClass(MinChunkSizePlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var options = this.options;
      var minChunkSize = options.minChunkSize;
      compiler.hooks.compilation.tap("MinChunkSizePlugin", function (compilation) {
        compilation.hooks.optimizeChunksAdvanced.tap("MinChunkSizePlugin", function (chunks) {
          var equalOptions = {
            chunkOverhead: 1,
            entryChunkMultiplicator: 1
          };
          var sortedSizeFilteredExtendedPairCombinations = chunks.reduce(function (combinations, a, idx) {
            // create combination pairs
            for (var i = 0; i < idx; i++) {
              var b = chunks[i];
              combinations.push([b, a]);
            }

            return combinations;
          }, []).filter(function (pair) {
            // check if one of the chunks sizes is smaller than the minChunkSize
            var p0SmallerThanMinChunkSize = pair[0].size(equalOptions) < minChunkSize;
            var p1SmallerThanMinChunkSize = pair[1].size(equalOptions) < minChunkSize;
            return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;
          }).map(function (pair) {
            // extend combination pairs with size and integrated size
            var a = pair[0].size(options);
            var b = pair[1].size(options);
            var ab = pair[0].integratedSize(pair[1], options);
            return [a + b - ab, ab, pair[0], pair[1]];
          }).filter(function (pair) {
            // filter pairs that do not have an integratedSize
            // meaning they can NOT be integrated!
            return pair[1] !== false;
          }).sort(function (a, b) {
            // sadly javascript does an inplace sort here
            // sort by size
            var diff = b[0] - a[0];
            if (diff !== 0) return diff;
            return a[1] - b[1];
          });
          if (sortedSizeFilteredExtendedPairCombinations.length === 0) return;
          var pair = sortedSizeFilteredExtendedPairCombinations[0];
          pair[2].integrate(pair[3], "min-size");
          chunks.splice(chunks.indexOf(pair[3]), 1);
          return true;
        });
      });
    }
  }]);

  return MinChunkSizePlugin;
}();

module.exports = MinChunkSizePlugin;