/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var validateOptions = require("schema-utils");

var schema = require("../../schemas/plugins/optimize/LimitChunkCountPlugin.json");

var LazyBucketSortedSet = require("../util/LazyBucketSortedSet");
/** @typedef {import("../../declarations/plugins/optimize/LimitChunkCountPlugin").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */

/** @typedef {import("../Chunk")} Chunk */

/** @typedef {import("../Compiler")} Compiler */

/**
 * @typedef {Object} ChunkCombination
 * @property {boolean} deleted this is set to true when combination was removed
 * @property {number} sizeDiff
 * @property {number} integratedSize
 * @property {Chunk} a
 * @property {Chunk} b
 * @property {number} aIdx
 * @property {number} bIdx
 * @property {number} aSize
 * @property {number} bSize
 */


var addToSetMap = function addToSetMap(map, key, value) {
  var set = map.get(key);

  if (set === undefined) {
    map.set(key, new Set([value]));
  } else {
    set.add(value);
  }
};

var LimitChunkCountPlugin =
/*#__PURE__*/
function () {
  /**
   * @param {LimitChunkCountPluginOptions=} options options object
   */
  function LimitChunkCountPlugin(options) {
    _classCallCheck(this, LimitChunkCountPlugin);

    if (!options) options = {};
    validateOptions(schema, options, "Limit Chunk Count Plugin");
    this.options = options;
  }
  /**
   * @param {Compiler} compiler the webpack compiler
   * @returns {void}
   */


  _createClass(LimitChunkCountPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var options = this.options;
      compiler.hooks.compilation.tap("LimitChunkCountPlugin", function (compilation) {
        compilation.hooks.optimizeChunksAdvanced.tap("LimitChunkCountPlugin", function (chunks) {
          var maxChunks = options.maxChunks;
          if (!maxChunks) return;
          if (maxChunks < 1) return;
          if (chunks.length <= maxChunks) return;
          var remainingChunksToMerge = chunks.length - maxChunks; // order chunks in a deterministic way

          var orderedChunks = chunks.slice().sort(function (a, b) {
            return a.compareTo(b);
          }); // create a lazy sorted data structure to keep all combinations
          // this is large. Size = chunks * (chunks - 1) / 2
          // It uses a multi layer bucket sort plus normal sort in the last layer
          // It's also lazy so only accessed buckets are sorted

          var combinations = new LazyBucketSortedSet( // Layer 1: ordered by largest size benefit
          function (c) {
            return c.sizeDiff;
          }, function (a, b) {
            return b - a;
          }, // Layer 2: ordered by smallest combined size
          function (c) {
            return c.integratedSize;
          }, function (a, b) {
            return a - b;
          }, // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)
          function (c) {
            return c.bIdx - c.aIdx;
          }, function (a, b) {
            return a - b;
          }, // Layer 4: ordered by position in orderedChunk (-> to be deterministic)
          function (a, b) {
            return a.bIdx - b.bIdx;
          }); // we keep a mappng from chunk to all combinations
          // but this mapping is not kept up-to-date with deletions
          // so `deleted` flag need to be considered when iterating this

          /** @type {Map<Chunk, Set<ChunkCombination>>} */

          var combinationsByChunk = new Map();
          orderedChunks.forEach(function (b, bIdx) {
            // create combination pairs with size and integrated size
            for (var aIdx = 0; aIdx < bIdx; aIdx++) {
              var a = orderedChunks[aIdx];
              var integratedSize = a.integratedSize(b, options); // filter pairs that do not have an integratedSize
              // meaning they can NOT be integrated!

              if (integratedSize === false) continue;
              var aSize = a.size(options);
              var bSize = b.size(options);
              var c = {
                deleted: false,
                sizeDiff: aSize + bSize - integratedSize,
                integratedSize: integratedSize,
                a: a,
                b: b,
                aIdx: aIdx,
                bIdx: bIdx,
                aSize: aSize,
                bSize: bSize
              };
              combinations.add(c);
              addToSetMap(combinationsByChunk, a, c);
              addToSetMap(combinationsByChunk, b, c);
            }

            return combinations;
          }); // list of modified chunks during this run
          // combinations affected by this change are skipped to allow
          // futher optimizations

          /** @type {Set<Chunk>} */

          var modifiedChunks = new Set();
          var changed = false; // eslint-disable-next-line no-constant-condition

          loop: while (true) {
            var combination = combinations.popFirst();
            if (combination === undefined) break;
            combination.deleted = true;
            var a = combination.a,
                b = combination.b,
                integratedSize = combination.integratedSize; // skip over pair when
            // one of the already merged chunks is a parent of one of the chunks

            if (modifiedChunks.size > 0) {
              var queue = new Set(a.groupsIterable);
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = b.groupsIterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var group = _step.value;
                  queue.add(group);
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = queue[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var _group = _step2.value;
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = undefined;

                  try {
                    for (var _iterator3 = modifiedChunks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var mChunk = _step3.value;

                      if (mChunk !== a && mChunk !== b && mChunk.isInGroup(_group)) {
                        // This is a potential pair which needs recalculation
                        // We can't do that now, but it merge before following pairs
                        // so we leave space for it, and consider chunks as modified
                        // just for the worse case
                        remainingChunksToMerge--;
                        if (remainingChunksToMerge <= 0) break loop;
                        modifiedChunks.add(a);
                        modifiedChunks.add(b);
                        continue loop;
                      }
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                        _iterator3["return"]();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }

                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = undefined;

                  try {
                    for (var _iterator4 = _group.parentsIterable[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var parent = _step4.value;
                      queue.add(parent);
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                        _iterator4["return"]();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            } // merge the chunks


            if (a.integrate(b, "limit")) {
              chunks.splice(chunks.indexOf(b), 1); // flag chunk a as modified as further optimization are possible for all children here

              modifiedChunks.add(a);
              changed = true;
              remainingChunksToMerge--;
              if (remainingChunksToMerge <= 0) break; // Update all affected combinations
              // delete all combination with the removed chunk
              // we will use combinations with the kept chunk instead

              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = combinationsByChunk.get(b)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var _combination = _step5.value;
                  if (_combination.deleted) continue;
                  _combination.deleted = true;
                  combinations["delete"](_combination);
                } // Update combinations with the kept chunk with new sizes

              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                    _iterator5["return"]();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }

              var _iteratorNormalCompletion6 = true;
              var _didIteratorError6 = false;
              var _iteratorError6 = undefined;

              try {
                for (var _iterator6 = combinationsByChunk.get(a)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  var _combination2 = _step6.value;
                  if (_combination2.deleted) continue;

                  if (_combination2.a === a) {
                    // Update size
                    var newIntegratedSize = a.integratedSize(_combination2.b, options);

                    if (newIntegratedSize === false) {
                      _combination2.deleted = true;
                      combinations["delete"](_combination2);
                      continue;
                    }

                    var finishUpdate = combinations.startUpdate(_combination2);
                    _combination2.integratedSize = newIntegratedSize;
                    _combination2.aSize = integratedSize;
                    _combination2.sizeDiff = _combination2.bSize + integratedSize - newIntegratedSize;
                    finishUpdate();
                  } else if (_combination2.b === a) {
                    // Update size
                    var _newIntegratedSize = _combination2.a.integratedSize(a, options);

                    if (_newIntegratedSize === false) {
                      _combination2.deleted = true;
                      combinations["delete"](_combination2);
                      continue;
                    }

                    var _finishUpdate = combinations.startUpdate(_combination2);

                    _combination2.integratedSize = _newIntegratedSize;
                    _combination2.bSize = integratedSize;
                    _combination2.sizeDiff = integratedSize + _combination2.aSize - _newIntegratedSize;

                    _finishUpdate();
                  }
                }
              } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                    _iterator6["return"]();
                  }
                } finally {
                  if (_didIteratorError6) {
                    throw _iteratorError6;
                  }
                }
              }
            }
          }

          if (changed) return true;
        });
      });
    }
  }]);

  return LimitChunkCountPlugin;
}();

module.exports = LimitChunkCountPlugin;