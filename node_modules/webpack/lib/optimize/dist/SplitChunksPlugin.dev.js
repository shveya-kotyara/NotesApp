/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var crypto = require("crypto");

var SortableSet = require("../util/SortableSet");

var GraphHelpers = require("../GraphHelpers");

var _require = require("../util/SetHelpers"),
    isSubset = _require.isSubset;

var deterministicGrouping = require("../util/deterministicGrouping");

var MinMaxSizeWarning = require("./MinMaxSizeWarning");

var contextify = require("../util/identifier").contextify;
/** @typedef {import("../Compiler")} Compiler */

/** @typedef {import("../Chunk")} Chunk */

/** @typedef {import("../Module")} Module */

/** @typedef {import("../util/deterministicGrouping").Options<Module>} DeterministicGroupingOptionsForModule */

/** @typedef {import("../util/deterministicGrouping").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */


var deterministicGroupingForModules =
/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */
deterministicGrouping;

var hashFilename = function hashFilename(name) {
  return crypto.createHash("md4").update(name).digest("hex").slice(0, 8);
};

var sortByIdentifier = function sortByIdentifier(a, b) {
  if (a.identifier() > b.identifier()) return 1;
  if (a.identifier() < b.identifier()) return -1;
  return 0;
};

var getRequests = function getRequests(chunk) {
  var requests = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = chunk.groupsIterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var chunkGroup = _step.value;
      requests = Math.max(requests, chunkGroup.chunks.length);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return requests;
};

var getModulesSize = function getModulesSize(modules) {
  var sum = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var m = _step2.value;
      sum += m.size();
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return sum;
};
/**
 * @template T
 * @param {Set<T>} a set
 * @param {Set<T>} b other set
 * @returns {boolean} true if at least one item of a is in b
 */


var isOverlap = function isOverlap(a, b) {
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = a[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var item = _step3.value;
      if (b.has(item)) return true;
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return false;
};

var compareEntries = function compareEntries(a, b) {
  // 1. by priority
  var diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;
  if (diffPriority) return diffPriority; // 2. by number of chunks

  var diffCount = a.chunks.size - b.chunks.size;
  if (diffCount) return diffCount; // 3. by size reduction

  var aSizeReduce = a.size * (a.chunks.size - 1);
  var bSizeReduce = b.size * (b.chunks.size - 1);
  var diffSizeReduce = aSizeReduce - bSizeReduce;
  if (diffSizeReduce) return diffSizeReduce; // 4. by cache group index

  var indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;
  if (indexDiff) return indexDiff; // 5. by number of modules (to be able to compare by identifier)

  var modulesA = a.modules;
  var modulesB = b.modules;
  var diff = modulesA.size - modulesB.size;
  if (diff) return diff; // 6. by module identifiers

  modulesA.sort();
  modulesB.sort();
  var aI = modulesA[Symbol.iterator]();
  var bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition

  while (true) {
    var aItem = aI.next();
    var bItem = bI.next();
    if (aItem.done) return 0;
    var aModuleIdentifier = aItem.value.identifier();
    var bModuleIdentifier = bItem.value.identifier();
    if (aModuleIdentifier > bModuleIdentifier) return -1;
    if (aModuleIdentifier < bModuleIdentifier) return 1;
  }
};

var compareNumbers = function compareNumbers(a, b) {
  return a - b;
};

var INITIAL_CHUNK_FILTER = function INITIAL_CHUNK_FILTER(chunk) {
  return chunk.canBeInitial();
};

var ASYNC_CHUNK_FILTER = function ASYNC_CHUNK_FILTER(chunk) {
  return !chunk.canBeInitial();
};

var ALL_CHUNK_FILTER = function ALL_CHUNK_FILTER(chunk) {
  return true;
};

module.exports =
/*#__PURE__*/
function () {
  function SplitChunksPlugin(options) {
    _classCallCheck(this, SplitChunksPlugin);

    this.options = SplitChunksPlugin.normalizeOptions(options);
  }

  _createClass(SplitChunksPlugin, [{
    key: "apply",

    /**
     * @param {Compiler} compiler webpack compiler
     * @returns {void}
     */
    value: function apply(compiler) {
      var _this = this;

      compiler.hooks.thisCompilation.tap("SplitChunksPlugin", function (compilation) {
        var alreadyOptimized = false;
        compilation.hooks.unseal.tap("SplitChunksPlugin", function () {
          alreadyOptimized = false;
        });
        compilation.hooks.optimizeChunksAdvanced.tap("SplitChunksPlugin", function (chunks) {
          if (alreadyOptimized) return;
          alreadyOptimized = true; // Give each selected chunk an index (to create strings from chunks)

          var indexMap = new Map();
          var index = 1;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = chunks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var chunk = _step4.value;
              indexMap.set(chunk, index++);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          var getKey = function getKey(chunks) {
            return Array.from(chunks, function (c) {
              return indexMap.get(c);
            }).sort(compareNumbers).join();
          };
          /** @type {Map<string, Set<Chunk>>} */


          var chunkSetsInGraph = new Map();
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = compilation.modules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _module = _step5.value;
              var chunksKey = getKey(_module.chunksIterable);

              if (!chunkSetsInGraph.has(chunksKey)) {
                chunkSetsInGraph.set(chunksKey, new Set(_module.chunksIterable));
              }
            } // group these set of chunks by count
            // to allow to check less sets via isSubset
            // (only smaller sets can be subset)

            /** @type {Map<number, Array<Set<Chunk>>>} */

          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          var chunkSetsByCount = new Map();
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = chunkSetsInGraph.values()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var chunksSet = _step6.value;
              var count = chunksSet.size;
              var array = chunkSetsByCount.get(count);

              if (array === undefined) {
                array = [];
                chunkSetsByCount.set(count, array);
              }

              array.push(chunksSet);
            } // Create a list of possible combinations

          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }

          var combinationsCache = new Map(); // Map<string, Set<Chunk>[]>

          var getCombinations = function getCombinations(key) {
            var chunksSet = chunkSetsInGraph.get(key);
            var array = [chunksSet];

            if (chunksSet.size > 1) {
              var _iteratorNormalCompletion7 = true;
              var _didIteratorError7 = false;
              var _iteratorError7 = undefined;

              try {
                for (var _iterator7 = chunkSetsByCount[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                  var _step7$value = _slicedToArray(_step7.value, 2),
                      count = _step7$value[0],
                      setArray = _step7$value[1];

                  // "equal" is not needed because they would have been merge in the first step
                  if (count < chunksSet.size) {
                    var _iteratorNormalCompletion8 = true;
                    var _didIteratorError8 = false;
                    var _iteratorError8 = undefined;

                    try {
                      for (var _iterator8 = setArray[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                        var set = _step8.value;

                        if (isSubset(chunksSet, set)) {
                          array.push(set);
                        }
                      }
                    } catch (err) {
                      _didIteratorError8 = true;
                      _iteratorError8 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                          _iterator8["return"]();
                        }
                      } finally {
                        if (_didIteratorError8) {
                          throw _iteratorError8;
                        }
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                    _iterator7["return"]();
                  }
                } finally {
                  if (_didIteratorError7) {
                    throw _iteratorError7;
                  }
                }
              }
            }

            return array;
          };
          /**
           * @typedef {Object} SelectedChunksResult
           * @property {Chunk[]} chunks the list of chunks
           * @property {string} key a key of the list
           */

          /**
           * @typedef {function(Chunk): boolean} ChunkFilterFunction
           */

          /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */


          var selectedChunksCacheByChunksSet = new WeakMap();
          /**
           * get list and key by applying the filter function to the list
           * It is cached for performance reasons
           * @param {Set<Chunk>} chunks list of chunks
           * @param {ChunkFilterFunction} chunkFilter filter function for chunks
           * @returns {SelectedChunksResult} list and key
           */

          var getSelectedChunks = function getSelectedChunks(chunks, chunkFilter) {
            var entry = selectedChunksCacheByChunksSet.get(chunks);

            if (entry === undefined) {
              entry = new WeakMap();
              selectedChunksCacheByChunksSet.set(chunks, entry);
            }
            /** @type {SelectedChunksResult} */


            var entry2 = entry.get(chunkFilter);

            if (entry2 === undefined) {
              /** @type {Chunk[]} */
              var selectedChunks = [];
              var _iteratorNormalCompletion9 = true;
              var _didIteratorError9 = false;
              var _iteratorError9 = undefined;

              try {
                for (var _iterator9 = chunks[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                  var chunk = _step9.value;
                  if (chunkFilter(chunk)) selectedChunks.push(chunk);
                }
              } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                    _iterator9["return"]();
                  }
                } finally {
                  if (_didIteratorError9) {
                    throw _iteratorError9;
                  }
                }
              }

              entry2 = {
                chunks: selectedChunks,
                key: getKey(selectedChunks)
              };
              entry.set(chunkFilter, entry2);
            }

            return entry2;
          };
          /**
           * @typedef {Object} ChunksInfoItem
           * @property {SortableSet} modules
           * @property {TODO} cacheGroup
           * @property {number} cacheGroupIndex
           * @property {string} name
           * @property {number} size
           * @property {Set<Chunk>} chunks
           * @property {Set<Chunk>} reuseableChunks
           * @property {Set<string>} chunksKeys
           */
          // Map a list of chunks to a list of modules
          // For the key the chunk "index" is used, the value is a SortableSet of modules

          /** @type {Map<string, ChunksInfoItem>} */


          var chunksInfoMap = new Map();
          /**
           * @param {TODO} cacheGroup the current cache group
           * @param {number} cacheGroupIndex the index of the cache group of ordering
           * @param {Chunk[]} selectedChunks chunks selected for this module
           * @param {string} selectedChunksKey a key of selectedChunks
           * @param {Module} module the current module
           * @returns {void}
           */

          var addModuleToChunksInfoMap = function addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) {
            // Break if minimum number of chunks is not reached
            if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk

            var name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Create key for maps
            // When it has a name we use the name as key
            // Elsewise we create the key from chunks and cache group key
            // This automatically merges equal names

            var key = cacheGroup.key + (name ? " name:".concat(name) : " chunks:".concat(selectedChunksKey)); // Add module to maps

            var info = chunksInfoMap.get(key);

            if (info === undefined) {
              chunksInfoMap.set(key, info = {
                modules: new SortableSet(undefined, sortByIdentifier),
                cacheGroup: cacheGroup,
                cacheGroupIndex: cacheGroupIndex,
                name: name,
                size: 0,
                chunks: new Set(),
                reuseableChunks: new Set(),
                chunksKeys: new Set()
              });
            }

            info.modules.add(module);
            info.size += module.size();

            if (!info.chunksKeys.has(selectedChunksKey)) {
              info.chunksKeys.add(selectedChunksKey);
              var _iteratorNormalCompletion10 = true;
              var _didIteratorError10 = false;
              var _iteratorError10 = undefined;

              try {
                for (var _iterator10 = selectedChunks[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                  var chunk = _step10.value;
                  info.chunks.add(chunk);
                }
              } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                    _iterator10["return"]();
                  }
                } finally {
                  if (_didIteratorError10) {
                    throw _iteratorError10;
                  }
                }
              }
            }
          }; // Walk through all modules


          var _iteratorNormalCompletion11 = true;
          var _didIteratorError11 = false;
          var _iteratorError11 = undefined;

          try {
            for (var _iterator11 = compilation.modules[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
              var _module2 = _step11.value;

              // Get cache group
              var cacheGroups = _this.options.getCacheGroups(_module2);

              if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {
                continue;
              } // Prepare some values


              var _chunksKey = getKey(_module2.chunksIterable);

              var combs = combinationsCache.get(_chunksKey);

              if (combs === undefined) {
                combs = getCombinations(_chunksKey);
                combinationsCache.set(_chunksKey, combs);
              }

              var cacheGroupIndex = 0;
              var _iteratorNormalCompletion14 = true;
              var _didIteratorError14 = false;
              var _iteratorError14 = undefined;

              try {
                for (var _iterator14 = cacheGroups[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                  var cacheGroupSource = _step14.value;
                  var minSize = cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : _this.options.minSize;
                  var enforceSizeThreshold = cacheGroupSource.enforceSizeThreshold !== undefined ? cacheGroupSource.enforceSizeThreshold : cacheGroupSource.enforce ? 0 : _this.options.enforceSizeThreshold;
                  var cacheGroup = {
                    key: cacheGroupSource.key,
                    priority: cacheGroupSource.priority || 0,
                    chunksFilter: cacheGroupSource.chunksFilter || _this.options.chunksFilter,
                    minSize: minSize,
                    minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : _this.options.minSize,
                    enforceSizeThreshold: enforceSizeThreshold,
                    maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : _this.options.maxSize,
                    minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : _this.options.minChunks,
                    maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxAsyncRequests,
                    maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxInitialRequests,
                    getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : _this.options.getName,
                    filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : _this.options.filename,
                    automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : _this.options.automaticNameDelimiter,
                    reuseExistingChunk: cacheGroupSource.reuseExistingChunk,
                    _validateSize: minSize > 0,
                    _conditionalEnforce: enforceSizeThreshold > 0
                  }; // For all combination of chunk selection

                  var _iteratorNormalCompletion15 = true;
                  var _didIteratorError15 = false;
                  var _iteratorError15 = undefined;

                  try {
                    for (var _iterator15 = combs[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                      var chunkCombination = _step15.value;
                      // Break if minimum number of chunks is not reached
                      if (chunkCombination.size < cacheGroup.minChunks) continue; // Select chunks by configuration

                      var _getSelectedChunks = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter),
                          selectedChunks = _getSelectedChunks.chunks,
                          selectedChunksKey = _getSelectedChunks.key;

                      addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, _module2);
                    }
                  } catch (err) {
                    _didIteratorError15 = true;
                    _iteratorError15 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
                        _iterator15["return"]();
                      }
                    } finally {
                      if (_didIteratorError15) {
                        throw _iteratorError15;
                      }
                    }
                  }

                  cacheGroupIndex++;
                }
              } catch (err) {
                _didIteratorError14 = true;
                _iteratorError14 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                    _iterator14["return"]();
                  }
                } finally {
                  if (_didIteratorError14) {
                    throw _iteratorError14;
                  }
                }
              }
            } // Filter items were size < minSize

          } catch (err) {
            _didIteratorError11 = true;
            _iteratorError11 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                _iterator11["return"]();
              }
            } finally {
              if (_didIteratorError11) {
                throw _iteratorError11;
              }
            }
          }

          var _iteratorNormalCompletion12 = true;
          var _didIteratorError12 = false;
          var _iteratorError12 = undefined;

          try {
            for (var _iterator12 = chunksInfoMap[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var pair = _step12.value;
              var info = pair[1];

              if (info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize) {
                chunksInfoMap["delete"](pair[0]);
              }
            }
            /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */

          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
                _iterator12["return"]();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }

          var maxSizeQueueMap = new Map();

          var _loop = function _loop() {
            // Find best matching entry
            var bestEntryKey = void 0;
            var bestEntry = void 0;
            var _iteratorNormalCompletion16 = true;
            var _didIteratorError16 = false;
            var _iteratorError16 = undefined;

            try {
              for (var _iterator16 = chunksInfoMap[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                var _pair = _step16.value;
                var key = _pair[0];
                var _info = _pair[1];

                if (bestEntry === undefined) {
                  bestEntry = _info;
                  bestEntryKey = key;
                } else if (compareEntries(bestEntry, _info) < 0) {
                  bestEntry = _info;
                  bestEntryKey = key;
                }
              }
            } catch (err) {
              _didIteratorError16 = true;
              _iteratorError16 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
                  _iterator16["return"]();
                }
              } finally {
                if (_didIteratorError16) {
                  throw _iteratorError16;
                }
              }
            }

            var item = bestEntry;
            chunksInfoMap["delete"](bestEntryKey);
            var chunkName = item.name; // Variable for the new chunk (lazy created)

            /** @type {Chunk} */

            var newChunk = void 0; // When no chunk name, check if we can reuse a chunk instead of creating a new one

            var isReused = false;

            if (item.cacheGroup.reuseExistingChunk) {
              var _iteratorNormalCompletion17 = true;
              var _didIteratorError17 = false;
              var _iteratorError17 = undefined;

              try {
                outer: for (var _iterator17 = item.chunks[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                  var _chunk = _step17.value;
                  if (_chunk.getNumberOfModules() !== item.modules.size) continue;
                  if (_chunk.hasEntryModule()) continue;
                  var _iteratorNormalCompletion18 = true;
                  var _didIteratorError18 = false;
                  var _iteratorError18 = undefined;

                  try {
                    for (var _iterator18 = item.modules[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                      var _module3 = _step18.value;
                      if (!_chunk.containsModule(_module3)) continue outer;
                    }
                  } catch (err) {
                    _didIteratorError18 = true;
                    _iteratorError18 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
                        _iterator18["return"]();
                      }
                    } finally {
                      if (_didIteratorError18) {
                        throw _iteratorError18;
                      }
                    }
                  }

                  if (!newChunk || !newChunk.name) {
                    newChunk = _chunk;
                  } else if (_chunk.name && _chunk.name.length < newChunk.name.length) {
                    newChunk = _chunk;
                  } else if (_chunk.name && _chunk.name.length === newChunk.name.length && _chunk.name < newChunk.name) {
                    newChunk = _chunk;
                  }

                  chunkName = undefined;
                  isReused = true;
                }
              } catch (err) {
                _didIteratorError17 = true;
                _iteratorError17 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
                    _iterator17["return"]();
                  }
                } finally {
                  if (_didIteratorError17) {
                    throw _iteratorError17;
                  }
                }
              }
            } // Check if maxRequests condition can be fulfilled


            var selectedChunks = Array.from(item.chunks).filter(function (chunk) {
              // skip if we address ourself
              return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;
            });
            var enforced = item.cacheGroup._conditionalEnforce && item.size >= item.cacheGroup.enforceSizeThreshold; // Skip when no chunk selected

            if (selectedChunks.length === 0) return "continue";
            var usedChunks = new Set(selectedChunks); // Check if maxRequests condition can be fulfilled

            if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {
              var _iteratorNormalCompletion19 = true;
              var _didIteratorError19 = false;
              var _iteratorError19 = undefined;

              try {
                for (var _iterator19 = usedChunks[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                  var _chunk2 = _step19.value;
                  // respect max requests
                  var maxRequests = _chunk2.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : _chunk2.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;

                  if (isFinite(maxRequests) && getRequests(_chunk2) >= maxRequests) {
                    usedChunks["delete"](_chunk2);
                  }
                }
              } catch (err) {
                _didIteratorError19 = true;
                _iteratorError19 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
                    _iterator19["return"]();
                  }
                } finally {
                  if (_didIteratorError19) {
                    throw _iteratorError19;
                  }
                }
              }
            }

            var _iteratorNormalCompletion20 = true;
            var _didIteratorError20 = false;
            var _iteratorError20 = undefined;

            try {
              outer: for (var _iterator20 = usedChunks[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                var _chunk5 = _step20.value;
                var _iteratorNormalCompletion28 = true;
                var _didIteratorError28 = false;
                var _iteratorError28 = undefined;

                try {
                  for (var _iterator28 = item.modules[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                    var _module7 = _step28.value;
                    if (_chunk5.containsModule(_module7)) continue outer;
                  }
                } catch (err) {
                  _didIteratorError28 = true;
                  _iteratorError28 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion28 && _iterator28["return"] != null) {
                      _iterator28["return"]();
                    }
                  } finally {
                    if (_didIteratorError28) {
                      throw _iteratorError28;
                    }
                  }
                }

                usedChunks["delete"](_chunk5);
              }
            } catch (err) {
              _didIteratorError20 = true;
              _iteratorError20 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
                  _iterator20["return"]();
                }
              } finally {
                if (_didIteratorError20) {
                  throw _iteratorError20;
                }
              }
            } // Were some (invalid) chunks removed from usedChunks?
            // => readd all modules to the queue, as things could have been changed


            if (usedChunks.size < selectedChunks.length) {
              if (usedChunks.size >= item.cacheGroup.minChunks) {
                var chunksArr = Array.from(usedChunks);
                var _iteratorNormalCompletion21 = true;
                var _didIteratorError21 = false;
                var _iteratorError21 = undefined;

                try {
                  for (var _iterator21 = item.modules[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                    var _module4 = _step21.value;
                    addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), _module4);
                  }
                } catch (err) {
                  _didIteratorError21 = true;
                  _iteratorError21 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
                      _iterator21["return"]();
                    }
                  } finally {
                    if (_didIteratorError21) {
                      throw _iteratorError21;
                    }
                  }
                }
              }

              return "continue";
            } // Create the new chunk if not reusing one


            if (!isReused) {
              newChunk = compilation.addChunk(chunkName);
            } // Walk through all chunks


            var _iteratorNormalCompletion22 = true;
            var _didIteratorError22 = false;
            var _iteratorError22 = undefined;

            try {
              for (var _iterator22 = usedChunks[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var _chunk6 = _step22.value;

                // Add graph connections for splitted chunk
                _chunk6.split(newChunk);
              } // Add a note to the chunk

            } catch (err) {
              _didIteratorError22 = true;
              _iteratorError22 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
                  _iterator22["return"]();
                }
              } finally {
                if (_didIteratorError22) {
                  throw _iteratorError22;
                }
              }
            }

            newChunk.chunkReason = isReused ? "reused as split chunk" : "split chunk";

            if (item.cacheGroup.key) {
              newChunk.chunkReason += " (cache group: ".concat(item.cacheGroup.key, ")");
            }

            if (chunkName) {
              newChunk.chunkReason += " (name: ".concat(chunkName, ")"); // If the chosen name is already an entry point we remove the entry point

              var entrypoint = compilation.entrypoints.get(chunkName);

              if (entrypoint) {
                compilation.entrypoints["delete"](chunkName);
                entrypoint.remove();
                newChunk.entryModule = undefined;
              }
            }

            if (item.cacheGroup.filename) {
              if (!newChunk.isOnlyInitial()) {
                throw new Error("SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. " + "The runtime can only handle loading of chunks which match the chunkFilename schema. " + "Using a custom filename would fail at runtime. " + "(cache group: ".concat(item.cacheGroup.key, ")"));
              }

              newChunk.filenameTemplate = item.cacheGroup.filename;
            }

            if (!isReused) {
              // Add all modules to the new chunk
              var _iteratorNormalCompletion23 = true;
              var _didIteratorError23 = false;
              var _iteratorError23 = undefined;

              try {
                for (var _iterator23 = item.modules[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                  var _module5 = _step23.value;

                  if (typeof _module5.chunkCondition === "function") {
                    if (!_module5.chunkCondition(newChunk)) continue;
                  } // Add module to new chunk


                  GraphHelpers.connectChunkAndModule(newChunk, _module5); // Remove module from used chunks

                  var _iteratorNormalCompletion24 = true;
                  var _didIteratorError24 = false;
                  var _iteratorError24 = undefined;

                  try {
                    for (var _iterator24 = usedChunks[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                      var _chunk3 = _step24.value;

                      _chunk3.removeModule(_module5);

                      _module5.rewriteChunkInReasons(_chunk3, [newChunk]);
                    }
                  } catch (err) {
                    _didIteratorError24 = true;
                    _iteratorError24 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
                        _iterator24["return"]();
                      }
                    } finally {
                      if (_didIteratorError24) {
                        throw _iteratorError24;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError23 = true;
                _iteratorError23 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
                    _iterator23["return"]();
                  }
                } finally {
                  if (_didIteratorError23) {
                    throw _iteratorError23;
                  }
                }
              }
            } else {
              // Remove all modules from used chunks
              var _iteratorNormalCompletion25 = true;
              var _didIteratorError25 = false;
              var _iteratorError25 = undefined;

              try {
                for (var _iterator25 = item.modules[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                  var _module6 = _step25.value;
                  var _iteratorNormalCompletion26 = true;
                  var _didIteratorError26 = false;
                  var _iteratorError26 = undefined;

                  try {
                    for (var _iterator26 = usedChunks[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
                      var _chunk4 = _step26.value;

                      _chunk4.removeModule(_module6);

                      _module6.rewriteChunkInReasons(_chunk4, [newChunk]);
                    }
                  } catch (err) {
                    _didIteratorError26 = true;
                    _iteratorError26 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion26 && _iterator26["return"] != null) {
                        _iterator26["return"]();
                      }
                    } finally {
                      if (_didIteratorError26) {
                        throw _iteratorError26;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError25 = true;
                _iteratorError25 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
                    _iterator25["return"]();
                  }
                } finally {
                  if (_didIteratorError25) {
                    throw _iteratorError25;
                  }
                }
              }
            }

            if (item.cacheGroup.maxSize > 0) {
              var oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);
              maxSizeQueueMap.set(newChunk, {
                minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),
                maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),
                automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,
                keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]
              });
            } // remove all modules from other entries and update size


            var _iteratorNormalCompletion27 = true;
            var _didIteratorError27 = false;
            var _iteratorError27 = undefined;

            try {
              for (var _iterator27 = chunksInfoMap[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                var _step27$value = _slicedToArray(_step27.value, 2),
                    _key = _step27$value[0],
                    _info2 = _step27$value[1];

                if (isOverlap(_info2.chunks, usedChunks)) {
                  // update modules and total size
                  // may remove it from the map when < minSize
                  var oldSize = _info2.modules.size;
                  var _iteratorNormalCompletion29 = true;
                  var _didIteratorError29 = false;
                  var _iteratorError29 = undefined;

                  try {
                    for (var _iterator29 = item.modules[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
                      var _module8 = _step29.value;

                      _info2.modules["delete"](_module8);
                    }
                  } catch (err) {
                    _didIteratorError29 = true;
                    _iteratorError29 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion29 && _iterator29["return"] != null) {
                        _iterator29["return"]();
                      }
                    } finally {
                      if (_didIteratorError29) {
                        throw _iteratorError29;
                      }
                    }
                  }

                  if (_info2.modules.size !== oldSize) {
                    if (_info2.modules.size === 0) {
                      chunksInfoMap["delete"](_key);
                      continue;
                    }

                    _info2.size = getModulesSize(_info2.modules);

                    if (_info2.cacheGroup._validateSize && _info2.size < _info2.cacheGroup.minSize) {
                      chunksInfoMap["delete"](_key);
                    }

                    if (_info2.modules.size === 0) {
                      chunksInfoMap["delete"](_key);
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError27 = true;
              _iteratorError27 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion27 && _iterator27["return"] != null) {
                  _iterator27["return"]();
                }
              } finally {
                if (_didIteratorError27) {
                  throw _iteratorError27;
                }
              }
            }
          };

          while (chunksInfoMap.size > 0) {
            var _ret = _loop();

            if (_ret === "continue") continue;
          }

          var incorrectMinMaxSizeSet = new Set(); // Make sure that maxSize is fulfilled

          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            var _loop2 = function _loop2() {
              var chunk = _step13.value;

              var _ref = maxSizeQueueMap.get(chunk) || _this.options.fallbackCacheGroup,
                  minSize = _ref.minSize,
                  maxSize = _ref.maxSize,
                  automaticNameDelimiter = _ref.automaticNameDelimiter,
                  keys = _ref.keys;

              if (!maxSize) return "continue";

              if (minSize > maxSize) {
                var warningKey = "".concat(keys && keys.join(), " ").concat(minSize, " ").concat(maxSize);

                if (!incorrectMinMaxSizeSet.has(warningKey)) {
                  incorrectMinMaxSizeSet.add(warningKey);
                  compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));
                }
              }

              var results = deterministicGroupingForModules({
                maxSize: Math.max(minSize, maxSize),
                minSize: minSize,
                items: chunk.modulesIterable,
                getKey: function getKey(module) {
                  var ident = contextify(compilation.options.context, module.identifier());
                  var name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\?[^?!]*$/g, "");
                  var fullKey = name + automaticNameDelimiter + hashFilename(ident);
                  return fullKey.replace(/[\\/?]/g, "_");
                },
                getSize: function getSize(module) {
                  return module.size();
                }
              });
              results.sort(function (a, b) {
                if (a.key < b.key) return -1;
                if (a.key > b.key) return 1;
                return 0;
              });

              for (var i = 0; i < results.length; i++) {
                var group = results[i];
                var key = _this.options.hidePathInfo ? hashFilename(group.key) : group.key;
                var name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;

                if (name && name.length > 100) {
                  name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);
                }

                var newPart = void 0;

                if (i !== results.length - 1) {
                  newPart = compilation.addChunk(name);
                  chunk.split(newPart);
                  newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk

                  var _iteratorNormalCompletion30 = true;
                  var _didIteratorError30 = false;
                  var _iteratorError30 = undefined;

                  try {
                    for (var _iterator30 = group.items[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                      var _module9 = _step30.value;

                      if (typeof _module9.chunkCondition === "function") {
                        if (!_module9.chunkCondition(newPart)) continue;
                      } // Add module to new chunk


                      GraphHelpers.connectChunkAndModule(newPart, _module9); // Remove module from used chunks

                      chunk.removeModule(_module9);

                      _module9.rewriteChunkInReasons(chunk, [newPart]);
                    }
                  } catch (err) {
                    _didIteratorError30 = true;
                    _iteratorError30 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion30 && _iterator30["return"] != null) {
                        _iterator30["return"]();
                      }
                    } finally {
                      if (_didIteratorError30) {
                        throw _iteratorError30;
                      }
                    }
                  }
                } else {
                  // change the chunk to be a part
                  newPart = chunk;
                  chunk.name = name;
                }
              }
            };

            for (var _iterator13 = compilation.chunks.slice()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var _ret2 = _loop2();

              if (_ret2 === "continue") continue;
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                _iterator13["return"]();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }
        });
      });
    }
  }], [{
    key: "normalizeOptions",
    value: function normalizeOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || "all"),
        minSize: options.minSize || 0,
        enforceSizeThreshold: options.enforceSizeThreshold || 0,
        maxSize: options.maxSize || 0,
        minChunks: options.minChunks || 1,
        maxAsyncRequests: options.maxAsyncRequests || 1,
        maxInitialRequests: options.maxInitialRequests || 1,
        hidePathInfo: options.hidePathInfo || false,
        filename: options.filename || undefined,
        getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({
          cacheGroups: options.cacheGroups,
          name: options.name,
          automaticNameDelimiter: options.automaticNameDelimiter,
          automaticNameMaxLength: options.automaticNameMaxLength
        }),
        automaticNameDelimiter: options.automaticNameDelimiter,
        automaticNameMaxLength: options.automaticNameMaxLength || 109,
        fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)
      };
    }
  }, {
    key: "normalizeName",
    value: function normalizeName(_ref2) {
      var name = _ref2.name,
          automaticNameDelimiter = _ref2.automaticNameDelimiter,
          automaticNamePrefix = _ref2.automaticNamePrefix,
          automaticNameMaxLength = _ref2.automaticNameMaxLength;

      if (name === true) {
        /** @type {WeakMap<Chunk[], Record<string, string>>} */
        var cache = new WeakMap();

        var fn = function fn(module, chunks, cacheGroup) {
          var cacheEntry = cache.get(chunks);

          if (cacheEntry === undefined) {
            cacheEntry = {};
            cache.set(chunks, cacheEntry);
          } else if (cacheGroup in cacheEntry) {
            return cacheEntry[cacheGroup];
          }

          var names = chunks.map(function (c) {
            return c.name;
          });

          if (!names.every(Boolean)) {
            cacheEntry[cacheGroup] = undefined;
            return;
          }

          names.sort();
          var prefix = typeof automaticNamePrefix === "string" ? automaticNamePrefix : cacheGroup;
          var namePrefix = prefix ? prefix + automaticNameDelimiter : "";
          var name = namePrefix + names.join(automaticNameDelimiter); // Filenames and paths can't be too long otherwise an
          // ENAMETOOLONG error is raised. If the generated name if too
          // long, it is truncated and a hash is appended. The limit has
          // been set to 109 to prevent `[name].[chunkhash].[ext]` from
          // generating a 256+ character string.

          if (name.length > automaticNameMaxLength) {
            var hashedFilename = hashFilename(name);
            var sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);
            name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;
          }

          cacheEntry[cacheGroup] = name;
          return name;
        };

        return fn;
      }

      if (typeof name === "string") {
        var _fn = function _fn() {
          return name;
        };

        return _fn;
      }

      if (typeof name === "function") return name;
    }
  }, {
    key: "normalizeChunksFilter",
    value: function normalizeChunksFilter(chunks) {
      if (chunks === "initial") {
        return INITIAL_CHUNK_FILTER;
      }

      if (chunks === "async") {
        return ASYNC_CHUNK_FILTER;
      }

      if (chunks === "all") {
        return ALL_CHUNK_FILTER;
      }

      if (typeof chunks === "function") return chunks;
    }
  }, {
    key: "normalizeFallbackCacheGroup",
    value: function normalizeFallbackCacheGroup(_ref3, _ref4) {
      var _ref3$minSize = _ref3.minSize,
          minSize = _ref3$minSize === void 0 ? undefined : _ref3$minSize,
          _ref3$maxSize = _ref3.maxSize,
          maxSize = _ref3$maxSize === void 0 ? undefined : _ref3$maxSize,
          _ref3$automaticNameDe = _ref3.automaticNameDelimiter,
          automaticNameDelimiter = _ref3$automaticNameDe === void 0 ? undefined : _ref3$automaticNameDe;
      var _ref4$minSize = _ref4.minSize,
          defaultMinSize = _ref4$minSize === void 0 ? undefined : _ref4$minSize,
          _ref4$maxSize = _ref4.maxSize,
          defaultMaxSize = _ref4$maxSize === void 0 ? undefined : _ref4$maxSize,
          _ref4$automaticNameDe = _ref4.automaticNameDelimiter,
          defaultAutomaticNameDelimiter = _ref4$automaticNameDe === void 0 ? undefined : _ref4$automaticNameDe;
      return {
        minSize: typeof minSize === "number" ? minSize : defaultMinSize || 0,
        maxSize: typeof maxSize === "number" ? maxSize : defaultMaxSize || 0,
        automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || "~"
      };
    }
  }, {
    key: "normalizeCacheGroups",
    value: function normalizeCacheGroups(_ref5) {
      var cacheGroups = _ref5.cacheGroups,
          name = _ref5.name,
          automaticNameDelimiter = _ref5.automaticNameDelimiter,
          automaticNameMaxLength = _ref5.automaticNameMaxLength;

      if (typeof cacheGroups === "function") {
        // TODO webpack 5 remove this
        if (cacheGroups.length !== 1) {
          return function (module) {
            return cacheGroups(module, module.getChunks());
          };
        }

        return cacheGroups;
      }

      if (cacheGroups && _typeof(cacheGroups) === "object") {
        var _fn2 = function _fn2(module) {
          var results;

          for (var _i2 = 0, _Object$keys = Object.keys(cacheGroups); _i2 < _Object$keys.length; _i2++) {
            var key = _Object$keys[_i2];
            var option = cacheGroups[key];
            if (option === false) continue;

            if (option instanceof RegExp || typeof option === "string") {
              option = {
                test: option
              };
            }

            if (typeof option === "function") {
              var result = option(module);

              if (result) {
                if (results === undefined) results = [];
                var _iteratorNormalCompletion31 = true;
                var _didIteratorError31 = false;
                var _iteratorError31 = undefined;

                try {
                  var _loop3 = function _loop3() {
                    var r = _step31.value;
                    var result = Object.assign({
                      key: key
                    }, r);
                    if (result.name) result.getName = function () {
                      return result.name;
                    };

                    if (result.chunks) {
                      result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);
                    }

                    results.push(result);
                  };

                  for (var _iterator31 = (Array.isArray(result) ? result : [result])[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
                    _loop3();
                  }
                } catch (err) {
                  _didIteratorError31 = true;
                  _iteratorError31 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion31 && _iterator31["return"] != null) {
                      _iterator31["return"]();
                    }
                  } finally {
                    if (_didIteratorError31) {
                      throw _iteratorError31;
                    }
                  }
                }
              }
            } else if (SplitChunksPlugin.checkTest(option.test, module)) {
              if (results === undefined) results = [];
              results.push({
                key: key,
                priority: option.priority,
                getName: SplitChunksPlugin.normalizeName({
                  name: option.name || name,
                  automaticNameDelimiter: typeof option.automaticNameDelimiter === "string" ? option.automaticNameDelimiter : automaticNameDelimiter,
                  automaticNamePrefix: option.automaticNamePrefix,
                  automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength
                }) || function () {},
                chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),
                enforce: option.enforce,
                minSize: option.minSize,
                enforceSizeThreshold: option.enforceSizeThreshold,
                maxSize: option.maxSize,
                minChunks: option.minChunks,
                maxAsyncRequests: option.maxAsyncRequests,
                maxInitialRequests: option.maxInitialRequests,
                filename: option.filename,
                reuseExistingChunk: option.reuseExistingChunk
              });
            }
          }

          return results;
        };

        return _fn2;
      }

      var fn = function fn() {};

      return fn;
    }
  }, {
    key: "checkTest",
    value: function checkTest(test, module) {
      if (test === undefined) return true;

      if (typeof test === "function") {
        if (test.length !== 1) {
          return test(module, module.getChunks());
        }

        return test(module);
      }

      if (typeof test === "boolean") return test;

      if (typeof test === "string") {
        if (module.nameForCondition && module.nameForCondition().startsWith(test)) {
          return true;
        }

        var _iteratorNormalCompletion32 = true;
        var _didIteratorError32 = false;
        var _iteratorError32 = undefined;

        try {
          for (var _iterator32 = module.chunksIterable[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
            var chunk = _step32.value;

            if (chunk.name && chunk.name.startsWith(test)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError32 = true;
          _iteratorError32 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion32 && _iterator32["return"] != null) {
              _iterator32["return"]();
            }
          } finally {
            if (_didIteratorError32) {
              throw _iteratorError32;
            }
          }
        }

        return false;
      }

      if (test instanceof RegExp) {
        if (module.nameForCondition && test.test(module.nameForCondition())) {
          return true;
        }

        var _iteratorNormalCompletion33 = true;
        var _didIteratorError33 = false;
        var _iteratorError33 = undefined;

        try {
          for (var _iterator33 = module.chunksIterable[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
            var _chunk7 = _step33.value;

            if (_chunk7.name && test.test(_chunk7.name)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError33 = true;
          _iteratorError33 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion33 && _iterator33["return"] != null) {
              _iterator33["return"]();
            }
          } finally {
            if (_didIteratorError33) {
              throw _iteratorError33;
            }
          }
        }

        return false;
      }

      return false;
    }
  }]);

  return SplitChunksPlugin;
}();