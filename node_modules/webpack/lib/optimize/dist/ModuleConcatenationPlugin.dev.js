/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var HarmonyImportDependency = require("../dependencies/HarmonyImportDependency");

var ModuleHotAcceptDependency = require("../dependencies/ModuleHotAcceptDependency");

var ModuleHotDeclineDependency = require("../dependencies/ModuleHotDeclineDependency");

var ConcatenatedModule = require("./ConcatenatedModule");

var HarmonyCompatibilityDependency = require("../dependencies/HarmonyCompatibilityDependency");

var StackedSetMap = require("../util/StackedSetMap");

var formatBailoutReason = function formatBailoutReason(msg) {
  return "ModuleConcatenation bailout: " + msg;
};

var ModuleConcatenationPlugin =
/*#__PURE__*/
function () {
  function ModuleConcatenationPlugin(options) {
    _classCallCheck(this, ModuleConcatenationPlugin);

    if (_typeof(options) !== "object") options = {};
    this.options = options;
  }

  _createClass(ModuleConcatenationPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      compiler.hooks.compilation.tap("ModuleConcatenationPlugin", function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;

        var handler = function handler(parser, parserOptions) {
          parser.hooks.call["for"]("eval").tap("ModuleConcatenationPlugin", function () {
            // Because of variable renaming we can't use modules with eval.
            parser.state.module.buildMeta.moduleConcatenationBailout = "eval()";
          });
        };

        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("ModuleConcatenationPlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/dynamic").tap("ModuleConcatenationPlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/esm").tap("ModuleConcatenationPlugin", handler);
        var bailoutReasonMap = new Map();

        var setBailoutReason = function setBailoutReason(module, reason) {
          bailoutReasonMap.set(module, reason);
          module.optimizationBailout.push(typeof reason === "function" ? function (rs) {
            return formatBailoutReason(reason(rs));
          } : formatBailoutReason(reason));
        };

        var getBailoutReason = function getBailoutReason(module, requestShortener) {
          var reason = bailoutReasonMap.get(module);
          if (typeof reason === "function") return reason(requestShortener);
          return reason;
        };

        compilation.hooks.optimizeChunkModules.tap("ModuleConcatenationPlugin", function (allChunks, modules) {
          var relevantModules = [];
          var possibleInners = new Set();
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            var _loop = function _loop() {
              var module = _step.value;

              // Only harmony modules are valid for optimization
              if (!module.buildMeta || module.buildMeta.exportsType !== "namespace" || !module.dependencies.some(function (d) {
                return d instanceof HarmonyCompatibilityDependency;
              })) {
                setBailoutReason(module, "Module is not an ECMAScript module");
                return "continue";
              } // Some expressions are not compatible with module concatenation
              // because they may produce unexpected results. The plugin bails out
              // if some were detected upfront.


              if (module.buildMeta && module.buildMeta.moduleConcatenationBailout) {
                setBailoutReason(module, "Module uses ".concat(module.buildMeta.moduleConcatenationBailout));
                return "continue";
              } // Exports must be known (and not dynamic)


              if (!Array.isArray(module.buildMeta.providedExports)) {
                setBailoutReason(module, "Module exports are unknown");
                return "continue";
              } // Using dependency variables is not possible as this wraps the code in a function


              if (module.variables.length > 0) {
                setBailoutReason(module, "Module uses injected variables (".concat(module.variables.map(function (v) {
                  return v.name;
                }).join(", "), ")"));
                return "continue";
              } // Hot Module Replacement need it's own module to work correctly


              if (module.dependencies.some(function (dep) {
                return dep instanceof ModuleHotAcceptDependency || dep instanceof ModuleHotDeclineDependency;
              })) {
                setBailoutReason(module, "Module uses Hot Module Replacement");
                return "continue";
              }

              relevantModules.push(module); // Module must not be the entry points

              if (module.isEntryModule()) {
                setBailoutReason(module, "Module is an entry point");
                return "continue";
              } // Module must be in any chunk (we don't want to do useless work)


              if (module.getNumberOfChunks() === 0) {
                setBailoutReason(module, "Module is not in any chunk");
                return "continue";
              } // Module must only be used by Harmony Imports


              var nonHarmonyReasons = module.reasons.filter(function (reason) {
                return !reason.dependency || !(reason.dependency instanceof HarmonyImportDependency);
              });

              if (nonHarmonyReasons.length > 0) {
                var importingModules = new Set(nonHarmonyReasons.map(function (r) {
                  return r.module;
                }).filter(Boolean));
                var importingExplanations = new Set(nonHarmonyReasons.map(function (r) {
                  return r.explanation;
                }).filter(Boolean));
                var importingModuleTypes = new Map(Array.from(importingModules).map(function (m) {
                  return (
                    /** @type {[string, Set]} */
                    [m, new Set(nonHarmonyReasons.filter(function (r) {
                      return r.module === m;
                    }).map(function (r) {
                      return r.dependency.type;
                    }).sort())]
                  );
                }));
                setBailoutReason(module, function (requestShortener) {
                  var names = Array.from(importingModules).map(function (m) {
                    return "".concat(m.readableIdentifier(requestShortener), " (referenced with ").concat(Array.from(importingModuleTypes.get(m)).join(", "), ")");
                  }).sort();
                  var explanations = Array.from(importingExplanations).sort();

                  if (names.length > 0 && explanations.length === 0) {
                    return "Module is referenced from these modules with unsupported syntax: ".concat(names.join(", "));
                  } else if (names.length === 0 && explanations.length > 0) {
                    return "Module is referenced by: ".concat(explanations.join(", "));
                  } else if (names.length > 0 && explanations.length > 0) {
                    return "Module is referenced from these modules with unsupported syntax: ".concat(names.join(", "), " and by: ").concat(explanations.join(", "));
                  } else {
                    return "Module is referenced in a unsupported way";
                  }
                });
                return "continue";
              }

              possibleInners.add(module);
            };

            for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _ret = _loop();

              if (_ret === "continue") continue;
            } // sort by depth
            // modules with lower depth are more likely suited as roots
            // this improves performance, because modules already selected as inner are skipped

          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          relevantModules.sort(function (a, b) {
            return a.depth - b.depth;
          });
          var concatConfigurations = [];
          var usedAsInner = new Set();

          for (var _i = 0, _relevantModules = relevantModules; _i < _relevantModules.length; _i++) {
            var currentRoot = _relevantModules[_i];
            // when used by another configuration as inner:
            // the other configuration is better and we can skip this one
            if (usedAsInner.has(currentRoot)) continue; // create a configuration with the root

            var currentConfiguration = new ConcatConfiguration(currentRoot); // cache failures to add modules

            var failureCache = new Map(); // try to add all imports

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _this._getImports(compilation, currentRoot)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var imp = _step2.value;

                var problem = _this._tryToAdd(compilation, currentConfiguration, imp, possibleInners, failureCache);

                if (problem) {
                  failureCache.set(imp, problem);
                  currentConfiguration.addWarning(imp, problem);
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            if (!currentConfiguration.isEmpty()) {
              concatConfigurations.push(currentConfiguration);
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = currentConfiguration.getModules()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var _module = _step3.value;

                  if (_module !== currentConfiguration.rootModule) {
                    usedAsInner.add(_module);
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                    _iterator3["return"]();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          } // HACK: Sort configurations by length and start with the longest one
          // to get the biggers groups possible. Used modules are marked with usedModules
          // TODO: Allow to reuse existing configuration while trying to add dependencies.
          // This would improve performance. O(n^2) -> O(n)


          concatConfigurations.sort(function (a, b) {
            return b.modules.size - a.modules.size;
          });
          var usedModules = new Set();

          for (var _i2 = 0, _concatConfigurations = concatConfigurations; _i2 < _concatConfigurations.length; _i2++) {
            var concatConfiguration = _concatConfigurations[_i2];
            if (usedModules.has(concatConfiguration.rootModule)) continue;

            var _modules = concatConfiguration.getModules();

            var rootModule = concatConfiguration.rootModule;
            var newModule = new ConcatenatedModule(rootModule, Array.from(_modules), ConcatenatedModule.createConcatenationList(rootModule, _modules, compilation));
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              var _loop2 = function _loop2() {
                var warning = _step4.value;
                newModule.optimizationBailout.push(function (requestShortener) {
                  var reason = getBailoutReason(warning[0], requestShortener);
                  var reasonWithPrefix = reason ? " (<- ".concat(reason, ")") : "";

                  if (warning[0] === warning[1]) {
                    return formatBailoutReason("Cannot concat with ".concat(warning[0].readableIdentifier(requestShortener)).concat(reasonWithPrefix));
                  } else {
                    return formatBailoutReason("Cannot concat with ".concat(warning[0].readableIdentifier(requestShortener), " because of ").concat(warning[1].readableIdentifier(requestShortener)).concat(reasonWithPrefix));
                  }
                });
              };

              for (var _iterator4 = concatConfiguration.getWarningsSorted()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                _loop2();
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            var chunks = concatConfiguration.rootModule.getChunks();
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = _modules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var m = _step5.value;
                usedModules.add(m);
                var _iteratorNormalCompletion9 = true;
                var _didIteratorError9 = false;
                var _iteratorError9 = undefined;

                try {
                  for (var _iterator9 = chunks[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    var chunk = _step9.value;
                    chunk.removeModule(m);
                  }
                } catch (err) {
                  _didIteratorError9 = true;
                  _iteratorError9 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                      _iterator9["return"]();
                    }
                  } finally {
                    if (_didIteratorError9) {
                      throw _iteratorError9;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                  _iterator5["return"]();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }

            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              for (var _iterator6 = chunks[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var _chunk = _step6.value;

                _chunk.addModule(newModule);

                newModule.addChunk(_chunk);
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                  _iterator6["return"]();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }

            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = allChunks[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var _chunk2 = _step7.value;

                if (_chunk2.entryModule === concatConfiguration.rootModule) {
                  _chunk2.entryModule = newModule;
                }
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                  _iterator7["return"]();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }

            compilation.modules.push(newModule);
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
              for (var _iterator8 = newModule.reasons[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var _reason = _step8.value;
                if (_reason.dependency.module === concatConfiguration.rootModule) _reason.dependency.module = newModule;
                if (_reason.dependency.redirectedModule === concatConfiguration.rootModule) _reason.dependency.redirectedModule = newModule;
              } // TODO: remove when LTS node version contains fixed v8 version
              // @see https://github.com/webpack/webpack/pull/6613
              // Turbofan does not correctly inline for-of loops with polymorphic input arrays.
              // Work around issue by using a standard for loop and assigning dep.module.reasons

            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                  _iterator8["return"]();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }

            for (var i = 0; i < newModule.dependencies.length; i++) {
              var dep = newModule.dependencies[i];

              if (dep.module) {
                var reasons = dep.module.reasons;

                for (var j = 0; j < reasons.length; j++) {
                  var reason = reasons[j];

                  if (reason.dependency === dep) {
                    reason.module = newModule;
                  }
                }
              }
            }
          }

          compilation.modules = compilation.modules.filter(function (m) {
            return !usedModules.has(m);
          });
        });
      });
    }
  }, {
    key: "_getImports",
    value: function _getImports(compilation, module) {
      return new Set(module.dependencies // Get reference info only for harmony Dependencies
      .map(function (dep) {
        if (!(dep instanceof HarmonyImportDependency)) return null;
        if (!compilation) return dep.getReference();
        return compilation.getDependencyReference(module, dep);
      }) // Reference is valid and has a module
      // Dependencies are simple enough to concat them
      .filter(function (ref) {
        return ref && ref.module && (Array.isArray(ref.importedNames) || Array.isArray(ref.module.buildMeta.providedExports));
      }) // Take the imported module
      .map(function (ref) {
        return ref.module;
      }));
    }
  }, {
    key: "_tryToAdd",
    value: function _tryToAdd(compilation, config, module, possibleModules, failureCache) {
      var cacheEntry = failureCache.get(module);

      if (cacheEntry) {
        return cacheEntry;
      } // Already added?


      if (config.has(module)) {
        return null;
      } // Not possible to add?


      if (!possibleModules.has(module)) {
        failureCache.set(module, module); // cache failures for performance

        return module;
      } // module must be in the same chunks


      if (!config.rootModule.hasEqualsChunks(module)) {
        failureCache.set(module, module); // cache failures for performance

        return module;
      } // Clone config to make experimental changes


      var testConfig = config.clone(); // Add the module

      testConfig.add(module); // Every module which depends on the added module must be in the configuration too.

      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = module.reasons[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var reason = _step10.value;
          // Modules that are not used can be ignored
          if (reason.module.factoryMeta.sideEffectFree && reason.module.used === false) continue;

          var problem = this._tryToAdd(compilation, testConfig, reason.module, possibleModules, failureCache);

          if (problem) {
            failureCache.set(module, problem); // cache failures for performance

            return problem;
          }
        } // Commit experimental changes

      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      config.set(testConfig); // Eagerly try to add imports too if possible

      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = this._getImports(compilation, module)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var imp = _step11.value;

          var _problem = this._tryToAdd(compilation, config, imp, possibleModules, failureCache);

          if (_problem) {
            config.addWarning(imp, _problem);
          }
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      return null;
    }
  }]);

  return ModuleConcatenationPlugin;
}();

var ConcatConfiguration =
/*#__PURE__*/
function () {
  function ConcatConfiguration(rootModule, cloneFrom) {
    _classCallCheck(this, ConcatConfiguration);

    this.rootModule = rootModule;

    if (cloneFrom) {
      this.modules = cloneFrom.modules.createChild(5);
      this.warnings = cloneFrom.warnings.createChild(5);
    } else {
      this.modules = new StackedSetMap();
      this.modules.add(rootModule);
      this.warnings = new StackedSetMap();
    }
  }

  _createClass(ConcatConfiguration, [{
    key: "add",
    value: function add(module) {
      this.modules.add(module);
    }
  }, {
    key: "has",
    value: function has(module) {
      return this.modules.has(module);
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.modules.size === 1;
    }
  }, {
    key: "addWarning",
    value: function addWarning(module, problem) {
      this.warnings.set(module, problem);
    }
  }, {
    key: "getWarningsSorted",
    value: function getWarningsSorted() {
      return new Map(this.warnings.asPairArray().sort(function (a, b) {
        var ai = a[0].identifier();
        var bi = b[0].identifier();
        if (ai < bi) return -1;
        if (ai > bi) return 1;
        return 0;
      }));
    }
  }, {
    key: "getModules",
    value: function getModules() {
      return this.modules.asSet();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new ConcatConfiguration(this.rootModule, this);
    }
  }, {
    key: "set",
    value: function set(config) {
      this.rootModule = config.rootModule;
      this.modules = config.modules;
      this.warnings = config.warnings;
    }
  }]);

  return ConcatConfiguration;
}();

module.exports = ModuleConcatenationPlugin;