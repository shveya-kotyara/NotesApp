/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require("path");

var AMDRequireDependency = require("./AMDRequireDependency");

var AMDRequireItemDependency = require("./AMDRequireItemDependency");

var AMDRequireArrayDependency = require("./AMDRequireArrayDependency");

var AMDRequireContextDependency = require("./AMDRequireContextDependency");

var AMDDefineDependency = require("./AMDDefineDependency");

var UnsupportedDependency = require("./UnsupportedDependency");

var LocalModuleDependency = require("./LocalModuleDependency");

var NullFactory = require("../NullFactory");

var AMDRequireDependenciesBlockParserPlugin = require("./AMDRequireDependenciesBlockParserPlugin");

var AMDDefineDependencyParserPlugin = require("./AMDDefineDependencyParserPlugin");

var AliasPlugin = require("enhanced-resolve/lib/AliasPlugin");

var ParserHelpers = require("../ParserHelpers");

var AMDPlugin =
/*#__PURE__*/
function () {
  function AMDPlugin(options, amdOptions) {
    _classCallCheck(this, AMDPlugin);

    this.amdOptions = amdOptions;
    this.options = options;
  }

  _createClass(AMDPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var options = this.options;
      var amdOptions = this.amdOptions;
      compiler.hooks.compilation.tap("AMDPlugin", function (compilation, _ref) {
        var contextModuleFactory = _ref.contextModuleFactory,
            normalModuleFactory = _ref.normalModuleFactory;
        compilation.dependencyFactories.set(AMDRequireDependency, new NullFactory());
        compilation.dependencyTemplates.set(AMDRequireDependency, new AMDRequireDependency.Template());
        compilation.dependencyFactories.set(AMDRequireItemDependency, normalModuleFactory);
        compilation.dependencyTemplates.set(AMDRequireItemDependency, new AMDRequireItemDependency.Template());
        compilation.dependencyFactories.set(AMDRequireArrayDependency, new NullFactory());
        compilation.dependencyTemplates.set(AMDRequireArrayDependency, new AMDRequireArrayDependency.Template());
        compilation.dependencyFactories.set(AMDRequireContextDependency, contextModuleFactory);
        compilation.dependencyTemplates.set(AMDRequireContextDependency, new AMDRequireContextDependency.Template());
        compilation.dependencyFactories.set(AMDDefineDependency, new NullFactory());
        compilation.dependencyTemplates.set(AMDDefineDependency, new AMDDefineDependency.Template());
        compilation.dependencyFactories.set(UnsupportedDependency, new NullFactory());
        compilation.dependencyTemplates.set(UnsupportedDependency, new UnsupportedDependency.Template());
        compilation.dependencyFactories.set(LocalModuleDependency, new NullFactory());
        compilation.dependencyTemplates.set(LocalModuleDependency, new LocalModuleDependency.Template());

        var handler = function handler(parser, parserOptions) {
          if (parserOptions.amd !== undefined && !parserOptions.amd) return;

          var setExpressionToModule = function setExpressionToModule(outerExpr, module) {
            parser.hooks.expression["for"](outerExpr).tap("AMDPlugin", function (expr) {
              var dep = new AMDRequireItemDependency(module, expr.range);
              dep.userRequest = outerExpr;
              dep.loc = expr.loc;
              parser.state.current.addDependency(dep);
              return true;
            });
          };

          new AMDRequireDependenciesBlockParserPlugin(options).apply(parser);
          new AMDDefineDependencyParserPlugin(options).apply(parser);
          setExpressionToModule("require.amd", "!!webpack amd options");
          setExpressionToModule("define.amd", "!!webpack amd options");
          setExpressionToModule("define", "!!webpack amd define");
          parser.hooks.expression["for"]("__webpack_amd_options__").tap("AMDPlugin", function () {
            return parser.state.current.addVariable("__webpack_amd_options__", JSON.stringify(amdOptions));
          });
          parser.hooks.evaluateTypeof["for"]("define.amd").tap("AMDPlugin", ParserHelpers.evaluateToString(_typeof(amdOptions)));
          parser.hooks.evaluateTypeof["for"]("require.amd").tap("AMDPlugin", ParserHelpers.evaluateToString(_typeof(amdOptions)));
          parser.hooks.evaluateIdentifier["for"]("define.amd").tap("AMDPlugin", ParserHelpers.evaluateToIdentifier("define.amd", true));
          parser.hooks.evaluateIdentifier["for"]("require.amd").tap("AMDPlugin", ParserHelpers.evaluateToIdentifier("require.amd", true));
          parser.hooks["typeof"]["for"]("define").tap("AMDPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function")));
          parser.hooks.evaluateTypeof["for"]("define").tap("AMDPlugin", ParserHelpers.evaluateToString("function"));
          parser.hooks.canRename["for"]("define").tap("AMDPlugin", ParserHelpers.approve);
          parser.hooks.rename["for"]("define").tap("AMDPlugin", function (expr) {
            var dep = new AMDRequireItemDependency("!!webpack amd define", expr.range);
            dep.userRequest = "define";
            dep.loc = expr.loc;
            parser.state.current.addDependency(dep);
            return false;
          });
          parser.hooks["typeof"]["for"]("require").tap("AMDPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function")));
          parser.hooks.evaluateTypeof["for"]("require").tap("AMDPlugin", ParserHelpers.evaluateToString("function"));
        };

        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("AMDPlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/dynamic").tap("AMDPlugin", handler);
      });
      compiler.hooks.afterResolvers.tap("AMDPlugin", function () {
        compiler.resolverFactory.hooks.resolver["for"]("normal").tap("AMDPlugin", function (resolver) {
          new AliasPlugin("described-resolve", {
            name: "amdefine",
            alias: path.join(__dirname, "..", "..", "buildin", "amd-define.js")
          }, "resolve").apply(resolver);
          new AliasPlugin("described-resolve", {
            name: "webpack amd options",
            alias: path.join(__dirname, "..", "..", "buildin", "amd-options.js")
          }, "resolve").apply(resolver);
          new AliasPlugin("described-resolve", {
            name: "webpack amd define",
            alias: path.join(__dirname, "..", "..", "buildin", "amd-define.js")
          }, "resolve").apply(resolver);
        });
      });
    }
  }]);

  return AMDPlugin;
}();

module.exports = AMDPlugin;