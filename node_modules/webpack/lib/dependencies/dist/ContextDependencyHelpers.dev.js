/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

var ContextDependencyHelpers = exports;
/**
 * Escapes regular expression metacharacters
 * @param {string} str String to quote
 * @returns {string} Escaped string
 */

var quotemeta = function quotemeta(str) {
  return str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
};

var splitContextFromPrefix = function splitContextFromPrefix(prefix) {
  var idx = prefix.lastIndexOf("/");
  var context = ".";

  if (idx >= 0) {
    context = prefix.substr(0, idx);
    prefix = ".".concat(prefix.substr(idx));
  }

  return {
    context: context,
    prefix: prefix
  };
};

var splitQueryFromPostfix = function splitQueryFromPostfix(postfix) {
  var idx = postfix.indexOf("?");
  var query = "";

  if (idx >= 0) {
    query = postfix.substr(idx);
    postfix = postfix.substr(0, idx);
  }

  return {
    postfix: postfix,
    query: query
  };
};

ContextDependencyHelpers.create = function (Dep, range, param, expr, options, contextOptions) {
  var parser = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

  if (param.isTemplateString()) {
    var prefixRaw = param.quasis[0].string;
    var postfixRaw = param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : "";
    var valueRange = param.range;

    var _splitContextFromPref = splitContextFromPrefix(prefixRaw),
        context = _splitContextFromPref.context,
        prefix = _splitContextFromPref.prefix;

    var _splitQueryFromPostfi = splitQueryFromPostfix(postfixRaw),
        postfix = _splitQueryFromPostfi.postfix,
        query = _splitQueryFromPostfi.query; // When there are more than two quasis, the generated RegExp can be more precise
    // We join the quasis with the expression regexp


    var innerQuasis = param.quasis.slice(1, param.quasis.length - 1);
    var innerRegExp = options.wrappedContextRegExp.source + innerQuasis.map(function (q) {
      return quotemeta(q.string) + options.wrappedContextRegExp.source;
    }).join(""); // Example: `./context/pre${e}inner${e}inner2${e}post?query`
    // context: "./context"
    // prefix: "./pre"
    // innerQuasis: [BEE("inner"), BEE("inner2")]
    // (BEE = BasicEvaluatedExpression)
    // postfix: "post"
    // query: "?query"
    // regExp: /^\.\/pre.*inner.*inner2.*post$/

    var regExp = new RegExp("^".concat(quotemeta(prefix)).concat(innerRegExp).concat(quotemeta(postfix), "$"));
    var dep = new Dep(Object.assign({
      request: context + query,
      recursive: options.wrappedContextRecursive,
      regExp: regExp,
      mode: "sync"
    }, contextOptions), range, valueRange);
    dep.loc = expr.loc;
    var replaces = [];
    param.parts.forEach(function (part, i) {
      if (i % 2 === 0) {
        // Quasis or merged quasi
        var _range = part.range;
        var value = part.string;

        if (param.templateStringKind === "cooked") {
          value = JSON.stringify(value);
          value = value.slice(1, value.length - 1);
        }

        if (i === 0) {
          // prefix
          value = prefix;
          _range = [param.range[0], part.range[1]];
          value = (param.templateStringKind === "cooked" ? "`" : "String.raw`") + value;
        } else if (i === param.parts.length - 1) {
          // postfix
          value = postfix;
          _range = [part.range[0], param.range[1]];
          value = value + "`";
        } else if (part.expression && part.expression.type === "TemplateElement" && part.expression.value.raw === value) {
          // Shortcut when it's a single quasi and doesn't need to be replaced
          return;
        }

        replaces.push({
          range: _range,
          value: value
        });
      } else {
        // Expression
        if (parser) {
          parser.walkExpression(part.expression);
        }
      }
    });
    dep.replaces = replaces;
    dep.critical = options.wrappedContextCritical && "a part of the request of a dependency is an expression";
    return dep;
  } else if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {
    var _prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : "";

    var _postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : "";

    var prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;
    var postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null;
    var _valueRange = param.range;

    var _splitContextFromPref2 = splitContextFromPrefix(_prefixRaw),
        _context = _splitContextFromPref2.context,
        _prefix = _splitContextFromPref2.prefix;

    var _splitQueryFromPostfi2 = splitQueryFromPostfix(_postfixRaw),
        _postfix = _splitQueryFromPostfi2.postfix,
        _query = _splitQueryFromPostfi2.query;

    var _regExp = new RegExp("^".concat(quotemeta(_prefix)).concat(options.wrappedContextRegExp.source).concat(quotemeta(_postfix), "$"));

    var _dep = new Dep(Object.assign({
      request: _context + _query,
      recursive: options.wrappedContextRecursive,
      regExp: _regExp,
      mode: "sync"
    }, contextOptions), range, _valueRange);

    _dep.loc = expr.loc;
    var _replaces = [];

    if (prefixRange) {
      _replaces.push({
        range: prefixRange,
        value: JSON.stringify(_prefix)
      });
    }

    if (postfixRange) {
      _replaces.push({
        range: postfixRange,
        value: JSON.stringify(_postfix)
      });
    }

    _dep.replaces = _replaces;
    _dep.critical = options.wrappedContextCritical && "a part of the request of a dependency is an expression";

    if (parser && param.wrappedInnerExpressions) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = param.wrappedInnerExpressions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var part = _step.value;
          if (part.expression) parser.walkExpression(part.expression);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    return _dep;
  } else {
    var _dep2 = new Dep(Object.assign({
      request: options.exprContextRequest,
      recursive: options.exprContextRecursive,
      regExp: options.exprContextRegExp,
      mode: "sync"
    }, contextOptions), range, param.range);

    _dep2.loc = expr.loc;
    _dep2.critical = options.exprContextCritical && "the request of a dependency is an expression";

    if (parser) {
      parser.walkExpression(param.expression);
    }

    return _dep2;
  }
};