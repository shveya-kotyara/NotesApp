/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ConstDependency = require("./ConstDependency");

var CommonJsRequireDependency = require("./CommonJsRequireDependency");

var CommonJsRequireContextDependency = require("./CommonJsRequireContextDependency");

var RequireResolveDependency = require("./RequireResolveDependency");

var RequireResolveContextDependency = require("./RequireResolveContextDependency");

var RequireResolveHeaderDependency = require("./RequireResolveHeaderDependency");

var RequireHeaderDependency = require("./RequireHeaderDependency");

var NullFactory = require("../NullFactory");

var RequireResolveDependencyParserPlugin = require("./RequireResolveDependencyParserPlugin");

var CommonJsRequireDependencyParserPlugin = require("./CommonJsRequireDependencyParserPlugin");

var ParserHelpers = require("../ParserHelpers");

var CommonJsPlugin =
/*#__PURE__*/
function () {
  function CommonJsPlugin(options) {
    _classCallCheck(this, CommonJsPlugin);

    this.options = options;
  }

  _createClass(CommonJsPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var options = this.options;
      compiler.hooks.compilation.tap("CommonJsPlugin", function (compilation, _ref) {
        var contextModuleFactory = _ref.contextModuleFactory,
            normalModuleFactory = _ref.normalModuleFactory;
        compilation.dependencyFactories.set(CommonJsRequireDependency, normalModuleFactory);
        compilation.dependencyTemplates.set(CommonJsRequireDependency, new CommonJsRequireDependency.Template());
        compilation.dependencyFactories.set(CommonJsRequireContextDependency, contextModuleFactory);
        compilation.dependencyTemplates.set(CommonJsRequireContextDependency, new CommonJsRequireContextDependency.Template());
        compilation.dependencyFactories.set(RequireResolveDependency, normalModuleFactory);
        compilation.dependencyTemplates.set(RequireResolveDependency, new RequireResolveDependency.Template());
        compilation.dependencyFactories.set(RequireResolveContextDependency, contextModuleFactory);
        compilation.dependencyTemplates.set(RequireResolveContextDependency, new RequireResolveContextDependency.Template());
        compilation.dependencyFactories.set(RequireResolveHeaderDependency, new NullFactory());
        compilation.dependencyTemplates.set(RequireResolveHeaderDependency, new RequireResolveHeaderDependency.Template());
        compilation.dependencyFactories.set(RequireHeaderDependency, new NullFactory());
        compilation.dependencyTemplates.set(RequireHeaderDependency, new RequireHeaderDependency.Template());

        var handler = function handler(parser, parserOptions) {
          if (parserOptions.commonjs !== undefined && !parserOptions.commonjs) return;
          var requireExpressions = ["require", "require.resolve", "require.resolveWeak"];

          for (var _i = 0, _requireExpressions = requireExpressions; _i < _requireExpressions.length; _i++) {
            var expression = _requireExpressions[_i];
            parser.hooks["typeof"]["for"](expression).tap("CommonJsPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function")));
            parser.hooks.evaluateTypeof["for"](expression).tap("CommonJsPlugin", ParserHelpers.evaluateToString("function"));
            parser.hooks.evaluateIdentifier["for"](expression).tap("CommonJsPlugin", ParserHelpers.evaluateToIdentifier(expression, true));
          }

          parser.hooks.evaluateTypeof["for"]("module").tap("CommonJsPlugin", ParserHelpers.evaluateToString("object"));
          parser.hooks.assign["for"]("require").tap("CommonJsPlugin", function (expr) {
            // to not leak to global "require", we need to define a local require here.
            var dep = new ConstDependency("var require;", 0);
            dep.loc = expr.loc;
            parser.state.current.addDependency(dep);
            parser.scope.definitions.add("require");
            return true;
          });
          parser.hooks.canRename["for"]("require").tap("CommonJsPlugin", function () {
            return true;
          });
          parser.hooks.rename["for"]("require").tap("CommonJsPlugin", function (expr) {
            // define the require variable. It's still undefined, but not "not defined".
            var dep = new ConstDependency("var require;", 0);
            dep.loc = expr.loc;
            parser.state.current.addDependency(dep);
            return false;
          });
          parser.hooks["typeof"]["for"]("module").tap("CommonJsPlugin", function () {
            return true;
          });
          parser.hooks.evaluateTypeof["for"]("exports").tap("CommonJsPlugin", ParserHelpers.evaluateToString("object"));
          new CommonJsRequireDependencyParserPlugin(options).apply(parser);
          new RequireResolveDependencyParserPlugin(options).apply(parser);
        };

        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("CommonJsPlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/dynamic").tap("CommonJsPlugin", handler);
      });
    }
  }]);

  return CommonJsPlugin;
}();

module.exports = CommonJsPlugin;