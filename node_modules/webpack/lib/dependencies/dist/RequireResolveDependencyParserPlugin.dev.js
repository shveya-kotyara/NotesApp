/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RequireResolveDependency = require("./RequireResolveDependency");

var RequireResolveContextDependency = require("./RequireResolveContextDependency");

var RequireResolveHeaderDependency = require("./RequireResolveHeaderDependency");

var ContextDependencyHelpers = require("./ContextDependencyHelpers");

var RequireResolveDependencyParserPlugin =
/*#__PURE__*/
function () {
  function RequireResolveDependencyParserPlugin(options) {
    _classCallCheck(this, RequireResolveDependencyParserPlugin);

    this.options = options;
  }

  _createClass(RequireResolveDependencyParserPlugin, [{
    key: "apply",
    value: function apply(parser) {
      var options = this.options;

      var process = function process(expr, weak) {
        if (expr.arguments.length !== 1) return;
        var param = parser.evaluateExpression(expr.arguments[0]);

        if (param.isConditional()) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = param.options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var option = _step.value;
              var result = processItem(expr, option, weak);

              if (result === undefined) {
                processContext(expr, option, weak);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var dep = new RequireResolveHeaderDependency(expr.callee.range);
          dep.loc = expr.loc;
          parser.state.current.addDependency(dep);
          return true;
        } else {
          var _result = processItem(expr, param, weak);

          if (_result === undefined) {
            processContext(expr, param, weak);
          }

          var _dep = new RequireResolveHeaderDependency(expr.callee.range);

          _dep.loc = expr.loc;
          parser.state.current.addDependency(_dep);
          return true;
        }
      };

      var processItem = function processItem(expr, param, weak) {
        if (param.isString()) {
          var dep = new RequireResolveDependency(param.string, param.range);
          dep.loc = expr.loc;
          dep.optional = !!parser.scope.inTry;
          dep.weak = weak;
          parser.state.current.addDependency(dep);
          return true;
        }
      };

      var processContext = function processContext(expr, param, weak) {
        var dep = ContextDependencyHelpers.create(RequireResolveContextDependency, param.range, param, expr, options, {
          mode: weak ? "weak" : "sync"
        }, parser);
        if (!dep) return;
        dep.loc = expr.loc;
        dep.optional = !!parser.scope.inTry;
        parser.state.current.addDependency(dep);
        return true;
      };

      parser.hooks.call["for"]("require.resolve").tap("RequireResolveDependencyParserPlugin", function (expr) {
        return process(expr, false);
      });
      parser.hooks.call["for"]("require.resolveWeak").tap("RequireResolveDependencyParserPlugin", function (expr) {
        return process(expr, true);
      });
    }
  }]);

  return RequireResolveDependencyParserPlugin;
}();

module.exports = RequireResolveDependencyParserPlugin;