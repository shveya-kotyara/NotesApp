/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require("tapable"),
    SyncBailHook = _require.SyncBailHook;

var HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");

var HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");

var HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");

var HarmonyAcceptDependency = require("./HarmonyAcceptDependency");

var ConstDependency = require("./ConstDependency");

module.exports =
/*#__PURE__*/
function () {
  function HarmonyImportDependencyParserPlugin(moduleOptions) {
    _classCallCheck(this, HarmonyImportDependencyParserPlugin);

    this.strictExportPresence = moduleOptions.strictExportPresence;
    this.strictThisContextOnImports = moduleOptions.strictThisContextOnImports;
  }

  _createClass(HarmonyImportDependencyParserPlugin, [{
    key: "apply",
    value: function apply(parser) {
      var _this = this;

      parser.hooks["import"].tap("HarmonyImportDependencyParserPlugin", function (statement, source) {
        parser.state.lastHarmonyImportOrder = (parser.state.lastHarmonyImportOrder || 0) + 1;
        var clearDep = new ConstDependency("", statement.range);
        clearDep.loc = statement.loc;
        parser.state.module.addDependency(clearDep);
        var sideEffectDep = new HarmonyImportSideEffectDependency(source, parser.state.module, parser.state.lastHarmonyImportOrder, parser.state.harmonyParserScope);
        sideEffectDep.loc = statement.loc;
        parser.state.module.addDependency(sideEffectDep);
        return true;
      });
      parser.hooks.importSpecifier.tap("HarmonyImportDependencyParserPlugin", function (statement, source, id, name) {
        parser.scope.definitions["delete"](name);
        parser.scope.renames.set(name, "imported var");

        if (!parser.state.harmonySpecifier) {
          parser.state.harmonySpecifier = new Map();
        }

        parser.state.harmonySpecifier.set(name, {
          source: source,
          id: id,
          sourceOrder: parser.state.lastHarmonyImportOrder
        });
        return true;
      });
      parser.hooks.expression["for"]("imported var").tap("HarmonyImportDependencyParserPlugin", function (expr) {
        var name = expr.name;
        var settings = parser.state.harmonySpecifier.get(name);
        var dep = new HarmonyImportSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, settings.id, name, expr.range, _this.strictExportPresence);
        dep.shorthand = parser.scope.inShorthand;
        dep.directImport = true;
        dep.loc = expr.loc;
        parser.state.module.addDependency(dep);
        return true;
      });
      parser.hooks.expressionAnyMember["for"]("imported var").tap("HarmonyImportDependencyParserPlugin", function (expr) {
        var name = expr.object.name;
        var settings = parser.state.harmonySpecifier.get(name);
        if (settings.id !== null) return false;
        var dep = new HarmonyImportSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, expr.property.name || expr.property.value, name, expr.range, _this.strictExportPresence);
        dep.shorthand = parser.scope.inShorthand;
        dep.directImport = false;
        dep.loc = expr.loc;
        parser.state.module.addDependency(dep);
        return true;
      });

      if (this.strictThisContextOnImports) {
        // only in case when we strictly follow the spec we need a special case here
        parser.hooks.callAnyMember["for"]("imported var").tap("HarmonyImportDependencyParserPlugin", function (expr) {
          if (expr.callee.type !== "MemberExpression") return;
          if (expr.callee.object.type !== "Identifier") return;
          var name = expr.callee.object.name;
          var settings = parser.state.harmonySpecifier.get(name);
          if (settings.id !== null) return false;
          var dep = new HarmonyImportSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, expr.callee.property.name || expr.callee.property.value, name, expr.callee.range, _this.strictExportPresence);
          dep.shorthand = parser.scope.inShorthand;
          dep.directImport = false;
          dep.namespaceObjectAsContext = true;
          dep.loc = expr.callee.loc;
          parser.state.module.addDependency(dep);
          if (expr.arguments) parser.walkExpressions(expr.arguments);
          return true;
        });
      }

      parser.hooks.call["for"]("imported var").tap("HarmonyImportDependencyParserPlugin", function (expr) {
        var args = expr.arguments;
        var fullExpr = expr;
        expr = expr.callee;
        if (expr.type !== "Identifier") return;
        var name = expr.name;
        var settings = parser.state.harmonySpecifier.get(name);
        var dep = new HarmonyImportSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, settings.id, name, expr.range, _this.strictExportPresence);
        dep.directImport = true;
        dep.callArgs = args;
        dep.call = fullExpr;
        dep.loc = expr.loc;
        parser.state.module.addDependency(dep);
        if (args) parser.walkExpressions(args);
        return true;
      }); // TODO webpack 5: refactor this, no custom hooks

      if (!parser.hooks.hotAcceptCallback) {
        parser.hooks.hotAcceptCallback = new SyncBailHook(["expression", "requests"]);
      }

      if (!parser.hooks.hotAcceptWithoutCallback) {
        parser.hooks.hotAcceptWithoutCallback = new SyncBailHook(["expression", "requests"]);
      }

      parser.hooks.hotAcceptCallback.tap("HarmonyImportDependencyParserPlugin", function (expr, requests) {
        var harmonyParserScope = parser.state.harmonyParserScope;

        if (!harmonyParserScope) {
          // This is not a harmony module, skip it
          return;
        }

        var dependencies = requests.map(function (request) {
          var dep = new HarmonyAcceptImportDependency(request, parser.state.module, harmonyParserScope);
          dep.loc = expr.loc;
          parser.state.module.addDependency(dep);
          return dep;
        });

        if (dependencies.length > 0) {
          var dep = new HarmonyAcceptDependency(expr.range, dependencies, true);
          dep.loc = expr.loc;
          parser.state.module.addDependency(dep);
        }
      });
      parser.hooks.hotAcceptWithoutCallback.tap("HarmonyImportDependencyParserPlugin", function (expr, requests) {
        var dependencies = requests.map(function (request) {
          var dep = new HarmonyAcceptImportDependency(request, parser.state.module, parser.state.harmonyParserScope);
          dep.loc = expr.loc;
          parser.state.module.addDependency(dep);
          return dep;
        });

        if (dependencies.length > 0) {
          var dep = new HarmonyAcceptDependency(expr.range, dependencies, false);
          dep.loc = expr.loc;
          parser.state.module.addDependency(dep);
        }
      });
    }
  }]);

  return HarmonyImportDependencyParserPlugin;
}();