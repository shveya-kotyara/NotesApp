/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AMDRequireItemDependency = require("./AMDRequireItemDependency");

var AMDRequireContextDependency = require("./AMDRequireContextDependency");

var ConstDependency = require("./ConstDependency");

var AMDDefineDependency = require("./AMDDefineDependency");

var AMDRequireArrayDependency = require("./AMDRequireArrayDependency");

var LocalModuleDependency = require("./LocalModuleDependency");

var ContextDependencyHelpers = require("./ContextDependencyHelpers");

var LocalModulesHelpers = require("./LocalModulesHelpers");

var isBoundFunctionExpression = function isBoundFunctionExpression(expr) {
  if (expr.type !== "CallExpression") return false;
  if (expr.callee.type !== "MemberExpression") return false;
  if (expr.callee.computed) return false;
  if (expr.callee.object.type !== "FunctionExpression") return false;
  if (expr.callee.property.type !== "Identifier") return false;
  if (expr.callee.property.name !== "bind") return false;
  return true;
};

var isUnboundFunctionExpression = function isUnboundFunctionExpression(expr) {
  if (expr.type === "FunctionExpression") return true;
  if (expr.type === "ArrowFunctionExpression") return true;
  return false;
};

var isCallable = function isCallable(expr) {
  if (isUnboundFunctionExpression(expr)) return true;
  if (isBoundFunctionExpression(expr)) return true;
  return false;
};

var AMDDefineDependencyParserPlugin =
/*#__PURE__*/
function () {
  function AMDDefineDependencyParserPlugin(options) {
    _classCallCheck(this, AMDDefineDependencyParserPlugin);

    this.options = options;
  }

  _createClass(AMDDefineDependencyParserPlugin, [{
    key: "apply",
    value: function apply(parser) {
      parser.hooks.call["for"]("define").tap("AMDDefineDependencyParserPlugin", this.processCallDefine.bind(this, parser));
    }
  }, {
    key: "processArray",
    value: function processArray(parser, expr, param, identifiers, namedModule) {
      var _this = this;

      if (param.isArray()) {
        param.items.forEach(function (param, idx) {
          if (param.isString() && ["require", "module", "exports"].includes(param.string)) identifiers[idx] = param.string;

          var result = _this.processItem(parser, expr, param, namedModule);

          if (result === undefined) {
            _this.processContext(parser, expr, param);
          }
        });
        return true;
      } else if (param.isConstArray()) {
        var deps = [];
        param.array.forEach(function (request, idx) {
          var dep;
          var localModule;

          if (request === "require") {
            identifiers[idx] = request;
            dep = "__webpack_require__";
          } else if (["exports", "module"].includes(request)) {
            identifiers[idx] = request;
            dep = request;
          } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) {
            dep = new LocalModuleDependency(localModule, undefined, false);
            dep.loc = expr.loc;
            parser.state.current.addDependency(dep);
          } else {
            dep = _this.newRequireItemDependency(request);
            dep.loc = expr.loc;
            dep.optional = !!parser.scope.inTry;
            parser.state.current.addDependency(dep);
          }

          deps.push(dep);
        });
        var dep = this.newRequireArrayDependency(deps, param.range);
        dep.loc = expr.loc;
        dep.optional = !!parser.scope.inTry;
        parser.state.current.addDependency(dep);
        return true;
      }
    }
  }, {
    key: "processItem",
    value: function processItem(parser, expr, param, namedModule) {
      var _this2 = this;

      if (param.isConditional()) {
        param.options.forEach(function (param) {
          var result = _this2.processItem(parser, expr, param);

          if (result === undefined) {
            _this2.processContext(parser, expr, param);
          }
        });
        return true;
      } else if (param.isString()) {
        var dep, localModule;

        if (param.string === "require") {
          dep = new ConstDependency("__webpack_require__", param.range);
        } else if (["require", "exports", "module"].includes(param.string)) {
          dep = new ConstDependency(param.string, param.range);
        } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string, namedModule)) {
          dep = new LocalModuleDependency(localModule, param.range, false);
        } else {
          dep = this.newRequireItemDependency(param.string, param.range);
        }

        dep.loc = expr.loc;
        dep.optional = !!parser.scope.inTry;
        parser.state.current.addDependency(dep);
        return true;
      }
    }
  }, {
    key: "processContext",
    value: function processContext(parser, expr, param) {
      var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {}, parser);
      if (!dep) return;
      dep.loc = expr.loc;
      dep.optional = !!parser.scope.inTry;
      parser.state.current.addDependency(dep);
      return true;
    }
  }, {
    key: "processCallDefine",
    value: function processCallDefine(parser, expr) {
      var array, fn, obj, namedModule;

      switch (expr.arguments.length) {
        case 1:
          if (isCallable(expr.arguments[0])) {
            // define(f() {…})
            fn = expr.arguments[0];
          } else if (expr.arguments[0].type === "ObjectExpression") {
            // define({…})
            obj = expr.arguments[0];
          } else {
            // define(expr)
            // unclear if function or object
            obj = fn = expr.arguments[0];
          }

          break;

        case 2:
          if (expr.arguments[0].type === "Literal") {
            namedModule = expr.arguments[0].value; // define("…", …)

            if (isCallable(expr.arguments[1])) {
              // define("…", f() {…})
              fn = expr.arguments[1];
            } else if (expr.arguments[1].type === "ObjectExpression") {
              // define("…", {…})
              obj = expr.arguments[1];
            } else {
              // define("…", expr)
              // unclear if function or object
              obj = fn = expr.arguments[1];
            }
          } else {
            array = expr.arguments[0];

            if (isCallable(expr.arguments[1])) {
              // define([…], f() {})
              fn = expr.arguments[1];
            } else if (expr.arguments[1].type === "ObjectExpression") {
              // define([…], {…})
              obj = expr.arguments[1];
            } else {
              // define([…], expr)
              // unclear if function or object
              obj = fn = expr.arguments[1];
            }
          }

          break;

        case 3:
          // define("…", […], f() {…})
          namedModule = expr.arguments[0].value;
          array = expr.arguments[1];

          if (isCallable(expr.arguments[2])) {
            // define("…", […], f() {})
            fn = expr.arguments[2];
          } else if (expr.arguments[2].type === "ObjectExpression") {
            // define("…", […], {…})
            obj = expr.arguments[2];
          } else {
            // define("…", […], expr)
            // unclear if function or object
            obj = fn = expr.arguments[2];
          }

          break;

        default:
          return;
      }

      var fnParams = null;
      var fnParamsOffset = 0;

      if (fn) {
        if (isUnboundFunctionExpression(fn)) {
          fnParams = fn.params;
        } else if (isBoundFunctionExpression(fn)) {
          fnParams = fn.callee.object.params;
          fnParamsOffset = fn.arguments.length - 1;

          if (fnParamsOffset < 0) {
            fnParamsOffset = 0;
          }
        }
      }

      var fnRenames = parser.scope.renames.createChild();

      if (array) {
        var identifiers = {};
        var param = parser.evaluateExpression(array);
        var result = this.processArray(parser, expr, param, identifiers, namedModule);
        if (!result) return;

        if (fnParams) {
          fnParams = fnParams.slice(fnParamsOffset).filter(function (param, idx) {
            if (identifiers[idx]) {
              fnRenames.set(param.name, identifiers[idx]);
              return false;
            }

            return true;
          });
        }
      } else {
        var _identifiers = ["require", "exports", "module"];

        if (fnParams) {
          fnParams = fnParams.slice(fnParamsOffset).filter(function (param, idx) {
            if (_identifiers[idx]) {
              fnRenames.set(param.name, _identifiers[idx]);
              return false;
            }

            return true;
          });
        }
      }

      var inTry;

      if (fn && isUnboundFunctionExpression(fn)) {
        inTry = parser.scope.inTry;
        parser.inScope(fnParams, function () {
          parser.scope.renames = fnRenames;
          parser.scope.inTry = inTry;

          if (fn.body.type === "BlockStatement") {
            parser.walkStatement(fn.body);
          } else {
            parser.walkExpression(fn.body);
          }
        });
      } else if (fn && isBoundFunctionExpression(fn)) {
        inTry = parser.scope.inTry;
        parser.inScope(fn.callee.object.params.filter(function (i) {
          return !["require", "module", "exports"].includes(i.name);
        }), function () {
          parser.scope.renames = fnRenames;
          parser.scope.inTry = inTry;

          if (fn.callee.object.body.type === "BlockStatement") {
            parser.walkStatement(fn.callee.object.body);
          } else {
            parser.walkExpression(fn.callee.object.body);
          }
        });

        if (fn.arguments) {
          parser.walkExpressions(fn.arguments);
        }
      } else if (fn || obj) {
        parser.walkExpression(fn || obj);
      }

      var dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule ? namedModule : null);
      dep.loc = expr.loc;

      if (namedModule) {
        dep.localModule = LocalModulesHelpers.addLocalModule(parser.state, namedModule);
      }

      parser.state.current.addDependency(dep);
      return true;
    }
  }, {
    key: "newDefineDependency",
    value: function newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {
      return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);
    }
  }, {
    key: "newRequireArrayDependency",
    value: function newRequireArrayDependency(depsArray, range) {
      return new AMDRequireArrayDependency(depsArray, range);
    }
  }, {
    key: "newRequireItemDependency",
    value: function newRequireItemDependency(request, range) {
      return new AMDRequireItemDependency(request, range);
    }
  }]);

  return AMDDefineDependencyParserPlugin;
}();

module.exports = AMDDefineDependencyParserPlugin;