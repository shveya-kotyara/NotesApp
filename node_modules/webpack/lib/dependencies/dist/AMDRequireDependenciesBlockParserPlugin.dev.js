/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AMDRequireItemDependency = require("./AMDRequireItemDependency");

var AMDRequireArrayDependency = require("./AMDRequireArrayDependency");

var AMDRequireContextDependency = require("./AMDRequireContextDependency");

var AMDRequireDependenciesBlock = require("./AMDRequireDependenciesBlock");

var UnsupportedDependency = require("./UnsupportedDependency");

var LocalModuleDependency = require("./LocalModuleDependency");

var ContextDependencyHelpers = require("./ContextDependencyHelpers");

var LocalModulesHelpers = require("./LocalModulesHelpers");

var ConstDependency = require("./ConstDependency");

var getFunctionExpression = require("./getFunctionExpression");

var UnsupportedFeatureWarning = require("../UnsupportedFeatureWarning");

var AMDRequireDependenciesBlockParserPlugin =
/*#__PURE__*/
function () {
  function AMDRequireDependenciesBlockParserPlugin(options) {
    _classCallCheck(this, AMDRequireDependenciesBlockParserPlugin);

    this.options = options;
  }

  _createClass(AMDRequireDependenciesBlockParserPlugin, [{
    key: "processFunctionArgument",
    value: function processFunctionArgument(parser, expression) {
      var bindThis = true;
      var fnData = getFunctionExpression(expression);

      if (fnData) {
        parser.inScope(fnData.fn.params.filter(function (i) {
          return !["require", "module", "exports"].includes(i.name);
        }), function () {
          if (fnData.fn.body.type === "BlockStatement") {
            parser.walkStatement(fnData.fn.body);
          } else {
            parser.walkExpression(fnData.fn.body);
          }
        });
        parser.walkExpressions(fnData.expressions);

        if (fnData.needThis === false) {
          bindThis = false;
        }
      } else {
        parser.walkExpression(expression);
      }

      return bindThis;
    }
  }, {
    key: "apply",
    value: function apply(parser) {
      parser.hooks.call["for"]("require").tap("AMDRequireDependenciesBlockParserPlugin", this.processCallRequire.bind(this, parser));
    }
  }, {
    key: "processArray",
    value: function processArray(parser, expr, param) {
      if (param.isArray()) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = param.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var p = _step.value;
            var result = this.processItem(parser, expr, p);

            if (result === undefined) {
              this.processContext(parser, expr, p);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return true;
      } else if (param.isConstArray()) {
        var deps = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = param.array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var request = _step2.value;

            var _dep = void 0,
                localModule = void 0;

            if (request === "require") {
              _dep = "__webpack_require__";
            } else if (["exports", "module"].includes(request)) {
              _dep = request;
            } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) {
              _dep = new LocalModuleDependency(localModule, undefined, false);
              _dep.loc = expr.loc;
              parser.state.current.addDependency(_dep);
            } else {
              _dep = this.newRequireItemDependency(request);
              _dep.loc = expr.loc;
              _dep.optional = !!parser.scope.inTry;
              parser.state.current.addDependency(_dep);
            }

            deps.push(_dep);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var dep = this.newRequireArrayDependency(deps, param.range);
        dep.loc = expr.loc;
        dep.optional = !!parser.scope.inTry;
        parser.state.current.addDependency(dep);
        return true;
      }
    }
  }, {
    key: "processItem",
    value: function processItem(parser, expr, param) {
      if (param.isConditional()) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = param.options[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var p = _step3.value;
            var result = this.processItem(parser, expr, p);

            if (result === undefined) {
              this.processContext(parser, expr, p);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return true;
      } else if (param.isString()) {
        var dep, localModule;

        if (param.string === "require") {
          dep = new ConstDependency("__webpack_require__", param.string);
        } else if (param.string === "module") {
          dep = new ConstDependency(parser.state.module.buildInfo.moduleArgument, param.range);
        } else if (param.string === "exports") {
          dep = new ConstDependency(parser.state.module.buildInfo.exportsArgument, param.range);
        } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string)) {
          dep = new LocalModuleDependency(localModule, param.range, false);
        } else {
          dep = this.newRequireItemDependency(param.string, param.range);
        }

        dep.loc = expr.loc;
        dep.optional = !!parser.scope.inTry;
        parser.state.current.addDependency(dep);
        return true;
      }
    }
  }, {
    key: "processContext",
    value: function processContext(parser, expr, param) {
      var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {}, parser);
      if (!dep) return;
      dep.loc = expr.loc;
      dep.optional = !!parser.scope.inTry;
      parser.state.current.addDependency(dep);
      return true;
    }
  }, {
    key: "processArrayForRequestString",
    value: function processArrayForRequestString(param) {
      var _this = this;

      if (param.isArray()) {
        var result = param.items.map(function (item) {
          return _this.processItemForRequestString(item);
        });
        if (result.every(Boolean)) return result.join(" ");
      } else if (param.isConstArray()) {
        return param.array.join(" ");
      }
    }
  }, {
    key: "processItemForRequestString",
    value: function processItemForRequestString(param) {
      var _this2 = this;

      if (param.isConditional()) {
        var result = param.options.map(function (item) {
          return _this2.processItemForRequestString(item);
        });
        if (result.every(Boolean)) return result.join("|");
      } else if (param.isString()) {
        return param.string;
      }
    }
  }, {
    key: "processCallRequire",
    value: function processCallRequire(parser, expr) {
      var _this3 = this;

      var param;
      var dep;
      var result;
      var old = parser.state.current;

      if (expr.arguments.length >= 1) {
        param = parser.evaluateExpression(expr.arguments[0]);
        dep = this.newRequireDependenciesBlock(expr, param.range, expr.arguments.length > 1 ? expr.arguments[1].range : null, expr.arguments.length > 2 ? expr.arguments[2].range : null, parser.state.module, expr.loc, this.processArrayForRequestString(param));
        parser.state.current = dep;
      }

      if (expr.arguments.length === 1) {
        parser.inScope([], function () {
          result = _this3.processArray(parser, expr, param);
        });
        parser.state.current = old;
        if (!result) return;
        parser.state.current.addBlock(dep);
        return true;
      }

      if (expr.arguments.length === 2 || expr.arguments.length === 3) {
        try {
          parser.inScope([], function () {
            result = _this3.processArray(parser, expr, param);
          });

          if (!result) {
            dep = new UnsupportedDependency("unsupported", expr.range);
            old.addDependency(dep);

            if (parser.state.module) {
              parser.state.module.errors.push(new UnsupportedFeatureWarning(parser.state.module, "Cannot statically analyse 'require(…, …)' in line " + expr.loc.start.line, expr.loc));
            }

            dep = null;
            return true;
          }

          dep.functionBindThis = this.processFunctionArgument(parser, expr.arguments[1]);

          if (expr.arguments.length === 3) {
            dep.errorCallbackBindThis = this.processFunctionArgument(parser, expr.arguments[2]);
          }
        } finally {
          parser.state.current = old;
          if (dep) parser.state.current.addBlock(dep);
        }

        return true;
      }
    }
  }, {
    key: "newRequireDependenciesBlock",
    value: function newRequireDependenciesBlock(expr, arrayRange, functionRange, errorCallbackRange, module, loc, request) {
      return new AMDRequireDependenciesBlock(expr, arrayRange, functionRange, errorCallbackRange, module, loc, request);
    }
  }, {
    key: "newRequireItemDependency",
    value: function newRequireItemDependency(request, range) {
      return new AMDRequireItemDependency(request, range);
    }
  }, {
    key: "newRequireArrayDependency",
    value: function newRequireArrayDependency(depsArray, range) {
      return new AMDRequireArrayDependency(depsArray, range);
    }
  }]);

  return AMDRequireDependenciesBlockParserPlugin;
}();

module.exports = AMDRequireDependenciesBlockParserPlugin;