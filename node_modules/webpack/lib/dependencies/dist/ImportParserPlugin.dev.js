/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ImportContextDependency = require("./ImportContextDependency");

var ImportWeakDependency = require("./ImportWeakDependency");

var ImportDependenciesBlock = require("./ImportDependenciesBlock");

var ImportEagerDependency = require("./ImportEagerDependency");

var ContextDependencyHelpers = require("./ContextDependencyHelpers");

var UnsupportedFeatureWarning = require("../UnsupportedFeatureWarning");

var CommentCompilationWarning = require("../CommentCompilationWarning");

var ImportParserPlugin =
/*#__PURE__*/
function () {
  function ImportParserPlugin(options) {
    _classCallCheck(this, ImportParserPlugin);

    this.options = options;
  }

  _createClass(ImportParserPlugin, [{
    key: "apply",
    value: function apply(parser) {
      var _this = this;

      parser.hooks.importCall.tap("ImportParserPlugin", function (expr) {
        if (expr.arguments.length !== 1) {
          throw new Error("Incorrect number of arguments provided to 'import(module: string) -> Promise'.");
        }

        var param = parser.evaluateExpression(expr.arguments[0]);
        var chunkName = null;
        var mode = "lazy";
        var include = null;
        var exclude = null;
        var groupOptions = {};

        var _parser$parseCommentO = parser.parseCommentOptions(expr.range),
            importOptions = _parser$parseCommentO.options,
            commentErrors = _parser$parseCommentO.errors;

        if (commentErrors) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = commentErrors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var e = _step.value;
              var comment = e.comment;
              parser.state.module.warnings.push(new CommentCompilationWarning("Compilation error while processing magic comment(-s): /*".concat(comment.value, "*/: ").concat(e.message), parser.state.module, comment.loc));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        if (importOptions) {
          if (importOptions.webpackIgnore !== undefined) {
            if (typeof importOptions.webpackIgnore !== "boolean") {
              parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackIgnore` expected a boolean, but received: ".concat(importOptions.webpackIgnore, "."), expr.loc));
            } else {
              // Do not instrument `import()` if `webpackIgnore` is `true`
              if (importOptions.webpackIgnore) {
                return false;
              }
            }
          }

          if (importOptions.webpackChunkName !== undefined) {
            if (typeof importOptions.webpackChunkName !== "string") {
              parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackChunkName` expected a string, but received: ".concat(importOptions.webpackChunkName, "."), expr.loc));
            } else {
              chunkName = importOptions.webpackChunkName;
            }
          }

          if (importOptions.webpackMode !== undefined) {
            if (typeof importOptions.webpackMode !== "string") {
              parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackMode` expected a string, but received: ".concat(importOptions.webpackMode, "."), expr.loc));
            } else {
              mode = importOptions.webpackMode;
            }
          }

          if (importOptions.webpackPrefetch !== undefined) {
            if (importOptions.webpackPrefetch === true) {
              groupOptions.prefetchOrder = 0;
            } else if (typeof importOptions.webpackPrefetch === "number") {
              groupOptions.prefetchOrder = importOptions.webpackPrefetch;
            } else {
              parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackPrefetch` expected true or a number, but received: ".concat(importOptions.webpackPrefetch, "."), expr.loc));
            }
          }

          if (importOptions.webpackPreload !== undefined) {
            if (importOptions.webpackPreload === true) {
              groupOptions.preloadOrder = 0;
            } else if (typeof importOptions.webpackPreload === "number") {
              groupOptions.preloadOrder = importOptions.webpackPreload;
            } else {
              parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackPreload` expected true or a number, but received: ".concat(importOptions.webpackPreload, "."), expr.loc));
            }
          }

          if (importOptions.webpackInclude !== undefined) {
            if (!importOptions.webpackInclude || importOptions.webpackInclude.constructor.name !== "RegExp") {
              parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackInclude` expected a regular expression, but received: ".concat(importOptions.webpackInclude, "."), expr.loc));
            } else {
              include = new RegExp(importOptions.webpackInclude);
            }
          }

          if (importOptions.webpackExclude !== undefined) {
            if (!importOptions.webpackExclude || importOptions.webpackExclude.constructor.name !== "RegExp") {
              parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackExclude` expected a regular expression, but received: ".concat(importOptions.webpackExclude, "."), expr.loc));
            } else {
              exclude = new RegExp(importOptions.webpackExclude);
            }
          }
        }

        if (param.isString()) {
          if (mode !== "lazy" && mode !== "eager" && mode !== "weak") {
            parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackMode` expected 'lazy', 'eager' or 'weak', but received: ".concat(mode, "."), expr.loc));
          }

          if (mode === "eager") {
            var dep = new ImportEagerDependency(param.string, parser.state.module, expr.range);
            parser.state.current.addDependency(dep);
          } else if (mode === "weak") {
            var _dep = new ImportWeakDependency(param.string, parser.state.module, expr.range);

            parser.state.current.addDependency(_dep);
          } else {
            var depBlock = new ImportDependenciesBlock(param.string, expr.range, Object.assign(groupOptions, {
              name: chunkName
            }), parser.state.module, expr.loc, parser.state.module);
            parser.state.current.addBlock(depBlock);
          }

          return true;
        } else {
          if (mode !== "lazy" && mode !== "lazy-once" && mode !== "eager" && mode !== "weak") {
            parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, "`webpackMode` expected 'lazy', 'lazy-once', 'eager' or 'weak', but received: ".concat(mode, "."), expr.loc));
            mode = "lazy";
          }

          if (mode === "weak") {
            mode = "async-weak";
          }

          var _dep2 = ContextDependencyHelpers.create(ImportContextDependency, expr.range, param, expr, _this.options, {
            chunkName: chunkName,
            groupOptions: groupOptions,
            include: include,
            exclude: exclude,
            mode: mode,
            namespaceObject: parser.state.module.buildMeta.strictHarmonyModule ? "strict" : true
          }, parser);

          if (!_dep2) return;
          _dep2.loc = expr.loc;
          _dep2.optional = !!parser.scope.inTry;
          parser.state.current.addDependency(_dep2);
          return true;
        }
      });
    }
  }]);

  return ImportParserPlugin;
}();

module.exports = ImportParserPlugin;