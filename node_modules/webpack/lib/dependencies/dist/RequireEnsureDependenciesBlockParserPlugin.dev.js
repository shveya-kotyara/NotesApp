/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RequireEnsureDependenciesBlock = require("./RequireEnsureDependenciesBlock");

var RequireEnsureItemDependency = require("./RequireEnsureItemDependency");

var getFunctionExpression = require("./getFunctionExpression");

module.exports =
/*#__PURE__*/
function () {
  function RequireEnsureDependenciesBlockParserPlugin() {
    _classCallCheck(this, RequireEnsureDependenciesBlockParserPlugin);
  }

  _createClass(RequireEnsureDependenciesBlockParserPlugin, [{
    key: "apply",
    value: function apply(parser) {
      parser.hooks.call["for"]("require.ensure").tap("RequireEnsureDependenciesBlockParserPlugin", function (expr) {
        var chunkName = null;
        var chunkNameRange = null;
        var errorExpressionArg = null;
        var errorExpression = null;

        switch (expr.arguments.length) {
          case 4:
            {
              var chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
              if (!chunkNameExpr.isString()) return;
              chunkNameRange = chunkNameExpr.range;
              chunkName = chunkNameExpr.string;
            }
          // falls through

          case 3:
            {
              errorExpressionArg = expr.arguments[2];
              errorExpression = getFunctionExpression(errorExpressionArg);

              if (!errorExpression && !chunkName) {
                var _chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);

                if (!_chunkNameExpr.isString()) return;
                chunkNameRange = _chunkNameExpr.range;
                chunkName = _chunkNameExpr.string;
              }
            }
          // falls through

          case 2:
            {
              var dependenciesExpr = parser.evaluateExpression(expr.arguments[0]);
              var dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];
              var successExpressionArg = expr.arguments[1];
              var successExpression = getFunctionExpression(successExpressionArg);

              if (successExpression) {
                parser.walkExpressions(successExpression.expressions);
              }

              if (errorExpression) {
                parser.walkExpressions(errorExpression.expressions);
              }

              var dep = new RequireEnsureDependenciesBlock(expr, successExpression ? successExpression.fn : successExpressionArg, errorExpression ? errorExpression.fn : errorExpressionArg, chunkName, chunkNameRange, parser.state.module, expr.loc);
              var old = parser.state.current;
              parser.state.current = dep;

              try {
                var failed = false;
                parser.inScope([], function () {
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = undefined;

                  try {
                    for (var _iterator = dependenciesItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var ee = _step.value;

                      if (ee.isString()) {
                        var edep = new RequireEnsureItemDependency(ee.string);
                        edep.loc = dep.loc;
                        dep.addDependency(edep);
                      } else {
                        failed = true;
                      }
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                        _iterator["return"]();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }
                });

                if (failed) {
                  return;
                }

                if (successExpression) {
                  if (successExpression.fn.body.type === "BlockStatement") {
                    parser.walkStatement(successExpression.fn.body);
                  } else {
                    parser.walkExpression(successExpression.fn.body);
                  }
                }

                old.addBlock(dep);
              } finally {
                parser.state.current = old;
              }

              if (!successExpression) {
                parser.walkExpression(successExpressionArg);
              }

              if (errorExpression) {
                if (errorExpression.fn.body.type === "BlockStatement") {
                  parser.walkStatement(errorExpression.fn.body);
                } else {
                  parser.walkExpression(errorExpression.fn.body);
                }
              } else if (errorExpressionArg) {
                parser.walkExpression(errorExpressionArg);
              }

              return true;
            }
        }
      });
    }
  }]);

  return RequireEnsureDependenciesBlockParserPlugin;
}();