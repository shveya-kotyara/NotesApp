/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var parseJson = require("json-parse-better-errors");

var asyncLib = require("neo-async");

var path = require("path");

var _require = require("webpack-sources"),
    Source = _require.Source;

var util = require("util");

var _require2 = require("tapable"),
    Tapable = _require2.Tapable,
    SyncHook = _require2.SyncHook,
    SyncBailHook = _require2.SyncBailHook,
    AsyncParallelHook = _require2.AsyncParallelHook,
    AsyncSeriesHook = _require2.AsyncSeriesHook;

var Compilation = require("./Compilation");

var Stats = require("./Stats");

var Watching = require("./Watching");

var NormalModuleFactory = require("./NormalModuleFactory");

var ContextModuleFactory = require("./ContextModuleFactory");

var ResolverFactory = require("./ResolverFactory");

var RequestShortener = require("./RequestShortener");

var _require3 = require("./util/identifier"),
    makePathsRelative = _require3.makePathsRelative;

var ConcurrentCompilationError = require("./ConcurrentCompilationError");

var _require4 = require("./logging/Logger"),
    Logger = _require4.Logger;
/** @typedef {import("../declarations/WebpackOptions").Entry} Entry */

/** @typedef {import("../declarations/WebpackOptions").WebpackOptions} WebpackOptions */

/**
 * @typedef {Object} CompilationParams
 * @property {NormalModuleFactory} normalModuleFactory
 * @property {ContextModuleFactory} contextModuleFactory
 * @property {Set<string>} compilationDependencies
 */


var Compiler =
/*#__PURE__*/
function (_Tapable) {
  _inherits(Compiler, _Tapable);

  function Compiler(context) {
    var _this;

    _classCallCheck(this, Compiler);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Compiler).call(this));
    _this.hooks = {
      /** @type {SyncBailHook<Compilation>} */
      shouldEmit: new SyncBailHook(["compilation"]),

      /** @type {AsyncSeriesHook<Stats>} */
      done: new AsyncSeriesHook(["stats"]),

      /** @type {AsyncSeriesHook<>} */
      additionalPass: new AsyncSeriesHook([]),

      /** @type {AsyncSeriesHook<Compiler>} */
      beforeRun: new AsyncSeriesHook(["compiler"]),

      /** @type {AsyncSeriesHook<Compiler>} */
      run: new AsyncSeriesHook(["compiler"]),

      /** @type {AsyncSeriesHook<Compilation>} */
      emit: new AsyncSeriesHook(["compilation"]),

      /** @type {AsyncSeriesHook<string, Buffer>} */
      assetEmitted: new AsyncSeriesHook(["file", "content"]),

      /** @type {AsyncSeriesHook<Compilation>} */
      afterEmit: new AsyncSeriesHook(["compilation"]),

      /** @type {SyncHook<Compilation, CompilationParams>} */
      thisCompilation: new SyncHook(["compilation", "params"]),

      /** @type {SyncHook<Compilation, CompilationParams>} */
      compilation: new SyncHook(["compilation", "params"]),

      /** @type {SyncHook<NormalModuleFactory>} */
      normalModuleFactory: new SyncHook(["normalModuleFactory"]),

      /** @type {SyncHook<ContextModuleFactory>}  */
      contextModuleFactory: new SyncHook(["contextModulefactory"]),

      /** @type {AsyncSeriesHook<CompilationParams>} */
      beforeCompile: new AsyncSeriesHook(["params"]),

      /** @type {SyncHook<CompilationParams>} */
      compile: new SyncHook(["params"]),

      /** @type {AsyncParallelHook<Compilation>} */
      make: new AsyncParallelHook(["compilation"]),

      /** @type {AsyncSeriesHook<Compilation>} */
      afterCompile: new AsyncSeriesHook(["compilation"]),

      /** @type {AsyncSeriesHook<Compiler>} */
      watchRun: new AsyncSeriesHook(["compiler"]),

      /** @type {SyncHook<Error>} */
      failed: new SyncHook(["error"]),

      /** @type {SyncHook<string, string>} */
      invalid: new SyncHook(["filename", "changeTime"]),

      /** @type {SyncHook} */
      watchClose: new SyncHook([]),

      /** @type {SyncBailHook<string, string, any[]>} */
      infrastructureLog: new SyncBailHook(["origin", "type", "args"]),
      // TODO the following hooks are weirdly located here
      // TODO move them for webpack 5

      /** @type {SyncHook} */
      environment: new SyncHook([]),

      /** @type {SyncHook} */
      afterEnvironment: new SyncHook([]),

      /** @type {SyncHook<Compiler>} */
      afterPlugins: new SyncHook(["compiler"]),

      /** @type {SyncHook<Compiler>} */
      afterResolvers: new SyncHook(["compiler"]),

      /** @type {SyncBailHook<string, Entry>} */
      entryOption: new SyncBailHook(["context", "entry"])
    }; // TODO webpack 5 remove this

    _this.hooks.infrastructurelog = _this.hooks.infrastructureLog;

    _this._pluginCompat.tap("Compiler", function (options) {
      switch (options.name) {
        case "additional-pass":
        case "before-run":
        case "run":
        case "emit":
        case "after-emit":
        case "before-compile":
        case "make":
        case "after-compile":
        case "watch-run":
          options.async = true;
          break;
      }
    });
    /** @type {string=} */


    _this.name = undefined;
    /** @type {Compilation=} */

    _this.parentCompilation = undefined;
    /** @type {string} */

    _this.outputPath = "";
    _this.outputFileSystem = null;
    _this.inputFileSystem = null;
    /** @type {string|null} */

    _this.recordsInputPath = null;
    /** @type {string|null} */

    _this.recordsOutputPath = null;
    _this.records = {};
    _this.removedFiles = new Set();
    /** @type {Map<string, number>} */

    _this.fileTimestamps = new Map();
    /** @type {Map<string, number>} */

    _this.contextTimestamps = new Map();
    /** @type {ResolverFactory} */

    _this.resolverFactory = new ResolverFactory();
    _this.infrastructureLogger = undefined; // TODO remove in webpack 5

    _this.resolvers = {
      normal: {
        plugins: util.deprecate(function (hook, fn) {
          _this.resolverFactory.plugin("resolver normal", function (resolver) {
            resolver.plugin(hook, fn);
          });
        }, "webpack: Using compiler.resolvers.normal is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
        apply: util.deprecate(function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this.resolverFactory.plugin("resolver normal", function (resolver) {
            resolver.apply.apply(resolver, args);
          });
        }, "webpack: Using compiler.resolvers.normal is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
      },
      loader: {
        plugins: util.deprecate(function (hook, fn) {
          _this.resolverFactory.plugin("resolver loader", function (resolver) {
            resolver.plugin(hook, fn);
          });
        }, "webpack: Using compiler.resolvers.loader is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
        apply: util.deprecate(function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          _this.resolverFactory.plugin("resolver loader", function (resolver) {
            resolver.apply.apply(resolver, args);
          });
        }, "webpack: Using compiler.resolvers.loader is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
      },
      context: {
        plugins: util.deprecate(function (hook, fn) {
          _this.resolverFactory.plugin("resolver context", function (resolver) {
            resolver.plugin(hook, fn);
          });
        }, "webpack: Using compiler.resolvers.context is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
        apply: util.deprecate(function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          _this.resolverFactory.plugin("resolver context", function (resolver) {
            resolver.apply.apply(resolver, args);
          });
        }, "webpack: Using compiler.resolvers.context is deprecated.\n" + 'Use compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
      }
    };
    /** @type {WebpackOptions} */

    _this.options =
    /** @type {WebpackOptions} */
    {};
    _this.context = context;
    _this.requestShortener = new RequestShortener(context);
    /** @type {boolean} */

    _this.running = false;
    /** @type {boolean} */

    _this.watchMode = false;
    /** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */

    _this._assetEmittingSourceCache = new WeakMap();
    /** @private @type {Map<string, number>} */

    _this._assetEmittingWrittenFiles = new Map();
    return _this;
  }
  /**
   * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name
   * @returns {Logger} a logger with that name
   */


  _createClass(Compiler, [{
    key: "getInfrastructureLogger",
    value: function getInfrastructureLogger(name) {
      var _this2 = this;

      if (!name) {
        throw new TypeError("Compiler.getInfrastructureLogger(name) called without a name");
      }

      return new Logger(function (type, args) {
        if (typeof name === "function") {
          name = name();

          if (!name) {
            throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
          }
        }

        if (_this2.hooks.infrastructureLog.call(name, type, args) === undefined) {
          if (_this2.infrastructureLogger !== undefined) {
            _this2.infrastructureLogger(name, type, args);
          }
        }
      });
    }
  }, {
    key: "watch",
    value: function watch(watchOptions, handler) {
      if (this.running) return handler(new ConcurrentCompilationError());
      this.running = true;
      this.watchMode = true;
      this.fileTimestamps = new Map();
      this.contextTimestamps = new Map();
      this.removedFiles = new Set();
      return new Watching(this, watchOptions, handler);
    }
  }, {
    key: "run",
    value: function run(callback) {
      var _this3 = this;

      if (this.running) return callback(new ConcurrentCompilationError());

      var finalCallback = function finalCallback(err, stats) {
        _this3.running = false;

        if (err) {
          _this3.hooks.failed.call(err);
        }

        if (callback !== undefined) return callback(err, stats);
      };

      var startTime = Date.now();
      this.running = true;

      var onCompiled = function onCompiled(err, compilation) {
        if (err) return finalCallback(err);

        if (_this3.hooks.shouldEmit.call(compilation) === false) {
          var stats = new Stats(compilation);
          stats.startTime = startTime;
          stats.endTime = Date.now();

          _this3.hooks.done.callAsync(stats, function (err) {
            if (err) return finalCallback(err);
            return finalCallback(null, stats);
          });

          return;
        }

        _this3.emitAssets(compilation, function (err) {
          if (err) return finalCallback(err);

          if (compilation.hooks.needAdditionalPass.call()) {
            compilation.needAdditionalPass = true;

            var _stats = new Stats(compilation);

            _stats.startTime = startTime;
            _stats.endTime = Date.now();

            _this3.hooks.done.callAsync(_stats, function (err) {
              if (err) return finalCallback(err);

              _this3.hooks.additionalPass.callAsync(function (err) {
                if (err) return finalCallback(err);

                _this3.compile(onCompiled);
              });
            });

            return;
          }

          _this3.emitRecords(function (err) {
            if (err) return finalCallback(err);
            var stats = new Stats(compilation);
            stats.startTime = startTime;
            stats.endTime = Date.now();

            _this3.hooks.done.callAsync(stats, function (err) {
              if (err) return finalCallback(err);
              return finalCallback(null, stats);
            });
          });
        });
      };

      this.hooks.beforeRun.callAsync(this, function (err) {
        if (err) return finalCallback(err);

        _this3.hooks.run.callAsync(_this3, function (err) {
          if (err) return finalCallback(err);

          _this3.readRecords(function (err) {
            if (err) return finalCallback(err);

            _this3.compile(onCompiled);
          });
        });
      });
    }
  }, {
    key: "runAsChild",
    value: function runAsChild(callback) {
      var _this4 = this;

      this.compile(function (err, compilation) {
        if (err) return callback(err);

        _this4.parentCompilation.children.push(compilation);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = compilation.getAssets()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _step.value,
                name = _step$value.name,
                source = _step$value.source,
                info = _step$value.info;

            _this4.parentCompilation.emitAsset(name, source, info);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var entries = Array.from(compilation.entrypoints.values(), function (ep) {
          return ep.chunks;
        }).reduce(function (array, chunks) {
          return array.concat(chunks);
        }, []);
        return callback(null, entries, compilation);
      });
    }
  }, {
    key: "purgeInputFileSystem",
    value: function purgeInputFileSystem() {
      if (this.inputFileSystem && this.inputFileSystem.purge) {
        this.inputFileSystem.purge();
      }
    }
  }, {
    key: "emitAssets",
    value: function emitAssets(compilation, callback) {
      var _this5 = this;

      var outputPath;

      var emitFiles = function emitFiles(err) {
        if (err) return callback(err);
        asyncLib.forEachLimit(compilation.getAssets(), 15, function (_ref, callback) {
          var file = _ref.name,
              source = _ref.source;
          var targetFile = file;
          var queryStringIdx = targetFile.indexOf("?");

          if (queryStringIdx >= 0) {
            targetFile = targetFile.substr(0, queryStringIdx);
          }

          var writeOut = function writeOut(err) {
            if (err) return callback(err);

            var targetPath = _this5.outputFileSystem.join(outputPath, targetFile); // TODO webpack 5 remove futureEmitAssets option and make it on by default


            if (_this5.options.output.futureEmitAssets) {
              // check if the target file has already been written by this Compiler
              var targetFileGeneration = _this5._assetEmittingWrittenFiles.get(targetPath); // create an cache entry for this Source if not already existing


              var cacheEntry = _this5._assetEmittingSourceCache.get(source);

              if (cacheEntry === undefined) {
                cacheEntry = {
                  sizeOnlySource: undefined,
                  writtenTo: new Map()
                };

                _this5._assetEmittingSourceCache.set(source, cacheEntry);
              } // if the target file has already been written


              if (targetFileGeneration !== undefined) {
                // check if the Source has been written to this target file
                var writtenGeneration = cacheEntry.writtenTo.get(targetPath);

                if (writtenGeneration === targetFileGeneration) {
                  // if yes, we skip writing the file
                  // as it's already there
                  // (we assume one doesn't remove files while the Compiler is running)
                  compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
                    size: cacheEntry.sizeOnlySource.size()
                  });
                  return callback();
                }
              } // TODO webpack 5: if info.immutable check if file already exists in output
              // skip emitting if it's already there
              // get the binary (Buffer) content from the Source

              /** @type {Buffer} */


              var content;

              if (typeof source.buffer === "function") {
                content = source.buffer();
              } else {
                var bufferOrString = source.source();

                if (Buffer.isBuffer(bufferOrString)) {
                  content = bufferOrString;
                } else {
                  content = Buffer.from(bufferOrString, "utf8");
                }
              } // Create a replacement resource which only allows to ask for size
              // This allows to GC all memory allocated by the Source
              // (expect when the Source is stored in any other cache)


              cacheEntry.sizeOnlySource = new SizeOnlySource(content.length);
              compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
                size: content.length
              }); // Write the file to output file system

              _this5.outputFileSystem.writeFile(targetPath, content, function (err) {
                if (err) return callback(err); // information marker that the asset has been emitted

                compilation.emittedAssets.add(file); // cache the information that the Source has been written to that location

                var newGeneration = targetFileGeneration === undefined ? 1 : targetFileGeneration + 1;
                cacheEntry.writtenTo.set(targetPath, newGeneration);

                _this5._assetEmittingWrittenFiles.set(targetPath, newGeneration);

                _this5.hooks.assetEmitted.callAsync(file, content, callback);
              });
            } else {
              if (source.existsAt === targetPath) {
                source.emitted = false;
                return callback();
              }

              var _content = source.source();

              if (!Buffer.isBuffer(_content)) {
                _content = Buffer.from(_content, "utf8");
              }

              source.existsAt = targetPath;
              source.emitted = true;

              _this5.outputFileSystem.writeFile(targetPath, _content, function (err) {
                if (err) return callback(err);

                _this5.hooks.assetEmitted.callAsync(file, _content, callback);
              });
            }
          };

          if (targetFile.match(/\/|\\/)) {
            var dir = path.dirname(targetFile);

            _this5.outputFileSystem.mkdirp(_this5.outputFileSystem.join(outputPath, dir), writeOut);
          } else {
            writeOut();
          }
        }, function (err) {
          if (err) return callback(err);

          _this5.hooks.afterEmit.callAsync(compilation, function (err) {
            if (err) return callback(err);
            return callback();
          });
        });
      };

      this.hooks.emit.callAsync(compilation, function (err) {
        if (err) return callback(err);
        outputPath = compilation.getPath(_this5.outputPath);

        _this5.outputFileSystem.mkdirp(outputPath, emitFiles);
      });
    }
  }, {
    key: "emitRecords",
    value: function emitRecords(callback) {
      var _this6 = this;

      if (!this.recordsOutputPath) return callback();
      var idx1 = this.recordsOutputPath.lastIndexOf("/");
      var idx2 = this.recordsOutputPath.lastIndexOf("\\");
      var recordsOutputPathDirectory = null;

      if (idx1 > idx2) {
        recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);
      } else if (idx1 < idx2) {
        recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);
      }

      var writeFile = function writeFile() {
        _this6.outputFileSystem.writeFile(_this6.recordsOutputPath, JSON.stringify(_this6.records, undefined, 2), callback);
      };

      if (!recordsOutputPathDirectory) {
        return writeFile();
      }

      this.outputFileSystem.mkdirp(recordsOutputPathDirectory, function (err) {
        if (err) return callback(err);
        writeFile();
      });
    }
  }, {
    key: "readRecords",
    value: function readRecords(callback) {
      var _this7 = this;

      if (!this.recordsInputPath) {
        this.records = {};
        return callback();
      }

      this.inputFileSystem.stat(this.recordsInputPath, function (err) {
        // It doesn't exist
        // We can ignore this.
        if (err) return callback();

        _this7.inputFileSystem.readFile(_this7.recordsInputPath, function (err, content) {
          if (err) return callback(err);

          try {
            _this7.records = parseJson(content.toString("utf-8"));
          } catch (e) {
            e.message = "Cannot parse records: " + e.message;
            return callback(e);
          }

          return callback();
        });
      });
    }
  }, {
    key: "createChildCompiler",
    value: function createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {
      var childCompiler = new Compiler(this.context);

      if (Array.isArray(plugins)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var plugin = _step2.value;
            plugin.apply(childCompiler);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      for (var name in this.hooks) {
        if (!["make", "compile", "emit", "afterEmit", "invalid", "done", "thisCompilation"].includes(name)) {
          if (childCompiler.hooks[name]) {
            childCompiler.hooks[name].taps = this.hooks[name].taps.slice();
          }
        }
      }

      childCompiler.name = compilerName;
      childCompiler.outputPath = this.outputPath;
      childCompiler.inputFileSystem = this.inputFileSystem;
      childCompiler.outputFileSystem = null;
      childCompiler.resolverFactory = this.resolverFactory;
      childCompiler.fileTimestamps = this.fileTimestamps;
      childCompiler.contextTimestamps = this.contextTimestamps;
      var relativeCompilerName = makePathsRelative(this.context, compilerName);

      if (!this.records[relativeCompilerName]) {
        this.records[relativeCompilerName] = [];
      }

      if (this.records[relativeCompilerName][compilerIndex]) {
        childCompiler.records = this.records[relativeCompilerName][compilerIndex];
      } else {
        this.records[relativeCompilerName].push(childCompiler.records = {});
      }

      childCompiler.options = Object.create(this.options);
      childCompiler.options.output = Object.create(childCompiler.options.output);

      for (var _name in outputOptions) {
        childCompiler.options.output[_name] = outputOptions[_name];
      }

      childCompiler.parentCompilation = compilation;
      compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);
      return childCompiler;
    }
  }, {
    key: "isChild",
    value: function isChild() {
      return !!this.parentCompilation;
    }
  }, {
    key: "createCompilation",
    value: function createCompilation() {
      return new Compilation(this);
    }
  }, {
    key: "newCompilation",
    value: function newCompilation(params) {
      var compilation = this.createCompilation();
      compilation.fileTimestamps = this.fileTimestamps;
      compilation.contextTimestamps = this.contextTimestamps;
      compilation.name = this.name;
      compilation.records = this.records;
      compilation.compilationDependencies = params.compilationDependencies;
      this.hooks.thisCompilation.call(compilation, params);
      this.hooks.compilation.call(compilation, params);
      return compilation;
    }
  }, {
    key: "createNormalModuleFactory",
    value: function createNormalModuleFactory() {
      var normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolverFactory, this.options.module || {});
      this.hooks.normalModuleFactory.call(normalModuleFactory);
      return normalModuleFactory;
    }
  }, {
    key: "createContextModuleFactory",
    value: function createContextModuleFactory() {
      var contextModuleFactory = new ContextModuleFactory(this.resolverFactory);
      this.hooks.contextModuleFactory.call(contextModuleFactory);
      return contextModuleFactory;
    }
  }, {
    key: "newCompilationParams",
    value: function newCompilationParams() {
      var params = {
        normalModuleFactory: this.createNormalModuleFactory(),
        contextModuleFactory: this.createContextModuleFactory(),
        compilationDependencies: new Set()
      };
      return params;
    }
  }, {
    key: "compile",
    value: function compile(callback) {
      var _this8 = this;

      var params = this.newCompilationParams();
      this.hooks.beforeCompile.callAsync(params, function (err) {
        if (err) return callback(err);

        _this8.hooks.compile.call(params);

        var compilation = _this8.newCompilation(params);

        _this8.hooks.make.callAsync(compilation, function (err) {
          if (err) return callback(err);
          compilation.finish(function (err) {
            if (err) return callback(err);
            compilation.seal(function (err) {
              if (err) return callback(err);

              _this8.hooks.afterCompile.callAsync(compilation, function (err) {
                if (err) return callback(err);
                return callback(null, compilation);
              });
            });
          });
        });
      });
    }
  }]);

  return Compiler;
}(Tapable);

module.exports = Compiler;

var SizeOnlySource =
/*#__PURE__*/
function (_Source) {
  _inherits(SizeOnlySource, _Source);

  function SizeOnlySource(size) {
    var _this9;

    _classCallCheck(this, SizeOnlySource);

    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(SizeOnlySource).call(this));
    _this9._size = size;
    return _this9;
  }

  _createClass(SizeOnlySource, [{
    key: "_error",
    value: function _error() {
      return new Error("Content and Map of this Source is no longer available (only size() is supported)");
    }
  }, {
    key: "size",
    value: function size() {
      return this._size;
    }
    /**
     * @param {any} options options
     * @returns {string} the source
     */

  }, {
    key: "source",
    value: function source(options) {
      throw this._error();
    }
  }, {
    key: "node",
    value: function node() {
      throw this._error();
    }
  }, {
    key: "listMap",
    value: function listMap() {
      throw this._error();
    }
  }, {
    key: "map",
    value: function map() {
      throw this._error();
    }
  }, {
    key: "listNode",
    value: function listNode() {
      throw this._error();
    }
  }, {
    key: "updateHash",
    value: function updateHash() {
      throw this._error();
    }
  }]);

  return SizeOnlySource;
}(Source);