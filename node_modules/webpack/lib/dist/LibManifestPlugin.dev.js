/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require("path");

var asyncLib = require("neo-async");

var SingleEntryDependency = require("./dependencies/SingleEntryDependency");

var LibManifestPlugin =
/*#__PURE__*/
function () {
  function LibManifestPlugin(options) {
    _classCallCheck(this, LibManifestPlugin);

    this.options = options;
  }

  _createClass(LibManifestPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      compiler.hooks.emit.tapAsync("LibManifestPlugin", function (compilation, callback) {
        asyncLib.forEach(compilation.chunks, function (chunk, callback) {
          if (!chunk.isOnlyInitial()) {
            callback();
            return;
          }

          var targetPath = compilation.getPath(_this.options.path, {
            hash: compilation.hash,
            chunk: chunk
          });
          var name = _this.options.name && compilation.getPath(_this.options.name, {
            hash: compilation.hash,
            chunk: chunk
          });
          var manifest = {
            name: name,
            type: _this.options.type,
            content: Array.from(chunk.modulesIterable, function (module) {
              if (_this.options.entryOnly && !module.reasons.some(function (r) {
                return r.dependency instanceof SingleEntryDependency;
              })) {
                return;
              }

              if (module.libIdent) {
                var ident = module.libIdent({
                  context: _this.options.context || compiler.options.context
                });

                if (ident) {
                  return {
                    ident: ident,
                    data: {
                      id: module.id,
                      buildMeta: module.buildMeta
                    }
                  };
                }
              }
            }).filter(Boolean).reduce(function (obj, item) {
              obj[item.ident] = item.data;
              return obj;
            }, Object.create(null))
          }; // Apply formatting to content if format flag is true;

          var manifestContent = _this.options.format ? JSON.stringify(manifest, null, 2) : JSON.stringify(manifest);
          var content = Buffer.from(manifestContent, "utf8");
          compiler.outputFileSystem.mkdirp(path.dirname(targetPath), function (err) {
            if (err) return callback(err);
            compiler.outputFileSystem.writeFile(targetPath, content, callback);
          });
        }, callback);
      });
    }
  }]);

  return LibManifestPlugin;
}();

module.exports = LibManifestPlugin;