/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict"; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var acorn = require("acorn");

var _require = require("tapable"),
    Tapable = _require.Tapable,
    SyncBailHook = _require.SyncBailHook,
    HookMap = _require.HookMap;

var util = require("util");

var vm = require("vm");

var BasicEvaluatedExpression = require("./BasicEvaluatedExpression");

var StackedSetMap = require("./util/StackedSetMap");

var acornParser = acorn.Parser;

var joinRanges = function joinRanges(startRange, endRange) {
  if (!endRange) return startRange;
  if (!startRange) return endRange;
  return [startRange[0], endRange[1]];
};

var defaultParserOptions = {
  ranges: true,
  locations: true,
  ecmaVersion: 11,
  sourceType: "module",
  onComment: null
}; // regexp to match at least one "magic comment"

var webpackCommentRegExp = new RegExp(/(^|\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);
var EMPTY_COMMENT_OPTIONS = {
  options: null,
  errors: null
};

var Parser =
/*#__PURE__*/
function (_Tapable) {
  _inherits(Parser, _Tapable);

  function Parser(options) {
    var _this;

    var sourceType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "auto";

    _classCallCheck(this, Parser);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Parser).call(this));
    _this.hooks = {
      evaluateTypeof: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      evaluate: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      evaluateIdentifier: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      evaluateDefinedIdentifier: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      evaluateCallExpressionMember: new HookMap(function () {
        return new SyncBailHook(["expression", "param"]);
      }),
      statement: new SyncBailHook(["statement"]),
      statementIf: new SyncBailHook(["statement"]),
      label: new HookMap(function () {
        return new SyncBailHook(["statement"]);
      }),
      "import": new SyncBailHook(["statement", "source"]),
      importSpecifier: new SyncBailHook(["statement", "source", "exportName", "identifierName"]),
      "export": new SyncBailHook(["statement"]),
      exportImport: new SyncBailHook(["statement", "source"]),
      exportDeclaration: new SyncBailHook(["statement", "declaration"]),
      exportExpression: new SyncBailHook(["statement", "declaration"]),
      exportSpecifier: new SyncBailHook(["statement", "identifierName", "exportName", "index"]),
      exportImportSpecifier: new SyncBailHook(["statement", "source", "identifierName", "exportName", "index"]),
      varDeclaration: new HookMap(function () {
        return new SyncBailHook(["declaration"]);
      }),
      varDeclarationLet: new HookMap(function () {
        return new SyncBailHook(["declaration"]);
      }),
      varDeclarationConst: new HookMap(function () {
        return new SyncBailHook(["declaration"]);
      }),
      varDeclarationVar: new HookMap(function () {
        return new SyncBailHook(["declaration"]);
      }),
      canRename: new HookMap(function () {
        return new SyncBailHook(["initExpression"]);
      }),
      rename: new HookMap(function () {
        return new SyncBailHook(["initExpression"]);
      }),
      assigned: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      assign: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      "typeof": new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      importCall: new SyncBailHook(["expression"]),
      call: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      callAnyMember: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      "new": new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      expression: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      expressionAnyMember: new HookMap(function () {
        return new SyncBailHook(["expression"]);
      }),
      expressionConditionalOperator: new SyncBailHook(["expression"]),
      expressionLogicalOperator: new SyncBailHook(["expression"]),
      program: new SyncBailHook(["ast", "comments"])
    };
    var HOOK_MAP_COMPAT_CONFIG = {
      evaluateTypeof: /^evaluate typeof (.+)$/,
      evaluateIdentifier: /^evaluate Identifier (.+)$/,
      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,
      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,
      evaluate: /^evaluate (.+)$/,
      label: /^label (.+)$/,
      varDeclarationLet: /^var-let (.+)$/,
      varDeclarationConst: /^var-const (.+)$/,
      varDeclarationVar: /^var-var (.+)$/,
      varDeclaration: /^var (.+)$/,
      canRename: /^can-rename (.+)$/,
      rename: /^rename (.+)$/,
      "typeof": /^typeof (.+)$/,
      assigned: /^assigned (.+)$/,
      assign: /^assign (.+)$/,
      callAnyMember: /^call (.+)\.\*$/,
      call: /^call (.+)$/,
      "new": /^new (.+)$/,
      expressionConditionalOperator: /^expression \?:$/,
      expressionAnyMember: /^expression (.+)\.\*$/,
      expression: /^expression (.+)$/
    };

    _this._pluginCompat.tap("Parser", function (options) {
      for (var _i = 0, _Object$keys = Object.keys(HOOK_MAP_COMPAT_CONFIG); _i < _Object$keys.length; _i++) {
        var name = _Object$keys[_i];
        var regexp = HOOK_MAP_COMPAT_CONFIG[name];
        var match = regexp.exec(options.name);

        if (match) {
          if (match[1]) {
            _this.hooks[name].tap(match[1], options.fn.name || "unnamed compat plugin", options.fn.bind(_assertThisInitialized(_this)));
          } else {
            _this.hooks[name].tap(options.fn.name || "unnamed compat plugin", options.fn.bind(_assertThisInitialized(_this)));
          }

          return true;
        }
      }
    });

    _this.options = options;
    _this.sourceType = sourceType;
    _this.scope = undefined;
    _this.state = undefined;
    _this.comments = undefined;

    _this.initializeEvaluating();

    return _this;
  }

  _createClass(Parser, [{
    key: "initializeEvaluating",
    value: function initializeEvaluating() {
      var _this2 = this;

      this.hooks.evaluate["for"]("Literal").tap("Parser", function (expr) {
        switch (_typeof(expr.value)) {
          case "number":
            return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);

          case "string":
            return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);

          case "boolean":
            return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);
        }

        if (expr.value === null) {
          return new BasicEvaluatedExpression().setNull().setRange(expr.range);
        }

        if (expr.value instanceof RegExp) {
          return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);
        }
      });
      this.hooks.evaluate["for"]("LogicalExpression").tap("Parser", function (expr) {
        var left;
        var leftAsBool;
        var right;

        if (expr.operator === "&&") {
          left = _this2.evaluateExpression(expr.left);
          leftAsBool = left && left.asBool();
          if (leftAsBool === false) return left.setRange(expr.range);
          if (leftAsBool !== true) return;
          right = _this2.evaluateExpression(expr.right);
          return right.setRange(expr.range);
        } else if (expr.operator === "||") {
          left = _this2.evaluateExpression(expr.left);
          leftAsBool = left && left.asBool();
          if (leftAsBool === true) return left.setRange(expr.range);
          if (leftAsBool !== false) return;
          right = _this2.evaluateExpression(expr.right);
          return right.setRange(expr.range);
        }
      });
      this.hooks.evaluate["for"]("BinaryExpression").tap("Parser", function (expr) {
        var left;
        var right;
        var res;

        if (expr.operator === "+") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          res = new BasicEvaluatedExpression();

          if (left.isString()) {
            if (right.isString()) {
              res.setString(left.string + right.string);
            } else if (right.isNumber()) {
              res.setString(left.string + right.number);
            } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {
              // "left" + ("prefix" + inner + "postfix")
              // => ("leftprefix" + inner + "postfix")
              res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);
            } else if (right.isWrapped()) {
              // "left" + ([null] + inner + "postfix")
              // => ("left" + inner + "postfix")
              res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);
            } else {
              // "left" + expr
              // => ("left" + expr + "")
              res.setWrapped(left, null, [right]);
            }
          } else if (left.isNumber()) {
            if (right.isString()) {
              res.setString(left.number + right.string);
            } else if (right.isNumber()) {
              res.setNumber(left.number + right.number);
            } else {
              return;
            }
          } else if (left.isWrapped()) {
            if (left.postfix && left.postfix.isString() && right.isString()) {
              // ("prefix" + inner + "postfix") + "right"
              // => ("prefix" + inner + "postfixright")
              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);
            } else if (left.postfix && left.postfix.isString() && right.isNumber()) {
              // ("prefix" + inner + "postfix") + 123
              // => ("prefix" + inner + "postfix123")
              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);
            } else if (right.isString()) {
              // ("prefix" + inner + [null]) + "right"
              // => ("prefix" + inner + "right")
              res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
            } else if (right.isNumber()) {
              // ("prefix" + inner + [null]) + 123
              // => ("prefix" + inner + "123")
              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + "").setRange(right.range), left.wrappedInnerExpressions);
            } else if (right.isWrapped()) {
              // ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
              // ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
              res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));
            } else {
              // ("prefix" + inner + postfix) + expr
              // => ("prefix" + inner + postfix + expr + [null])
              res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));
            }
          } else {
            if (right.isString()) {
              // left + "right"
              // => ([null] + left + "right")
              res.setWrapped(null, right, [left]);
            } else if (right.isWrapped()) {
              // left + (prefix + inner + "postfix")
              // => ([null] + left + prefix + inner + "postfix")
              res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));
            } else {
              return;
            }
          }

          res.setRange(expr.range);
          return res;
        } else if (expr.operator === "-") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number - right.number);
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === "*") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number * right.number);
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === "/") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number / right.number);
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === "**") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(Math.pow(left.number, right.number));
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === "==" || expr.operator === "===") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          res = new BasicEvaluatedExpression();
          res.setRange(expr.range);

          if (left.isString() && right.isString()) {
            return res.setBoolean(left.string === right.string);
          } else if (left.isNumber() && right.isNumber()) {
            return res.setBoolean(left.number === right.number);
          } else if (left.isBoolean() && right.isBoolean()) {
            return res.setBoolean(left.bool === right.bool);
          }
        } else if (expr.operator === "!=" || expr.operator === "!==") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          res = new BasicEvaluatedExpression();
          res.setRange(expr.range);

          if (left.isString() && right.isString()) {
            return res.setBoolean(left.string !== right.string);
          } else if (left.isNumber() && right.isNumber()) {
            return res.setBoolean(left.number !== right.number);
          } else if (left.isBoolean() && right.isBoolean()) {
            return res.setBoolean(left.bool !== right.bool);
          }
        } else if (expr.operator === "&") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number & right.number);
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === "|") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number | right.number);
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === "^") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number ^ right.number);
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === ">>>") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number >>> right.number);
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === ">>") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number >> right.number);
          res.setRange(expr.range);
          return res;
        } else if (expr.operator === "<<") {
          left = _this2.evaluateExpression(expr.left);
          right = _this2.evaluateExpression(expr.right);
          if (!left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          res = new BasicEvaluatedExpression();
          res.setNumber(left.number << right.number);
          res.setRange(expr.range);
          return res;
        }
      });
      this.hooks.evaluate["for"]("UnaryExpression").tap("Parser", function (expr) {
        if (expr.operator === "typeof") {
          var res;
          var name;

          if (expr.argument.type === "Identifier") {
            name = _this2.scope.renames.get(expr.argument.name) || expr.argument.name;

            if (!_this2.scope.definitions.has(name)) {
              var hook = _this2.hooks.evaluateTypeof.get(name);

              if (hook !== undefined) {
                res = hook.call(expr);
                if (res !== undefined) return res;
              }
            }
          }

          if (expr.argument.type === "MemberExpression") {
            var exprName = _this2.getNameForExpression(expr.argument);

            if (exprName && exprName.free) {
              var _hook = _this2.hooks.evaluateTypeof.get(exprName.name);

              if (_hook !== undefined) {
                res = _hook.call(expr);
                if (res !== undefined) return res;
              }
            }
          }

          if (expr.argument.type === "FunctionExpression") {
            return new BasicEvaluatedExpression().setString("function").setRange(expr.range);
          }

          var arg = _this2.evaluateExpression(expr.argument);

          if (arg.isString() || arg.isWrapped()) {
            return new BasicEvaluatedExpression().setString("string").setRange(expr.range);
          }

          if (arg.isNumber()) {
            return new BasicEvaluatedExpression().setString("number").setRange(expr.range);
          }

          if (arg.isBoolean()) {
            return new BasicEvaluatedExpression().setString("boolean").setRange(expr.range);
          }

          if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {
            return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
          }
        } else if (expr.operator === "!") {
          var argument = _this2.evaluateExpression(expr.argument);

          if (!argument) return;

          if (argument.isBoolean()) {
            return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);
          }

          if (argument.isTruthy()) {
            return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);
          }

          if (argument.isFalsy()) {
            return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);
          }

          if (argument.isString()) {
            return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);
          }

          if (argument.isNumber()) {
            return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);
          }
        } else if (expr.operator === "~") {
          var _argument = _this2.evaluateExpression(expr.argument);

          if (!_argument) return;
          if (!_argument.isNumber()) return;

          var _res = new BasicEvaluatedExpression();

          _res.setNumber(~_argument.number);

          _res.setRange(expr.range);

          return _res;
        }
      });
      this.hooks.evaluateTypeof["for"]("undefined").tap("Parser", function (expr) {
        return new BasicEvaluatedExpression().setString("undefined").setRange(expr.range);
      });
      this.hooks.evaluate["for"]("Identifier").tap("Parser", function (expr) {
        var name = _this2.scope.renames.get(expr.name) || expr.name;

        if (!_this2.scope.definitions.has(expr.name)) {
          var hook = _this2.hooks.evaluateIdentifier.get(name);

          if (hook !== undefined) {
            var result = hook.call(expr);
            if (result) return result;
          }

          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);
        } else {
          var _hook2 = _this2.hooks.evaluateDefinedIdentifier.get(name);

          if (_hook2 !== undefined) {
            return _hook2.call(expr);
          }
        }
      });
      this.hooks.evaluate["for"]("ThisExpression").tap("Parser", function (expr) {
        var name = _this2.scope.renames.get("this");

        if (name) {
          var hook = _this2.hooks.evaluateIdentifier.get(name);

          if (hook !== undefined) {
            var result = hook.call(expr);
            if (result) return result;
          }

          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);
        }
      });
      this.hooks.evaluate["for"]("MemberExpression").tap("Parser", function (expression) {
        var exprName = _this2.getNameForExpression(expression);

        if (exprName) {
          if (exprName.free) {
            var hook = _this2.hooks.evaluateIdentifier.get(exprName.name);

            if (hook !== undefined) {
              var result = hook.call(expression);
              if (result) return result;
            }

            return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);
          } else {
            var _hook3 = _this2.hooks.evaluateDefinedIdentifier.get(exprName.name);

            if (_hook3 !== undefined) {
              return _hook3.call(expression);
            }
          }
        }
      });
      this.hooks.evaluate["for"]("CallExpression").tap("Parser", function (expr) {
        if (expr.callee.type !== "MemberExpression") return;
        if (expr.callee.property.type !== (expr.callee.computed ? "Literal" : "Identifier")) return;

        var param = _this2.evaluateExpression(expr.callee.object);

        if (!param) return;
        var property = expr.callee.property.name || expr.callee.property.value;

        var hook = _this2.hooks.evaluateCallExpressionMember.get(property);

        if (hook !== undefined) {
          return hook.call(expr, param);
        }
      });
      this.hooks.evaluateCallExpressionMember["for"]("replace").tap("Parser", function (expr, param) {
        if (!param.isString()) return;
        if (expr.arguments.length !== 2) return;

        var arg1 = _this2.evaluateExpression(expr.arguments[0]);

        var arg2 = _this2.evaluateExpression(expr.arguments[1]);

        if (!arg1.isString() && !arg1.isRegExp()) return;
        arg1 = arg1.regExp || arg1.string;
        if (!arg2.isString()) return;
        arg2 = arg2.string;
        return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);
      });
      ["substr", "substring"].forEach(function (fn) {
        _this2.hooks.evaluateCallExpressionMember["for"](fn).tap("Parser", function (expr, param) {
          if (!param.isString()) return;
          var arg1;
          var result,
              str = param.string;

          switch (expr.arguments.length) {
            case 1:
              arg1 = _this2.evaluateExpression(expr.arguments[0]);
              if (!arg1.isNumber()) return;
              result = str[fn](arg1.number);
              break;

            case 2:
              {
                arg1 = _this2.evaluateExpression(expr.arguments[0]);

                var arg2 = _this2.evaluateExpression(expr.arguments[1]);

                if (!arg1.isNumber()) return;
                if (!arg2.isNumber()) return;
                result = str[fn](arg1.number, arg2.number);
                break;
              }

            default:
              return;
          }

          return new BasicEvaluatedExpression().setString(result).setRange(expr.range);
        });
      });
      /**
       * @param {string} kind "cooked" | "raw"
       * @param {TODO} templateLiteralExpr TemplateLiteral expr
       * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template
       */

      var getSimplifiedTemplateResult = function getSimplifiedTemplateResult(kind, templateLiteralExpr) {
        var quasis = [];
        var parts = [];

        for (var i = 0; i < templateLiteralExpr.quasis.length; i++) {
          var quasiExpr = templateLiteralExpr.quasis[i];
          var quasi = quasiExpr.value[kind];

          if (i > 0) {
            var prevExpr = parts[parts.length - 1];

            var expr = _this2.evaluateExpression(templateLiteralExpr.expressions[i - 1]);

            var exprAsString = expr.asString();

            if (typeof exprAsString === "string") {
              // We can merge quasi + expr + quasi when expr
              // is a const string
              prevExpr.setString(prevExpr.string + exprAsString + quasi);
              prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression

              prevExpr.setExpression(undefined);
              continue;
            }

            parts.push(expr);
          }

          var part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);
          quasis.push(part);
          parts.push(part);
        }

        return {
          quasis: quasis,
          parts: parts
        };
      };

      this.hooks.evaluate["for"]("TemplateLiteral").tap("Parser", function (node) {
        var _getSimplifiedTemplat = getSimplifiedTemplateResult("cooked", node),
            quasis = _getSimplifiedTemplat.quasis,
            parts = _getSimplifiedTemplat.parts;

        if (parts.length === 1) {
          return parts[0].setRange(node.range);
        }

        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, "cooked").setRange(node.range);
      });
      this.hooks.evaluate["for"]("TaggedTemplateExpression").tap("Parser", function (node) {
        if (_this2.evaluateExpression(node.tag).identifier !== "String.raw") return;

        var _getSimplifiedTemplat2 = getSimplifiedTemplateResult("raw", node.quasi),
            quasis = _getSimplifiedTemplat2.quasis,
            parts = _getSimplifiedTemplat2.parts;

        if (parts.length === 1) {
          return parts[0].setRange(node.range);
        }

        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, "raw").setRange(node.range);
      });
      this.hooks.evaluateCallExpressionMember["for"]("concat").tap("Parser", function (expr, param) {
        if (!param.isString() && !param.isWrapped()) return;
        var stringSuffix = null;
        var hasUnknownParams = false;

        for (var i = expr.arguments.length - 1; i >= 0; i--) {
          var argExpr = _this2.evaluateExpression(expr.arguments[i]);

          if (!argExpr.isString() && !argExpr.isNumber()) {
            hasUnknownParams = true;
            break;
          }

          var value = argExpr.isString() ? argExpr.string : "" + argExpr.number;
          var newString = value + (stringSuffix ? stringSuffix.string : "");
          var newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];
          stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);
        }

        if (hasUnknownParams) {
          var prefix = param.isString() ? param : param.prefix;
          return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);
        } else if (param.isWrapped()) {
          var postfix = stringSuffix || param.postfix;
          return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);
        } else {
          var _newString = param.string + (stringSuffix ? stringSuffix.string : "");

          return new BasicEvaluatedExpression().setString(_newString).setRange(expr.range);
        }
      });
      this.hooks.evaluateCallExpressionMember["for"]("split").tap("Parser", function (expr, param) {
        if (!param.isString()) return;
        if (expr.arguments.length !== 1) return;
        var result;

        var arg = _this2.evaluateExpression(expr.arguments[0]);

        if (arg.isString()) {
          result = param.string.split(arg.string);
        } else if (arg.isRegExp()) {
          result = param.string.split(arg.regExp);
        } else {
          return;
        }

        return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);
      });
      this.hooks.evaluate["for"]("ConditionalExpression").tap("Parser", function (expr) {
        var condition = _this2.evaluateExpression(expr.test);

        var conditionValue = condition.asBool();
        var res;

        if (conditionValue === undefined) {
          var consequent = _this2.evaluateExpression(expr.consequent);

          var alternate = _this2.evaluateExpression(expr.alternate);

          if (!consequent || !alternate) return;
          res = new BasicEvaluatedExpression();

          if (consequent.isConditional()) {
            res.setOptions(consequent.options);
          } else {
            res.setOptions([consequent]);
          }

          if (alternate.isConditional()) {
            res.addOptions(alternate.options);
          } else {
            res.addOptions([alternate]);
          }
        } else {
          res = _this2.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);
        }

        res.setRange(expr.range);
        return res;
      });
      this.hooks.evaluate["for"]("ArrayExpression").tap("Parser", function (expr) {
        var items = expr.elements.map(function (element) {
          return element !== null && _this2.evaluateExpression(element);
        });
        if (!items.every(Boolean)) return;
        return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);
      });
    }
  }, {
    key: "getRenameIdentifier",
    value: function getRenameIdentifier(expr) {
      var result = this.evaluateExpression(expr);

      if (result && result.isIdentifier()) {
        return result.identifier;
      }
    }
  }, {
    key: "walkClass",
    value: function walkClass(classy) {
      if (classy.superClass) this.walkExpression(classy.superClass);

      if (classy.body && classy.body.type === "ClassBody") {
        var wasTopLevel = this.scope.topLevelScope;
        this.scope.topLevelScope = false;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = classy.body.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var methodDefinition = _step.value;

            if (methodDefinition.type === "MethodDefinition") {
              this.walkMethodDefinition(methodDefinition);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.scope.topLevelScope = wasTopLevel;
      }
    }
  }, {
    key: "walkMethodDefinition",
    value: function walkMethodDefinition(methodDefinition) {
      if (methodDefinition.computed && methodDefinition.key) {
        this.walkExpression(methodDefinition.key);
      }

      if (methodDefinition.value) {
        this.walkExpression(methodDefinition.value);
      }
    } // Prewalking iterates the scope for variable declarations

  }, {
    key: "prewalkStatements",
    value: function prewalkStatements(statements) {
      for (var index = 0, len = statements.length; index < len; index++) {
        var statement = statements[index];
        this.prewalkStatement(statement);
      }
    } // Block-Prewalking iterates the scope for block variable declarations

  }, {
    key: "blockPrewalkStatements",
    value: function blockPrewalkStatements(statements) {
      for (var index = 0, len = statements.length; index < len; index++) {
        var statement = statements[index];
        this.blockPrewalkStatement(statement);
      }
    } // Walking iterates the statements and expressions and processes them

  }, {
    key: "walkStatements",
    value: function walkStatements(statements) {
      for (var index = 0, len = statements.length; index < len; index++) {
        var statement = statements[index];
        this.walkStatement(statement);
      }
    }
  }, {
    key: "prewalkStatement",
    value: function prewalkStatement(statement) {
      switch (statement.type) {
        case "BlockStatement":
          this.prewalkBlockStatement(statement);
          break;

        case "DoWhileStatement":
          this.prewalkDoWhileStatement(statement);
          break;

        case "ExportAllDeclaration":
          this.prewalkExportAllDeclaration(statement);
          break;

        case "ExportDefaultDeclaration":
          this.prewalkExportDefaultDeclaration(statement);
          break;

        case "ExportNamedDeclaration":
          this.prewalkExportNamedDeclaration(statement);
          break;

        case "ForInStatement":
          this.prewalkForInStatement(statement);
          break;

        case "ForOfStatement":
          this.prewalkForOfStatement(statement);
          break;

        case "ForStatement":
          this.prewalkForStatement(statement);
          break;

        case "FunctionDeclaration":
          this.prewalkFunctionDeclaration(statement);
          break;

        case "IfStatement":
          this.prewalkIfStatement(statement);
          break;

        case "ImportDeclaration":
          this.prewalkImportDeclaration(statement);
          break;

        case "LabeledStatement":
          this.prewalkLabeledStatement(statement);
          break;

        case "SwitchStatement":
          this.prewalkSwitchStatement(statement);
          break;

        case "TryStatement":
          this.prewalkTryStatement(statement);
          break;

        case "VariableDeclaration":
          this.prewalkVariableDeclaration(statement);
          break;

        case "WhileStatement":
          this.prewalkWhileStatement(statement);
          break;

        case "WithStatement":
          this.prewalkWithStatement(statement);
          break;
      }
    }
  }, {
    key: "blockPrewalkStatement",
    value: function blockPrewalkStatement(statement) {
      switch (statement.type) {
        case "VariableDeclaration":
          this.blockPrewalkVariableDeclaration(statement);
          break;

        case "ExportDefaultDeclaration":
          this.blockPrewalkExportDefaultDeclaration(statement);
          break;

        case "ExportNamedDeclaration":
          this.blockPrewalkExportNamedDeclaration(statement);
          break;

        case "ClassDeclaration":
          this.blockPrewalkClassDeclaration(statement);
          break;
      }
    }
  }, {
    key: "walkStatement",
    value: function walkStatement(statement) {
      if (this.hooks.statement.call(statement) !== undefined) return;

      switch (statement.type) {
        case "BlockStatement":
          this.walkBlockStatement(statement);
          break;

        case "ClassDeclaration":
          this.walkClassDeclaration(statement);
          break;

        case "DoWhileStatement":
          this.walkDoWhileStatement(statement);
          break;

        case "ExportDefaultDeclaration":
          this.walkExportDefaultDeclaration(statement);
          break;

        case "ExportNamedDeclaration":
          this.walkExportNamedDeclaration(statement);
          break;

        case "ExpressionStatement":
          this.walkExpressionStatement(statement);
          break;

        case "ForInStatement":
          this.walkForInStatement(statement);
          break;

        case "ForOfStatement":
          this.walkForOfStatement(statement);
          break;

        case "ForStatement":
          this.walkForStatement(statement);
          break;

        case "FunctionDeclaration":
          this.walkFunctionDeclaration(statement);
          break;

        case "IfStatement":
          this.walkIfStatement(statement);
          break;

        case "LabeledStatement":
          this.walkLabeledStatement(statement);
          break;

        case "ReturnStatement":
          this.walkReturnStatement(statement);
          break;

        case "SwitchStatement":
          this.walkSwitchStatement(statement);
          break;

        case "ThrowStatement":
          this.walkThrowStatement(statement);
          break;

        case "TryStatement":
          this.walkTryStatement(statement);
          break;

        case "VariableDeclaration":
          this.walkVariableDeclaration(statement);
          break;

        case "WhileStatement":
          this.walkWhileStatement(statement);
          break;

        case "WithStatement":
          this.walkWithStatement(statement);
          break;
      }
    } // Real Statements

  }, {
    key: "prewalkBlockStatement",
    value: function prewalkBlockStatement(statement) {
      this.prewalkStatements(statement.body);
    }
  }, {
    key: "walkBlockStatement",
    value: function walkBlockStatement(statement) {
      var _this3 = this;

      this.inBlockScope(function () {
        var body = statement.body;

        _this3.blockPrewalkStatements(body);

        _this3.walkStatements(body);
      });
    }
  }, {
    key: "walkExpressionStatement",
    value: function walkExpressionStatement(statement) {
      this.walkExpression(statement.expression);
    }
  }, {
    key: "prewalkIfStatement",
    value: function prewalkIfStatement(statement) {
      this.prewalkStatement(statement.consequent);

      if (statement.alternate) {
        this.prewalkStatement(statement.alternate);
      }
    }
  }, {
    key: "walkIfStatement",
    value: function walkIfStatement(statement) {
      var result = this.hooks.statementIf.call(statement);

      if (result === undefined) {
        this.walkExpression(statement.test);
        this.walkStatement(statement.consequent);

        if (statement.alternate) {
          this.walkStatement(statement.alternate);
        }
      } else {
        if (result) {
          this.walkStatement(statement.consequent);
        } else if (statement.alternate) {
          this.walkStatement(statement.alternate);
        }
      }
    }
  }, {
    key: "prewalkLabeledStatement",
    value: function prewalkLabeledStatement(statement) {
      this.prewalkStatement(statement.body);
    }
  }, {
    key: "walkLabeledStatement",
    value: function walkLabeledStatement(statement) {
      var hook = this.hooks.label.get(statement.label.name);

      if (hook !== undefined) {
        var result = hook.call(statement);
        if (result === true) return;
      }

      this.walkStatement(statement.body);
    }
  }, {
    key: "prewalkWithStatement",
    value: function prewalkWithStatement(statement) {
      this.prewalkStatement(statement.body);
    }
  }, {
    key: "walkWithStatement",
    value: function walkWithStatement(statement) {
      this.walkExpression(statement.object);
      this.walkStatement(statement.body);
    }
  }, {
    key: "prewalkSwitchStatement",
    value: function prewalkSwitchStatement(statement) {
      this.prewalkSwitchCases(statement.cases);
    }
  }, {
    key: "walkSwitchStatement",
    value: function walkSwitchStatement(statement) {
      this.walkExpression(statement.discriminant);
      this.walkSwitchCases(statement.cases);
    }
  }, {
    key: "walkTerminatingStatement",
    value: function walkTerminatingStatement(statement) {
      if (statement.argument) this.walkExpression(statement.argument);
    }
  }, {
    key: "walkReturnStatement",
    value: function walkReturnStatement(statement) {
      this.walkTerminatingStatement(statement);
    }
  }, {
    key: "walkThrowStatement",
    value: function walkThrowStatement(statement) {
      this.walkTerminatingStatement(statement);
    }
  }, {
    key: "prewalkTryStatement",
    value: function prewalkTryStatement(statement) {
      this.prewalkStatement(statement.block);
    }
  }, {
    key: "walkTryStatement",
    value: function walkTryStatement(statement) {
      if (this.scope.inTry) {
        this.walkStatement(statement.block);
      } else {
        this.scope.inTry = true;
        this.walkStatement(statement.block);
        this.scope.inTry = false;
      }

      if (statement.handler) this.walkCatchClause(statement.handler);
      if (statement.finalizer) this.walkStatement(statement.finalizer);
    }
  }, {
    key: "prewalkWhileStatement",
    value: function prewalkWhileStatement(statement) {
      this.prewalkStatement(statement.body);
    }
  }, {
    key: "walkWhileStatement",
    value: function walkWhileStatement(statement) {
      this.walkExpression(statement.test);
      this.walkStatement(statement.body);
    }
  }, {
    key: "prewalkDoWhileStatement",
    value: function prewalkDoWhileStatement(statement) {
      this.prewalkStatement(statement.body);
    }
  }, {
    key: "walkDoWhileStatement",
    value: function walkDoWhileStatement(statement) {
      this.walkStatement(statement.body);
      this.walkExpression(statement.test);
    }
  }, {
    key: "prewalkForStatement",
    value: function prewalkForStatement(statement) {
      if (statement.init) {
        if (statement.init.type === "VariableDeclaration") {
          this.prewalkStatement(statement.init);
        }
      }

      this.prewalkStatement(statement.body);
    }
  }, {
    key: "walkForStatement",
    value: function walkForStatement(statement) {
      var _this4 = this;

      this.inBlockScope(function () {
        if (statement.init) {
          if (statement.init.type === "VariableDeclaration") {
            _this4.blockPrewalkVariableDeclaration(statement.init);

            _this4.walkStatement(statement.init);
          } else {
            _this4.walkExpression(statement.init);
          }
        }

        if (statement.test) {
          _this4.walkExpression(statement.test);
        }

        if (statement.update) {
          _this4.walkExpression(statement.update);
        }

        var body = statement.body;

        if (body.type === "BlockStatement") {
          // no need to add additional scope
          _this4.blockPrewalkStatements(body.body);

          _this4.walkStatements(body.body);
        } else {
          _this4.walkStatement(body);
        }
      });
    }
  }, {
    key: "prewalkForInStatement",
    value: function prewalkForInStatement(statement) {
      if (statement.left.type === "VariableDeclaration") {
        this.prewalkVariableDeclaration(statement.left);
      }

      this.prewalkStatement(statement.body);
    }
  }, {
    key: "walkForInStatement",
    value: function walkForInStatement(statement) {
      var _this5 = this;

      this.inBlockScope(function () {
        if (statement.left.type === "VariableDeclaration") {
          _this5.blockPrewalkVariableDeclaration(statement.left);

          _this5.walkVariableDeclaration(statement.left);
        } else {
          _this5.walkPattern(statement.left);
        }

        _this5.walkExpression(statement.right);

        var body = statement.body;

        if (body.type === "BlockStatement") {
          // no need to add additional scope
          _this5.blockPrewalkStatements(body.body);

          _this5.walkStatements(body.body);
        } else {
          _this5.walkStatement(body);
        }
      });
    }
  }, {
    key: "prewalkForOfStatement",
    value: function prewalkForOfStatement(statement) {
      if (statement.left.type === "VariableDeclaration") {
        this.prewalkVariableDeclaration(statement.left);
      }

      this.prewalkStatement(statement.body);
    }
  }, {
    key: "walkForOfStatement",
    value: function walkForOfStatement(statement) {
      var _this6 = this;

      this.inBlockScope(function () {
        if (statement.left.type === "VariableDeclaration") {
          _this6.blockPrewalkVariableDeclaration(statement.left);

          _this6.walkVariableDeclaration(statement.left);
        } else {
          _this6.walkPattern(statement.left);
        }

        _this6.walkExpression(statement.right);

        var body = statement.body;

        if (body.type === "BlockStatement") {
          // no need to add additional scope
          _this6.blockPrewalkStatements(body.body);

          _this6.walkStatements(body.body);
        } else {
          _this6.walkStatement(body);
        }
      });
    } // Declarations

  }, {
    key: "prewalkFunctionDeclaration",
    value: function prewalkFunctionDeclaration(statement) {
      if (statement.id) {
        this.scope.renames.set(statement.id.name, null);
        this.scope.definitions.add(statement.id.name);
      }
    }
  }, {
    key: "walkFunctionDeclaration",
    value: function walkFunctionDeclaration(statement) {
      var _this7 = this;

      var wasTopLevel = this.scope.topLevelScope;
      this.scope.topLevelScope = false;
      this.inFunctionScope(true, statement.params, function () {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = statement.params[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var param = _step2.value;

            _this7.walkPattern(param);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (statement.body.type === "BlockStatement") {
          _this7.detectMode(statement.body.body);

          _this7.prewalkStatement(statement.body);

          _this7.walkStatement(statement.body);
        } else {
          _this7.walkExpression(statement.body);
        }
      });
      this.scope.topLevelScope = wasTopLevel;
    }
  }, {
    key: "prewalkImportDeclaration",
    value: function prewalkImportDeclaration(statement) {
      var source = statement.source.value;
      this.hooks["import"].call(statement, source);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = statement.specifiers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var specifier = _step3.value;
          var name = specifier.local.name;
          this.scope.renames.set(name, null);
          this.scope.definitions.add(name);

          switch (specifier.type) {
            case "ImportDefaultSpecifier":
              this.hooks.importSpecifier.call(statement, source, "default", name);
              break;

            case "ImportSpecifier":
              this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);
              break;

            case "ImportNamespaceSpecifier":
              this.hooks.importSpecifier.call(statement, source, null, name);
              break;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "enterDeclaration",
    value: function enterDeclaration(declaration, onIdent) {
      switch (declaration.type) {
        case "VariableDeclaration":
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = declaration.declarations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var declarator = _step4.value;

              switch (declarator.type) {
                case "VariableDeclarator":
                  {
                    this.enterPattern(declarator.id, onIdent);
                    break;
                  }
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          break;

        case "FunctionDeclaration":
          this.enterPattern(declaration.id, onIdent);
          break;

        case "ClassDeclaration":
          this.enterPattern(declaration.id, onIdent);
          break;
      }
    }
  }, {
    key: "blockPrewalkExportNamedDeclaration",
    value: function blockPrewalkExportNamedDeclaration(statement) {
      if (statement.declaration) {
        this.blockPrewalkStatement(statement.declaration);
      }
    }
  }, {
    key: "prewalkExportNamedDeclaration",
    value: function prewalkExportNamedDeclaration(statement) {
      var _this8 = this;

      var source;

      if (statement.source) {
        source = statement.source.value;
        this.hooks.exportImport.call(statement, source);
      } else {
        this.hooks["export"].call(statement);
      }

      if (statement.declaration) {
        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {
          this.prewalkStatement(statement.declaration);
          var index = 0;
          this.enterDeclaration(statement.declaration, function (def) {
            _this8.hooks.exportSpecifier.call(statement, def, def, index++);
          });
        }
      }

      if (statement.specifiers) {
        for (var specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {
          var specifier = statement.specifiers[specifierIndex];

          switch (specifier.type) {
            case "ExportSpecifier":
              {
                var name = specifier.exported.name;

                if (source) {
                  this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);
                } else {
                  this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);
                }

                break;
              }
          }
        }
      }
    }
  }, {
    key: "walkExportNamedDeclaration",
    value: function walkExportNamedDeclaration(statement) {
      if (statement.declaration) {
        this.walkStatement(statement.declaration);
      }
    }
  }, {
    key: "blockPrewalkExportDefaultDeclaration",
    value: function blockPrewalkExportDefaultDeclaration(statement) {
      if (statement.declaration.type === "ClassDeclaration") {
        this.blockPrewalkClassDeclaration(statement.declaration);
      }
    }
  }, {
    key: "prewalkExportDefaultDeclaration",
    value: function prewalkExportDefaultDeclaration(statement) {
      this.prewalkStatement(statement.declaration);

      if (statement.declaration.id && statement.declaration.type !== "FunctionExpression" && statement.declaration.type !== "ClassExpression") {
        this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, "default");
      }
    }
  }, {
    key: "walkExportDefaultDeclaration",
    value: function walkExportDefaultDeclaration(statement) {
      this.hooks["export"].call(statement);

      if (statement.declaration.id && statement.declaration.type !== "FunctionExpression" && statement.declaration.type !== "ClassExpression") {
        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {
          this.walkStatement(statement.declaration);
        }
      } else {
        // Acorn parses `export default function() {}` as `FunctionDeclaration` and
        // `export default class {}` as `ClassDeclaration`, both with `id = null`.
        // These nodes must be treated as expressions.
        if (statement.declaration.type === "FunctionDeclaration") {
          this.walkFunctionDeclaration(statement.declaration);
        } else if (statement.declaration.type === "ClassDeclaration") {
          this.walkClassDeclaration(statement.declaration);
        } else {
          this.walkExpression(statement.declaration);
        }

        if (!this.hooks.exportExpression.call(statement, statement.declaration)) {
          this.hooks.exportSpecifier.call(statement, statement.declaration, "default");
        }
      }
    }
  }, {
    key: "prewalkExportAllDeclaration",
    value: function prewalkExportAllDeclaration(statement) {
      var source = statement.source.value;
      this.hooks.exportImport.call(statement, source);
      this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);
    }
  }, {
    key: "prewalkVariableDeclaration",
    value: function prewalkVariableDeclaration(statement) {
      if (statement.kind !== "var") return;

      this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);
    }
  }, {
    key: "blockPrewalkVariableDeclaration",
    value: function blockPrewalkVariableDeclaration(statement) {
      if (statement.kind === "var") return;
      var hookMap = statement.kind === "const" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;

      this._prewalkVariableDeclaration(statement, hookMap);
    }
  }, {
    key: "_prewalkVariableDeclaration",
    value: function _prewalkVariableDeclaration(statement, hookMap) {
      var _this9 = this;

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = statement.declarations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var declarator = _step5.value;

          switch (declarator.type) {
            case "VariableDeclarator":
              {
                this.enterPattern(declarator.id, function (name, decl) {
                  var hook = hookMap.get(name);

                  if (hook === undefined || !hook.call(decl)) {
                    hook = _this9.hooks.varDeclaration.get(name);

                    if (hook === undefined || !hook.call(decl)) {
                      _this9.scope.renames.set(name, null);

                      _this9.scope.definitions.add(name);
                    }
                  }
                });
                break;
              }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: "walkVariableDeclaration",
    value: function walkVariableDeclaration(statement) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = statement.declarations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var declarator = _step6.value;

          switch (declarator.type) {
            case "VariableDeclarator":
              {
                var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);

                if (renameIdentifier && declarator.id.type === "Identifier") {
                  var hook = this.hooks.canRename.get(renameIdentifier);

                  if (hook !== undefined && hook.call(declarator.init)) {
                    // renaming with "var a = b;"
                    var _hook4 = this.hooks.rename.get(renameIdentifier);

                    if (_hook4 === undefined || !_hook4.call(declarator.init)) {
                      this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);
                      this.scope.definitions["delete"](declarator.id.name);
                    }

                    break;
                  }
                }

                this.walkPattern(declarator.id);
                if (declarator.init) this.walkExpression(declarator.init);
                break;
              }
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  }, {
    key: "blockPrewalkClassDeclaration",
    value: function blockPrewalkClassDeclaration(statement) {
      if (statement.id) {
        this.scope.renames.set(statement.id.name, null);
        this.scope.definitions.add(statement.id.name);
      }
    }
  }, {
    key: "walkClassDeclaration",
    value: function walkClassDeclaration(statement) {
      this.walkClass(statement);
    }
  }, {
    key: "prewalkSwitchCases",
    value: function prewalkSwitchCases(switchCases) {
      for (var index = 0, len = switchCases.length; index < len; index++) {
        var switchCase = switchCases[index];
        this.prewalkStatements(switchCase.consequent);
      }
    }
  }, {
    key: "walkSwitchCases",
    value: function walkSwitchCases(switchCases) {
      for (var index = 0, len = switchCases.length; index < len; index++) {
        var switchCase = switchCases[index];

        if (switchCase.test) {
          this.walkExpression(switchCase.test);
        }

        this.walkStatements(switchCase.consequent);
      }
    }
  }, {
    key: "walkCatchClause",
    value: function walkCatchClause(catchClause) {
      var _this10 = this;

      this.inBlockScope(function () {
        // Error binding is optional in catch clause since ECMAScript 2019
        if (catchClause.param !== null) {
          _this10.enterPattern(catchClause.param, function (ident) {
            _this10.scope.renames.set(ident, null);

            _this10.scope.definitions.add(ident);
          });

          _this10.walkPattern(catchClause.param);
        }

        _this10.prewalkStatement(catchClause.body);

        _this10.walkStatement(catchClause.body);
      });
    }
  }, {
    key: "walkPattern",
    value: function walkPattern(pattern) {
      switch (pattern.type) {
        case "ArrayPattern":
          this.walkArrayPattern(pattern);
          break;

        case "AssignmentPattern":
          this.walkAssignmentPattern(pattern);
          break;

        case "MemberExpression":
          this.walkMemberExpression(pattern);
          break;

        case "ObjectPattern":
          this.walkObjectPattern(pattern);
          break;

        case "RestElement":
          this.walkRestElement(pattern);
          break;
      }
    }
  }, {
    key: "walkAssignmentPattern",
    value: function walkAssignmentPattern(pattern) {
      this.walkExpression(pattern.right);
      this.walkPattern(pattern.left);
    }
  }, {
    key: "walkObjectPattern",
    value: function walkObjectPattern(pattern) {
      for (var i = 0, len = pattern.properties.length; i < len; i++) {
        var prop = pattern.properties[i];

        if (prop) {
          if (prop.computed) this.walkExpression(prop.key);
          if (prop.value) this.walkPattern(prop.value);
        }
      }
    }
  }, {
    key: "walkArrayPattern",
    value: function walkArrayPattern(pattern) {
      for (var i = 0, len = pattern.elements.length; i < len; i++) {
        var element = pattern.elements[i];
        if (element) this.walkPattern(element);
      }
    }
  }, {
    key: "walkRestElement",
    value: function walkRestElement(pattern) {
      this.walkPattern(pattern.argument);
    }
  }, {
    key: "walkExpressions",
    value: function walkExpressions(expressions) {
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = expressions[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var expression = _step7.value;

          if (expression) {
            this.walkExpression(expression);
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
  }, {
    key: "walkExpression",
    value: function walkExpression(expression) {
      switch (expression.type) {
        case "ArrayExpression":
          this.walkArrayExpression(expression);
          break;

        case "ArrowFunctionExpression":
          this.walkArrowFunctionExpression(expression);
          break;

        case "AssignmentExpression":
          this.walkAssignmentExpression(expression);
          break;

        case "AwaitExpression":
          this.walkAwaitExpression(expression);
          break;

        case "BinaryExpression":
          this.walkBinaryExpression(expression);
          break;

        case "CallExpression":
          this.walkCallExpression(expression);
          break;

        case "ClassExpression":
          this.walkClassExpression(expression);
          break;

        case "ConditionalExpression":
          this.walkConditionalExpression(expression);
          break;

        case "FunctionExpression":
          this.walkFunctionExpression(expression);
          break;

        case "Identifier":
          this.walkIdentifier(expression);
          break;

        case "LogicalExpression":
          this.walkLogicalExpression(expression);
          break;

        case "MemberExpression":
          this.walkMemberExpression(expression);
          break;

        case "NewExpression":
          this.walkNewExpression(expression);
          break;

        case "ObjectExpression":
          this.walkObjectExpression(expression);
          break;

        case "SequenceExpression":
          this.walkSequenceExpression(expression);
          break;

        case "SpreadElement":
          this.walkSpreadElement(expression);
          break;

        case "TaggedTemplateExpression":
          this.walkTaggedTemplateExpression(expression);
          break;

        case "TemplateLiteral":
          this.walkTemplateLiteral(expression);
          break;

        case "ThisExpression":
          this.walkThisExpression(expression);
          break;

        case "UnaryExpression":
          this.walkUnaryExpression(expression);
          break;

        case "UpdateExpression":
          this.walkUpdateExpression(expression);
          break;

        case "YieldExpression":
          this.walkYieldExpression(expression);
          break;
      }
    }
  }, {
    key: "walkAwaitExpression",
    value: function walkAwaitExpression(expression) {
      this.walkExpression(expression.argument);
    }
  }, {
    key: "walkArrayExpression",
    value: function walkArrayExpression(expression) {
      if (expression.elements) {
        this.walkExpressions(expression.elements);
      }
    }
  }, {
    key: "walkSpreadElement",
    value: function walkSpreadElement(expression) {
      if (expression.argument) {
        this.walkExpression(expression.argument);
      }
    }
  }, {
    key: "walkObjectExpression",
    value: function walkObjectExpression(expression) {
      for (var propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {
        var prop = expression.properties[propIndex];

        if (prop.type === "SpreadElement") {
          this.walkExpression(prop.argument);
          continue;
        }

        if (prop.computed) {
          this.walkExpression(prop.key);
        }

        if (prop.shorthand) {
          this.scope.inShorthand = true;
        }

        this.walkExpression(prop.value);

        if (prop.shorthand) {
          this.scope.inShorthand = false;
        }
      }
    }
  }, {
    key: "walkFunctionExpression",
    value: function walkFunctionExpression(expression) {
      var _this11 = this;

      var wasTopLevel = this.scope.topLevelScope;
      this.scope.topLevelScope = false;
      var scopeParams = expression.params; // Add function name in scope for recursive calls

      if (expression.id) {
        scopeParams.push(expression.id.name);
      }

      this.inFunctionScope(true, scopeParams, function () {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = expression.params[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var param = _step8.value;

            _this11.walkPattern(param);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
              _iterator8["return"]();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }

        if (expression.body.type === "BlockStatement") {
          _this11.detectMode(expression.body.body);

          _this11.prewalkStatement(expression.body);

          _this11.walkStatement(expression.body);
        } else {
          _this11.walkExpression(expression.body);
        }
      });
      this.scope.topLevelScope = wasTopLevel;
    }
  }, {
    key: "walkArrowFunctionExpression",
    value: function walkArrowFunctionExpression(expression) {
      var _this12 = this;

      this.inFunctionScope(false, expression.params, function () {
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = expression.params[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var param = _step9.value;

            _this12.walkPattern(param);
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
              _iterator9["return"]();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }

        if (expression.body.type === "BlockStatement") {
          _this12.detectMode(expression.body.body);

          _this12.prewalkStatement(expression.body);

          _this12.walkStatement(expression.body);
        } else {
          _this12.walkExpression(expression.body);
        }
      });
    }
  }, {
    key: "walkSequenceExpression",
    value: function walkSequenceExpression(expression) {
      if (expression.expressions) this.walkExpressions(expression.expressions);
    }
  }, {
    key: "walkUpdateExpression",
    value: function walkUpdateExpression(expression) {
      this.walkExpression(expression.argument);
    }
  }, {
    key: "walkUnaryExpression",
    value: function walkUnaryExpression(expression) {
      if (expression.operator === "typeof") {
        var exprName = this.getNameForExpression(expression.argument);

        if (exprName && exprName.free) {
          var hook = this.hooks["typeof"].get(exprName.name);

          if (hook !== undefined) {
            var result = hook.call(expression);
            if (result === true) return;
          }
        }
      }

      this.walkExpression(expression.argument);
    }
  }, {
    key: "walkLeftRightExpression",
    value: function walkLeftRightExpression(expression) {
      this.walkExpression(expression.left);
      this.walkExpression(expression.right);
    }
  }, {
    key: "walkBinaryExpression",
    value: function walkBinaryExpression(expression) {
      this.walkLeftRightExpression(expression);
    }
  }, {
    key: "walkLogicalExpression",
    value: function walkLogicalExpression(expression) {
      var result = this.hooks.expressionLogicalOperator.call(expression);

      if (result === undefined) {
        this.walkLeftRightExpression(expression);
      } else {
        if (result) {
          this.walkExpression(expression.right);
        }
      }
    }
  }, {
    key: "walkAssignmentExpression",
    value: function walkAssignmentExpression(expression) {
      var _this13 = this;

      var renameIdentifier = this.getRenameIdentifier(expression.right);

      if (expression.left.type === "Identifier" && renameIdentifier) {
        var hook = this.hooks.canRename.get(renameIdentifier);

        if (hook !== undefined && hook.call(expression.right)) {
          // renaming "a = b;"
          var _hook5 = this.hooks.rename.get(renameIdentifier);

          if (_hook5 === undefined || !_hook5.call(expression.right)) {
            this.scope.renames.set(expression.left.name, renameIdentifier);
            this.scope.definitions["delete"](expression.left.name);
          }

          return;
        }
      }

      if (expression.left.type === "Identifier") {
        var assignedHook = this.hooks.assigned.get(expression.left.name);

        if (assignedHook === undefined || !assignedHook.call(expression)) {
          this.walkExpression(expression.right);
        }

        this.scope.renames.set(expression.left.name, null);
        var assignHook = this.hooks.assign.get(expression.left.name);

        if (assignHook === undefined || !assignHook.call(expression)) {
          this.walkExpression(expression.left);
        }

        return;
      }

      this.walkExpression(expression.right);
      this.walkPattern(expression.left);
      this.enterPattern(expression.left, function (name, decl) {
        _this13.scope.renames.set(name, null);
      });
    }
  }, {
    key: "walkConditionalExpression",
    value: function walkConditionalExpression(expression) {
      var result = this.hooks.expressionConditionalOperator.call(expression);

      if (result === undefined) {
        this.walkExpression(expression.test);
        this.walkExpression(expression.consequent);

        if (expression.alternate) {
          this.walkExpression(expression.alternate);
        }
      } else {
        if (result) {
          this.walkExpression(expression.consequent);
        } else if (expression.alternate) {
          this.walkExpression(expression.alternate);
        }
      }
    }
  }, {
    key: "walkNewExpression",
    value: function walkNewExpression(expression) {
      var callee = this.evaluateExpression(expression.callee);

      if (callee.isIdentifier()) {
        var hook = this.hooks["new"].get(callee.identifier);

        if (hook !== undefined) {
          var result = hook.call(expression);

          if (result === true) {
            return;
          }
        }
      }

      this.walkExpression(expression.callee);

      if (expression.arguments) {
        this.walkExpressions(expression.arguments);
      }
    }
  }, {
    key: "walkYieldExpression",
    value: function walkYieldExpression(expression) {
      if (expression.argument) {
        this.walkExpression(expression.argument);
      }
    }
  }, {
    key: "walkTemplateLiteral",
    value: function walkTemplateLiteral(expression) {
      if (expression.expressions) {
        this.walkExpressions(expression.expressions);
      }
    }
  }, {
    key: "walkTaggedTemplateExpression",
    value: function walkTaggedTemplateExpression(expression) {
      if (expression.tag) {
        this.walkExpression(expression.tag);
      }

      if (expression.quasi && expression.quasi.expressions) {
        this.walkExpressions(expression.quasi.expressions);
      }
    }
  }, {
    key: "walkClassExpression",
    value: function walkClassExpression(expression) {
      this.walkClass(expression);
    }
  }, {
    key: "_walkIIFE",
    value: function _walkIIFE(functionExpression, options, currentThis) {
      var _this14 = this;

      var renameArgOrThis = function renameArgOrThis(argOrThis) {
        var renameIdentifier = _this14.getRenameIdentifier(argOrThis);

        if (renameIdentifier) {
          var hook = _this14.hooks.canRename.get(renameIdentifier);

          if (hook !== undefined && hook.call(argOrThis)) {
            var _hook6 = _this14.hooks.rename.get(renameIdentifier);

            if (_hook6 === undefined || !_hook6.call(argOrThis)) {
              return renameIdentifier;
            }
          }
        }

        _this14.walkExpression(argOrThis);
      };

      var params = functionExpression.params;
      var renameThis = currentThis ? renameArgOrThis(currentThis) : null;
      var args = options.map(renameArgOrThis);
      var wasTopLevel = this.scope.topLevelScope;
      this.scope.topLevelScope = false;
      var scopeParams = params.filter(function (identifier, idx) {
        return !args[idx];
      }); // Add function name in scope for recursive calls

      if (functionExpression.id) {
        scopeParams.push(functionExpression.id.name);
      }

      this.inFunctionScope(true, scopeParams, function () {
        if (renameThis) {
          _this14.scope.renames.set("this", renameThis);
        }

        for (var i = 0; i < args.length; i++) {
          var param = args[i];
          if (!param) continue;
          if (!params[i] || params[i].type !== "Identifier") continue;

          _this14.scope.renames.set(params[i].name, param);
        }

        if (functionExpression.body.type === "BlockStatement") {
          _this14.detectMode(functionExpression.body.body);

          _this14.prewalkStatement(functionExpression.body);

          _this14.walkStatement(functionExpression.body);
        } else {
          _this14.walkExpression(functionExpression.body);
        }
      });
      this.scope.topLevelScope = wasTopLevel;
    }
  }, {
    key: "walkCallExpression",
    value: function walkCallExpression(expression) {
      if (expression.callee.type === "MemberExpression" && expression.callee.object.type === "FunctionExpression" && !expression.callee.computed && (expression.callee.property.name === "call" || expression.callee.property.name === "bind") && expression.arguments.length > 0) {
        // (function(…) { }.call/bind(?, …))
        this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);
      } else if (expression.callee.type === "FunctionExpression") {
        // (function(…) { }(…))
        this._walkIIFE(expression.callee, expression.arguments, null);
      } else if (expression.callee.type === "Import") {
        var result = this.hooks.importCall.call(expression);
        if (result === true) return;
        if (expression.arguments) this.walkExpressions(expression.arguments);
      } else {
        var callee = this.evaluateExpression(expression.callee);

        if (callee.isIdentifier()) {
          var callHook = this.hooks.call.get(callee.identifier);

          if (callHook !== undefined) {
            var _result = callHook.call(expression);

            if (_result === true) return;
          }

          var identifier = callee.identifier.replace(/\.[^.]+$/, "");

          if (identifier !== callee.identifier) {
            var callAnyHook = this.hooks.callAnyMember.get(identifier);

            if (callAnyHook !== undefined) {
              var _result2 = callAnyHook.call(expression);

              if (_result2 === true) return;
            }
          }
        }

        if (expression.callee) this.walkExpression(expression.callee);
        if (expression.arguments) this.walkExpressions(expression.arguments);
      }
    }
  }, {
    key: "walkMemberExpression",
    value: function walkMemberExpression(expression) {
      var exprName = this.getNameForExpression(expression);

      if (exprName && exprName.free) {
        var expressionHook = this.hooks.expression.get(exprName.name);

        if (expressionHook !== undefined) {
          var result = expressionHook.call(expression);
          if (result === true) return;
        }

        var expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);

        if (expressionAnyMemberHook !== undefined) {
          var _result3 = expressionAnyMemberHook.call(expression);

          if (_result3 === true) return;
        }
      }

      this.walkExpression(expression.object);
      if (expression.computed === true) this.walkExpression(expression.property);
    }
  }, {
    key: "walkThisExpression",
    value: function walkThisExpression(expression) {
      var expressionHook = this.hooks.expression.get("this");

      if (expressionHook !== undefined) {
        expressionHook.call(expression);
      }
    }
  }, {
    key: "walkIdentifier",
    value: function walkIdentifier(expression) {
      if (!this.scope.definitions.has(expression.name)) {
        var hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);

        if (hook !== undefined) {
          var result = hook.call(expression);
          if (result === true) return;
        }
      }
    }
    /**
     * @deprecated
     * @param {any} params scope params
     * @param {function(): void} fn inner function
     * @returns {void}
     */

  }, {
    key: "inScope",
    value: function inScope(params, fn) {
      var _this15 = this;

      var oldScope = this.scope;
      this.scope = {
        topLevelScope: oldScope.topLevelScope,
        inTry: false,
        inShorthand: false,
        isStrict: oldScope.isStrict,
        isAsmJs: oldScope.isAsmJs,
        definitions: oldScope.definitions.createChild(),
        renames: oldScope.renames.createChild()
      };
      this.scope.renames.set("this", null);
      this.enterPatterns(params, function (ident) {
        _this15.scope.renames.set(ident, null);

        _this15.scope.definitions.add(ident);
      });
      fn();
      this.scope = oldScope;
    }
  }, {
    key: "inFunctionScope",
    value: function inFunctionScope(hasThis, params, fn) {
      var _this16 = this;

      var oldScope = this.scope;
      this.scope = {
        topLevelScope: oldScope.topLevelScope,
        inTry: false,
        inShorthand: false,
        isStrict: oldScope.isStrict,
        isAsmJs: oldScope.isAsmJs,
        definitions: oldScope.definitions.createChild(),
        renames: oldScope.renames.createChild()
      };

      if (hasThis) {
        this.scope.renames.set("this", null);
      }

      this.enterPatterns(params, function (ident) {
        _this16.scope.renames.set(ident, null);

        _this16.scope.definitions.add(ident);
      });
      fn();
      this.scope = oldScope;
    }
  }, {
    key: "inBlockScope",
    value: function inBlockScope(fn) {
      var oldScope = this.scope;
      this.scope = {
        topLevelScope: oldScope.topLevelScope,
        inTry: oldScope.inTry,
        inShorthand: false,
        isStrict: oldScope.isStrict,
        isAsmJs: oldScope.isAsmJs,
        definitions: oldScope.definitions.createChild(),
        renames: oldScope.renames.createChild()
      };
      fn();
      this.scope = oldScope;
    } // TODO webpack 5: remove this methods
    // only for backward-compat

  }, {
    key: "detectStrictMode",
    value: function detectStrictMode(statements) {
      this.detectMode(statements);
    }
  }, {
    key: "detectMode",
    value: function detectMode(statements) {
      var isLiteral = statements.length >= 1 && statements[0].type === "ExpressionStatement" && statements[0].expression.type === "Literal";

      if (isLiteral && statements[0].expression.value === "use strict") {
        this.scope.isStrict = true;
      }

      if (isLiteral && statements[0].expression.value === "use asm") {
        this.scope.isAsmJs = true;
      }
    }
  }, {
    key: "enterPatterns",
    value: function enterPatterns(patterns, onIdent) {
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = patterns[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var pattern = _step10.value;

          if (typeof pattern !== "string") {
            this.enterPattern(pattern, onIdent);
          } else if (pattern) {
            onIdent(pattern);
          }
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    }
  }, {
    key: "enterPattern",
    value: function enterPattern(pattern, onIdent) {
      if (!pattern) return;

      switch (pattern.type) {
        case "ArrayPattern":
          this.enterArrayPattern(pattern, onIdent);
          break;

        case "AssignmentPattern":
          this.enterAssignmentPattern(pattern, onIdent);
          break;

        case "Identifier":
          this.enterIdentifier(pattern, onIdent);
          break;

        case "ObjectPattern":
          this.enterObjectPattern(pattern, onIdent);
          break;

        case "RestElement":
          this.enterRestElement(pattern, onIdent);
          break;

        case "Property":
          this.enterPattern(pattern.value, onIdent);
          break;
      }
    }
  }, {
    key: "enterIdentifier",
    value: function enterIdentifier(pattern, onIdent) {
      onIdent(pattern.name, pattern);
    }
  }, {
    key: "enterObjectPattern",
    value: function enterObjectPattern(pattern, onIdent) {
      for (var propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {
        var prop = pattern.properties[propIndex];
        this.enterPattern(prop, onIdent);
      }
    }
  }, {
    key: "enterArrayPattern",
    value: function enterArrayPattern(pattern, onIdent) {
      for (var elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {
        var element = pattern.elements[elementIndex];
        this.enterPattern(element, onIdent);
      }
    }
  }, {
    key: "enterRestElement",
    value: function enterRestElement(pattern, onIdent) {
      this.enterPattern(pattern.argument, onIdent);
    }
  }, {
    key: "enterAssignmentPattern",
    value: function enterAssignmentPattern(pattern, onIdent) {
      this.enterPattern(pattern.left, onIdent);
    }
  }, {
    key: "evaluateExpression",
    value: function evaluateExpression(expression) {
      try {
        var hook = this.hooks.evaluate.get(expression.type);

        if (hook !== undefined) {
          var result = hook.call(expression);

          if (result !== undefined) {
            if (result) {
              result.setExpression(expression);
            }

            return result;
          }
        }
      } catch (e) {
        console.warn(e); // ignore error
      }

      return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);
    }
  }, {
    key: "parseString",
    value: function parseString(expression) {
      switch (expression.type) {
        case "BinaryExpression":
          if (expression.operator === "+") {
            return this.parseString(expression.left) + this.parseString(expression.right);
          }

          break;

        case "Literal":
          return expression.value + "";
      }

      throw new Error(expression.type + " is not supported as parameter for require");
    }
  }, {
    key: "parseCalculatedString",
    value: function parseCalculatedString(expression) {
      switch (expression.type) {
        case "BinaryExpression":
          if (expression.operator === "+") {
            var left = this.parseCalculatedString(expression.left);
            var right = this.parseCalculatedString(expression.right);

            if (left.code) {
              return {
                range: left.range,
                value: left.value,
                code: true,
                conditional: false
              };
            } else if (right.code) {
              return {
                range: [left.range[0], right.range ? right.range[1] : left.range[1]],
                value: left.value + right.value,
                code: true,
                conditional: false
              };
            } else {
              return {
                range: [left.range[0], right.range[1]],
                value: left.value + right.value,
                code: false,
                conditional: false
              };
            }
          }

          break;

        case "ConditionalExpression":
          {
            var consequent = this.parseCalculatedString(expression.consequent);
            var alternate = this.parseCalculatedString(expression.alternate);
            var items = [];

            if (consequent.conditional) {
              items.push.apply(items, _toConsumableArray(consequent.conditional));
            } else if (!consequent.code) {
              items.push(consequent);
            } else {
              break;
            }

            if (alternate.conditional) {
              items.push.apply(items, _toConsumableArray(alternate.conditional));
            } else if (!alternate.code) {
              items.push(alternate);
            } else {
              break;
            }

            return {
              range: undefined,
              value: "",
              code: true,
              conditional: items
            };
          }

        case "Literal":
          return {
            range: expression.range,
            value: expression.value + "",
            code: false,
            conditional: false
          };
      }

      return {
        range: undefined,
        value: "",
        code: true,
        conditional: false
      };
    }
  }, {
    key: "parse",
    value: function parse(source, initialState) {
      var ast;
      var comments;

      if (_typeof(source) === "object" && source !== null) {
        ast = source;
        comments = source.comments;
      } else {
        comments = [];
        ast = Parser.parse(source, {
          sourceType: this.sourceType,
          onComment: comments
        });
      }

      var oldScope = this.scope;
      var oldState = this.state;
      var oldComments = this.comments;
      this.scope = {
        topLevelScope: true,
        inTry: false,
        inShorthand: false,
        isStrict: false,
        isAsmJs: false,
        definitions: new StackedSetMap(),
        renames: new StackedSetMap()
      };
      var state = this.state = initialState || {};
      this.comments = comments;

      if (this.hooks.program.call(ast, comments) === undefined) {
        this.detectMode(ast.body);
        this.prewalkStatements(ast.body);
        this.blockPrewalkStatements(ast.body);
        this.walkStatements(ast.body);
      }

      this.scope = oldScope;
      this.state = oldState;
      this.comments = oldComments;
      return state;
    }
  }, {
    key: "evaluate",
    value: function evaluate(source) {
      var ast = Parser.parse("(" + source + ")", {
        sourceType: this.sourceType,
        locations: false
      }); // TODO(https://github.com/acornjs/acorn/issues/741)
      // @ts-ignore

      if (ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement") {
        throw new Error("evaluate: Source is not a expression");
      } // TODO(https://github.com/acornjs/acorn/issues/741)
      // @ts-ignore


      return this.evaluateExpression(ast.body[0].expression);
    }
  }, {
    key: "getComments",
    value: function getComments(range) {
      return this.comments.filter(function (comment) {
        return comment.range[0] >= range[0] && comment.range[1] <= range[1];
      });
    }
  }, {
    key: "parseCommentOptions",
    value: function parseCommentOptions(range) {
      var comments = this.getComments(range);

      if (comments.length === 0) {
        return EMPTY_COMMENT_OPTIONS;
      }

      var options = {};
      var errors = [];
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = comments[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var comment = _step11.value;
          var value = comment.value;

          if (value && webpackCommentRegExp.test(value)) {
            // try compile only if webpack options comment is present
            try {
              var val = vm.runInNewContext("(function(){return {".concat(value, "};})()"));
              Object.assign(options, val);
            } catch (e) {
              e.comment = comment;
              errors.push(e);
            }
          }
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      return {
        options: options,
        errors: errors
      };
    }
  }, {
    key: "getNameForExpression",
    value: function getNameForExpression(expression) {
      var expr = expression;
      var exprName = [];

      while (expr.type === "MemberExpression" && expr.property.type === (expr.computed ? "Literal" : "Identifier")) {
        exprName.push(expr.computed ? expr.property.value : expr.property.name);
        expr = expr.object;
      }

      var free;

      if (expr.type === "Identifier") {
        free = !this.scope.definitions.has(expr.name);
        exprName.push(this.scope.renames.get(expr.name) || expr.name);
      } else if (expr.type === "ThisExpression" && this.scope.renames.get("this")) {
        free = true;
        exprName.push(this.scope.renames.get("this"));
      } else if (expr.type === "ThisExpression") {
        free = this.scope.topLevelScope;
        exprName.push("this");
      } else {
        return null;
      }

      var prefix = "";

      for (var i = exprName.length - 1; i >= 2; i--) {
        prefix += exprName[i] + ".";
      }

      if (exprName.length > 1) {
        prefix += exprName[1];
      }

      var name = prefix ? prefix + "." + exprName[0] : exprName[0];
      var nameGeneral = prefix;
      return {
        name: name,
        nameGeneral: nameGeneral,
        free: free
      };
    }
  }], [{
    key: "parse",
    value: function parse(code, options) {
      var type = options ? options.sourceType : "module";
      var parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);

      if (type === "auto") {
        parserOptions.sourceType = "module";
      } else if (parserOptions.sourceType === "script") {
        parserOptions.allowReturnOutsideFunction = true;
      }

      var ast;
      var error;
      var threw = false;

      try {
        ast = acornParser.parse(code, parserOptions);
      } catch (e) {
        error = e;
        threw = true;
      }

      if (threw && type === "auto") {
        parserOptions.sourceType = "script";
        parserOptions.allowReturnOutsideFunction = true;

        if (Array.isArray(parserOptions.onComment)) {
          parserOptions.onComment.length = 0;
        }

        try {
          ast = acornParser.parse(code, parserOptions);
          threw = false;
        } catch (e) {
          threw = true;
        }
      }

      if (threw) {
        throw error;
      }

      return ast;
    }
  }]);

  return Parser;
}(Tapable); // TODO remove in webpack 5


Object.defineProperty(Parser.prototype, "getCommentOptions", {
  configurable: false,
  value: util.deprecate(
  /**
   * @deprecated
   * @param {TODO} range Range
   * @returns {void}
   * @this {Parser}
   */
  function (range) {
    return this.parseCommentOptions(range).options;
  }, "Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead")
});
module.exports = Parser;