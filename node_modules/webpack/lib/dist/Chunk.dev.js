/*
MIT License http://www.opensource.org/licenses/mit-license.php
Author Tobias Koppers @sokra
*/
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var util = require("util");

var SortableSet = require("./util/SortableSet");

var intersect = require("./util/SetHelpers").intersect;

var GraphHelpers = require("./GraphHelpers");

var Entrypoint = require("./Entrypoint");

var debugId = 1000;
var ERR_CHUNK_ENTRY = "Chunk.entry was removed. Use hasRuntime()";
var ERR_CHUNK_INITIAL = "Chunk.initial was removed. Use canBeInitial/isOnlyInitial()";
/** @typedef {import("./Module")} Module */

/** @typedef {import("./ChunkGroup")} ChunkGroup */

/** @typedef {import("./ModuleReason")} ModuleReason */

/** @typedef {import("webpack-sources").Source} Source */

/** @typedef {import("./util/createHash").Hash} Hash */

/**
 *  @typedef {Object} WithId an object who has an id property *
 *  @property {string | number} id the id of the object
 */

/**
 * Compare two Modules based on their ids for sorting
 * @param {Module} a module
 * @param {Module} b module
 * @returns {-1|0|1} sort value
 */
// TODO use @callback

/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */

/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */

/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */

var sortModuleById = function sortModuleById(a, b) {
  if (a.id < b.id) return -1;
  if (b.id < a.id) return 1;
  return 0;
};
/**
 * Compare two ChunkGroups based on their ids for sorting
 * @param {ChunkGroup} a chunk group
 * @param {ChunkGroup} b chunk group
 * @returns {-1|0|1} sort value
 */


var sortChunkGroupById = function sortChunkGroupById(a, b) {
  if (a.id < b.id) return -1;
  if (b.id < a.id) return 1;
  return 0;
};
/**
 * Compare two Identifiables , based on their ids for sorting
 * @param {Module} a first object with ident fn
 * @param {Module} b second object with ident fn
 * @returns {-1|0|1} The order number of the sort
 */


var sortByIdentifier = function sortByIdentifier(a, b) {
  if (a.identifier() > b.identifier()) return 1;
  if (a.identifier() < b.identifier()) return -1;
  return 0;
};
/**
 * @returns {string} a concatenation of module identifiers sorted
 * @param {SortableSet} set to pull module identifiers from
 */


var _getModulesIdent = function getModulesIdent(set) {
  set.sort();
  var str = "";
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var m = _step.value;
      str += m.identifier() + "#";
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return str;
};
/**
 * @template T
 * @param {SortableSet<T>} set the sortable set to convert to array
 * @returns {Array<T>} the array returned from Array.from(set)
 */


var getArray = function getArray(set) {
  return Array.from(set);
};
/**
 * @param {SortableSet<Module>} set the sortable Set to get the count/size of
 * @returns {number} the size of the modules
 */


var getModulesSize = function getModulesSize(set) {
  var size = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = set[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _module = _step2.value;
      size += _module.size();
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return size;
};
/**
 * A Chunk is a unit of encapsulation for Modules.
 * Chunks are "rendered" into bundles that get emitted when the build completes.
 */


var Chunk =
/*#__PURE__*/
function () {
  /**
   * @param {string=} name of chunk being created, is optional (for subclasses)
   */
  function Chunk(name) {
    _classCallCheck(this, Chunk);

    /** @type {number | null} */
    this.id = null;
    /** @type {number[] | null} */

    this.ids = null;
    /** @type {number} */

    this.debugId = debugId++;
    /** @type {string} */

    this.name = name;
    /** @type {boolean} */

    this.preventIntegration = false;
    /** @type {Module=} */

    this.entryModule = undefined;
    /** @private @type {SortableSet<Module>} */

    this._modules = new SortableSet(undefined, sortByIdentifier);
    /** @type {string?} */

    this.filenameTemplate = undefined;
    /** @private @type {SortableSet<ChunkGroup>} */

    this._groups = new SortableSet(undefined, sortChunkGroupById);
    /** @type {string[]} */

    this.files = [];
    /** @type {boolean} */

    this.rendered = false;
    /** @type {string=} */

    this.hash = undefined;
    /** @type {Object} */

    this.contentHash = Object.create(null);
    /** @type {string=} */

    this.renderedHash = undefined;
    /** @type {string=} */

    this.chunkReason = undefined;
    /** @type {boolean} */

    this.extraAsync = false;
    this.removedModules = undefined;
  }
  /**
   * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead
   * @returns {never} Throws an error trying to access this property
   */


  _createClass(Chunk, [{
    key: "hasRuntime",

    /**
     * @returns {boolean} whether or not the Chunk will have a runtime
     */
    value: function hasRuntime() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._groups[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var chunkGroup = _step3.value;

          if (chunkGroup.isInitial() && chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return false;
    }
    /**
     * @returns {boolean} whether or not this chunk can be an initial chunk
     */

  }, {
    key: "canBeInitial",
    value: function canBeInitial() {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._groups[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var chunkGroup = _step4.value;
          if (chunkGroup.isInitial()) return true;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return false;
    }
    /**
     * @returns {boolean} whether this chunk can only be an initial chunk
     */

  }, {
    key: "isOnlyInitial",
    value: function isOnlyInitial() {
      if (this._groups.size <= 0) return false;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._groups[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var chunkGroup = _step5.value;
          if (!chunkGroup.isInitial()) return false;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return true;
    }
    /**
     * @returns {boolean} if this chunk contains the entry module
     */

  }, {
    key: "hasEntryModule",
    value: function hasEntryModule() {
      return !!this.entryModule;
    }
    /**
     * @param {Module} module the module that will be added to this chunk.
     * @returns {boolean} returns true if the chunk doesn't have the module and it was added
     */

  }, {
    key: "addModule",
    value: function addModule(module) {
      if (!this._modules.has(module)) {
        this._modules.add(module);

        return true;
      }

      return false;
    }
    /**
     * @param {Module} module the module that will be removed from this chunk
     * @returns {boolean} returns true if chunk exists and is successfully deleted
     */

  }, {
    key: "removeModule",
    value: function removeModule(module) {
      if (this._modules["delete"](module)) {
        module.removeChunk(this);
        return true;
      }

      return false;
    }
    /**
     * @param {Module[]} modules the new modules to be set
     * @returns {void} set new modules to this chunk and return nothing
     */

  }, {
    key: "setModules",
    value: function setModules(modules) {
      this._modules = new SortableSet(modules, sortByIdentifier);
    }
    /**
     * @returns {number} the amount of modules in chunk
     */

  }, {
    key: "getNumberOfModules",
    value: function getNumberOfModules() {
      return this._modules.size;
    }
    /**
     * @returns {SortableSet} return the modules SortableSet for this chunk
     */

  }, {
    key: "addGroup",

    /**
     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added
     * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully
     */
    value: function addGroup(chunkGroup) {
      if (this._groups.has(chunkGroup)) return false;

      this._groups.add(chunkGroup);

      return true;
    }
    /**
     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from
     * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed
     */

  }, {
    key: "removeGroup",
    value: function removeGroup(chunkGroup) {
      if (!this._groups.has(chunkGroup)) return false;

      this._groups["delete"](chunkGroup);

      return true;
    }
    /**
     * @param {ChunkGroup} chunkGroup the chunkGroup to check
     * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup
     */

  }, {
    key: "isInGroup",
    value: function isInGroup(chunkGroup) {
      return this._groups.has(chunkGroup);
    }
    /**
     * @returns {number} the amount of groups said chunk is in
     */

  }, {
    key: "getNumberOfGroups",
    value: function getNumberOfGroups() {
      return this._groups.size;
    }
    /**
     * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in
     */

  }, {
    key: "compareTo",

    /**
     * @param {Chunk} otherChunk the chunk to compare itself with
     * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order
     */
    value: function compareTo(otherChunk) {
      if (this.name && !otherChunk.name) return -1;
      if (!this.name && otherChunk.name) return 1;
      if (this.name < otherChunk.name) return -1;
      if (this.name > otherChunk.name) return 1;
      if (this._modules.size > otherChunk._modules.size) return -1;
      if (this._modules.size < otherChunk._modules.size) return 1;

      this._modules.sort();

      otherChunk._modules.sort();

      var a = this._modules[Symbol.iterator]();

      var b = otherChunk._modules[Symbol.iterator](); // eslint-disable-next-line no-constant-condition


      while (true) {
        var aItem = a.next();
        if (aItem.done) return 0;
        var bItem = b.next();
        var aModuleIdentifier = aItem.value.identifier();
        var bModuleIdentifier = bItem.value.identifier();
        if (aModuleIdentifier < bModuleIdentifier) return -1;
        if (aModuleIdentifier > bModuleIdentifier) return 1;
      }
    }
    /**
     * @param {Module} module Module to check
     * @returns {boolean} returns true if module does exist in this chunk
     */

  }, {
    key: "containsModule",
    value: function containsModule(module) {
      return this._modules.has(module);
    }
    /**
     * @returns {Module[]} an array of modules (do not modify)
     */

  }, {
    key: "getModules",
    value: function getModules() {
      return this._modules.getFromCache(getArray);
    }
  }, {
    key: "getModulesIdent",
    value: function getModulesIdent() {
      return this._modules.getFromUnorderedCache(_getModulesIdent);
    }
    /**
     * @param {string=} reason reason why chunk is removed
     * @returns {void}
     */

  }, {
    key: "remove",
    value: function remove(reason) {
      // cleanup modules
      // Array.from is used here to create a clone, because removeChunk modifies this._modules
      for (var _i = 0, _Array$from = Array.from(this._modules); _i < _Array$from.length; _i++) {
        var _module2 = _Array$from[_i];

        _module2.removeChunk(this);
      }

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this._groups[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var chunkGroup = _step6.value;
          chunkGroup.removeChunk(this);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
    /**
     *
     * @param {Module} module module to move
     * @param {Chunk} otherChunk other chunk to move it to
     * @returns {void}
     */

  }, {
    key: "moveModule",
    value: function moveModule(module, otherChunk) {
      GraphHelpers.disconnectChunkAndModule(this, module);
      GraphHelpers.connectChunkAndModule(otherChunk, module);
      module.rewriteChunkInReasons(this, [otherChunk]);
    }
    /**
     *
     * @param {Chunk} otherChunk the chunk to integrate with
     * @param {string} reason reason why the module is being integrated
     * @returns {boolean} returns true or false if integration succeeds or fails
     */

  }, {
    key: "integrate",
    value: function integrate(otherChunk, reason) {
      if (!this.canBeIntegrated(otherChunk)) {
        return false;
      } // Pick a new name for the integrated chunk


      if (this.name && otherChunk.name) {
        if (this.hasEntryModule() === otherChunk.hasEntryModule()) {
          // When both chunks have entry modules or none have one, use
          // shortest name
          if (this.name.length !== otherChunk.name.length) {
            this.name = this.name.length < otherChunk.name.length ? this.name : otherChunk.name;
          } else {
            this.name = this.name < otherChunk.name ? this.name : otherChunk.name;
          }
        } else if (otherChunk.hasEntryModule()) {
          // Pick the name of the chunk with the entry module
          this.name = otherChunk.name;
        }
      } else if (otherChunk.name) {
        this.name = otherChunk.name;
      } // Array.from is used here to create a clone, because moveModule modifies otherChunk._modules


      for (var _i2 = 0, _Array$from2 = Array.from(otherChunk._modules); _i2 < _Array$from2.length; _i2++) {
        var _module3 = _Array$from2[_i2];
        otherChunk.moveModule(_module3, this);
      }

      otherChunk._modules.clear();

      if (otherChunk.entryModule) {
        this.entryModule = otherChunk.entryModule;
      }

      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = otherChunk._groups[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var chunkGroup = _step7.value;
          chunkGroup.replaceChunk(otherChunk, this);
          this.addGroup(chunkGroup);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      otherChunk._groups.clear();

      return true;
    }
    /**
     * @param {Chunk} newChunk the new chunk that will be split out of the current chunk
     * @returns {void}
     */

  }, {
    key: "split",
    value: function split(newChunk) {
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this._groups[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var chunkGroup = _step8.value;
          chunkGroup.insertChunk(newChunk, this);
          newChunk.addGroup(chunkGroup);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._modules.size === 0;
    }
  }, {
    key: "updateHash",
    value: function updateHash(hash) {
      hash.update("".concat(this.id, " "));
      hash.update(this.ids ? this.ids.join(",") : "");
      hash.update("".concat(this.name || "", " "));
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this._modules[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var m = _step9.value;
          hash.update(m.hash);
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }
    }
  }, {
    key: "canBeIntegrated",
    value: function canBeIntegrated(otherChunk) {
      if (this.preventIntegration || otherChunk.preventIntegration) {
        return false;
      }
      /**
       * @param {Chunk} a chunk
       * @param {Chunk} b chunk
       * @returns {boolean} true, if a is always available when b is reached
       */


      var isAvailable = function isAvailable(a, b) {
        var queue = new Set(b.groupsIterable);
        var _iteratorNormalCompletion10 = true;
        var _didIteratorError10 = false;
        var _iteratorError10 = undefined;

        try {
          for (var _iterator10 = queue[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
            var chunkGroup = _step10.value;
            if (a.isInGroup(chunkGroup)) continue;
            if (chunkGroup.isInitial()) return false;
            var _iteratorNormalCompletion11 = true;
            var _didIteratorError11 = false;
            var _iteratorError11 = undefined;

            try {
              for (var _iterator11 = chunkGroup.parentsIterable[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                var parent = _step11.value;
                queue.add(parent);
              }
            } catch (err) {
              _didIteratorError11 = true;
              _iteratorError11 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                  _iterator11["return"]();
                }
              } finally {
                if (_didIteratorError11) {
                  throw _iteratorError11;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError10 = true;
          _iteratorError10 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
              _iterator10["return"]();
            }
          } finally {
            if (_didIteratorError10) {
              throw _iteratorError10;
            }
          }
        }

        return true;
      };

      var selfHasRuntime = this.hasRuntime();
      var otherChunkHasRuntime = otherChunk.hasRuntime();

      if (selfHasRuntime !== otherChunkHasRuntime) {
        if (selfHasRuntime) {
          return isAvailable(this, otherChunk);
        } else if (otherChunkHasRuntime) {
          return isAvailable(otherChunk, this);
        } else {
          return false;
        }
      }

      if (this.hasEntryModule() || otherChunk.hasEntryModule()) {
        return false;
      }

      return true;
    }
    /**
     *
     * @param {number} size the size
     * @param {Object} options the options passed in
     * @returns {number} the multiplier returned
     */

  }, {
    key: "addMultiplierAndOverhead",
    value: function addMultiplierAndOverhead(size, options) {
      var overhead = typeof options.chunkOverhead === "number" ? options.chunkOverhead : 10000;
      var multiplicator = this.canBeInitial() ? options.entryChunkMultiplicator || 10 : 1;
      return size * multiplicator + overhead;
    }
    /**
     * @returns {number} the size of all modules
     */

  }, {
    key: "modulesSize",
    value: function modulesSize() {
      return this._modules.getFromUnorderedCache(getModulesSize);
    }
    /**
     * @param {Object} options the size display options
     * @returns {number} the chunk size
     */

  }, {
    key: "size",
    value: function size() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.addMultiplierAndOverhead(this.modulesSize(), options);
    }
    /**
     * @param {Chunk} otherChunk the other chunk
     * @param {TODO} options the options for this function
     * @returns {number | false} the size, or false if it can't be integrated
     */

  }, {
    key: "integratedSize",
    value: function integratedSize(otherChunk, options) {
      // Chunk if it's possible to integrate this chunk
      if (!this.canBeIntegrated(otherChunk)) {
        return false;
      }

      var integratedModulesSize = this.modulesSize(); // only count modules that do not exist in this chunk!

      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = otherChunk._modules[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var otherModule = _step12.value;

          if (!this._modules.has(otherModule)) {
            integratedModulesSize += otherModule.size();
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
            _iterator12["return"]();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      return this.addMultiplierAndOverhead(integratedModulesSize, options);
    }
    /**
     * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules
     * @returns {void}
     */

  }, {
    key: "sortModules",
    value: function sortModules(sortByFn) {
      this._modules.sortWith(sortByFn || sortModuleById);
    }
  }, {
    key: "sortItems",
    value: function sortItems() {
      this.sortModules();
    }
    /**
     * @returns {Set<Chunk>} a set of all the async chunks
     */

  }, {
    key: "getAllAsyncChunks",
    value: function getAllAsyncChunks() {
      var queue = new Set();
      var chunks = new Set();
      var initialChunks = intersect(Array.from(this.groupsIterable, function (g) {
        return new Set(g.chunks);
      }));
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = this.groupsIterable[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var chunkGroup = _step13.value;
          var _iteratorNormalCompletion15 = true;
          var _didIteratorError15 = false;
          var _iteratorError15 = undefined;

          try {
            for (var _iterator15 = chunkGroup.childrenIterable[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
              var child = _step15.value;
              queue.add(child);
            }
          } catch (err) {
            _didIteratorError15 = true;
            _iteratorError15 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
                _iterator15["return"]();
              }
            } finally {
              if (_didIteratorError15) {
                throw _iteratorError15;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
            _iterator13["return"]();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }

      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = queue[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var _chunkGroup = _step14.value;
          var _iteratorNormalCompletion16 = true;
          var _didIteratorError16 = false;
          var _iteratorError16 = undefined;

          try {
            for (var _iterator16 = _chunkGroup.chunks[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
              var chunk = _step16.value;

              if (!initialChunks.has(chunk)) {
                chunks.add(chunk);
              }
            }
          } catch (err) {
            _didIteratorError16 = true;
            _iteratorError16 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
                _iterator16["return"]();
              }
            } finally {
              if (_didIteratorError16) {
                throw _iteratorError16;
              }
            }
          }

          var _iteratorNormalCompletion17 = true;
          var _didIteratorError17 = false;
          var _iteratorError17 = undefined;

          try {
            for (var _iterator17 = _chunkGroup.childrenIterable[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
              var _child = _step17.value;
              queue.add(_child);
            }
          } catch (err) {
            _didIteratorError17 = true;
            _iteratorError17 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
                _iterator17["return"]();
              }
            } finally {
              if (_didIteratorError17) {
                throw _iteratorError17;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
            _iterator14["return"]();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }

      return chunks;
    }
    /**
     * @typedef {Object} ChunkMaps
     * @property {Record<string|number, string>} hash
     * @property {Record<string|number, Record<string, string>>} contentHash
     * @property {Record<string|number, string>} name
     */

    /**
     * @param {boolean} realHash should the full hash or the rendered hash be used
     * @returns {ChunkMaps} the chunk map information
     */

  }, {
    key: "getChunkMaps",
    value: function getChunkMaps(realHash) {
      /** @type {Record<string|number, string>} */
      var chunkHashMap = Object.create(null);
      /** @type {Record<string|number, Record<string, string>>} */

      var chunkContentHashMap = Object.create(null);
      /** @type {Record<string|number, string>} */

      var chunkNameMap = Object.create(null);
      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = this.getAllAsyncChunks()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var chunk = _step18.value;
          chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;

          for (var _i3 = 0, _Object$keys = Object.keys(chunk.contentHash); _i3 < _Object$keys.length; _i3++) {
            var key = _Object$keys[_i3];

            if (!chunkContentHashMap[key]) {
              chunkContentHashMap[key] = Object.create(null);
            }

            chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];
          }

          if (chunk.name) {
            chunkNameMap[chunk.id] = chunk.name;
          }
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
            _iterator18["return"]();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }

      return {
        hash: chunkHashMap,
        contentHash: chunkContentHashMap,
        name: chunkNameMap
      };
    }
    /**
     * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)
     */

  }, {
    key: "getChildIdsByOrders",
    value: function getChildIdsByOrders() {
      var lists = new Map();
      var _iteratorNormalCompletion19 = true;
      var _didIteratorError19 = false;
      var _iteratorError19 = undefined;

      try {
        for (var _iterator19 = this.groupsIterable[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
          var group = _step19.value;

          if (group.chunks[group.chunks.length - 1] === this) {
            var _iteratorNormalCompletion21 = true;
            var _didIteratorError21 = false;
            var _iteratorError21 = undefined;

            try {
              for (var _iterator21 = group.childrenIterable[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                var childGroup = _step21.value;

                // TODO webpack 5 remove this check for options
                if (_typeof(childGroup.options) === "object") {
                  for (var _i4 = 0, _Object$keys2 = Object.keys(childGroup.options); _i4 < _Object$keys2.length; _i4++) {
                    var key = _Object$keys2[_i4];

                    if (key.endsWith("Order")) {
                      var name = key.substr(0, key.length - "Order".length);
                      var list = lists.get(name);
                      if (list === undefined) lists.set(name, list = []);
                      list.push({
                        order: childGroup.options[key],
                        group: childGroup
                      });
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError21 = true;
              _iteratorError21 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
                  _iterator21["return"]();
                }
              } finally {
                if (_didIteratorError21) {
                  throw _iteratorError21;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError19 = true;
        _iteratorError19 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
            _iterator19["return"]();
          }
        } finally {
          if (_didIteratorError19) {
            throw _iteratorError19;
          }
        }
      }

      var result = Object.create(null);
      var _iteratorNormalCompletion20 = true;
      var _didIteratorError20 = false;
      var _iteratorError20 = undefined;

      try {
        for (var _iterator20 = lists[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
          var _step20$value = _slicedToArray(_step20.value, 2),
              _name = _step20$value[0],
              _list = _step20$value[1];

          _list.sort(function (a, b) {
            var cmp = b.order - a.order;
            if (cmp !== 0) return cmp; // TODO webpack 5 remove this check of compareTo

            if (a.group.compareTo) {
              return a.group.compareTo(b.group);
            }

            return 0;
          });

          result[_name] = Array.from(_list.reduce(function (set, item) {
            var _iteratorNormalCompletion22 = true;
            var _didIteratorError22 = false;
            var _iteratorError22 = undefined;

            try {
              for (var _iterator22 = item.group.chunks[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var chunk = _step22.value;
                set.add(chunk.id);
              }
            } catch (err) {
              _didIteratorError22 = true;
              _iteratorError22 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
                  _iterator22["return"]();
                }
              } finally {
                if (_didIteratorError22) {
                  throw _iteratorError22;
                }
              }
            }

            return set;
          }, new Set()));
        }
      } catch (err) {
        _didIteratorError20 = true;
        _iteratorError20 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
            _iterator20["return"]();
          }
        } finally {
          if (_didIteratorError20) {
            throw _iteratorError20;
          }
        }
      }

      return result;
    }
  }, {
    key: "getChildIdsByOrdersMap",
    value: function getChildIdsByOrdersMap(includeDirectChildren) {
      var chunkMaps = Object.create(null);

      var addChildIdsByOrdersToMap = function addChildIdsByOrdersToMap(chunk) {
        var data = chunk.getChildIdsByOrders();

        for (var _i5 = 0, _Object$keys3 = Object.keys(data); _i5 < _Object$keys3.length; _i5++) {
          var key = _Object$keys3[_i5];
          var chunkMap = chunkMaps[key];

          if (chunkMap === undefined) {
            chunkMaps[key] = chunkMap = Object.create(null);
          }

          chunkMap[chunk.id] = data[key];
        }
      };

      if (includeDirectChildren) {
        var chunks = new Set();
        var _iteratorNormalCompletion23 = true;
        var _didIteratorError23 = false;
        var _iteratorError23 = undefined;

        try {
          for (var _iterator23 = this.groupsIterable[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
            var chunkGroup = _step23.value;
            var _iteratorNormalCompletion25 = true;
            var _didIteratorError25 = false;
            var _iteratorError25 = undefined;

            try {
              for (var _iterator25 = chunkGroup.chunks[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                var chunk = _step25.value;
                chunks.add(chunk);
              }
            } catch (err) {
              _didIteratorError25 = true;
              _iteratorError25 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
                  _iterator25["return"]();
                }
              } finally {
                if (_didIteratorError25) {
                  throw _iteratorError25;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError23 = true;
          _iteratorError23 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
              _iterator23["return"]();
            }
          } finally {
            if (_didIteratorError23) {
              throw _iteratorError23;
            }
          }
        }

        var _iteratorNormalCompletion24 = true;
        var _didIteratorError24 = false;
        var _iteratorError24 = undefined;

        try {
          for (var _iterator24 = chunks[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
            var _chunk = _step24.value;
            addChildIdsByOrdersToMap(_chunk);
          }
        } catch (err) {
          _didIteratorError24 = true;
          _iteratorError24 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
              _iterator24["return"]();
            }
          } finally {
            if (_didIteratorError24) {
              throw _iteratorError24;
            }
          }
        }
      }

      var _iteratorNormalCompletion26 = true;
      var _didIteratorError26 = false;
      var _iteratorError26 = undefined;

      try {
        for (var _iterator26 = this.getAllAsyncChunks()[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
          var _chunk2 = _step26.value;
          addChildIdsByOrdersToMap(_chunk2);
        }
      } catch (err) {
        _didIteratorError26 = true;
        _iteratorError26 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion26 && _iterator26["return"] != null) {
            _iterator26["return"]();
          }
        } finally {
          if (_didIteratorError26) {
            throw _iteratorError26;
          }
        }
      }

      return chunkMaps;
    }
    /**
     * @typedef {Object} ChunkModuleMaps
     * @property {Record<string|number, (string|number)[]>} id
     * @property {Record<string|number, string>} hash
     */

    /**
     * @param {ModuleFilterPredicate} filterFn function used to filter modules
     * @returns {ChunkModuleMaps} module map information
     */

  }, {
    key: "getChunkModuleMaps",
    value: function getChunkModuleMaps(filterFn) {
      /** @type {Record<string|number, (string|number)[]>} */
      var chunkModuleIdMap = Object.create(null);
      /** @type {Record<string|number, string>} */

      var chunkModuleHashMap = Object.create(null);
      var _iteratorNormalCompletion27 = true;
      var _didIteratorError27 = false;
      var _iteratorError27 = undefined;

      try {
        for (var _iterator27 = this.getAllAsyncChunks()[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
          var chunk = _step27.value;

          /** @type {(string|number)[]} */
          var array = void 0;
          var _iteratorNormalCompletion28 = true;
          var _didIteratorError28 = false;
          var _iteratorError28 = undefined;

          try {
            for (var _iterator28 = chunk.modulesIterable[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
              var _module4 = _step28.value;

              if (filterFn(_module4)) {
                if (array === undefined) {
                  array = [];
                  chunkModuleIdMap[chunk.id] = array;
                }

                array.push(_module4.id);
                chunkModuleHashMap[_module4.id] = _module4.renderedHash;
              }
            }
          } catch (err) {
            _didIteratorError28 = true;
            _iteratorError28 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion28 && _iterator28["return"] != null) {
                _iterator28["return"]();
              }
            } finally {
              if (_didIteratorError28) {
                throw _iteratorError28;
              }
            }
          }

          if (array !== undefined) {
            array.sort();
          }
        }
      } catch (err) {
        _didIteratorError27 = true;
        _iteratorError27 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion27 && _iterator27["return"] != null) {
            _iterator27["return"]();
          }
        } finally {
          if (_didIteratorError27) {
            throw _iteratorError27;
          }
        }
      }

      return {
        id: chunkModuleIdMap,
        hash: chunkModuleHashMap
      };
    }
    /**
     *
     * @param {function(Module): boolean} filterFn predicate function used to filter modules
     * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks
     * @returns {boolean} return true if module exists in graph
     */

  }, {
    key: "hasModuleInGraph",
    value: function hasModuleInGraph(filterFn, filterChunkFn) {
      var queue = new Set(this.groupsIterable);
      var chunksProcessed = new Set();
      var _iteratorNormalCompletion29 = true;
      var _didIteratorError29 = false;
      var _iteratorError29 = undefined;

      try {
        for (var _iterator29 = queue[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
          var chunkGroup = _step29.value;
          var _iteratorNormalCompletion30 = true;
          var _didIteratorError30 = false;
          var _iteratorError30 = undefined;

          try {
            for (var _iterator30 = chunkGroup.chunks[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
              var chunk = _step30.value;

              if (!chunksProcessed.has(chunk)) {
                chunksProcessed.add(chunk);

                if (!filterChunkFn || filterChunkFn(chunk)) {
                  var _iteratorNormalCompletion32 = true;
                  var _didIteratorError32 = false;
                  var _iteratorError32 = undefined;

                  try {
                    for (var _iterator32 = chunk.modulesIterable[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
                      var _module5 = _step32.value;

                      if (filterFn(_module5)) {
                        return true;
                      }
                    }
                  } catch (err) {
                    _didIteratorError32 = true;
                    _iteratorError32 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion32 && _iterator32["return"] != null) {
                        _iterator32["return"]();
                      }
                    } finally {
                      if (_didIteratorError32) {
                        throw _iteratorError32;
                      }
                    }
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError30 = true;
            _iteratorError30 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion30 && _iterator30["return"] != null) {
                _iterator30["return"]();
              }
            } finally {
              if (_didIteratorError30) {
                throw _iteratorError30;
              }
            }
          }

          var _iteratorNormalCompletion31 = true;
          var _didIteratorError31 = false;
          var _iteratorError31 = undefined;

          try {
            for (var _iterator31 = chunkGroup.childrenIterable[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
              var child = _step31.value;
              queue.add(child);
            }
          } catch (err) {
            _didIteratorError31 = true;
            _iteratorError31 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion31 && _iterator31["return"] != null) {
                _iterator31["return"]();
              }
            } finally {
              if (_didIteratorError31) {
                throw _iteratorError31;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError29 = true;
        _iteratorError29 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion29 && _iterator29["return"] != null) {
            _iterator29["return"]();
          }
        } finally {
          if (_didIteratorError29) {
            throw _iteratorError29;
          }
        }
      }

      return false;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Chunk[".concat(Array.from(this._modules).join(), "]");
    }
  }, {
    key: "entry",
    get: function get() {
      throw new Error(ERR_CHUNK_ENTRY);
    }
    /**
     * @deprecated .entry has been deprecated. Please use .hasRuntime() instead
     * @param {never} data The data that was attempting to be set
     * @returns {never} Throws an error trying to access this property
     */
    ,
    set: function set(data) {
      throw new Error(ERR_CHUNK_ENTRY);
    }
    /**
     * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()
     * @returns {never} Throws an error trying to access this property
     */

  }, {
    key: "initial",
    get: function get() {
      throw new Error(ERR_CHUNK_INITIAL);
    }
    /**
     * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()
     * @param {never} data The data attempting to be set
     * @returns {never} Throws an error trying to access this property
     */
    ,
    set: function set(data) {
      throw new Error(ERR_CHUNK_INITIAL);
    }
  }, {
    key: "modulesIterable",
    get: function get() {
      return this._modules;
    }
  }, {
    key: "groupsIterable",
    get: function get() {
      return this._groups;
    }
  }]);

  return Chunk;
}(); // TODO remove in webpack 5


Object.defineProperty(Chunk.prototype, "forEachModule", {
  configurable: false,
  value: util.deprecate(
  /**
   * @deprecated
   * @this {Chunk}
   * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback
   * @param {ForEachModuleCallback} fn Callback function
   * @returns {void}
   */
  function (fn) {
    this._modules.forEach(fn);
  }, "Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead")
}); // TODO remove in webpack 5

Object.defineProperty(Chunk.prototype, "mapModules", {
  configurable: false,
  value: util.deprecate(
  /**
   * @deprecated
   * @this {Chunk}
   * @typedef {function(any, number): any} MapModulesCallback
   * @param {MapModulesCallback} fn Callback function
   * @returns {TODO[]} result of mapped modules
   */
  function (fn) {
    return Array.from(this._modules, fn);
  }, "Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead")
}); // TODO remove in webpack 5

Object.defineProperty(Chunk.prototype, "chunks", {
  configurable: false,
  get: function get() {
    throw new Error("Chunk.chunks: Use ChunkGroup.getChildren() instead");
  },
  set: function set() {
    throw new Error("Chunk.chunks: Use ChunkGroup.add/removeChild() instead");
  }
}); // TODO remove in webpack 5

Object.defineProperty(Chunk.prototype, "parents", {
  configurable: false,
  get: function get() {
    throw new Error("Chunk.parents: Use ChunkGroup.getParents() instead");
  },
  set: function set() {
    throw new Error("Chunk.parents: Use ChunkGroup.add/removeParent() instead");
  }
}); // TODO remove in webpack 5

Object.defineProperty(Chunk.prototype, "blocks", {
  configurable: false,
  get: function get() {
    throw new Error("Chunk.blocks: Use ChunkGroup.getBlocks() instead");
  },
  set: function set() {
    throw new Error("Chunk.blocks: Use ChunkGroup.add/removeBlock() instead");
  }
}); // TODO remove in webpack 5

Object.defineProperty(Chunk.prototype, "entrypoints", {
  configurable: false,
  get: function get() {
    throw new Error("Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead");
  },
  set: function set() {
    throw new Error("Chunk.entrypoints: Use Chunks.addGroup instead");
  }
});
module.exports = Chunk;