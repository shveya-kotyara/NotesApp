/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ConstDependency = require("./dependencies/ConstDependency");

var BasicEvaluatedExpression = require("./BasicEvaluatedExpression");

var ParserHelpers = require("./ParserHelpers");

var NullFactory = require("./NullFactory");
/** @typedef {import("./Compiler")} Compiler */

/** @typedef {import("./Parser")} Parser */

/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */

/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */


var RuntimeValue =
/*#__PURE__*/
function () {
  function RuntimeValue(fn, fileDependencies) {
    _classCallCheck(this, RuntimeValue);

    this.fn = fn;
    this.fileDependencies = fileDependencies || [];
  }

  _createClass(RuntimeValue, [{
    key: "exec",
    value: function exec(parser) {
      if (this.fileDependencies === true) {
        parser.state.module.buildInfo.cacheable = false;
      } else {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.fileDependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var fileDependency = _step.value;
            parser.state.module.buildInfo.fileDependencies.add(fileDependency);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return this.fn({
        module: parser.state.module
      });
    }
  }]);

  return RuntimeValue;
}();

var stringifyObj = function stringifyObj(obj, parser) {
  return "Object({" + Object.keys(obj).map(function (key) {
    var code = obj[key];
    return JSON.stringify(key) + ":" + toCode(code, parser);
  }).join(",") + "})";
};
/**
 * Convert code to a string that evaluates
 * @param {CodeValue} code Code to evaluate
 * @param {Parser} parser Parser
 * @returns {string} code converted to string that evaluates
 */


var toCode = function toCode(code, parser) {
  if (code === null) {
    return "null";
  }

  if (code === undefined) {
    return "undefined";
  }

  if (code instanceof RuntimeValue) {
    return toCode(code.exec(parser), parser);
  }

  if (code instanceof RegExp && code.toString) {
    return code.toString();
  }

  if (typeof code === "function" && code.toString) {
    return "(" + code.toString() + ")";
  }

  if (_typeof(code) === "object") {
    return stringifyObj(code, parser);
  }

  return code + "";
};

var DefinePlugin =
/*#__PURE__*/
function () {
  /**
   * Create a new define plugin
   * @param {Record<string, CodeValue>} definitions A map of global object definitions
   */
  function DefinePlugin(definitions) {
    _classCallCheck(this, DefinePlugin);

    this.definitions = definitions;
  }

  _createClass(DefinePlugin, [{
    key: "apply",

    /**
     * Apply the plugin
     * @param {Compiler} compiler Webpack compiler
     * @returns {void}
     */
    value: function apply(compiler) {
      var definitions = this.definitions;
      compiler.hooks.compilation.tap("DefinePlugin", function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;
        compilation.dependencyFactories.set(ConstDependency, new NullFactory());
        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
        /**
         * Handler
         * @param {Parser} parser Parser
         * @returns {void}
         */

        var handler = function handler(parser) {
          /**
           * Walk definitions
           * @param {Object} definitions Definitions map
           * @param {string} prefix Prefix string
           * @returns {void}
           */
          var walkDefinitions = function walkDefinitions(definitions, prefix) {
            Object.keys(definitions).forEach(function (key) {
              var code = definitions[key];

              if (code && _typeof(code) === "object" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {
                walkDefinitions(code, prefix + key + ".");
                applyObjectDefine(prefix + key, code);
                return;
              }

              applyDefineKey(prefix, key);
              applyDefine(prefix + key, code);
            });
          };
          /**
           * Apply define key
           * @param {string} prefix Prefix
           * @param {string} key Key
           * @returns {void}
           */


          var applyDefineKey = function applyDefineKey(prefix, key) {
            var splittedKey = key.split(".");
            splittedKey.slice(1).forEach(function (_, i) {
              var fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
              parser.hooks.canRename["for"](fullKey).tap("DefinePlugin", ParserHelpers.approve);
            });
          };
          /**
           * Apply Code
           * @param {string} key Key
           * @param {CodeValue} code Code
           * @returns {void}
           */


          var applyDefine = function applyDefine(key, code) {
            var isTypeof = /^typeof\s+/.test(key);
            if (isTypeof) key = key.replace(/^typeof\s+/, "");
            var recurse = false;
            var recurseTypeof = false;

            if (!isTypeof) {
              parser.hooks.canRename["for"](key).tap("DefinePlugin", ParserHelpers.approve);
              parser.hooks.evaluateIdentifier["for"](key).tap("DefinePlugin", function (expr) {
                /**
                 * this is needed in case there is a recursion in the DefinePlugin
                 * to prevent an endless recursion
                 * e.g.: new DefinePlugin({
                 * "a": "b",
                 * "b": "a"
                 * });
                 */
                if (recurse) return;
                recurse = true;
                var res = parser.evaluate(toCode(code, parser));
                recurse = false;
                res.setRange(expr.range);
                return res;
              });
              parser.hooks.expression["for"](key).tap("DefinePlugin", function (expr) {
                var strCode = toCode(code, parser);

                if (/__webpack_require__/.test(strCode)) {
                  return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);
                } else {
                  return ParserHelpers.toConstantDependency(parser, strCode)(expr);
                }
              });
            }

            parser.hooks.evaluateTypeof["for"](key).tap("DefinePlugin", function (expr) {
              /**
               * this is needed in case there is a recursion in the DefinePlugin
               * to prevent an endless recursion
               * e.g.: new DefinePlugin({
               * "typeof a": "typeof b",
               * "typeof b": "typeof a"
               * });
               */
              if (recurseTypeof) return;
              recurseTypeof = true;
              var typeofCode = isTypeof ? toCode(code, parser) : "typeof (" + toCode(code, parser) + ")";
              var res = parser.evaluate(typeofCode);
              recurseTypeof = false;
              res.setRange(expr.range);
              return res;
            });
            parser.hooks["typeof"]["for"](key).tap("DefinePlugin", function (expr) {
              var typeofCode = isTypeof ? toCode(code, parser) : "typeof (" + toCode(code, parser) + ")";
              var res = parser.evaluate(typeofCode);
              if (!res.isString()) return;
              return ParserHelpers.toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);
            });
          };
          /**
           * Apply Object
           * @param {string} key Key
           * @param {Object} obj Object
           * @returns {void}
           */


          var applyObjectDefine = function applyObjectDefine(key, obj) {
            parser.hooks.canRename["for"](key).tap("DefinePlugin", ParserHelpers.approve);
            parser.hooks.evaluateIdentifier["for"](key).tap("DefinePlugin", function (expr) {
              return new BasicEvaluatedExpression().setTruthy().setRange(expr.range);
            });
            parser.hooks.evaluateTypeof["for"](key).tap("DefinePlugin", function (expr) {
              return ParserHelpers.evaluateToString("object")(expr);
            });
            parser.hooks.expression["for"](key).tap("DefinePlugin", function (expr) {
              var strCode = stringifyObj(obj, parser);

              if (/__webpack_require__/.test(strCode)) {
                return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);
              } else {
                return ParserHelpers.toConstantDependency(parser, strCode)(expr);
              }
            });
            parser.hooks["typeof"]["for"](key).tap("DefinePlugin", function (expr) {
              return ParserHelpers.toConstantDependency(parser, JSON.stringify("object"))(expr);
            });
          };

          walkDefinitions(definitions, "");
        };

        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("DefinePlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/dynamic").tap("DefinePlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/esm").tap("DefinePlugin", handler);
      });
    }
  }], [{
    key: "runtimeValue",
    value: function runtimeValue(fn, fileDependencies) {
      return new RuntimeValue(fn, fileDependencies);
    }
  }]);

  return DefinePlugin;
}();

module.exports = DefinePlugin;