/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var AsyncDependencyToInitialChunkError = require("./AsyncDependencyToInitialChunkError");

var GraphHelpers = require("./GraphHelpers");
/** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */

/** @typedef {import("./Chunk")} Chunk */

/** @typedef {import("./ChunkGroup")} ChunkGroup */

/** @typedef {import("./Compilation")} Compilation */

/** @typedef {import("./DependenciesBlock")} DependenciesBlock */

/** @typedef {import("./Dependency")} Dependency */

/** @typedef {import("./Entrypoint")} Entrypoint */

/** @typedef {import("./Module")} Module */

/**
 * @typedef {Object} QueueItem
 * @property {number} action
 * @property {DependenciesBlock} block
 * @property {Module} module
 * @property {Chunk} chunk
 * @property {ChunkGroup} chunkGroup
 */

/**
 * @typedef {Object} ChunkGroupInfo
 * @property {ChunkGroup} chunkGroup the chunk group
 * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point
 * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified
 * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules
 * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)
 * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group
 * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink
 */

/**
 * @typedef {Object} BlockChunkGroupConnection
 * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group
 * @property {ChunkGroup} chunkGroup referenced chunk group
 */

/**
 * @template T
 * @param {Set<T>} a first set
 * @param {Set<T>} b second set
 * @returns {number} cmp
 */


var bySetSize = function bySetSize(a, b) {
  return b.size - a.size;
};
/**
 * Extracts simplified info from the modules and their dependencies
 * @param {Compilation} compilation the compilation
 * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks
 */


var extraceBlockInfoMap = function extraceBlockInfoMap(compilation) {
  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */
  var blockInfoMap = new Map();
  /**
   * @param {Dependency} d dependency to iterate over
   * @returns {void}
   */

  var iteratorDependency = function iteratorDependency(d) {
    // We skip Dependencies without Reference
    var ref = compilation.getDependencyReference(currentModule, d);

    if (!ref) {
      return;
    } // We skip Dependencies without Module pointer


    var refModule = ref.module;

    if (!refModule) {
      return;
    } // We skip weak Dependencies


    if (ref.weak) {
      return;
    }

    blockInfoModules.add(refModule);
  };
  /**
   * @param {AsyncDependenciesBlock} b blocks to prepare
   * @returns {void}
   */


  var iteratorBlockPrepare = function iteratorBlockPrepare(b) {
    blockInfoBlocks.push(b);
    blockQueue.push(b);
  };
  /** @type {Module} */


  var currentModule;
  /** @type {DependenciesBlock} */

  var block;
  /** @type {DependenciesBlock[]} */

  var blockQueue;
  /** @type {Set<Module>} */

  var blockInfoModules;
  /** @type {AsyncDependenciesBlock[]} */

  var blockInfoBlocks;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = compilation.modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _module = _step.value;
      blockQueue = [_module];
      currentModule = _module;

      while (blockQueue.length > 0) {
        block = blockQueue.pop();
        blockInfoModules = new Set();
        blockInfoBlocks = [];

        if (block.variables) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = block.variables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var variable = _step2.value;
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = variable.dependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var dep = _step3.value;
                  iteratorDependency(dep);
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                    _iterator3["return"]();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        if (block.dependencies) {
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = block.dependencies[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _dep = _step4.value;
              iteratorDependency(_dep);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }

        if (block.blocks) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = block.blocks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var b = _step5.value;
              iteratorBlockPrepare(b);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }

        var blockInfo = {
          modules: blockInfoModules,
          blocks: blockInfoBlocks
        };
        blockInfoMap.set(block, blockInfo);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return blockInfoMap;
};
/**
 *
 * @param {Compilation} compilation the compilation
 * @param {Entrypoint[]} inputChunkGroups input groups
 * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules
 * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks
 * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks
 * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here
 */


var visitModules = function visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) {
  var logger = compilation.getLogger("webpack.buildChunkGraph.visitModules");
  var namedChunkGroups = compilation.namedChunkGroups;
  logger.time("prepare");
  var blockInfoMap = extraceBlockInfoMap(compilation);
  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */

  var chunkGroupCounters = new Map();
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = inputChunkGroups[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var _chunkGroup3 = _step6.value;
      chunkGroupCounters.set(_chunkGroup3, {
        index: 0,
        index2: 0
      });
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  var nextFreeModuleIndex = 0;
  var nextFreeModuleIndex2 = 0;
  /** @type {Map<DependenciesBlock, ChunkGroup>} */

  var blockChunkGroups = new Map();
  var ADD_AND_ENTER_MODULE = 0;
  var ENTER_MODULE = 1;
  var PROCESS_BLOCK = 2;
  var LEAVE_MODULE = 3;
  /**
   * @param {QueueItem[]} queue the queue array (will be mutated)
   * @param {ChunkGroup} chunkGroup chunk group
   * @returns {QueueItem[]} the queue array again
   */

  var reduceChunkGroupToQueueItem = function reduceChunkGroupToQueueItem(queue, chunkGroup) {
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
      for (var _iterator7 = chunkGroup.chunks[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var _chunk = _step7.value;
        var _module2 = _chunk.entryModule;
        queue.push({
          action: ENTER_MODULE,
          block: _module2,
          module: _module2,
          chunk: _chunk,
          chunkGroup: chunkGroup
        });
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
          _iterator7["return"]();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }

    chunkGroupInfoMap.set(chunkGroup, {
      chunkGroup: chunkGroup,
      minAvailableModules: new Set(),
      minAvailableModulesOwned: true,
      availableModulesToBeMerged: [],
      skippedItems: [],
      resultingAvailableModules: undefined,
      children: undefined
    });
    return queue;
  }; // Start with the provided modules/chunks

  /** @type {QueueItem[]} */


  var queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();
  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */

  var queueConnect = new Map();
  /** @type {Set<ChunkGroupInfo>} */

  var outdatedChunkGroupInfo = new Set();
  /** @type {QueueItem[]} */

  var queueDelayed = [];
  logger.timeEnd("prepare");
  /** @type {Module} */

  var module;
  /** @type {Chunk} */

  var chunk;
  /** @type {ChunkGroup} */

  var chunkGroup;
  /** @type {ChunkGroupInfo} */

  var chunkGroupInfo;
  /** @type {DependenciesBlock} */

  var block;
  /** @type {Set<Module>} */

  var minAvailableModules;
  /** @type {QueueItem[]} */

  var skippedItems; // For each async Block in graph

  /**
   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock
   * @returns {void}
   */

  var iteratorBlock = function iteratorBlock(b) {
    // 1. We create a chunk for this Block
    // but only once (blockChunkGroups map)
    var c = blockChunkGroups.get(b);

    if (c === undefined) {
      c = namedChunkGroups.get(b.chunkName);

      if (c && c.isInitial()) {
        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));
        c = chunkGroup;
      } else {
        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);
        chunkGroupCounters.set(c, {
          index: 0,
          index2: 0
        });
        blockChunkGroups.set(b, c);
        allCreatedChunkGroups.add(c);
      }

      blockConnections.set(b, []);
    } else {
      // TODO webpack 5 remove addOptions check
      if (c.addOptions) c.addOptions(b.groupOptions);
      c.addOrigin(module, b.loc, b.request);
    } // 2. We store the connection for the block
    // to connect it later if needed


    blockConnections.get(b).push({
      originChunkGroupInfo: chunkGroupInfo,
      chunkGroup: c
    }); // 3. We create/update the chunk group info

    var connectList = queueConnect.get(chunkGroup);

    if (connectList === undefined) {
      connectList = new Set();
      queueConnect.set(chunkGroup, connectList);
    }

    connectList.add(c); // 4. We enqueue the DependenciesBlock for traversal

    queueDelayed.push({
      action: PROCESS_BLOCK,
      block: b,
      module: module,
      chunk: c.chunks[0],
      chunkGroup: c
    });
  }; // Iterative traversal of the Module graph
  // Recursive would be simpler to write but could result in Stack Overflows


  while (queue.length) {
    logger.time("visiting");

    while (queue.length) {
      var queueItem = queue.pop();
      module = queueItem.module;
      block = queueItem.block;
      chunk = queueItem.chunk;

      if (chunkGroup !== queueItem.chunkGroup) {
        chunkGroup = queueItem.chunkGroup;
        chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);
        minAvailableModules = chunkGroupInfo.minAvailableModules;
        skippedItems = chunkGroupInfo.skippedItems;
      }

      switch (queueItem.action) {
        case ADD_AND_ENTER_MODULE:
          {
            if (minAvailableModules.has(module)) {
              // already in parent chunks
              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks
              skippedItems.push(queueItem);
              break;
            } // We connect Module and Chunk when not already done


            if (chunk.addModule(module)) {
              module.addChunk(chunk);
            } else {
              // already connected, skip it
              break;
            }
          }
        // fallthrough

        case ENTER_MODULE:
          {
            if (chunkGroup !== undefined) {
              var index = chunkGroup.getModuleIndex(module);

              if (index === undefined) {
                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);
              }
            }

            if (module.index === null) {
              module.index = nextFreeModuleIndex++;
            }

            queue.push({
              action: LEAVE_MODULE,
              block: block,
              module: module,
              chunk: chunk,
              chunkGroup: chunkGroup
            });
          }
        // fallthrough

        case PROCESS_BLOCK:
          {
            // get prepared block info
            var blockInfo = blockInfoMap.get(block); // Buffer items because order need to be reverse to get indicies correct

            var skipBuffer = [];
            var queueBuffer = []; // Traverse all referenced modules

            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
              for (var _iterator8 = blockInfo.modules[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var refModule = _step8.value;

                if (chunk.containsModule(refModule)) {
                  // skip early if already connected
                  continue;
                }

                if (minAvailableModules.has(refModule)) {
                  // already in parent chunks, skip it for now
                  skipBuffer.push({
                    action: ADD_AND_ENTER_MODULE,
                    block: refModule,
                    module: refModule,
                    chunk: chunk,
                    chunkGroup: chunkGroup
                  });
                  continue;
                } // enqueue the add and enter to enter in the correct order
                // this is relevant with circular dependencies


                queueBuffer.push({
                  action: ADD_AND_ENTER_MODULE,
                  block: refModule,
                  module: refModule,
                  chunk: chunk,
                  chunkGroup: chunkGroup
                });
              } // Add buffered items in reversed order

            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                  _iterator8["return"]();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }

            for (var i = skipBuffer.length - 1; i >= 0; i--) {
              skippedItems.push(skipBuffer[i]);
            }

            for (var _i = queueBuffer.length - 1; _i >= 0; _i--) {
              queue.push(queueBuffer[_i]);
            } // Traverse all Blocks


            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
              for (var _iterator9 = blockInfo.blocks[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var _block = _step9.value;
                iteratorBlock(_block);
              }
            } catch (err) {
              _didIteratorError9 = true;
              _iteratorError9 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                  _iterator9["return"]();
                }
              } finally {
                if (_didIteratorError9) {
                  throw _iteratorError9;
                }
              }
            }

            if (blockInfo.blocks.length > 0 && module !== block) {
              blocksWithNestedBlocks.add(block);
            }

            break;
          }

        case LEAVE_MODULE:
          {
            if (chunkGroup !== undefined) {
              var _index = chunkGroup.getModuleIndex2(module);

              if (_index === undefined) {
                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);
              }
            }

            if (module.index2 === null) {
              module.index2 = nextFreeModuleIndex2++;
            }

            break;
          }
      }
    }

    logger.timeEnd("visiting");

    while (queueConnect.size > 0) {
      logger.time("calculating available modules"); // Figure out new parents for chunk groups
      // to get new available modules for these children

      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = queueConnect[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var _step10$value = _slicedToArray(_step10.value, 2),
              _chunkGroup2 = _step10$value[0],
              targets = _step10$value[1];

          var _info = chunkGroupInfoMap.get(_chunkGroup2);

          var _minAvailableModules = _info.minAvailableModules; // 1. Create a new Set of available modules at this points

          var resultingAvailableModules = new Set(_minAvailableModules);
          var _iteratorNormalCompletion17 = true;
          var _didIteratorError17 = false;
          var _iteratorError17 = undefined;

          try {
            for (var _iterator17 = _chunkGroup2.chunks[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
              var _chunk2 = _step17.value;
              var _iteratorNormalCompletion20 = true;
              var _didIteratorError20 = false;
              var _iteratorError20 = undefined;

              try {
                for (var _iterator20 = _chunk2.modulesIterable[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                  var _m2 = _step20.value;
                  resultingAvailableModules.add(_m2);
                }
              } catch (err) {
                _didIteratorError20 = true;
                _iteratorError20 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
                    _iterator20["return"]();
                  }
                } finally {
                  if (_didIteratorError20) {
                    throw _iteratorError20;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError17 = true;
            _iteratorError17 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
                _iterator17["return"]();
              }
            } finally {
              if (_didIteratorError17) {
                throw _iteratorError17;
              }
            }
          }

          _info.resultingAvailableModules = resultingAvailableModules;

          if (_info.children === undefined) {
            _info.children = targets;
          } else {
            var _iteratorNormalCompletion18 = true;
            var _didIteratorError18 = false;
            var _iteratorError18 = undefined;

            try {
              for (var _iterator18 = targets[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                var target = _step18.value;

                _info.children.add(target);
              }
            } catch (err) {
              _didIteratorError18 = true;
              _iteratorError18 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
                  _iterator18["return"]();
                }
              } finally {
                if (_didIteratorError18) {
                  throw _iteratorError18;
                }
              }
            }
          } // 2. Update chunk group info


          var _iteratorNormalCompletion19 = true;
          var _didIteratorError19 = false;
          var _iteratorError19 = undefined;

          try {
            for (var _iterator19 = targets[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
              var _target = _step19.value;

              var _chunkGroupInfo = chunkGroupInfoMap.get(_target);

              if (_chunkGroupInfo === undefined) {
                _chunkGroupInfo = {
                  chunkGroup: _target,
                  minAvailableModules: undefined,
                  minAvailableModulesOwned: undefined,
                  availableModulesToBeMerged: [],
                  skippedItems: [],
                  resultingAvailableModules: undefined,
                  children: undefined
                };
                chunkGroupInfoMap.set(_target, _chunkGroupInfo);
              }

              _chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);

              outdatedChunkGroupInfo.add(_chunkGroupInfo);
            }
          } catch (err) {
            _didIteratorError19 = true;
            _iteratorError19 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
                _iterator19["return"]();
              }
            } finally {
              if (_didIteratorError19) {
                throw _iteratorError19;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      queueConnect.clear();
      logger.timeEnd("calculating available modules");

      if (outdatedChunkGroupInfo.size > 0) {
        logger.time("merging available modules"); // Execute the merge

        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = outdatedChunkGroupInfo[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var info = _step11.value;
            var availableModulesToBeMerged = info.availableModulesToBeMerged;
            var cachedMinAvailableModules = info.minAvailableModules; // 1. Get minimal available modules
            // It doesn't make sense to traverse a chunk again with more available modules.
            // This step calculates the minimal available modules and skips traversal when
            // the list didn't shrink.

            if (availableModulesToBeMerged.length > 1) {
              availableModulesToBeMerged.sort(bySetSize);
            }

            var changed = false;
            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
              for (var _iterator12 = availableModulesToBeMerged[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var availableModules = _step12.value;

                if (cachedMinAvailableModules === undefined) {
                  cachedMinAvailableModules = availableModules;
                  info.minAvailableModules = cachedMinAvailableModules;
                  info.minAvailableModulesOwned = false;
                  changed = true;
                } else {
                  if (info.minAvailableModulesOwned) {
                    // We own it and can modify it
                    var _iteratorNormalCompletion15 = true;
                    var _didIteratorError15 = false;
                    var _iteratorError15 = undefined;

                    try {
                      for (var _iterator15 = cachedMinAvailableModules[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                        var m = _step15.value;

                        if (!availableModules.has(m)) {
                          cachedMinAvailableModules["delete"](m);
                          changed = true;
                        }
                      }
                    } catch (err) {
                      _didIteratorError15 = true;
                      _iteratorError15 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
                          _iterator15["return"]();
                        }
                      } finally {
                        if (_didIteratorError15) {
                          throw _iteratorError15;
                        }
                      }
                    }
                  } else {
                    var _iteratorNormalCompletion16 = true;
                    var _didIteratorError16 = false;
                    var _iteratorError16 = undefined;

                    try {
                      for (var _iterator16 = cachedMinAvailableModules[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                        var _m = _step16.value;

                        if (!availableModules.has(_m)) {
                          // cachedMinAvailableModules need to be modified
                          // but we don't own it
                          // construct a new Set as intersection of cachedMinAvailableModules and availableModules

                          /** @type {Set<Module>} */
                          var newSet = new Set();
                          var iterator = cachedMinAvailableModules[Symbol.iterator]();
                          /** @type {IteratorResult<Module>} */

                          var it = void 0;

                          while (!(it = iterator.next()).done) {
                            var _module3 = it.value;
                            if (_module3 === _m) break;
                            newSet.add(_module3);
                          }

                          while (!(it = iterator.next()).done) {
                            var _module4 = it.value;

                            if (availableModules.has(_module4)) {
                              newSet.add(_module4);
                            }
                          }

                          cachedMinAvailableModules = newSet;
                          info.minAvailableModulesOwned = true;
                          info.minAvailableModules = newSet; // Update the cache from the first queue
                          // if the chunkGroup is currently cached

                          if (chunkGroup === info.chunkGroup) {
                            minAvailableModules = cachedMinAvailableModules;
                          }

                          changed = true;
                          break;
                        }
                      }
                    } catch (err) {
                      _didIteratorError16 = true;
                      _iteratorError16 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
                          _iterator16["return"]();
                        }
                      } finally {
                        if (_didIteratorError16) {
                          throw _iteratorError16;
                        }
                      }
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
                  _iterator12["return"]();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }

            availableModulesToBeMerged.length = 0;
            if (!changed) continue; // 2. Reconsider skipped items

            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
              for (var _iterator13 = info.skippedItems[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                var _queueItem = _step13.value;
                queue.push(_queueItem);
              }
            } catch (err) {
              _didIteratorError13 = true;
              _iteratorError13 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                  _iterator13["return"]();
                }
              } finally {
                if (_didIteratorError13) {
                  throw _iteratorError13;
                }
              }
            }

            info.skippedItems.length = 0; // 3. Reconsider children chunk groups

            if (info.children !== undefined) {
              var _chunkGroup = info.chunkGroup;
              var _iteratorNormalCompletion14 = true;
              var _didIteratorError14 = false;
              var _iteratorError14 = undefined;

              try {
                for (var _iterator14 = info.children[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                  var c = _step14.value;
                  var connectList = queueConnect.get(_chunkGroup);

                  if (connectList === undefined) {
                    connectList = new Set();
                    queueConnect.set(_chunkGroup, connectList);
                  }

                  connectList.add(c);
                }
              } catch (err) {
                _didIteratorError14 = true;
                _iteratorError14 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                    _iterator14["return"]();
                  }
                } finally {
                  if (_didIteratorError14) {
                    throw _iteratorError14;
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
              _iterator11["return"]();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }

        outdatedChunkGroupInfo.clear();
        logger.timeEnd("merging available modules");
      }
    } // Run queueDelayed when all items of the queue are processed
    // This is important to get the global indicing correct
    // Async blocks should be processed after all sync blocks are processed


    if (queue.length === 0) {
      var tempQueue = queue;
      queue = queueDelayed.reverse();
      queueDelayed = tempQueue;
    }
  }
};
/**
 *
 * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks
 * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks
 * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules
 */


var connectChunkGroups = function connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) {
  /**
   * Helper function to check if all modules of a chunk are available
   *
   * @param {ChunkGroup} chunkGroup the chunkGroup to scan
   * @param {Set<Module>} availableModules the comparitor set
   * @returns {boolean} return true if all modules of a chunk are available
   */
  var areModulesAvailable = function areModulesAvailable(chunkGroup, availableModules) {
    var _iteratorNormalCompletion21 = true;
    var _didIteratorError21 = false;
    var _iteratorError21 = undefined;

    try {
      for (var _iterator21 = chunkGroup.chunks[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
        var chunk = _step21.value;
        var _iteratorNormalCompletion22 = true;
        var _didIteratorError22 = false;
        var _iteratorError22 = undefined;

        try {
          for (var _iterator22 = chunk.modulesIterable[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
            var _module5 = _step22.value;
            if (!availableModules.has(_module5)) return false;
          }
        } catch (err) {
          _didIteratorError22 = true;
          _iteratorError22 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
              _iterator22["return"]();
            }
          } finally {
            if (_didIteratorError22) {
              throw _iteratorError22;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError21 = true;
      _iteratorError21 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
          _iterator21["return"]();
        }
      } finally {
        if (_didIteratorError21) {
          throw _iteratorError21;
        }
      }
    }

    return true;
  }; // For each edge in the basic chunk graph


  var _iteratorNormalCompletion23 = true;
  var _didIteratorError23 = false;
  var _iteratorError23 = undefined;

  try {
    for (var _iterator23 = blockConnections[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
      var _step23$value = _slicedToArray(_step23.value, 2),
          block = _step23$value[0],
          connections = _step23$value[1];

      // 1. Check if connection is needed
      // When none of the dependencies need to be connected
      // we can skip all of them
      // It's not possible to filter each item so it doesn't create inconsistent
      // connections and modules can only create one version
      // TODO maybe decide this per runtime
      if ( // TODO is this needed?
      !blocksWithNestedBlocks.has(block) && connections.every(function (_ref) {
        var chunkGroup = _ref.chunkGroup,
            originChunkGroupInfo = _ref.originChunkGroupInfo;
        return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);
      })) {
        continue;
      } // 2. Foreach edge


      for (var i = 0; i < connections.length; i++) {
        var _connections$i = connections[i],
            chunkGroup = _connections$i.chunkGroup,
            originChunkGroupInfo = _connections$i.originChunkGroupInfo; // 3. Connect block with chunk

        GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup); // 4. Connect chunk with parent

        GraphHelpers.connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);
      }
    }
  } catch (err) {
    _didIteratorError23 = true;
    _iteratorError23 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
        _iterator23["return"]();
      }
    } finally {
      if (_didIteratorError23) {
        throw _iteratorError23;
      }
    }
  }
};
/**
 * Remove all unconnected chunk groups
 * @param {Compilation} compilation the compilation
 * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before
 */


var cleanupUnconnectedGroups = function cleanupUnconnectedGroups(compilation, allCreatedChunkGroups) {
  var _iteratorNormalCompletion24 = true;
  var _didIteratorError24 = false;
  var _iteratorError24 = undefined;

  try {
    for (var _iterator24 = allCreatedChunkGroups[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
      var chunkGroup = _step24.value;

      if (chunkGroup.getNumberOfParents() === 0) {
        var _iteratorNormalCompletion25 = true;
        var _didIteratorError25 = false;
        var _iteratorError25 = undefined;

        try {
          for (var _iterator25 = chunkGroup.chunks[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
            var chunk = _step25.value;
            var idx = compilation.chunks.indexOf(chunk);
            if (idx >= 0) compilation.chunks.splice(idx, 1);
            chunk.remove("unconnected");
          }
        } catch (err) {
          _didIteratorError25 = true;
          _iteratorError25 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
              _iterator25["return"]();
            }
          } finally {
            if (_didIteratorError25) {
              throw _iteratorError25;
            }
          }
        }

        chunkGroup.remove("unconnected");
      }
    }
  } catch (err) {
    _didIteratorError24 = true;
    _iteratorError24 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
        _iterator24["return"]();
      }
    } finally {
      if (_didIteratorError24) {
        throw _iteratorError24;
      }
    }
  }
};
/**
 * This method creates the Chunk graph from the Module graph
 * @param {Compilation} compilation the compilation
 * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed
 * @returns {void}
 */


var buildChunkGraph = function buildChunkGraph(compilation, inputChunkGroups) {
  // SHARED STATE

  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */
  var blockConnections = new Map();
  /** @type {Set<ChunkGroup>} */

  var allCreatedChunkGroups = new Set();
  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */

  var chunkGroupInfoMap = new Map();
  /** @type {Set<DependenciesBlock>} */

  var blocksWithNestedBlocks = new Set(); // PART ONE

  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups); // PART TWO

  connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap); // Cleaup work

  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);
};

module.exports = buildChunkGraph;