/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ConstDependency = require("./dependencies/ConstDependency");

var NullFactory = require("./NullFactory");
/** @typedef {import("./Compiler")} Compiler */


var CompatibilityPlugin =
/*#__PURE__*/
function () {
  function CompatibilityPlugin() {
    _classCallCheck(this, CompatibilityPlugin);
  }

  _createClass(CompatibilityPlugin, [{
    key: "apply",

    /**
     * Apply the plugin
     * @param {Compiler} compiler Webpack Compiler
     * @returns {void}
     */
    value: function apply(compiler) {
      compiler.hooks.compilation.tap("CompatibilityPlugin", function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;
        compilation.dependencyFactories.set(ConstDependency, new NullFactory());
        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("CompatibilityPlugin", function (parser, parserOptions) {
          if (parserOptions.browserify !== undefined && !parserOptions.browserify) return;
          parser.hooks.call["for"]("require").tap("CompatibilityPlugin", function (expr) {
            // support for browserify style require delegator: "require(o, !0)"
            if (expr.arguments.length !== 2) return;
            var second = parser.evaluateExpression(expr.arguments[1]);
            if (!second.isBoolean()) return;
            if (second.asBool() !== true) return;
            var dep = new ConstDependency("require", expr.callee.range);
            dep.loc = expr.loc;

            if (parser.state.current.dependencies.length > 1) {
              var last = parser.state.current.dependencies[parser.state.current.dependencies.length - 1];
              if (last.critical && last.options && last.options.request === "." && last.userRequest === "." && last.options.recursive) parser.state.current.dependencies.pop();
            }

            parser.state.current.addDependency(dep);
            return true;
          });
        });
      });
    }
  }]);

  return CompatibilityPlugin;
}();

module.exports = CompatibilityPlugin;