/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SortableSet = require("./util/SortableSet");

var compareLocations = require("./compareLocations");
/** @typedef {import("./Chunk")} Chunk */

/** @typedef {import("./Module")} Module */

/** @typedef {import("./ModuleReason")} ModuleReason */

/** @typedef {{module: Module, loc: TODO, request: string}} OriginRecord */

/** @typedef {string|{name: string}} ChunkGroupOptions */


var debugId = 5000;
/**
 * @template T
 * @param {SortableSet<T>} set set to convert to array.
 * @returns {T[]} the array format of existing set
 */

var getArray = function getArray(set) {
  return Array.from(set);
};
/**
 * A convenience method used to sort chunks based on their id's
 * @param {ChunkGroup} a first sorting comparator
 * @param {ChunkGroup} b second sorting comparator
 * @returns {1|0|-1} a sorting index to determine order
 */


var sortById = function sortById(a, b) {
  if (a.id < b.id) return -1;
  if (b.id < a.id) return 1;
  return 0;
};
/**
 * @param {OriginRecord} a the first comparator in sort
 * @param {OriginRecord} b the second comparator in sort
 * @returns {1|-1|0} returns sorting order as index
 */


var sortOrigin = function sortOrigin(a, b) {
  var aIdent = a.module ? a.module.identifier() : "";
  var bIdent = b.module ? b.module.identifier() : "";
  if (aIdent < bIdent) return -1;
  if (aIdent > bIdent) return 1;
  return compareLocations(a.loc, b.loc);
};

var ChunkGroup =
/*#__PURE__*/
function () {
  /**
   * Creates an instance of ChunkGroup.
   * @param {ChunkGroupOptions=} options chunk group options passed to chunkGroup
   */
  function ChunkGroup(options) {
    _classCallCheck(this, ChunkGroup);

    if (typeof options === "string") {
      options = {
        name: options
      };
    } else if (!options) {
      options = {
        name: undefined
      };
    }
    /** @type {number} */


    this.groupDebugId = debugId++;
    this.options = options;
    /** @type {SortableSet<ChunkGroup>} */

    this._children = new SortableSet(undefined, sortById);
    this._parents = new SortableSet(undefined, sortById);
    this._blocks = new SortableSet();
    /** @type {Chunk[]} */

    this.chunks = [];
    /** @type {OriginRecord[]} */

    this.origins = [];
    /** Indices in top-down order */

    /** @private @type {Map<Module, number>} */

    this._moduleIndices = new Map();
    /** Indices in bottom-up order */

    /** @private @type {Map<Module, number>} */

    this._moduleIndices2 = new Map();
  }
  /**
   * when a new chunk is added to a chunkGroup, addingOptions will occur.
   * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions
   * @returns {void}
   */


  _createClass(ChunkGroup, [{
    key: "addOptions",
    value: function addOptions(options) {
      for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];

        if (this.options[key] === undefined) {
          this.options[key] = options[key];
        } else if (this.options[key] !== options[key]) {
          if (key.endsWith("Order")) {
            this.options[key] = Math.max(this.options[key], options[key]);
          } else {
            throw new Error("ChunkGroup.addOptions: No option merge strategy for ".concat(key));
          }
        }
      }
    }
    /**
     * returns the name of current ChunkGroup
     * @returns {string|undefined} returns the ChunkGroup name
     */

  }, {
    key: "unshiftChunk",

    /**
     * Performs an unshift of a specific chunk
     * @param {Chunk} chunk chunk being unshifted
     * @returns {boolean} returns true if attempted chunk shift is accepted
     */
    value: function unshiftChunk(chunk) {
      var oldIdx = this.chunks.indexOf(chunk);

      if (oldIdx > 0) {
        this.chunks.splice(oldIdx, 1);
        this.chunks.unshift(chunk);
      } else if (oldIdx < 0) {
        this.chunks.unshift(chunk);
        return true;
      }

      return false;
    }
    /**
     * inserts a chunk before another existing chunk in group
     * @param {Chunk} chunk Chunk being inserted
     * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point
     * @returns {boolean} return true if insertion was successful
     */

  }, {
    key: "insertChunk",
    value: function insertChunk(chunk, before) {
      var oldIdx = this.chunks.indexOf(chunk);
      var idx = this.chunks.indexOf(before);

      if (idx < 0) {
        throw new Error("before chunk not found");
      }

      if (oldIdx >= 0 && oldIdx > idx) {
        this.chunks.splice(oldIdx, 1);
        this.chunks.splice(idx, 0, chunk);
      } else if (oldIdx < 0) {
        this.chunks.splice(idx, 0, chunk);
        return true;
      }

      return false;
    }
    /**
     * add a chunk into ChunkGroup. Is pushed on or prepended
     * @param {Chunk} chunk chunk being pushed into ChunkGroupS
     * @returns {boolean} returns true if chunk addition was successful.
     */

  }, {
    key: "pushChunk",
    value: function pushChunk(chunk) {
      var oldIdx = this.chunks.indexOf(chunk);

      if (oldIdx >= 0) {
        return false;
      }

      this.chunks.push(chunk);
      return true;
    }
    /**
     * @param {Chunk} oldChunk chunk to be replaced
     * @param {Chunk} newChunk New chunk that will be replaced with
     * @returns {boolean} returns true if the replacement was successful
     */

  }, {
    key: "replaceChunk",
    value: function replaceChunk(oldChunk, newChunk) {
      var oldIdx = this.chunks.indexOf(oldChunk);
      if (oldIdx < 0) return false;
      var newIdx = this.chunks.indexOf(newChunk);

      if (newIdx < 0) {
        this.chunks[oldIdx] = newChunk;
        return true;
      }

      if (newIdx < oldIdx) {
        this.chunks.splice(oldIdx, 1);
        return true;
      } else if (newIdx !== oldIdx) {
        this.chunks[oldIdx] = newChunk;
        this.chunks.splice(newIdx, 1);
        return true;
      }
    }
  }, {
    key: "removeChunk",
    value: function removeChunk(chunk) {
      var idx = this.chunks.indexOf(chunk);

      if (idx >= 0) {
        this.chunks.splice(idx, 1);
        return true;
      }

      return false;
    }
  }, {
    key: "isInitial",
    value: function isInitial() {
      return false;
    }
  }, {
    key: "addChild",
    value: function addChild(chunk) {
      if (this._children.has(chunk)) {
        return false;
      }

      this._children.add(chunk);

      return true;
    }
  }, {
    key: "getChildren",
    value: function getChildren() {
      return this._children.getFromCache(getArray);
    }
  }, {
    key: "getNumberOfChildren",
    value: function getNumberOfChildren() {
      return this._children.size;
    }
  }, {
    key: "removeChild",
    value: function removeChild(chunk) {
      if (!this._children.has(chunk)) {
        return false;
      }

      this._children["delete"](chunk);

      chunk.removeParent(this);
      return true;
    }
  }, {
    key: "addParent",
    value: function addParent(parentChunk) {
      if (!this._parents.has(parentChunk)) {
        this._parents.add(parentChunk);

        return true;
      }

      return false;
    }
  }, {
    key: "getParents",
    value: function getParents() {
      return this._parents.getFromCache(getArray);
    }
  }, {
    key: "setParents",
    value: function setParents(newParents) {
      this._parents.clear();

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newParents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var p = _step.value;

          this._parents.add(p);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "getNumberOfParents",
    value: function getNumberOfParents() {
      return this._parents.size;
    }
  }, {
    key: "hasParent",
    value: function hasParent(parent) {
      return this._parents.has(parent);
    }
  }, {
    key: "removeParent",
    value: function removeParent(chunk) {
      if (this._parents["delete"](chunk)) {
        chunk.removeChunk(this);
        return true;
      }

      return false;
    }
    /**
     * @returns {Array} - an array containing the blocks
     */

  }, {
    key: "getBlocks",
    value: function getBlocks() {
      return this._blocks.getFromCache(getArray);
    }
  }, {
    key: "getNumberOfBlocks",
    value: function getNumberOfBlocks() {
      return this._blocks.size;
    }
  }, {
    key: "hasBlock",
    value: function hasBlock(block) {
      return this._blocks.has(block);
    }
  }, {
    key: "addBlock",
    value: function addBlock(block) {
      if (!this._blocks.has(block)) {
        this._blocks.add(block);

        return true;
      }

      return false;
    }
  }, {
    key: "addOrigin",
    value: function addOrigin(module, loc, request) {
      this.origins.push({
        module: module,
        loc: loc,
        request: request
      });
    }
  }, {
    key: "containsModule",
    value: function containsModule(module) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.chunks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var chunk = _step2.value;
          if (chunk.containsModule(module)) return true;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return false;
    }
  }, {
    key: "getFiles",
    value: function getFiles() {
      var files = new Set();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.chunks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var chunk = _step3.value;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = chunk.files[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var file = _step4.value;
              files.add(file);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return Array.from(files);
    }
    /**
     * @param {string=} reason reason for removing ChunkGroup
     * @returns {void}
     */

  }, {
    key: "remove",
    value: function remove(reason) {
      // cleanup parents
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._parents[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var parentChunkGroup = _step5.value;

          // remove this chunk from its parents
          parentChunkGroup._children["delete"](this); // cleanup "sub chunks"


          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = this._children[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var chunkGroup = _step9.value;

              /**
               * remove this chunk as "intermediary" and connect
               * it "sub chunks" and parents directly
               */
              // add parent to each "sub chunk"
              chunkGroup.addParent(parentChunkGroup); // add "sub chunk" to parent

              parentChunkGroup.addChild(chunkGroup);
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                _iterator9["return"]();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }
        }
        /**
         * we need to iterate again over the children
         * to remove this from the child's parents.
         * This can not be done in the above loop
         * as it is not guaranteed that `this._parents` contains anything.
         */

      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this._children[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _chunkGroup = _step6.value;

          // remove this as parent of every "sub chunk"
          _chunkGroup._parents["delete"](this);
        } // cleanup blocks

      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this._blocks[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var block = _step7.value;
          block.chunkGroup = null;
        } // remove chunks

      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.chunks[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var chunk = _step8.value;
          chunk.removeGroup(this);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
  }, {
    key: "sortItems",
    value: function sortItems() {
      this.origins.sort(sortOrigin);

      this._parents.sort();

      this._children.sort();
    }
    /**
     * Sorting predicate which allows current ChunkGroup to be compared against another.
     * Sorting values are based off of number of chunks in ChunkGroup.
     *
     * @param {ChunkGroup} otherGroup the chunkGroup to compare this against
     * @returns {-1|0|1} sort position for comparison
     */

  }, {
    key: "compareTo",
    value: function compareTo(otherGroup) {
      if (this.chunks.length > otherGroup.chunks.length) return -1;
      if (this.chunks.length < otherGroup.chunks.length) return 1;
      var a = this.chunks[Symbol.iterator]();
      var b = otherGroup.chunks[Symbol.iterator](); // eslint-disable-next-line no-constant-condition

      while (true) {
        var aItem = a.next();
        var bItem = b.next();
        if (aItem.done) return 0;
        var cmp = aItem.value.compareTo(bItem.value);
        if (cmp !== 0) return cmp;
      }
    }
  }, {
    key: "getChildrenByOrders",
    value: function getChildrenByOrders() {
      var lists = new Map();
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = this._children[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var childGroup = _step10.value;

          // TODO webpack 5 remove this check for options
          if (_typeof(childGroup.options) === "object") {
            for (var _i2 = 0, _Object$keys2 = Object.keys(childGroup.options); _i2 < _Object$keys2.length; _i2++) {
              var key = _Object$keys2[_i2];

              if (key.endsWith("Order")) {
                var name = key.substr(0, key.length - "Order".length);
                var list = lists.get(name);

                if (list === undefined) {
                  lists.set(name, list = []);
                }

                list.push({
                  order: childGroup.options[key],
                  group: childGroup
                });
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      var result = Object.create(null);
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = lists[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var _step11$value = _slicedToArray(_step11.value, 2),
              _name = _step11$value[0],
              _list = _step11$value[1];

          _list.sort(function (a, b) {
            var cmp = b.order - a.order;
            if (cmp !== 0) return cmp; // TODO webpack 5 remove this check of compareTo

            if (a.group.compareTo) {
              return a.group.compareTo(b.group);
            }

            return 0;
          });

          result[_name] = _list.map(function (i) {
            return i.group;
          });
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      return result;
    }
    /**
     * Sets the top-down index of a module in this ChunkGroup
     * @param {Module} module module for which the index should be set
     * @param {number} index the index of the module
     * @returns {void}
     */

  }, {
    key: "setModuleIndex",
    value: function setModuleIndex(module, index) {
      this._moduleIndices.set(module, index);
    }
    /**
     * Gets the top-down index of a module in this ChunkGroup
     * @param {Module} module the module
     * @returns {number} index
     */

  }, {
    key: "getModuleIndex",
    value: function getModuleIndex(module) {
      return this._moduleIndices.get(module);
    }
    /**
     * Sets the bottom-up index of a module in this ChunkGroup
     * @param {Module} module module for which the index should be set
     * @param {number} index the index of the module
     * @returns {void}
     */

  }, {
    key: "setModuleIndex2",
    value: function setModuleIndex2(module, index) {
      this._moduleIndices2.set(module, index);
    }
    /**
     * Gets the bottom-up index of a module in this ChunkGroup
     * @param {Module} module the module
     * @returns {number} index
     */

  }, {
    key: "getModuleIndex2",
    value: function getModuleIndex2(module) {
      return this._moduleIndices2.get(module);
    }
  }, {
    key: "checkConstraints",
    value: function checkConstraints() {
      var chunk = this;
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = chunk._children[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var child = _step12.value;

          if (!child._parents.has(chunk)) {
            throw new Error("checkConstraints: child missing parent ".concat(chunk.debugId, " -> ").concat(child.debugId));
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
            _iterator12["return"]();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = chunk._parents[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var parentChunk = _step13.value;

          if (!parentChunk._children.has(chunk)) {
            throw new Error("checkConstraints: parent missing child ".concat(parentChunk.debugId, " <- ").concat(chunk.debugId));
          }
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
            _iterator13["return"]();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }
    }
  }, {
    key: "name",
    get: function get() {
      return this.options.name;
    }
    /**
     * sets a new name for current ChunkGroup
     * @param {string} value the new name for ChunkGroup
     * @returns {void}
     */
    ,
    set: function set(value) {
      this.options.name = value;
    }
    /**
     * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's
     * @returns {string} a unique concatenation of chunk debugId's
     */

  }, {
    key: "debugId",
    get: function get() {
      return Array.from(this.chunks, function (x) {
        return x.debugId;
      }).join("+");
    }
    /**
     * get a unique id for ChunkGroup, made up of its member Chunk id's
     * @returns {string} a unique concatenation of chunk ids
     */

  }, {
    key: "id",
    get: function get() {
      return Array.from(this.chunks, function (x) {
        return x.id;
      }).join("+");
    }
  }, {
    key: "childrenIterable",
    get: function get() {
      return this._children;
    }
  }, {
    key: "parentsIterable",
    get: function get() {
      return this._parents;
    }
  }, {
    key: "blocksIterable",
    get: function get() {
      return this._blocks;
    }
  }]);

  return ChunkGroup;
}();

module.exports = ChunkGroup;