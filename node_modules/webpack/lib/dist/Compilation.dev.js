/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
	*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var asyncLib = require("neo-async");

var util = require("util");

var _require = require("webpack-sources"),
    CachedSource = _require.CachedSource;

var _require2 = require("tapable"),
    Tapable = _require2.Tapable,
    SyncHook = _require2.SyncHook,
    SyncBailHook = _require2.SyncBailHook,
    SyncWaterfallHook = _require2.SyncWaterfallHook,
    AsyncSeriesHook = _require2.AsyncSeriesHook;

var EntryModuleNotFoundError = require("./EntryModuleNotFoundError");

var ModuleNotFoundError = require("./ModuleNotFoundError");

var ModuleDependencyWarning = require("./ModuleDependencyWarning");

var ModuleDependencyError = require("./ModuleDependencyError");

var ChunkGroup = require("./ChunkGroup");

var Chunk = require("./Chunk");

var Entrypoint = require("./Entrypoint");

var MainTemplate = require("./MainTemplate");

var ChunkTemplate = require("./ChunkTemplate");

var HotUpdateChunkTemplate = require("./HotUpdateChunkTemplate");

var ModuleTemplate = require("./ModuleTemplate");

var RuntimeTemplate = require("./RuntimeTemplate");

var ChunkRenderError = require("./ChunkRenderError");

var Stats = require("./Stats");

var Semaphore = require("./util/Semaphore");

var _createHash = require("./util/createHash");

var SortableSet = require("./util/SortableSet");

var GraphHelpers = require("./GraphHelpers");

var ModuleDependency = require("./dependencies/ModuleDependency");

var compareLocations = require("./compareLocations");

var _require3 = require("./logging/Logger"),
    Logger = _require3.Logger,
    LogType = _require3.LogType;

var ErrorHelpers = require("./ErrorHelpers");

var buildChunkGraph = require("./buildChunkGraph");

var WebpackError = require("./WebpackError");
/** @typedef {import("./Module")} Module */

/** @typedef {import("./Compiler")} Compiler */

/** @typedef {import("webpack-sources").Source} Source */

/** @typedef {import("./DependenciesBlockVariable")} DependenciesBlockVariable */

/** @typedef {import("./dependencies/SingleEntryDependency")} SingleEntryDependency */

/** @typedef {import("./dependencies/MultiEntryDependency")} MultiEntryDependency */

/** @typedef {import("./dependencies/DllEntryDependency")} DllEntryDependency */

/** @typedef {import("./dependencies/DependencyReference")} DependencyReference */

/** @typedef {import("./DependenciesBlock")} DependenciesBlock */

/** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */

/** @typedef {import("./Dependency")} Dependency */

/** @typedef {import("./Dependency").DependencyLocation} DependencyLocation */

/** @typedef {import("./Dependency").DependencyTemplate} DependencyTemplate */

/** @typedef {import("./util/createHash").Hash} Hash */
// TODO use @callback

/** @typedef {{[assetName: string]: Source}} CompilationAssets */

/** @typedef {(err: Error|null, result?: Module) => void } ModuleCallback */

/** @typedef {(err?: Error|null, result?: Module) => void } ModuleChainCallback */

/** @typedef {(module: Module) => void} OnModuleCallback */

/** @typedef {(err?: Error|null) => void} Callback */

/** @typedef {(d: Dependency) => any} DepBlockVarDependenciesCallback */

/** @typedef {new (...args: any[]) => Dependency} DepConstructor */

/** @typedef {{apply: () => void}} Plugin */

/**
 * @typedef {Object} ModuleFactoryCreateDataContextInfo
 * @property {string} issuer
 * @property {string} compiler
 */

/**
 * @typedef {Object} ModuleFactoryCreateData
 * @property {ModuleFactoryCreateDataContextInfo} contextInfo
 * @property {any=} resolveOptions
 * @property {string} context
 * @property {Dependency[]} dependencies
 */

/**
 * @typedef {Object} ModuleFactory
 * @property {(data: ModuleFactoryCreateData, callback: ModuleCallback) => any} create
 */

/**
 * @typedef {Object} SortedDependency
 * @property {ModuleFactory} factory
 * @property {Dependency[]} dependencies
 */

/**
 * @typedef {Object} DependenciesBlockLike
 * @property {Dependency[]} dependencies
 * @property {AsyncDependenciesBlock[]} blocks
 * @property {DependenciesBlockVariable[]} variables
 */

/**
 * @typedef {Object} LogEntry
 * @property {string} type
 * @property {any[]} args
 * @property {number} time
 * @property {string[]=} trace
 */

/**
 * @typedef {Object} AssetInfo
 * @property {boolean=} immutable true, if the asset can be long term cached forever (contains a hash)
 * @property {number=} size size in bytes, only set after asset has been emitted
 * @property {boolean=} development true, when asset is only used for development and doesn't count towards user-facing assets
 * @property {boolean=} hotModuleReplacement true, when asset ships data for updating an existing application (HMR)
 */

/**
 * @typedef {Object} Asset
 * @property {string} name the filename of the asset
 * @property {Source} source source of the asset
 * @property {AssetInfo} info info about the asset
 */

/**
 * @param {Chunk} a first chunk to sort by id
 * @param {Chunk} b second chunk to sort by id
 * @returns {-1|0|1} sort value
 */


var byId = function byId(a, b) {
  if (_typeof(a.id) !== _typeof(b.id)) {
    return _typeof(a.id) < _typeof(b.id) ? -1 : 1;
  }

  if (a.id < b.id) return -1;
  if (a.id > b.id) return 1;
  return 0;
};
/**
 * @param {Module} a first module to sort by
 * @param {Module} b second module to sort by
 * @returns {-1|0|1} sort value
 */


var byIdOrIdentifier = function byIdOrIdentifier(a, b) {
  if (_typeof(a.id) !== _typeof(b.id)) {
    return _typeof(a.id) < _typeof(b.id) ? -1 : 1;
  }

  if (a.id < b.id) return -1;
  if (a.id > b.id) return 1;
  var identA = a.identifier();
  var identB = b.identifier();
  if (identA < identB) return -1;
  if (identA > identB) return 1;
  return 0;
};
/**
 * @param {Module} a first module to sort by
 * @param {Module} b second module to sort by
 * @returns {-1|0|1} sort value
 */


var byIndexOrIdentifier = function byIndexOrIdentifier(a, b) {
  if (a.index < b.index) return -1;
  if (a.index > b.index) return 1;
  var identA = a.identifier();
  var identB = b.identifier();
  if (identA < identB) return -1;
  if (identA > identB) return 1;
  return 0;
};
/**
 * @param {Compilation} a first compilation to sort by
 * @param {Compilation} b second compilation to sort by
 * @returns {-1|0|1} sort value
 */


var byNameOrHash = function byNameOrHash(a, b) {
  if (a.name < b.name) return -1;
  if (a.name > b.name) return 1;
  if (a.fullHash < b.fullHash) return -1;
  if (a.fullHash > b.fullHash) return 1;
  return 0;
};
/**
 * @param {DependenciesBlockVariable[]} variables DepBlock Variables to iterate over
 * @param {DepBlockVarDependenciesCallback} fn callback to apply on iterated elements
 * @returns {void}
 */


var iterationBlockVariable = function iterationBlockVariable(variables, fn) {
  for (var indexVariable = 0; indexVariable < variables.length; indexVariable++) {
    var varDep = variables[indexVariable].dependencies;

    for (var indexVDep = 0; indexVDep < varDep.length; indexVDep++) {
      fn(varDep[indexVDep]);
    }
  }
};
/**
 * @template T
 * @param {T[]} arr array of elements to iterate over
 * @param {function(T): void} fn callback applied to each element
 * @returns {void}
 */


var iterationOfArrayCallback = function iterationOfArrayCallback(arr, fn) {
  for (var index = 0; index < arr.length; index++) {
    fn(arr[index]);
  }
};
/**
 * @template T
 * @param {Set<T>} set set to add items to
 * @param {Set<T>} otherSet set to add items from
 * @returns {void}
 */


var addAllToSet = function addAllToSet(set, otherSet) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = otherSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;
      set.add(item);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};
/**
 * @param {Source} a a source
 * @param {Source} b another source
 * @returns {boolean} true, when both sources are equal
 */


var isSourceEqual = function isSourceEqual(a, b) {
  if (a === b) return true; // TODO webpack 5: check .buffer() instead, it's called anyway during emit

  /** @type {Buffer|string} */

  var aSource = a.source();
  /** @type {Buffer|string} */

  var bSource = b.source();
  if (aSource === bSource) return true;
  if (typeof aSource === "string" && typeof bSource === "string") return false;
  if (!Buffer.isBuffer(aSource)) aSource = Buffer.from(aSource, "utf-8");
  if (!Buffer.isBuffer(bSource)) bSource = Buffer.from(bSource, "utf-8");
  return aSource.equals(bSource);
};

var Compilation =
/*#__PURE__*/
function (_Tapable) {
  _inherits(Compilation, _Tapable);

  /**
   * Creates an instance of Compilation.
   * @param {Compiler} compiler the compiler which created the compilation
   */
  function Compilation(compiler) {
    var _this;

    _classCallCheck(this, Compilation);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Compilation).call(this));
    _this.hooks = {
      /** @type {SyncHook<Module>} */
      buildModule: new SyncHook(["module"]),

      /** @type {SyncHook<Module>} */
      rebuildModule: new SyncHook(["module"]),

      /** @type {SyncHook<Module, Error>} */
      failedModule: new SyncHook(["module", "error"]),

      /** @type {SyncHook<Module>} */
      succeedModule: new SyncHook(["module"]),

      /** @type {SyncHook<Dependency, string>} */
      addEntry: new SyncHook(["entry", "name"]),

      /** @type {SyncHook<Dependency, string, Error>} */
      failedEntry: new SyncHook(["entry", "name", "error"]),

      /** @type {SyncHook<Dependency, string, Module>} */
      succeedEntry: new SyncHook(["entry", "name", "module"]),

      /** @type {SyncWaterfallHook<DependencyReference, Dependency, Module>} */
      dependencyReference: new SyncWaterfallHook(["dependencyReference", "dependency", "module"]),

      /** @type {AsyncSeriesHook<Module[]>} */
      finishModules: new AsyncSeriesHook(["modules"]),

      /** @type {SyncHook<Module>} */
      finishRebuildingModule: new SyncHook(["module"]),

      /** @type {SyncHook} */
      unseal: new SyncHook([]),

      /** @type {SyncHook} */
      seal: new SyncHook([]),

      /** @type {SyncHook} */
      beforeChunks: new SyncHook([]),

      /** @type {SyncHook<Chunk[]>} */
      afterChunks: new SyncHook(["chunks"]),

      /** @type {SyncBailHook<Module[]>} */
      optimizeDependenciesBasic: new SyncBailHook(["modules"]),

      /** @type {SyncBailHook<Module[]>} */
      optimizeDependencies: new SyncBailHook(["modules"]),

      /** @type {SyncBailHook<Module[]>} */
      optimizeDependenciesAdvanced: new SyncBailHook(["modules"]),

      /** @type {SyncBailHook<Module[]>} */
      afterOptimizeDependencies: new SyncHook(["modules"]),

      /** @type {SyncHook} */
      optimize: new SyncHook([]),

      /** @type {SyncBailHook<Module[]>} */
      optimizeModulesBasic: new SyncBailHook(["modules"]),

      /** @type {SyncBailHook<Module[]>} */
      optimizeModules: new SyncBailHook(["modules"]),

      /** @type {SyncBailHook<Module[]>} */
      optimizeModulesAdvanced: new SyncBailHook(["modules"]),

      /** @type {SyncHook<Module[]>} */
      afterOptimizeModules: new SyncHook(["modules"]),

      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */
      optimizeChunksBasic: new SyncBailHook(["chunks", "chunkGroups"]),

      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */
      optimizeChunks: new SyncBailHook(["chunks", "chunkGroups"]),

      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */
      optimizeChunksAdvanced: new SyncBailHook(["chunks", "chunkGroups"]),

      /** @type {SyncHook<Chunk[], ChunkGroup[]>} */
      afterOptimizeChunks: new SyncHook(["chunks", "chunkGroups"]),

      /** @type {AsyncSeriesHook<Chunk[], Module[]>} */
      optimizeTree: new AsyncSeriesHook(["chunks", "modules"]),

      /** @type {SyncHook<Chunk[], Module[]>} */
      afterOptimizeTree: new SyncHook(["chunks", "modules"]),

      /** @type {SyncBailHook<Chunk[], Module[]>} */
      optimizeChunkModulesBasic: new SyncBailHook(["chunks", "modules"]),

      /** @type {SyncBailHook<Chunk[], Module[]>} */
      optimizeChunkModules: new SyncBailHook(["chunks", "modules"]),

      /** @type {SyncBailHook<Chunk[], Module[]>} */
      optimizeChunkModulesAdvanced: new SyncBailHook(["chunks", "modules"]),

      /** @type {SyncHook<Chunk[], Module[]>} */
      afterOptimizeChunkModules: new SyncHook(["chunks", "modules"]),

      /** @type {SyncBailHook} */
      shouldRecord: new SyncBailHook([]),

      /** @type {SyncHook<Module[], any>} */
      reviveModules: new SyncHook(["modules", "records"]),

      /** @type {SyncHook<Module[]>} */
      optimizeModuleOrder: new SyncHook(["modules"]),

      /** @type {SyncHook<Module[]>} */
      advancedOptimizeModuleOrder: new SyncHook(["modules"]),

      /** @type {SyncHook<Module[]>} */
      beforeModuleIds: new SyncHook(["modules"]),

      /** @type {SyncHook<Module[]>} */
      moduleIds: new SyncHook(["modules"]),

      /** @type {SyncHook<Module[]>} */
      optimizeModuleIds: new SyncHook(["modules"]),

      /** @type {SyncHook<Module[]>} */
      afterOptimizeModuleIds: new SyncHook(["modules"]),

      /** @type {SyncHook<Chunk[], any>} */
      reviveChunks: new SyncHook(["chunks", "records"]),

      /** @type {SyncHook<Chunk[]>} */
      optimizeChunkOrder: new SyncHook(["chunks"]),

      /** @type {SyncHook<Chunk[]>} */
      beforeChunkIds: new SyncHook(["chunks"]),

      /** @type {SyncHook<Chunk[]>} */
      optimizeChunkIds: new SyncHook(["chunks"]),

      /** @type {SyncHook<Chunk[]>} */
      afterOptimizeChunkIds: new SyncHook(["chunks"]),

      /** @type {SyncHook<Module[], any>} */
      recordModules: new SyncHook(["modules", "records"]),

      /** @type {SyncHook<Chunk[], any>} */
      recordChunks: new SyncHook(["chunks", "records"]),

      /** @type {SyncHook} */
      beforeHash: new SyncHook([]),

      /** @type {SyncHook<Chunk>} */
      contentHash: new SyncHook(["chunk"]),

      /** @type {SyncHook} */
      afterHash: new SyncHook([]),

      /** @type {SyncHook<any>} */
      recordHash: new SyncHook(["records"]),

      /** @type {SyncHook<Compilation, any>} */
      record: new SyncHook(["compilation", "records"]),

      /** @type {SyncHook} */
      beforeModuleAssets: new SyncHook([]),

      /** @type {SyncBailHook} */
      shouldGenerateChunkAssets: new SyncBailHook([]),

      /** @type {SyncHook} */
      beforeChunkAssets: new SyncHook([]),

      /** @type {SyncHook<Chunk[]>} */
      additionalChunkAssets: new SyncHook(["chunks"]),

      /** @type {AsyncSeriesHook} */
      additionalAssets: new AsyncSeriesHook([]),

      /** @type {AsyncSeriesHook<Chunk[]>} */
      optimizeChunkAssets: new AsyncSeriesHook(["chunks"]),

      /** @type {SyncHook<Chunk[]>} */
      afterOptimizeChunkAssets: new SyncHook(["chunks"]),

      /** @type {AsyncSeriesHook<CompilationAssets>} */
      optimizeAssets: new AsyncSeriesHook(["assets"]),

      /** @type {SyncHook<CompilationAssets>} */
      afterOptimizeAssets: new SyncHook(["assets"]),

      /** @type {SyncBailHook} */
      needAdditionalSeal: new SyncBailHook([]),

      /** @type {AsyncSeriesHook} */
      afterSeal: new AsyncSeriesHook([]),

      /** @type {SyncHook<Chunk, Hash>} */
      chunkHash: new SyncHook(["chunk", "chunkHash"]),

      /** @type {SyncHook<Module, string>} */
      moduleAsset: new SyncHook(["module", "filename"]),

      /** @type {SyncHook<Chunk, string>} */
      chunkAsset: new SyncHook(["chunk", "filename"]),

      /** @type {SyncWaterfallHook<string, TODO>} */
      assetPath: new SyncWaterfallHook(["filename", "data"]),
      // TODO MainTemplate

      /** @type {SyncBailHook} */
      needAdditionalPass: new SyncBailHook([]),

      /** @type {SyncHook<Compiler, string, number>} */
      childCompiler: new SyncHook(["childCompiler", "compilerName", "compilerIndex"]),

      /** @type {SyncBailHook<string, LogEntry>} */
      log: new SyncBailHook(["origin", "logEntry"]),
      // TODO the following hooks are weirdly located here
      // TODO move them for webpack 5

      /** @type {SyncHook<object, Module>} */
      normalModuleLoader: new SyncHook(["loaderContext", "module"]),

      /** @type {SyncBailHook<Chunk[]>} */
      optimizeExtractedChunksBasic: new SyncBailHook(["chunks"]),

      /** @type {SyncBailHook<Chunk[]>} */
      optimizeExtractedChunks: new SyncBailHook(["chunks"]),

      /** @type {SyncBailHook<Chunk[]>} */
      optimizeExtractedChunksAdvanced: new SyncBailHook(["chunks"]),

      /** @type {SyncHook<Chunk[]>} */
      afterOptimizeExtractedChunks: new SyncHook(["chunks"])
    };

    _this._pluginCompat.tap("Compilation", function (options) {
      switch (options.name) {
        case "optimize-tree":
        case "additional-assets":
        case "optimize-chunk-assets":
        case "optimize-assets":
        case "after-seal":
          options.async = true;
          break;
      }
    });
    /** @type {string=} */


    _this.name = undefined;
    /** @type {Compiler} */

    _this.compiler = compiler;
    _this.resolverFactory = compiler.resolverFactory;
    _this.inputFileSystem = compiler.inputFileSystem;
    _this.requestShortener = compiler.requestShortener;
    var options = compiler.options;
    _this.options = options;
    _this.outputOptions = options && options.output;
    /** @type {boolean=} */

    _this.bail = options && options.bail;
    _this.profile = options && options.profile;
    _this.performance = options && options.performance;
    _this.mainTemplate = new MainTemplate(_this.outputOptions);
    _this.chunkTemplate = new ChunkTemplate(_this.outputOptions);
    _this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(_this.outputOptions);
    _this.runtimeTemplate = new RuntimeTemplate(_this.outputOptions, _this.requestShortener);
    _this.moduleTemplates = {
      javascript: new ModuleTemplate(_this.runtimeTemplate, "javascript"),
      webassembly: new ModuleTemplate(_this.runtimeTemplate, "webassembly")
    };
    _this.semaphore = new Semaphore(options.parallelism || 100);
    _this.entries = [];
    /** @private @type {{name: string, request: string, module: Module}[]} */

    _this._preparedEntrypoints = [];
    /** @type {Map<string, Entrypoint>} */

    _this.entrypoints = new Map();
    /** @type {Chunk[]} */

    _this.chunks = [];
    /** @type {ChunkGroup[]} */

    _this.chunkGroups = [];
    /** @type {Map<string, ChunkGroup>} */

    _this.namedChunkGroups = new Map();
    /** @type {Map<string, Chunk>} */

    _this.namedChunks = new Map();
    /** @type {Module[]} */

    _this.modules = [];
    /** @private @type {Map<string, Module>} */

    _this._modules = new Map();
    _this.cache = null;
    _this.records = null;
    /** @type {string[]} */

    _this.additionalChunkAssets = [];
    /** @type {CompilationAssets} */

    _this.assets = {};
    /** @type {Map<string, AssetInfo>} */

    _this.assetsInfo = new Map();
    /** @type {WebpackError[]} */

    _this.errors = [];
    /** @type {WebpackError[]} */

    _this.warnings = [];
    /** @type {Compilation[]} */

    _this.children = [];
    /** @type {Map<string, LogEntry[]>} */

    _this.logging = new Map();
    /** @type {Map<DepConstructor, ModuleFactory>} */

    _this.dependencyFactories = new Map();
    /** @type {Map<DepConstructor, DependencyTemplate>} */

    _this.dependencyTemplates = new Map(); // TODO refactor this in webpack 5 to a custom DependencyTemplates class with a hash property
    // @ts-ignore

    _this.dependencyTemplates.set("hash", "");

    _this.childrenCounters = {};
    /** @type {Set<number|string>} */

    _this.usedChunkIds = null;
    /** @type {Set<number>} */

    _this.usedModuleIds = null;
    /** @type {Map<string, number>=} */

    _this.fileTimestamps = undefined;
    /** @type {Map<string, number>=} */

    _this.contextTimestamps = undefined;
    /** @type {Set<string>=} */

    _this.compilationDependencies = undefined;
    /** @private @type {Map<Module, Callback[]>} */

    _this._buildingModules = new Map();
    /** @private @type {Map<Module, Callback[]>} */

    _this._rebuildingModules = new Map();
    /** @type {Set<string>} */

    _this.emittedAssets = new Set();
    return _this;
  }

  _createClass(Compilation, [{
    key: "getStats",
    value: function getStats() {
      return new Stats(this);
    }
    /**
     * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name
     * @returns {Logger} a logger with that name
     */

  }, {
    key: "getLogger",
    value: function getLogger(name) {
      var _this2 = this;

      if (!name) {
        throw new TypeError("Compilation.getLogger(name) called without a name");
      }
      /** @type {LogEntry[] | undefined} */


      var logEntries;
      return new Logger(function (type, args) {
        if (typeof name === "function") {
          name = name();

          if (!name) {
            throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
          }
        }

        var trace;

        switch (type) {
          case LogType.warn:
          case LogType.error:
          case LogType.trace:
            trace = ErrorHelpers.cutOffLoaderExecution(new Error("Trace").stack).split("\n").slice(3);
            break;
        }
        /** @type {LogEntry} */


        var logEntry = {
          time: Date.now(),
          type: type,
          args: args,
          trace: trace
        };

        if (_this2.hooks.log.call(name, logEntry) === undefined) {
          if (logEntry.type === LogType.profileEnd) {
            // eslint-disable-next-line node/no-unsupported-features/node-builtins
            if (typeof console.profileEnd === "function") {
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              console.profileEnd("[".concat(name, "] ").concat(logEntry.args[0]));
            }
          }

          if (logEntries === undefined) {
            logEntries = _this2.logging.get(name);

            if (logEntries === undefined) {
              logEntries = [];

              _this2.logging.set(name, logEntries);
            }
          }

          logEntries.push(logEntry);

          if (logEntry.type === LogType.profile) {
            // eslint-disable-next-line node/no-unsupported-features/node-builtins
            if (typeof console.profile === "function") {
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              console.profile("[".concat(name, "] ").concat(logEntry.args[0]));
            }
          }
        }
      });
    }
    /**
     * @typedef {Object} AddModuleResult
     * @property {Module} module the added or existing module
     * @property {boolean} issuer was this the first request for this module
     * @property {boolean} build should the module be build
     * @property {boolean} dependencies should dependencies be walked
     */

    /**
     * @param {Module} module module to be added that was created
     * @param {any=} cacheGroup cacheGroup it is apart of
     * @returns {AddModuleResult} returns meta about whether or not the module had built
     * had an issuer, or any dependnecies
     */

  }, {
    key: "addModule",
    value: function addModule(module, cacheGroup) {
      var identifier = module.identifier();

      var alreadyAddedModule = this._modules.get(identifier);

      if (alreadyAddedModule) {
        return {
          module: alreadyAddedModule,
          issuer: false,
          build: false,
          dependencies: false
        };
      }

      var cacheName = (cacheGroup || "m") + identifier;

      if (this.cache && this.cache[cacheName]) {
        var cacheModule = this.cache[cacheName];

        if (typeof cacheModule.updateCacheModule === "function") {
          cacheModule.updateCacheModule(module);
        }

        var rebuild = true;

        if (this.fileTimestamps && this.contextTimestamps) {
          rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);
        }

        if (!rebuild) {
          cacheModule.disconnect();

          this._modules.set(identifier, cacheModule);

          this.modules.push(cacheModule);
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = cacheModule.errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var err = _step2.value;
              this.errors.push(err);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = cacheModule.warnings[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _err = _step3.value;
              this.warnings.push(_err);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          return {
            module: cacheModule,
            issuer: true,
            build: false,
            dependencies: true
          };
        }

        cacheModule.unbuild();
        module = cacheModule;
      }

      this._modules.set(identifier, module);

      if (this.cache) {
        this.cache[cacheName] = module;
      }

      this.modules.push(module);
      return {
        module: module,
        issuer: true,
        build: true,
        dependencies: true
      };
    }
    /**
     * Fetches a module from a compilation by its identifier
     * @param {Module} module the module provided
     * @returns {Module} the module requested
     */

  }, {
    key: "getModule",
    value: function getModule(module) {
      var identifier = module.identifier();
      return this._modules.get(identifier);
    }
    /**
     * Attempts to search for a module by its identifier
     * @param {string} identifier identifier (usually path) for module
     * @returns {Module|undefined} attempt to search for module and return it, else undefined
     */

  }, {
    key: "findModule",
    value: function findModule(identifier) {
      return this._modules.get(identifier);
    }
    /**
     * @param {Module} module module with its callback list
     * @param {Callback} callback the callback function
     * @returns {void}
     */

  }, {
    key: "waitForBuildingFinished",
    value: function waitForBuildingFinished(module, callback) {
      var callbackList = this._buildingModules.get(module);

      if (callbackList) {
        callbackList.push(function () {
          return callback();
        });
      } else {
        process.nextTick(callback);
      }
    }
    /**
     * Builds the module object
     *
     * @param {Module} module module to be built
     * @param {boolean} optional optional flag
     * @param {Module=} origin origin module this module build was requested from
     * @param {Dependency[]=} dependencies optional dependencies from the module to be built
     * @param {TODO} thisCallback the callback
     * @returns {TODO} returns the callback function with results
     */

  }, {
    key: "buildModule",
    value: function buildModule(module, optional, origin, dependencies, thisCallback) {
      var _this3 = this;

      var callbackList = this._buildingModules.get(module);

      if (callbackList) {
        callbackList.push(thisCallback);
        return;
      }

      this._buildingModules.set(module, callbackList = [thisCallback]);

      var callback = function callback(err) {
        _this3._buildingModules["delete"](module);

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = callbackList[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var cb = _step4.value;
            cb(err);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      };

      this.hooks.buildModule.call(module);
      module.build(this.options, this, this.resolverFactory.get("normal", module.resolveOptions), this.inputFileSystem, function (error) {
        var errors = module.errors;

        for (var indexError = 0; indexError < errors.length; indexError++) {
          var err = errors[indexError];
          err.origin = origin;
          err.dependencies = dependencies;

          if (optional) {
            _this3.warnings.push(err);
          } else {
            _this3.errors.push(err);
          }
        }

        var warnings = module.warnings;

        for (var indexWarning = 0; indexWarning < warnings.length; indexWarning++) {
          var war = warnings[indexWarning];
          war.origin = origin;
          war.dependencies = dependencies;

          _this3.warnings.push(war);
        }

        var originalMap = module.dependencies.reduce(function (map, v, i) {
          map.set(v, i);
          return map;
        }, new Map());
        module.dependencies.sort(function (a, b) {
          var cmp = compareLocations(a.loc, b.loc);
          if (cmp) return cmp;
          return originalMap.get(a) - originalMap.get(b);
        });

        if (error) {
          _this3.hooks.failedModule.call(module, error);

          return callback(error);
        }

        _this3.hooks.succeedModule.call(module);

        return callback();
      });
    }
    /**
     * @param {Module} module to be processed for deps
     * @param {ModuleCallback} callback callback to be triggered
     * @returns {void}
     */

  }, {
    key: "processModuleDependencies",
    value: function processModuleDependencies(module, callback) {
      var _this4 = this;

      var dependencies = new Map();

      var addDependency = function addDependency(dep) {
        var resourceIdent = dep.getResourceIdentifier();

        if (resourceIdent) {
          var factory = _this4.dependencyFactories.get(dep.constructor);

          if (factory === undefined) {
            throw new Error("No module factory available for dependency type: ".concat(dep.constructor.name));
          }

          var innerMap = dependencies.get(factory);

          if (innerMap === undefined) {
            dependencies.set(factory, innerMap = new Map());
          }

          var list = innerMap.get(resourceIdent);
          if (list === undefined) innerMap.set(resourceIdent, list = []);
          list.push(dep);
        }
      };

      var addDependenciesBlock = function addDependenciesBlock(block) {
        if (block.dependencies) {
          iterationOfArrayCallback(block.dependencies, addDependency);
        }

        if (block.blocks) {
          iterationOfArrayCallback(block.blocks, addDependenciesBlock);
        }

        if (block.variables) {
          iterationBlockVariable(block.variables, addDependency);
        }
      };

      try {
        addDependenciesBlock(module);
      } catch (e) {
        callback(e);
      }

      var sortedDependencies = [];
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = dependencies[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var pair1 = _step5.value;
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = pair1[1][Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var pair2 = _step6.value;
              sortedDependencies.push({
                factory: pair1[0],
                dependencies: pair2[1]
              });
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this.addModuleDependencies(module, sortedDependencies, this.bail, null, true, callback);
    }
    /**
     * @param {Module} module module to add deps to
     * @param {SortedDependency[]} dependencies set of sorted dependencies to iterate through
     * @param {(boolean|null)=} bail whether to bail or not
     * @param {TODO} cacheGroup optional cacheGroup
     * @param {boolean} recursive whether it is recursive traversal
     * @param {function} callback callback for when dependencies are finished being added
     * @returns {void}
     */

  }, {
    key: "addModuleDependencies",
    value: function addModuleDependencies(module, dependencies, bail, cacheGroup, recursive, callback) {
      var _this5 = this;

      var start = this.profile && Date.now();
      var currentProfile = this.profile && {};
      asyncLib.forEach(dependencies, function (item, callback) {
        var dependencies = item.dependencies;

        var errorAndCallback = function errorAndCallback(err) {
          err.origin = module;
          err.dependencies = dependencies;

          _this5.errors.push(err);

          if (bail) {
            callback(err);
          } else {
            callback();
          }
        };

        var warningAndCallback = function warningAndCallback(err) {
          err.origin = module;

          _this5.warnings.push(err);

          callback();
        };

        var semaphore = _this5.semaphore;
        semaphore.acquire(function () {
          var factory = item.factory;
          factory.create({
            contextInfo: {
              issuer: module.nameForCondition && module.nameForCondition(),
              compiler: _this5.compiler.name
            },
            resolveOptions: module.resolveOptions,
            context: module.context,
            dependencies: dependencies
          }, function (err, dependentModule) {
            var afterFactory;

            var isOptional = function isOptional() {
              return dependencies.every(function (d) {
                return d.optional;
              });
            };

            var errorOrWarningAndCallback = function errorOrWarningAndCallback(err) {
              if (isOptional()) {
                return warningAndCallback(err);
              } else {
                return errorAndCallback(err);
              }
            };

            if (err) {
              semaphore.release();
              return errorOrWarningAndCallback(new ModuleNotFoundError(module, err));
            }

            if (!dependentModule) {
              semaphore.release();
              return process.nextTick(callback);
            }

            if (currentProfile) {
              afterFactory = Date.now();
              currentProfile.factory = afterFactory - start;
            }

            var iterationDependencies = function iterationDependencies(depend) {
              for (var index = 0; index < depend.length; index++) {
                var dep = depend[index];
                dep.module = dependentModule;
                dependentModule.addReason(module, dep);
              }
            };

            var addModuleResult = _this5.addModule(dependentModule, cacheGroup);

            dependentModule = addModuleResult.module;
            iterationDependencies(dependencies);

            var afterBuild = function afterBuild() {
              if (recursive && addModuleResult.dependencies) {
                _this5.processModuleDependencies(dependentModule, callback);
              } else {
                return callback();
              }
            };

            if (addModuleResult.issuer) {
              if (currentProfile) {
                dependentModule.profile = currentProfile;
              }

              dependentModule.issuer = module;
            } else {
              if (_this5.profile) {
                if (module.profile) {
                  var time = Date.now() - start;

                  if (!module.profile.dependencies || time > module.profile.dependencies) {
                    module.profile.dependencies = time;
                  }
                }
              }
            }

            if (addModuleResult.build) {
              _this5.buildModule(dependentModule, isOptional(), module, dependencies, function (err) {
                if (err) {
                  semaphore.release();
                  return errorOrWarningAndCallback(err);
                }

                if (currentProfile) {
                  var afterBuilding = Date.now();
                  currentProfile.building = afterBuilding - afterFactory;
                }

                semaphore.release();
                afterBuild();
              });
            } else {
              semaphore.release();

              _this5.waitForBuildingFinished(dependentModule, afterBuild);
            }
          });
        });
      }, function (err) {
        // In V8, the Error objects keep a reference to the functions on the stack. These warnings &
        // errors are created inside closures that keep a reference to the Compilation, so errors are
        // leaking the Compilation object.
        if (err) {
          // eslint-disable-next-line no-self-assign
          err.stack = err.stack;
          return callback(err);
        }

        return process.nextTick(callback);
      });
    }
    /**
     *
     * @param {string} context context string path
     * @param {Dependency} dependency dependency used to create Module chain
     * @param {OnModuleCallback} onModule function invoked on modules creation
     * @param {ModuleChainCallback} callback callback for when module chain is complete
     * @returns {void} will throw if dependency instance is not a valid Dependency
     */

  }, {
    key: "_addModuleChain",
    value: function _addModuleChain(context, dependency, onModule, callback) {
      var _this6 = this;

      var start = this.profile && Date.now();
      var currentProfile = this.profile && {};
      var errorAndCallback = this.bail ? function (err) {
        callback(err);
      } : function (err) {
        err.dependencies = [dependency];

        _this6.errors.push(err);

        callback();
      };

      if (_typeof(dependency) !== "object" || dependency === null || !dependency.constructor) {
        throw new Error("Parameter 'dependency' must be a Dependency");
      }

      var Dep =
      /** @type {DepConstructor} */
      dependency.constructor;
      var moduleFactory = this.dependencyFactories.get(Dep);

      if (!moduleFactory) {
        throw new Error("No dependency factory available for this dependency type: ".concat(dependency.constructor.name));
      }

      this.semaphore.acquire(function () {
        moduleFactory.create({
          contextInfo: {
            issuer: "",
            compiler: _this6.compiler.name
          },
          context: context,
          dependencies: [dependency]
        }, function (err, module) {
          if (err) {
            _this6.semaphore.release();

            return errorAndCallback(new EntryModuleNotFoundError(err));
          }

          var afterFactory;

          if (currentProfile) {
            afterFactory = Date.now();
            currentProfile.factory = afterFactory - start;
          }

          var addModuleResult = _this6.addModule(module);

          module = addModuleResult.module;
          onModule(module);
          dependency.module = module;
          module.addReason(null, dependency);

          var afterBuild = function afterBuild() {
            if (addModuleResult.dependencies) {
              _this6.processModuleDependencies(module, function (err) {
                if (err) return callback(err);
                callback(null, module);
              });
            } else {
              return callback(null, module);
            }
          };

          if (addModuleResult.issuer) {
            if (currentProfile) {
              module.profile = currentProfile;
            }
          }

          if (addModuleResult.build) {
            _this6.buildModule(module, false, null, null, function (err) {
              if (err) {
                _this6.semaphore.release();

                return errorAndCallback(err);
              }

              if (currentProfile) {
                var afterBuilding = Date.now();
                currentProfile.building = afterBuilding - afterFactory;
              }

              _this6.semaphore.release();

              afterBuild();
            });
          } else {
            _this6.semaphore.release();

            _this6.waitForBuildingFinished(module, afterBuild);
          }
        });
      });
    }
    /**
     *
     * @param {string} context context path for entry
     * @param {Dependency} entry entry dependency being created
     * @param {string} name name of entry
     * @param {ModuleCallback} callback callback function
     * @returns {void} returns
     */

  }, {
    key: "addEntry",
    value: function addEntry(context, entry, name, callback) {
      var _this7 = this;

      this.hooks.addEntry.call(entry, name);
      var slot = {
        name: name,
        // TODO webpack 5 remove `request`
        request: null,
        module: null
      };

      if (entry instanceof ModuleDependency) {
        slot.request = entry.request;
      } // TODO webpack 5: merge modules instead when multiple entry modules are supported


      var idx = this._preparedEntrypoints.findIndex(function (slot) {
        return slot.name === name;
      });

      if (idx >= 0) {
        // Overwrite existing entrypoint
        this._preparedEntrypoints[idx] = slot;
      } else {
        this._preparedEntrypoints.push(slot);
      }

      this._addModuleChain(context, entry, function (module) {
        _this7.entries.push(module);
      }, function (err, module) {
        if (err) {
          _this7.hooks.failedEntry.call(entry, name, err);

          return callback(err);
        }

        if (module) {
          slot.module = module;
        } else {
          var _idx = _this7._preparedEntrypoints.indexOf(slot);

          if (_idx >= 0) {
            _this7._preparedEntrypoints.splice(_idx, 1);
          }
        }

        _this7.hooks.succeedEntry.call(entry, name, module);

        return callback(null, module);
      });
    }
    /**
     * @param {string} context context path string
     * @param {Dependency} dependency dep used to create module
     * @param {ModuleCallback} callback module callback sending module up a level
     * @returns {void}
     */

  }, {
    key: "prefetch",
    value: function prefetch(context, dependency, callback) {
      this._addModuleChain(context, dependency, function (module) {
        module.prefetched = true;
      }, callback);
    }
    /**
     * @param {Module} module module to be rebuilt
     * @param {Callback} thisCallback callback when module finishes rebuilding
     * @returns {void}
     */

  }, {
    key: "rebuildModule",
    value: function rebuildModule(module, thisCallback) {
      var _this8 = this;

      var callbackList = this._rebuildingModules.get(module);

      if (callbackList) {
        callbackList.push(thisCallback);
        return;
      }

      this._rebuildingModules.set(module, callbackList = [thisCallback]);

      var callback = function callback(err) {
        _this8._rebuildingModules["delete"](module);

        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = callbackList[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var cb = _step7.value;
            cb(err);
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
              _iterator7["return"]();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }
      };

      this.hooks.rebuildModule.call(module);
      var oldDependencies = module.dependencies.slice();
      var oldVariables = module.variables.slice();
      var oldBlocks = module.blocks.slice();
      module.unbuild();
      this.buildModule(module, false, module, null, function (err) {
        if (err) {
          _this8.hooks.finishRebuildingModule.call(module);

          return callback(err);
        }

        _this8.processModuleDependencies(module, function (err) {
          if (err) return callback(err);

          _this8.removeReasonsOfDependencyBlock(module, {
            dependencies: oldDependencies,
            variables: oldVariables,
            blocks: oldBlocks
          });

          _this8.hooks.finishRebuildingModule.call(module);

          callback();
        });
      });
    }
  }, {
    key: "finish",
    value: function finish(callback) {
      var _this9 = this;

      var modules = this.modules;
      this.hooks.finishModules.callAsync(modules, function (err) {
        if (err) return callback(err);

        for (var index = 0; index < modules.length; index++) {
          var _module = modules[index];

          _this9.reportDependencyErrorsAndWarnings(_module, [_module]);
        }

        callback();
      });
    }
  }, {
    key: "unseal",
    value: function unseal() {
      this.hooks.unseal.call();
      this.chunks.length = 0;
      this.chunkGroups.length = 0;
      this.namedChunks.clear();
      this.namedChunkGroups.clear();
      this.additionalChunkAssets.length = 0;
      this.assets = {};
      this.assetsInfo.clear();
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.modules[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var _module2 = _step8.value;

          _module2.unseal();
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
    /**
     * @param {Callback} callback signals when the seal method is finishes
     * @returns {void}
     */

  }, {
    key: "seal",
    value: function seal(callback) {
      var _this10 = this;

      this.hooks.seal.call();

      while (this.hooks.optimizeDependenciesBasic.call(this.modules) || this.hooks.optimizeDependencies.call(this.modules) || this.hooks.optimizeDependenciesAdvanced.call(this.modules)) {
        /* empty */
      }

      this.hooks.afterOptimizeDependencies.call(this.modules);
      this.hooks.beforeChunks.call();
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this._preparedEntrypoints[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var preparedEntrypoint = _step9.value;
          var _module3 = preparedEntrypoint.module;
          var name = preparedEntrypoint.name;
          var chunk = this.addChunk(name);
          var entrypoint = new Entrypoint(name);
          entrypoint.setRuntimeChunk(chunk);
          entrypoint.addOrigin(null, name, preparedEntrypoint.request);
          this.namedChunkGroups.set(name, entrypoint);
          this.entrypoints.set(name, entrypoint);
          this.chunkGroups.push(entrypoint);
          GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);
          GraphHelpers.connectChunkAndModule(chunk, _module3);
          chunk.entryModule = _module3;
          chunk.name = name;
          this.assignDepth(_module3);
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      buildChunkGraph(this,
      /** @type {Entrypoint[]} */
      this.chunkGroups.slice());
      this.sortModules(this.modules);
      this.hooks.afterChunks.call(this.chunks);
      this.hooks.optimize.call();

      while (this.hooks.optimizeModulesBasic.call(this.modules) || this.hooks.optimizeModules.call(this.modules) || this.hooks.optimizeModulesAdvanced.call(this.modules)) {
        /* empty */
      }

      this.hooks.afterOptimizeModules.call(this.modules);

      while (this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)) {
        /* empty */
      }

      this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);
      this.hooks.optimizeTree.callAsync(this.chunks, this.modules, function (err) {
        if (err) {
          return callback(err);
        }

        _this10.hooks.afterOptimizeTree.call(_this10.chunks, _this10.modules);

        while (_this10.hooks.optimizeChunkModulesBasic.call(_this10.chunks, _this10.modules) || _this10.hooks.optimizeChunkModules.call(_this10.chunks, _this10.modules) || _this10.hooks.optimizeChunkModulesAdvanced.call(_this10.chunks, _this10.modules)) {
          /* empty */
        }

        _this10.hooks.afterOptimizeChunkModules.call(_this10.chunks, _this10.modules);

        var shouldRecord = _this10.hooks.shouldRecord.call() !== false;

        _this10.hooks.reviveModules.call(_this10.modules, _this10.records);

        _this10.hooks.optimizeModuleOrder.call(_this10.modules);

        _this10.hooks.advancedOptimizeModuleOrder.call(_this10.modules);

        _this10.hooks.beforeModuleIds.call(_this10.modules);

        _this10.hooks.moduleIds.call(_this10.modules);

        _this10.applyModuleIds();

        _this10.hooks.optimizeModuleIds.call(_this10.modules);

        _this10.hooks.afterOptimizeModuleIds.call(_this10.modules);

        _this10.sortItemsWithModuleIds();

        _this10.hooks.reviveChunks.call(_this10.chunks, _this10.records);

        _this10.hooks.optimizeChunkOrder.call(_this10.chunks);

        _this10.hooks.beforeChunkIds.call(_this10.chunks);

        _this10.applyChunkIds();

        _this10.hooks.optimizeChunkIds.call(_this10.chunks);

        _this10.hooks.afterOptimizeChunkIds.call(_this10.chunks);

        _this10.sortItemsWithChunkIds();

        if (shouldRecord) {
          _this10.hooks.recordModules.call(_this10.modules, _this10.records);

          _this10.hooks.recordChunks.call(_this10.chunks, _this10.records);
        }

        _this10.hooks.beforeHash.call();

        _this10.createHash();

        _this10.hooks.afterHash.call();

        if (shouldRecord) {
          _this10.hooks.recordHash.call(_this10.records);
        }

        _this10.hooks.beforeModuleAssets.call();

        _this10.createModuleAssets();

        if (_this10.hooks.shouldGenerateChunkAssets.call() !== false) {
          _this10.hooks.beforeChunkAssets.call();

          _this10.createChunkAssets();
        }

        _this10.hooks.additionalChunkAssets.call(_this10.chunks);

        _this10.summarizeDependencies();

        if (shouldRecord) {
          _this10.hooks.record.call(_this10, _this10.records);
        }

        _this10.hooks.additionalAssets.callAsync(function (err) {
          if (err) {
            return callback(err);
          }

          _this10.hooks.optimizeChunkAssets.callAsync(_this10.chunks, function (err) {
            if (err) {
              return callback(err);
            }

            _this10.hooks.afterOptimizeChunkAssets.call(_this10.chunks);

            _this10.hooks.optimizeAssets.callAsync(_this10.assets, function (err) {
              if (err) {
                return callback(err);
              }

              _this10.hooks.afterOptimizeAssets.call(_this10.assets);

              if (_this10.hooks.needAdditionalSeal.call()) {
                _this10.unseal();

                return _this10.seal(callback);
              }

              return _this10.hooks.afterSeal.callAsync(callback);
            });
          });
        });
      });
    }
    /**
     * @param {Module[]} modules the modules array on compilation to perform the sort for
     * @returns {void}
     */

  }, {
    key: "sortModules",
    value: function sortModules(modules) {
      // TODO webpack 5: this should only be enabled when `moduleIds: "natural"`
      // TODO move it into a plugin (NaturalModuleIdsPlugin) and use this in WebpackOptionsApply
      // TODO remove this method
      modules.sort(byIndexOrIdentifier);
    }
    /**
     * @param {Module} module moulde to report from
     * @param {DependenciesBlock[]} blocks blocks to report from
     * @returns {void}
     */

  }, {
    key: "reportDependencyErrorsAndWarnings",
    value: function reportDependencyErrorsAndWarnings(module, blocks) {
      for (var indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
        var block = blocks[indexBlock];
        var dependencies = block.dependencies;

        for (var indexDep = 0; indexDep < dependencies.length; indexDep++) {
          var d = dependencies[indexDep];
          var warnings = d.getWarnings();

          if (warnings) {
            for (var indexWar = 0; indexWar < warnings.length; indexWar++) {
              var w = warnings[indexWar];
              var warning = new ModuleDependencyWarning(module, w, d.loc);
              this.warnings.push(warning);
            }
          }

          var errors = d.getErrors();

          if (errors) {
            for (var indexErr = 0; indexErr < errors.length; indexErr++) {
              var e = errors[indexErr];
              var error = new ModuleDependencyError(module, e, d.loc);
              this.errors.push(error);
            }
          }
        }

        this.reportDependencyErrorsAndWarnings(module, block.blocks);
      }
    }
    /**
     * @param {TODO} groupOptions options for the chunk group
     * @param {Module} module the module the references the chunk group
     * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)
     * @param {string} request the request from which the the chunk group is referenced
     * @returns {ChunkGroup} the new or existing chunk group
     */

  }, {
    key: "addChunkInGroup",
    value: function addChunkInGroup(groupOptions, module, loc, request) {
      if (typeof groupOptions === "string") {
        groupOptions = {
          name: groupOptions
        };
      }

      var name = groupOptions.name;

      if (name) {
        var _chunkGroup = this.namedChunkGroups.get(name);

        if (_chunkGroup !== undefined) {
          _chunkGroup.addOptions(groupOptions);

          if (module) {
            _chunkGroup.addOrigin(module, loc, request);
          }

          return _chunkGroup;
        }
      }

      var chunkGroup = new ChunkGroup(groupOptions);
      if (module) chunkGroup.addOrigin(module, loc, request);
      var chunk = this.addChunk(name);
      GraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);
      this.chunkGroups.push(chunkGroup);

      if (name) {
        this.namedChunkGroups.set(name, chunkGroup);
      }

      return chunkGroup;
    }
    /**
     * This method first looks to see if a name is provided for a new chunk,
     * and first looks to see if any named chunks already exist and reuse that chunk instead.
     *
     * @param {string=} name optional chunk name to be provided
     * @returns {Chunk} create a chunk (invoked during seal event)
     */

  }, {
    key: "addChunk",
    value: function addChunk(name) {
      if (name) {
        var _chunk = this.namedChunks.get(name);

        if (_chunk !== undefined) {
          return _chunk;
        }
      }

      var chunk = new Chunk(name);
      this.chunks.push(chunk);

      if (name) {
        this.namedChunks.set(name, chunk);
      }

      return chunk;
    }
    /**
     * @param {Module} module module to assign depth
     * @returns {void}
     */

  }, {
    key: "assignDepth",
    value: function assignDepth(module) {
      var queue = new Set([module]);
      var depth;
      module.depth = 0;
      /**
       * @param {Module} module module for processeing
       * @returns {void}
       */

      var enqueueJob = function enqueueJob(module) {
        var d = module.depth;
        if (typeof d === "number" && d <= depth) return;
        queue.add(module);
        module.depth = depth;
      };
      /**
       * @param {Dependency} dependency dependency to assign depth to
       * @returns {void}
       */


      var assignDepthToDependency = function assignDepthToDependency(dependency) {
        if (dependency.module) {
          enqueueJob(dependency.module);
        }
      };
      /**
       * @param {DependenciesBlock} block block to assign depth to
       * @returns {void}
       */


      var assignDepthToDependencyBlock = function assignDepthToDependencyBlock(block) {
        if (block.variables) {
          iterationBlockVariable(block.variables, assignDepthToDependency);
        }

        if (block.dependencies) {
          iterationOfArrayCallback(block.dependencies, assignDepthToDependency);
        }

        if (block.blocks) {
          iterationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);
        }
      };

      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = queue[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          module = _step10.value;
          queue["delete"](module);
          depth = module.depth;
          depth++;
          assignDepthToDependencyBlock(module);
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }
    }
    /**
     * @param {Module} module the module containing the dependency
     * @param {Dependency} dependency the dependency
     * @returns {DependencyReference} a reference for the dependency
     */

  }, {
    key: "getDependencyReference",
    value: function getDependencyReference(module, dependency) {
      // TODO remove dep.getReference existence check in webpack 5
      if (typeof dependency.getReference !== "function") return null;
      var ref = dependency.getReference();
      if (!ref) return null;
      return this.hooks.dependencyReference.call(ref, dependency, module);
    }
    /**
     *
     * @param {Module} module module relationship for removal
     * @param {DependenciesBlockLike} block //TODO: good description
     * @returns {void}
     */

  }, {
    key: "removeReasonsOfDependencyBlock",
    value: function removeReasonsOfDependencyBlock(module, block) {
      var _this11 = this;

      var iteratorDependency = function iteratorDependency(d) {
        if (!d.module) {
          return;
        }

        if (d.module.removeReason(module, d)) {
          var _iteratorNormalCompletion11 = true;
          var _didIteratorError11 = false;
          var _iteratorError11 = undefined;

          try {
            for (var _iterator11 = d.module.chunksIterable[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
              var chunk = _step11.value;

              _this11.patchChunksAfterReasonRemoval(d.module, chunk);
            }
          } catch (err) {
            _didIteratorError11 = true;
            _iteratorError11 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                _iterator11["return"]();
              }
            } finally {
              if (_didIteratorError11) {
                throw _iteratorError11;
              }
            }
          }
        }
      };

      if (block.blocks) {
        iterationOfArrayCallback(block.blocks, function (block) {
          return _this11.removeReasonsOfDependencyBlock(module, block);
        });
      }

      if (block.dependencies) {
        iterationOfArrayCallback(block.dependencies, iteratorDependency);
      }

      if (block.variables) {
        iterationBlockVariable(block.variables, iteratorDependency);
      }
    }
    /**
     * @param {Module} module module to patch tie
     * @param {Chunk} chunk chunk to patch tie
     * @returns {void}
     */

  }, {
    key: "patchChunksAfterReasonRemoval",
    value: function patchChunksAfterReasonRemoval(module, chunk) {
      if (!module.hasReasons()) {
        this.removeReasonsOfDependencyBlock(module, module);
      }

      if (!module.hasReasonForChunk(chunk)) {
        if (module.removeChunk(chunk)) {
          this.removeChunkFromDependencies(module, chunk);
        }
      }
    }
    /**
     *
     * @param {DependenciesBlock} block block tie for Chunk
     * @param {Chunk} chunk chunk to remove from dep
     * @returns {void}
     */

  }, {
    key: "removeChunkFromDependencies",
    value: function removeChunkFromDependencies(block, chunk) {
      var _this12 = this;

      var iteratorDependency = function iteratorDependency(d) {
        if (!d.module) {
          return;
        }

        _this12.patchChunksAfterReasonRemoval(d.module, chunk);
      };

      var blocks = block.blocks;

      for (var indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
        var asyncBlock = blocks[indexBlock]; // Grab all chunks from the first Block's AsyncDepBlock

        var chunks = asyncBlock.chunkGroup.chunks; // For each chunk in chunkGroup

        for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
          var iteratedChunk = chunks[indexChunk];
          asyncBlock.chunkGroup.removeChunk(iteratedChunk);
          asyncBlock.chunkGroup.removeParent(iteratedChunk); // Recurse

          this.removeChunkFromDependencies(block, iteratedChunk);
        }
      }

      if (block.dependencies) {
        iterationOfArrayCallback(block.dependencies, iteratorDependency);
      }

      if (block.variables) {
        iterationBlockVariable(block.variables, iteratorDependency);
      }
    }
  }, {
    key: "applyModuleIds",
    value: function applyModuleIds() {
      var unusedIds = [];
      var nextFreeModuleId = 0;
      var usedIds = new Set();

      if (this.usedModuleIds) {
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = this.usedModuleIds[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var id = _step12.value;
            usedIds.add(id);
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
              _iterator12["return"]();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }
      }

      var modules1 = this.modules;

      for (var indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {
        var module1 = modules1[indexModule1];

        if (module1.id !== null) {
          usedIds.add(module1.id);
        }
      }

      if (usedIds.size > 0) {
        var usedIdMax = -1;
        var _iteratorNormalCompletion13 = true;
        var _didIteratorError13 = false;
        var _iteratorError13 = undefined;

        try {
          for (var _iterator13 = usedIds[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            var usedIdKey = _step13.value;

            if (typeof usedIdKey !== "number") {
              continue;
            }

            usedIdMax = Math.max(usedIdMax, usedIdKey);
          }
        } catch (err) {
          _didIteratorError13 = true;
          _iteratorError13 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
              _iterator13["return"]();
            }
          } finally {
            if (_didIteratorError13) {
              throw _iteratorError13;
            }
          }
        }

        var lengthFreeModules = nextFreeModuleId = usedIdMax + 1;

        while (lengthFreeModules--) {
          if (!usedIds.has(lengthFreeModules)) {
            unusedIds.push(lengthFreeModules);
          }
        }
      }

      var modules2 = this.modules;

      for (var indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {
        var module2 = modules2[indexModule2];

        if (module2.id === null) {
          if (unusedIds.length > 0) {
            module2.id = unusedIds.pop();
          } else {
            module2.id = nextFreeModuleId++;
          }
        }
      }
    }
  }, {
    key: "applyChunkIds",
    value: function applyChunkIds() {
      /** @type {Set<number>} */
      var usedIds = new Set(); // Get used ids from usedChunkIds property (i. e. from records)

      if (this.usedChunkIds) {
        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = this.usedChunkIds[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var id = _step14.value;

            if (typeof id !== "number") {
              continue;
            }

            usedIds.add(id);
          }
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
              _iterator14["return"]();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }
      } // Get used ids from existing chunks


      var chunks = this.chunks;

      for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
        var chunk = chunks[indexChunk];
        var usedIdValue = chunk.id;

        if (typeof usedIdValue !== "number") {
          continue;
        }

        usedIds.add(usedIdValue);
      } // Calculate maximum assigned chunk id


      var nextFreeChunkId = -1;
      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = usedIds[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var _id = _step15.value;
          nextFreeChunkId = Math.max(nextFreeChunkId, _id);
        }
      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
            _iterator15["return"]();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }

      nextFreeChunkId++; // Determine free chunk ids from 0 to maximum

      /** @type {number[]} */

      var unusedIds = [];

      if (nextFreeChunkId > 0) {
        var index = nextFreeChunkId;

        while (index--) {
          if (!usedIds.has(index)) {
            unusedIds.push(index);
          }
        }
      } // Assign ids to chunk which has no id


      for (var _indexChunk = 0; _indexChunk < chunks.length; _indexChunk++) {
        var _chunk2 = chunks[_indexChunk];

        if (_chunk2.id === null) {
          if (unusedIds.length > 0) {
            _chunk2.id = unusedIds.pop();
          } else {
            _chunk2.id = nextFreeChunkId++;
          }
        }

        if (!_chunk2.ids) {
          _chunk2.ids = [_chunk2.id];
        }
      }
    }
  }, {
    key: "sortItemsWithModuleIds",
    value: function sortItemsWithModuleIds() {
      this.modules.sort(byIdOrIdentifier);
      var modules = this.modules;

      for (var indexModule = 0; indexModule < modules.length; indexModule++) {
        modules[indexModule].sortItems(false);
      }

      var chunks = this.chunks;

      for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
        chunks[indexChunk].sortItems();
      }

      chunks.sort(function (a, b) {
        return a.compareTo(b);
      });
    }
  }, {
    key: "sortItemsWithChunkIds",
    value: function sortItemsWithChunkIds() {
      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = this.chunkGroups[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var chunkGroup = _step16.value;
          chunkGroup.sortItems();
        }
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
            _iterator16["return"]();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      this.chunks.sort(byId);

      for (var indexModule = 0; indexModule < this.modules.length; indexModule++) {
        this.modules[indexModule].sortItems(true);
      }

      var chunks = this.chunks;

      for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
        chunks[indexChunk].sortItems();
      }
      /**
       * Used to sort errors and warnings in compilation. this.warnings, and
       * this.errors contribute to the compilation hash and therefore should be
       * updated whenever other references (having a chunk id) are sorted. This preserves the hash
       * integrity
       *
       * @param {WebpackError} a first WebpackError instance (including subclasses)
       * @param {WebpackError} b second WebpackError instance (including subclasses)
       * @returns {-1|0|1} sort order index
       */


      var byMessage = function byMessage(a, b) {
        var ma = "".concat(a.message);
        var mb = "".concat(b.message);
        if (ma < mb) return -1;
        if (mb < ma) return 1;
        return 0;
      };

      this.errors.sort(byMessage);
      this.warnings.sort(byMessage);
      this.children.sort(byNameOrHash);
    }
  }, {
    key: "summarizeDependencies",
    value: function summarizeDependencies() {
      this.fileDependencies = new SortableSet(this.compilationDependencies);
      this.contextDependencies = new SortableSet();
      this.missingDependencies = new SortableSet();

      for (var indexChildren = 0; indexChildren < this.children.length; indexChildren++) {
        var child = this.children[indexChildren];
        addAllToSet(this.fileDependencies, child.fileDependencies);
        addAllToSet(this.contextDependencies, child.contextDependencies);
        addAllToSet(this.missingDependencies, child.missingDependencies);
      }

      for (var indexModule = 0; indexModule < this.modules.length; indexModule++) {
        var _module4 = this.modules[indexModule];

        if (_module4.buildInfo.fileDependencies) {
          addAllToSet(this.fileDependencies, _module4.buildInfo.fileDependencies);
        }

        if (_module4.buildInfo.contextDependencies) {
          addAllToSet(this.contextDependencies, _module4.buildInfo.contextDependencies);
        }
      }

      var _iteratorNormalCompletion17 = true;
      var _didIteratorError17 = false;
      var _iteratorError17 = undefined;

      try {
        for (var _iterator17 = this.errors[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
          var error = _step17.value;

          if (_typeof(error.missing) === "object" && error.missing && error.missing[Symbol.iterator]) {
            addAllToSet(this.missingDependencies, error.missing);
          }
        }
      } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
            _iterator17["return"]();
          }
        } finally {
          if (_didIteratorError17) {
            throw _iteratorError17;
          }
        }
      }

      this.fileDependencies.sort();
      this.contextDependencies.sort();
      this.missingDependencies.sort();
    }
  }, {
    key: "createHash",
    value: function createHash() {
      var outputOptions = this.outputOptions;
      var hashFunction = outputOptions.hashFunction;
      var hashDigest = outputOptions.hashDigest;
      var hashDigestLength = outputOptions.hashDigestLength;

      var hash = _createHash(hashFunction);

      if (outputOptions.hashSalt) {
        hash.update(outputOptions.hashSalt);
      }

      this.mainTemplate.updateHash(hash);
      this.chunkTemplate.updateHash(hash);
      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = Object.keys(this.moduleTemplates).sort()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var key = _step18.value;
          this.moduleTemplates[key].updateHash(hash);
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
            _iterator18["return"]();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }

      var _iteratorNormalCompletion19 = true;
      var _didIteratorError19 = false;
      var _iteratorError19 = undefined;

      try {
        for (var _iterator19 = this.children[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
          var child = _step19.value;
          hash.update(child.hash);
        }
      } catch (err) {
        _didIteratorError19 = true;
        _iteratorError19 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
            _iterator19["return"]();
          }
        } finally {
          if (_didIteratorError19) {
            throw _iteratorError19;
          }
        }
      }

      var _iteratorNormalCompletion20 = true;
      var _didIteratorError20 = false;
      var _iteratorError20 = undefined;

      try {
        for (var _iterator20 = this.warnings[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
          var warning = _step20.value;
          hash.update("".concat(warning.message));
        }
      } catch (err) {
        _didIteratorError20 = true;
        _iteratorError20 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
            _iterator20["return"]();
          }
        } finally {
          if (_didIteratorError20) {
            throw _iteratorError20;
          }
        }
      }

      var _iteratorNormalCompletion21 = true;
      var _didIteratorError21 = false;
      var _iteratorError21 = undefined;

      try {
        for (var _iterator21 = this.errors[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
          var error = _step21.value;
          hash.update("".concat(error.message));
        }
      } catch (err) {
        _didIteratorError21 = true;
        _iteratorError21 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
            _iterator21["return"]();
          }
        } finally {
          if (_didIteratorError21) {
            throw _iteratorError21;
          }
        }
      }

      var modules = this.modules;

      for (var i = 0; i < modules.length; i++) {
        var _module5 = modules[i];

        var moduleHash = _createHash(hashFunction);

        _module5.updateHash(moduleHash);

        _module5.hash =
        /** @type {string} */
        moduleHash.digest(hashDigest);
        _module5.renderedHash = _module5.hash.substr(0, hashDigestLength);
      } // clone needed as sort below is inplace mutation


      var chunks = this.chunks.slice();
      /**
       * sort here will bring all "falsy" values to the beginning
       * this is needed as the "hasRuntime()" chunks are dependent on the
       * hashes of the non-runtime chunks.
       */

      chunks.sort(function (a, b) {
        var aEntry = a.hasRuntime();
        var bEntry = b.hasRuntime();
        if (aEntry && !bEntry) return 1;
        if (!aEntry && bEntry) return -1;
        return byId(a, b);
      });

      for (var _i = 0; _i < chunks.length; _i++) {
        var chunk = chunks[_i];

        var chunkHash = _createHash(hashFunction);

        try {
          if (outputOptions.hashSalt) {
            chunkHash.update(outputOptions.hashSalt);
          }

          chunk.updateHash(chunkHash);
          var template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;
          template.updateHashForChunk(chunkHash, chunk, this.moduleTemplates.javascript, this.dependencyTemplates);
          this.hooks.chunkHash.call(chunk, chunkHash);
          chunk.hash =
          /** @type {string} */
          chunkHash.digest(hashDigest);
          hash.update(chunk.hash);
          chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
          this.hooks.contentHash.call(chunk);
        } catch (err) {
          this.errors.push(new ChunkRenderError(chunk, "", err));
        }
      }

      this.fullHash =
      /** @type {string} */
      hash.digest(hashDigest);
      this.hash = this.fullHash.substr(0, hashDigestLength);
    }
    /**
     * @param {string} update extra information
     * @returns {void}
     */

  }, {
    key: "modifyHash",
    value: function modifyHash(update) {
      var outputOptions = this.outputOptions;
      var hashFunction = outputOptions.hashFunction;
      var hashDigest = outputOptions.hashDigest;
      var hashDigestLength = outputOptions.hashDigestLength;

      var hash = _createHash(hashFunction);

      hash.update(this.fullHash);
      hash.update(update);
      this.fullHash =
      /** @type {string} */
      hash.digest(hashDigest);
      this.hash = this.fullHash.substr(0, hashDigestLength);
    }
    /**
     * @param {string} file file name
     * @param {Source} source asset source
     * @param {AssetInfo} assetInfo extra asset information
     * @returns {void}
     */

  }, {
    key: "emitAsset",
    value: function emitAsset(file, source) {
      var assetInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (this.assets[file]) {
        if (!isSourceEqual(this.assets[file], source)) {
          // TODO webpack 5: make this an error instead
          this.warnings.push(new WebpackError("Conflict: Multiple assets emit different content to the same filename ".concat(file)));
          this.assets[file] = source;
          this.assetsInfo.set(file, assetInfo);
          return;
        }

        var oldInfo = this.assetsInfo.get(file);
        this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfo));
        return;
      }

      this.assets[file] = source;
      this.assetsInfo.set(file, assetInfo);
    }
    /**
     * @param {string} file file name
     * @param {Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new
     * @param {AssetInfo | function(AssetInfo | undefined): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new
     */

  }, {
    key: "updateAsset",
    value: function updateAsset(file, newSourceOrFunction) {
      var assetInfoUpdateOrFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (!this.assets[file]) {
        throw new Error("Called Compilation.updateAsset for not existing filename ".concat(file));
      }

      if (typeof newSourceOrFunction === "function") {
        this.assets[file] = newSourceOrFunction(this.assets[file]);
      } else {
        this.assets[file] = newSourceOrFunction;
      }

      if (assetInfoUpdateOrFunction !== undefined) {
        var oldInfo = this.assetsInfo.get(file);

        if (typeof assetInfoUpdateOrFunction === "function") {
          this.assetsInfo.set(file, assetInfoUpdateOrFunction(oldInfo || {}));
        } else {
          this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfoUpdateOrFunction));
        }
      }
    }
  }, {
    key: "getAssets",
    value: function getAssets() {
      /** @type {Asset[]} */
      var array = [];

      for (var _i2 = 0, _Object$keys = Object.keys(this.assets); _i2 < _Object$keys.length; _i2++) {
        var assetName = _Object$keys[_i2];

        if (Object.prototype.hasOwnProperty.call(this.assets, assetName)) {
          array.push({
            name: assetName,
            source: this.assets[assetName],
            info: this.assetsInfo.get(assetName) || {}
          });
        }
      }

      return array;
    }
    /**
     * @param {string} name the name of the asset
     * @returns {Asset | undefined} the asset or undefined when not found
     */

  }, {
    key: "getAsset",
    value: function getAsset(name) {
      if (!Object.prototype.hasOwnProperty.call(this.assets, name)) return undefined;
      return {
        name: name,
        source: this.assets[name],
        info: this.assetsInfo.get(name) || {}
      };
    }
  }, {
    key: "createModuleAssets",
    value: function createModuleAssets() {
      for (var i = 0; i < this.modules.length; i++) {
        var _module6 = this.modules[i];

        if (_module6.buildInfo.assets) {
          var assetsInfo = _module6.buildInfo.assetsInfo;

          for (var _i3 = 0, _Object$keys2 = Object.keys(_module6.buildInfo.assets); _i3 < _Object$keys2.length; _i3++) {
            var assetName = _Object$keys2[_i3];
            var fileName = this.getPath(assetName);
            this.emitAsset(fileName, _module6.buildInfo.assets[assetName], assetsInfo ? assetsInfo.get(assetName) : undefined);
            this.hooks.moduleAsset.call(_module6, fileName);
          }
        }
      }
    }
  }, {
    key: "createChunkAssets",
    value: function createChunkAssets() {
      var outputOptions = this.outputOptions;
      var cachedSourceMap = new Map();
      /** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */

      var alreadyWrittenFiles = new Map();

      for (var i = 0; i < this.chunks.length; i++) {
        var chunk = this.chunks[i];
        chunk.files = [];
        var source = void 0;
        var file = void 0;
        var filenameTemplate = void 0;

        try {
          var template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;
          var manifest = template.getRenderManifest({
            chunk: chunk,
            hash: this.hash,
            fullHash: this.fullHash,
            outputOptions: outputOptions,
            moduleTemplates: this.moduleTemplates,
            dependencyTemplates: this.dependencyTemplates
          }); // [{ render(), filenameTemplate, pathOptions, identifier, hash }]

          var _iteratorNormalCompletion22 = true;
          var _didIteratorError22 = false;
          var _iteratorError22 = undefined;

          try {
            for (var _iterator22 = manifest[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
              var fileManifest = _step22.value;
              var cacheName = fileManifest.identifier;
              var usedHash = fileManifest.hash;
              filenameTemplate = fileManifest.filenameTemplate;
              var pathAndInfo = this.getPathWithInfo(filenameTemplate, fileManifest.pathOptions);
              file = pathAndInfo.path;
              var assetInfo = pathAndInfo.info; // check if the same filename was already written by another chunk

              var alreadyWritten = alreadyWrittenFiles.get(file);

              if (alreadyWritten !== undefined) {
                if (alreadyWritten.hash === usedHash) {
                  if (this.cache) {
                    this.cache[cacheName] = {
                      hash: usedHash,
                      source: alreadyWritten.source
                    };
                  }

                  chunk.files.push(file);
                  this.hooks.chunkAsset.call(chunk, file);
                  continue;
                } else {
                  throw new Error("Conflict: Multiple chunks emit assets to the same filename ".concat(file) + " (chunks ".concat(alreadyWritten.chunk.id, " and ").concat(chunk.id, ")"));
                }
              }

              if (this.cache && this.cache[cacheName] && this.cache[cacheName].hash === usedHash) {
                source = this.cache[cacheName].source;
              } else {
                source = fileManifest.render(); // Ensure that source is a cached source to avoid additional cost because of repeated access

                if (!(source instanceof CachedSource)) {
                  var cacheEntry = cachedSourceMap.get(source);

                  if (cacheEntry) {
                    source = cacheEntry;
                  } else {
                    var cachedSource = new CachedSource(source);
                    cachedSourceMap.set(source, cachedSource);
                    source = cachedSource;
                  }
                }

                if (this.cache) {
                  this.cache[cacheName] = {
                    hash: usedHash,
                    source: source
                  };
                }
              }

              this.emitAsset(file, source, assetInfo);
              chunk.files.push(file);
              this.hooks.chunkAsset.call(chunk, file);
              alreadyWrittenFiles.set(file, {
                hash: usedHash,
                source: source,
                chunk: chunk
              });
            }
          } catch (err) {
            _didIteratorError22 = true;
            _iteratorError22 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
                _iterator22["return"]();
              }
            } finally {
              if (_didIteratorError22) {
                throw _iteratorError22;
              }
            }
          }
        } catch (err) {
          this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));
        }
      }
    }
    /**
     * @param {string} filename used to get asset path with hash
     * @param {TODO=} data // TODO: figure out this param type
     * @returns {string} interpolated path
     */

  }, {
    key: "getPath",
    value: function getPath(filename, data) {
      data = data || {};
      data.hash = data.hash || this.hash;
      return this.mainTemplate.getAssetPath(filename, data);
    }
    /**
     * @param {string} filename used to get asset path with hash
     * @param {TODO=} data // TODO: figure out this param type
     * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info
     */

  }, {
    key: "getPathWithInfo",
    value: function getPathWithInfo(filename, data) {
      data = data || {};
      data.hash = data.hash || this.hash;
      return this.mainTemplate.getAssetPathWithInfo(filename, data);
    }
    /**
     * This function allows you to run another instance of webpack inside of webpack however as
     * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins
     * from parent (or top level compiler) and creates a child Compilation
     *
     * @param {string} name name of the child compiler
     * @param {TODO} outputOptions // Need to convert config schema to types for this
     * @param {Plugin[]} plugins webpack plugins that will be applied
     * @returns {Compiler} creates a child Compiler instance
     */

  }, {
    key: "createChildCompiler",
    value: function createChildCompiler(name, outputOptions, plugins) {
      var idx = this.childrenCounters[name] || 0;
      this.childrenCounters[name] = idx + 1;
      return this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);
    }
  }, {
    key: "checkConstraints",
    value: function checkConstraints() {
      /** @type {Set<number|string>} */
      var usedIds = new Set();
      var modules = this.modules;

      for (var indexModule = 0; indexModule < modules.length; indexModule++) {
        var moduleId = modules[indexModule].id;
        if (moduleId === null) continue;

        if (usedIds.has(moduleId)) {
          throw new Error("checkConstraints: duplicate module id ".concat(moduleId));
        }

        usedIds.add(moduleId);
      }

      var chunks = this.chunks;

      for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
        var chunk = chunks[indexChunk];

        if (chunks.indexOf(chunk) !== indexChunk) {
          throw new Error("checkConstraints: duplicate chunk in compilation ".concat(chunk.debugId));
        }
      }

      var _iteratorNormalCompletion23 = true;
      var _didIteratorError23 = false;
      var _iteratorError23 = undefined;

      try {
        for (var _iterator23 = this.chunkGroups[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
          var chunkGroup = _step23.value;
          chunkGroup.checkConstraints();
        }
      } catch (err) {
        _didIteratorError23 = true;
        _iteratorError23 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
            _iterator23["return"]();
          }
        } finally {
          if (_didIteratorError23) {
            throw _iteratorError23;
          }
        }
      }
    }
  }]);

  return Compilation;
}(Tapable); // TODO remove in webpack 5


Compilation.prototype.applyPlugins = util.deprecate(
/**
 * @deprecated
 * @param {string} name Name
 * @param {any[]} args Other arguments
 * @returns {void}
 * @this {Compilation}
 */
function (name) {
  var _this$hooks$name$repl;

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  (_this$hooks$name$repl = this.hooks[name.replace(/[- ]([a-z])/g, function (match) {
    return match[1].toUpperCase();
  })]).call.apply(_this$hooks$name$repl, args);
}, "Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead"); // TODO remove in webpack 5

Object.defineProperty(Compilation.prototype, "moduleTemplate", {
  configurable: false,
  get: util.deprecate(
  /**
   * @deprecated
   * @this {Compilation}
   * @returns {TODO} module template
   */
  function () {
    return this.moduleTemplates.javascript;
  }, "Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead"),
  set: util.deprecate(
  /**
   * @deprecated
   * @param {ModuleTemplate} value Template value
   * @this {Compilation}
   * @returns {void}
   */
  function (value) {
    this.moduleTemplates.javascript = value;
  }, "Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead.")
});
module.exports = Compilation;