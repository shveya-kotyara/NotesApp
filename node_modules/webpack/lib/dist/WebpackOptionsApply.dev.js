/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var OptionsApply = require("./OptionsApply");

var JavascriptModulesPlugin = require("./JavascriptModulesPlugin");

var JsonModulesPlugin = require("./JsonModulesPlugin");

var WebAssemblyModulesPlugin = require("./wasm/WebAssemblyModulesPlugin");

var LoaderTargetPlugin = require("./LoaderTargetPlugin");

var FunctionModulePlugin = require("./FunctionModulePlugin");

var EvalDevToolModulePlugin = require("./EvalDevToolModulePlugin");

var SourceMapDevToolPlugin = require("./SourceMapDevToolPlugin");

var EvalSourceMapDevToolPlugin = require("./EvalSourceMapDevToolPlugin");

var EntryOptionPlugin = require("./EntryOptionPlugin");

var RecordIdsPlugin = require("./RecordIdsPlugin");

var APIPlugin = require("./APIPlugin");

var ConstPlugin = require("./ConstPlugin");

var CommonJsStuffPlugin = require("./CommonJsStuffPlugin");

var CompatibilityPlugin = require("./CompatibilityPlugin");

var TemplatedPathPlugin = require("./TemplatedPathPlugin");

var WarnCaseSensitiveModulesPlugin = require("./WarnCaseSensitiveModulesPlugin");

var UseStrictPlugin = require("./UseStrictPlugin");

var LoaderPlugin = require("./dependencies/LoaderPlugin");

var CommonJsPlugin = require("./dependencies/CommonJsPlugin");

var HarmonyModulesPlugin = require("./dependencies/HarmonyModulesPlugin");

var SystemPlugin = require("./dependencies/SystemPlugin");

var ImportPlugin = require("./dependencies/ImportPlugin");

var RequireContextPlugin = require("./dependencies/RequireContextPlugin");

var RequireEnsurePlugin = require("./dependencies/RequireEnsurePlugin");

var RequireIncludePlugin = require("./dependencies/RequireIncludePlugin");

var _require = require("./util/cleverMerge"),
    cachedCleverMerge = _require.cachedCleverMerge;
/** @typedef {import("../declarations/WebpackOptions").WebpackOptions} WebpackOptions */

/** @typedef {import("./Compiler")} Compiler */


var WebpackOptionsApply =
/*#__PURE__*/
function (_OptionsApply) {
  _inherits(WebpackOptionsApply, _OptionsApply);

  function WebpackOptionsApply() {
    _classCallCheck(this, WebpackOptionsApply);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebpackOptionsApply).call(this));
  }
  /**
   * @param {WebpackOptions} options options object
   * @param {Compiler} compiler compiler object
   * @returns {WebpackOptions} options object
   */


  _createClass(WebpackOptionsApply, [{
    key: "process",
    value: function process(options, compiler) {
      var ExternalsPlugin;
      compiler.outputPath = options.output.path;
      compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
      compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;
      compiler.name = options.name; // TODO webpack 5 refactor this to MultiCompiler.setDependencies() with a WeakMap
      // @ts-ignore TODO

      compiler.dependencies = options.dependencies;

      if (typeof options.target === "string") {
        var JsonpTemplatePlugin;
        var FetchCompileWasmTemplatePlugin;
        var ReadFileCompileWasmTemplatePlugin;
        var NodeSourcePlugin;
        var NodeTargetPlugin;
        var NodeTemplatePlugin;

        switch (options.target) {
          case "web":
            JsonpTemplatePlugin = require("./web/JsonpTemplatePlugin");
            FetchCompileWasmTemplatePlugin = require("./web/FetchCompileWasmTemplatePlugin");
            NodeSourcePlugin = require("./node/NodeSourcePlugin");
            new JsonpTemplatePlugin().apply(compiler);
            new FetchCompileWasmTemplatePlugin({
              mangleImports: options.optimization.mangleWasmImports
            }).apply(compiler);
            new FunctionModulePlugin().apply(compiler);
            new NodeSourcePlugin(options.node).apply(compiler);
            new LoaderTargetPlugin(options.target).apply(compiler);
            break;

          case "webworker":
            {
              var WebWorkerTemplatePlugin = require("./webworker/WebWorkerTemplatePlugin");

              FetchCompileWasmTemplatePlugin = require("./web/FetchCompileWasmTemplatePlugin");
              NodeSourcePlugin = require("./node/NodeSourcePlugin");
              new WebWorkerTemplatePlugin().apply(compiler);
              new FetchCompileWasmTemplatePlugin({
                mangleImports: options.optimization.mangleWasmImports
              }).apply(compiler);
              new FunctionModulePlugin().apply(compiler);
              new NodeSourcePlugin(options.node).apply(compiler);
              new LoaderTargetPlugin(options.target).apply(compiler);
              break;
            }

          case "node":
          case "async-node":
            NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
            ReadFileCompileWasmTemplatePlugin = require("./node/ReadFileCompileWasmTemplatePlugin");
            NodeTargetPlugin = require("./node/NodeTargetPlugin");
            new NodeTemplatePlugin({
              asyncChunkLoading: options.target === "async-node"
            }).apply(compiler);
            new ReadFileCompileWasmTemplatePlugin({
              mangleImports: options.optimization.mangleWasmImports
            }).apply(compiler);
            new FunctionModulePlugin().apply(compiler);
            new NodeTargetPlugin().apply(compiler);
            new LoaderTargetPlugin("node").apply(compiler);
            break;

          case "node-webkit":
            JsonpTemplatePlugin = require("./web/JsonpTemplatePlugin");
            NodeTargetPlugin = require("./node/NodeTargetPlugin");
            ExternalsPlugin = require("./ExternalsPlugin");
            new JsonpTemplatePlugin().apply(compiler);
            new FunctionModulePlugin().apply(compiler);
            new NodeTargetPlugin().apply(compiler);
            new ExternalsPlugin("commonjs", "nw.gui").apply(compiler);
            new LoaderTargetPlugin(options.target).apply(compiler);
            break;

          case "electron-main":
            NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
            NodeTargetPlugin = require("./node/NodeTargetPlugin");
            ExternalsPlugin = require("./ExternalsPlugin");
            new NodeTemplatePlugin({
              asyncChunkLoading: true
            }).apply(compiler);
            new FunctionModulePlugin().apply(compiler);
            new NodeTargetPlugin().apply(compiler);
            new ExternalsPlugin("commonjs", ["app", "auto-updater", "browser-window", "clipboard", "content-tracing", "crash-reporter", "dialog", "electron", "global-shortcut", "ipc", "ipc-main", "menu", "menu-item", "native-image", "original-fs", "power-monitor", "power-save-blocker", "protocol", "screen", "session", "shell", "tray", "web-contents"]).apply(compiler);
            new LoaderTargetPlugin(options.target).apply(compiler);
            break;

          case "electron-renderer":
          case "electron-preload":
            FetchCompileWasmTemplatePlugin = require("./web/FetchCompileWasmTemplatePlugin");
            NodeTargetPlugin = require("./node/NodeTargetPlugin");
            ExternalsPlugin = require("./ExternalsPlugin");

            if (options.target === "electron-renderer") {
              JsonpTemplatePlugin = require("./web/JsonpTemplatePlugin");
              new JsonpTemplatePlugin().apply(compiler);
            } else if (options.target === "electron-preload") {
              NodeTemplatePlugin = require("./node/NodeTemplatePlugin");
              new NodeTemplatePlugin({
                asyncChunkLoading: true
              }).apply(compiler);
            }

            new FetchCompileWasmTemplatePlugin({
              mangleImports: options.optimization.mangleWasmImports
            }).apply(compiler);
            new FunctionModulePlugin().apply(compiler);
            new NodeTargetPlugin().apply(compiler);
            new ExternalsPlugin("commonjs", ["clipboard", "crash-reporter", "desktop-capturer", "electron", "ipc", "ipc-renderer", "native-image", "original-fs", "remote", "screen", "shell", "web-frame"]).apply(compiler);
            new LoaderTargetPlugin(options.target).apply(compiler);
            break;

          default:
            throw new Error("Unsupported target '" + options.target + "'.");
        }
      } // @ts-ignore This is always true, which is good this way
      else if (options.target !== false) {
          options.target(compiler);
        } else {
          throw new Error("Unsupported target '" + options.target + "'.");
        }

      if (options.output.library || options.output.libraryTarget !== "var") {
        var LibraryTemplatePlugin = require("./LibraryTemplatePlugin");

        new LibraryTemplatePlugin(options.output.library, options.output.libraryTarget, options.output.umdNamedDefine, options.output.auxiliaryComment || "", options.output.libraryExport).apply(compiler);
      }

      if (options.externals) {
        ExternalsPlugin = require("./ExternalsPlugin");
        new ExternalsPlugin(options.output.libraryTarget, options.externals).apply(compiler);
      }

      var noSources;
      var legacy;
      var modern;
      var comment;

      if (options.devtool && (options.devtool.includes("sourcemap") || options.devtool.includes("source-map"))) {
        var hidden = options.devtool.includes("hidden");
        var inline = options.devtool.includes("inline");
        var evalWrapped = options.devtool.includes("eval");
        var cheap = options.devtool.includes("cheap");
        var moduleMaps = options.devtool.includes("module");
        noSources = options.devtool.includes("nosources");
        legacy = options.devtool.includes("@");
        modern = options.devtool.includes("#");
        comment = legacy && modern ? "\n/*\n//@ source" + "MappingURL=[url]\n//# source" + "MappingURL=[url]\n*/" : legacy ? "\n/*\n//@ source" + "MappingURL=[url]\n*/" : modern ? "\n//# source" + "MappingURL=[url]" : null;
        var Plugin = evalWrapped ? EvalSourceMapDevToolPlugin : SourceMapDevToolPlugin;
        new Plugin({
          filename: inline ? null : options.output.sourceMapFilename,
          moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
          fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,
          append: hidden ? false : comment,
          module: moduleMaps ? true : cheap ? false : true,
          columns: cheap ? false : true,
          lineToLine: options.output.devtoolLineToLine,
          noSources: noSources,
          namespace: options.output.devtoolNamespace
        }).apply(compiler);
      } else if (options.devtool && options.devtool.includes("eval")) {
        legacy = options.devtool.includes("@");
        modern = options.devtool.includes("#");
        comment = legacy && modern ? "\n//@ sourceURL=[url]\n//# sourceURL=[url]" : legacy ? "\n//@ sourceURL=[url]" : modern ? "\n//# sourceURL=[url]" : null;
        new EvalDevToolModulePlugin({
          sourceUrlComment: comment,
          moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
          namespace: options.output.devtoolNamespace
        }).apply(compiler);
      }

      new JavascriptModulesPlugin().apply(compiler);
      new JsonModulesPlugin().apply(compiler);
      new WebAssemblyModulesPlugin({
        mangleImports: options.optimization.mangleWasmImports
      }).apply(compiler);
      new EntryOptionPlugin().apply(compiler);
      compiler.hooks.entryOption.call(options.context, options.entry);
      new CompatibilityPlugin().apply(compiler);
      new HarmonyModulesPlugin(options.module).apply(compiler);

      if (options.amd !== false) {
        var AMDPlugin = require("./dependencies/AMDPlugin");

        var RequireJsStuffPlugin = require("./RequireJsStuffPlugin");

        new AMDPlugin(options.module, options.amd || {}).apply(compiler);
        new RequireJsStuffPlugin().apply(compiler);
      }

      new CommonJsPlugin(options.module).apply(compiler);
      new LoaderPlugin().apply(compiler);

      if (options.node !== false) {
        var NodeStuffPlugin = require("./NodeStuffPlugin");

        new NodeStuffPlugin(options.node).apply(compiler);
      }

      new CommonJsStuffPlugin().apply(compiler);
      new APIPlugin().apply(compiler);
      new ConstPlugin().apply(compiler);
      new UseStrictPlugin().apply(compiler);
      new RequireIncludePlugin().apply(compiler);
      new RequireEnsurePlugin().apply(compiler);
      new RequireContextPlugin(options.resolve.modules, options.resolve.extensions, options.resolve.mainFiles).apply(compiler);
      new ImportPlugin(options.module).apply(compiler);
      new SystemPlugin(options.module).apply(compiler);

      if (typeof options.mode !== "string") {
        var WarnNoModeSetPlugin = require("./WarnNoModeSetPlugin");

        new WarnNoModeSetPlugin().apply(compiler);
      }

      var EnsureChunkConditionsPlugin = require("./optimize/EnsureChunkConditionsPlugin");

      new EnsureChunkConditionsPlugin().apply(compiler);

      if (options.optimization.removeAvailableModules) {
        var RemoveParentModulesPlugin = require("./optimize/RemoveParentModulesPlugin");

        new RemoveParentModulesPlugin().apply(compiler);
      }

      if (options.optimization.removeEmptyChunks) {
        var RemoveEmptyChunksPlugin = require("./optimize/RemoveEmptyChunksPlugin");

        new RemoveEmptyChunksPlugin().apply(compiler);
      }

      if (options.optimization.mergeDuplicateChunks) {
        var MergeDuplicateChunksPlugin = require("./optimize/MergeDuplicateChunksPlugin");

        new MergeDuplicateChunksPlugin().apply(compiler);
      }

      if (options.optimization.flagIncludedChunks) {
        var FlagIncludedChunksPlugin = require("./optimize/FlagIncludedChunksPlugin");

        new FlagIncludedChunksPlugin().apply(compiler);
      }

      if (options.optimization.sideEffects) {
        var SideEffectsFlagPlugin = require("./optimize/SideEffectsFlagPlugin");

        new SideEffectsFlagPlugin().apply(compiler);
      }

      if (options.optimization.providedExports) {
        var FlagDependencyExportsPlugin = require("./FlagDependencyExportsPlugin");

        new FlagDependencyExportsPlugin().apply(compiler);
      }

      if (options.optimization.usedExports) {
        var FlagDependencyUsagePlugin = require("./FlagDependencyUsagePlugin");

        new FlagDependencyUsagePlugin().apply(compiler);
      }

      if (options.optimization.concatenateModules) {
        var ModuleConcatenationPlugin = require("./optimize/ModuleConcatenationPlugin");

        new ModuleConcatenationPlugin().apply(compiler);
      }

      if (options.optimization.splitChunks) {
        var SplitChunksPlugin = require("./optimize/SplitChunksPlugin");

        new SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
      }

      if (options.optimization.runtimeChunk) {
        var RuntimeChunkPlugin = require("./optimize/RuntimeChunkPlugin");

        new RuntimeChunkPlugin(options.optimization.runtimeChunk).apply(compiler);
      }

      if (options.optimization.noEmitOnErrors) {
        var NoEmitOnErrorsPlugin = require("./NoEmitOnErrorsPlugin");

        new NoEmitOnErrorsPlugin().apply(compiler);
      }

      if (options.optimization.checkWasmTypes) {
        var WasmFinalizeExportsPlugin = require("./wasm/WasmFinalizeExportsPlugin");

        new WasmFinalizeExportsPlugin().apply(compiler);
      }

      var moduleIds = options.optimization.moduleIds;

      if (moduleIds === undefined) {
        // TODO webpack 5 remove all these options
        if (options.optimization.occurrenceOrder) {
          moduleIds = "size";
        }

        if (options.optimization.namedModules) {
          moduleIds = "named";
        }

        if (options.optimization.hashedModuleIds) {
          moduleIds = "hashed";
        }

        if (moduleIds === undefined) {
          moduleIds = "natural";
        }
      }

      if (moduleIds) {
        var NamedModulesPlugin = require("./NamedModulesPlugin");

        var HashedModuleIdsPlugin = require("./HashedModuleIdsPlugin");

        var OccurrenceModuleOrderPlugin = require("./optimize/OccurrenceModuleOrderPlugin");

        switch (moduleIds) {
          case "natural":
            // TODO webpack 5: see hint in Compilation.sortModules
            break;

          case "named":
            new NamedModulesPlugin().apply(compiler);
            break;

          case "hashed":
            new HashedModuleIdsPlugin().apply(compiler);
            break;

          case "size":
            new OccurrenceModuleOrderPlugin({
              prioritiseInitial: true
            }).apply(compiler);
            break;

          case "total-size":
            new OccurrenceModuleOrderPlugin({
              prioritiseInitial: false
            }).apply(compiler);
            break;

          default:
            throw new Error("webpack bug: moduleIds: ".concat(moduleIds, " is not implemented"));
        }
      }

      var chunkIds = options.optimization.chunkIds;

      if (chunkIds === undefined) {
        // TODO webpack 5 remove all these options
        if (options.optimization.occurrenceOrder) {
          // This looks weird but it's for backward-compat
          // This bug already existed before adding this feature
          chunkIds = "total-size";
        }

        if (options.optimization.namedChunks) {
          chunkIds = "named";
        }

        if (chunkIds === undefined) {
          chunkIds = "natural";
        }
      }

      if (chunkIds) {
        var NaturalChunkOrderPlugin = require("./optimize/NaturalChunkOrderPlugin");

        var NamedChunksPlugin = require("./NamedChunksPlugin");

        var OccurrenceChunkOrderPlugin = require("./optimize/OccurrenceChunkOrderPlugin");

        switch (chunkIds) {
          case "natural":
            new NaturalChunkOrderPlugin().apply(compiler);
            break;

          case "named":
            // TODO webapck 5: for backward-compat this need to have OccurrenceChunkOrderPlugin too
            // The NamedChunksPlugin doesn't give every chunk a name
            // This should be fixed, and the OccurrenceChunkOrderPlugin should be removed here.
            new OccurrenceChunkOrderPlugin({
              prioritiseInitial: false
            }).apply(compiler);
            new NamedChunksPlugin().apply(compiler);
            break;

          case "size":
            new OccurrenceChunkOrderPlugin({
              prioritiseInitial: true
            }).apply(compiler);
            break;

          case "total-size":
            new OccurrenceChunkOrderPlugin({
              prioritiseInitial: false
            }).apply(compiler);
            break;

          default:
            throw new Error("webpack bug: chunkIds: ".concat(chunkIds, " is not implemented"));
        }
      }

      if (options.optimization.nodeEnv) {
        var DefinePlugin = require("./DefinePlugin");

        new DefinePlugin({
          "process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
        }).apply(compiler);
      }

      if (options.optimization.minimize) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = options.optimization.minimizer[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var minimizer = _step.value;

            if (typeof minimizer === "function") {
              minimizer.call(compiler, compiler);
            } else {
              minimizer.apply(compiler);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      if (options.performance) {
        var SizeLimitsPlugin = require("./performance/SizeLimitsPlugin");

        new SizeLimitsPlugin(options.performance).apply(compiler);
      }

      new TemplatedPathPlugin().apply(compiler);
      new RecordIdsPlugin({
        portableIds: options.optimization.portableRecords
      }).apply(compiler);
      new WarnCaseSensitiveModulesPlugin().apply(compiler);

      if (options.cache) {
        var CachePlugin = require("./CachePlugin");

        new CachePlugin(_typeof(options.cache) === "object" ? options.cache : null).apply(compiler);
      }

      compiler.hooks.afterPlugins.call(compiler);

      if (!compiler.inputFileSystem) {
        throw new Error("No input filesystem provided");
      }

      compiler.resolverFactory.hooks.resolveOptions["for"]("normal").tap("WebpackOptionsApply", function (resolveOptions) {
        return Object.assign({
          fileSystem: compiler.inputFileSystem
        }, cachedCleverMerge(options.resolve, resolveOptions));
      });
      compiler.resolverFactory.hooks.resolveOptions["for"]("context").tap("WebpackOptionsApply", function (resolveOptions) {
        return Object.assign({
          fileSystem: compiler.inputFileSystem,
          resolveToContext: true
        }, cachedCleverMerge(options.resolve, resolveOptions));
      });
      compiler.resolverFactory.hooks.resolveOptions["for"]("loader").tap("WebpackOptionsApply", function (resolveOptions) {
        return Object.assign({
          fileSystem: compiler.inputFileSystem
        }, cachedCleverMerge(options.resolveLoader, resolveOptions));
      });
      compiler.hooks.afterResolvers.call(compiler);
      return options;
    }
  }]);

  return WebpackOptionsApply;
}(OptionsApply);

module.exports = WebpackOptionsApply;