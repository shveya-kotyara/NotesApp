/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Gajus Kuizinas @gajus
*/
"use strict";

var Ajv = require("ajv");

var ajv = new Ajv({
  errorDataPath: "configuration",
  allErrors: true,
  verbose: true
});

require("ajv-keywords")(ajv, ["instanceof"]);

require("../schemas/ajv.absolutePath")(ajv);

var validateSchema = function validateSchema(schema, options) {
  if (Array.isArray(options)) {
    var errors = options.map(function (options) {
      return validateObject(schema, options);
    });
    errors.forEach(function (list, idx) {
      var applyPrefix = function applyPrefix(err) {
        err.dataPath = "[".concat(idx, "]").concat(err.dataPath);

        if (err.children) {
          err.children.forEach(applyPrefix);
        }
      };

      list.forEach(applyPrefix);
    });
    return errors.reduce(function (arr, items) {
      return arr.concat(items);
    }, []);
  } else {
    return validateObject(schema, options);
  }
};

var validateObject = function validateObject(schema, options) {
  var validate = ajv.compile(schema);
  var valid = validate(options);
  return valid ? [] : filterErrors(validate.errors);
};

var filterErrors = function filterErrors(errors) {
  var newErrors = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var err = _step.value;
      var dataPath = err.dataPath;
      var children = [];
      newErrors = newErrors.filter(function (oldError) {
        if (oldError.dataPath.includes(dataPath)) {
          if (oldError.children) {
            children = children.concat(oldError.children.slice(0));
          }

          oldError.children = undefined;
          children.push(oldError);
          return false;
        }

        return true;
      });

      if (children.length) {
        err.children = children;
      }

      newErrors.push(err);
    };

    for (var _iterator = errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return newErrors;
};

module.exports = validateSchema;