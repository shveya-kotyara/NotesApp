/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require("webpack-sources"),
    RawSource = _require.RawSource,
    ReplaceSource = _require.ReplaceSource; // TODO: clean up this file
// replace with newer constructs
// TODO: remove DependencyVariables and replace them with something better


var JavascriptGenerator =
/*#__PURE__*/
function () {
  function JavascriptGenerator() {
    _classCallCheck(this, JavascriptGenerator);
  }

  _createClass(JavascriptGenerator, [{
    key: "generate",
    value: function generate(module, dependencyTemplates, runtimeTemplate) {
      var originalSource = module.originalSource();

      if (!originalSource) {
        return new RawSource("throw new Error('No source available');");
      }

      var source = new ReplaceSource(originalSource);
      this.sourceBlock(module, module, [], dependencyTemplates, source, runtimeTemplate);
      return source;
    }
  }, {
    key: "sourceBlock",
    value: function sourceBlock(module, block, availableVars, dependencyTemplates, source, runtimeTemplate) {
      var _this = this;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = block.dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dependency = _step.value;
          this.sourceDependency(dependency, dependencyTemplates, source, runtimeTemplate);
        }
        /**
         * Get the variables of all blocks that we need to inject.
         * These will contain the variable name and its expression.
         * The name will be added as a parameter in a IIFE the expression as its value.
         */

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var vars = block.variables.reduce(function (result, value) {
        var variable = _this.sourceVariables(value, availableVars, dependencyTemplates, runtimeTemplate);

        if (variable) {
          result.push(variable);
        }

        return result;
      }, []);
      /**
       * if we actually have variables
       * this is important as how #splitVariablesInUniqueNamedChunks works
       * it will always return an array in an array which would lead to a IIFE wrapper around
       * a module if we do this with an empty vars array.
       */

      if (vars.length > 0) {
        /**
         * Split all variables up into chunks of unique names.
         * e.g. imagine you have the following variable names that need to be injected:
         * [foo, bar, baz, foo, some, more]
         * we can not inject "foo" twice, therefore we just make two IIFEs like so:
         * (function(foo, bar, baz){
         *   (function(foo, some, more){
         *     …
         *   }(…));
         * }(…));
         *
         * "splitVariablesInUniqueNamedChunks" splits the variables shown above up to this:
         * [[foo, bar, baz], [foo, some, more]]
         */
        var injectionVariableChunks = this.splitVariablesInUniqueNamedChunks(vars); // create all the beginnings of IIFEs

        var functionWrapperStarts = injectionVariableChunks.map(function (variableChunk) {
          return _this.variableInjectionFunctionWrapperStartCode(variableChunk.map(function (variable) {
            return variable.name;
          }));
        }); // and all the ends

        var functionWrapperEnds = injectionVariableChunks.map(function (variableChunk) {
          return _this.variableInjectionFunctionWrapperEndCode(module, variableChunk.map(function (variable) {
            return variable.expression;
          }), block);
        }); // join them to one big string

        var varStartCode = functionWrapperStarts.join(""); // reverse the ends first before joining them, as the last added must be the inner most

        var varEndCode = functionWrapperEnds.reverse().join(""); // if we have anything, add it to the source

        if (varStartCode && varEndCode) {
          var start = block.range ? block.range[0] : -10;
          var end = block.range ? block.range[1] : module.originalSource().size() + 1;
          source.insert(start + 0.5, varStartCode);
          source.insert(end + 0.5, "\n/* WEBPACK VAR INJECTION */" + varEndCode);
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = block.blocks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var childBlock = _step2.value;
          this.sourceBlock(module, childBlock, availableVars.concat(vars), dependencyTemplates, source, runtimeTemplate);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "sourceDependency",
    value: function sourceDependency(dependency, dependencyTemplates, source, runtimeTemplate) {
      var template = dependencyTemplates.get(dependency.constructor);

      if (!template) {
        throw new Error("No template for dependency: " + dependency.constructor.name);
      }

      template.apply(dependency, source, runtimeTemplate, dependencyTemplates);
    }
  }, {
    key: "sourceVariables",
    value: function sourceVariables(variable, availableVars, dependencyTemplates, runtimeTemplate) {
      var name = variable.name;
      var expr = variable.expressionSource(dependencyTemplates, runtimeTemplate);

      if (availableVars.some(function (v) {
        return v.name === name && v.expression.source() === expr.source();
      })) {
        return;
      }

      return {
        name: name,
        expression: expr
      };
    }
    /*
     * creates the start part of a IIFE around the module to inject a variable name
     * (function(…){   <- this part
     * }.call(…))
     */

  }, {
    key: "variableInjectionFunctionWrapperStartCode",
    value: function variableInjectionFunctionWrapperStartCode(varNames) {
      var args = varNames.join(", ");
      return "/* WEBPACK VAR INJECTION */(function(".concat(args, ") {");
    }
  }, {
    key: "contextArgument",
    value: function contextArgument(module, block) {
      if (this === block) {
        return module.exportsArgument;
      }

      return "this";
    }
    /*
     * creates the end part of a IIFE around the module to inject a variable name
     * (function(…){
     * }.call(…))   <- this part
     */

  }, {
    key: "variableInjectionFunctionWrapperEndCode",
    value: function variableInjectionFunctionWrapperEndCode(module, varExpressions, block) {
      var firstParam = this.contextArgument(module, block);
      var furtherParams = varExpressions.map(function (e) {
        return e.source();
      }).join(", ");
      return "}.call(".concat(firstParam, ", ").concat(furtherParams, "))");
    }
  }, {
    key: "splitVariablesInUniqueNamedChunks",
    value: function splitVariablesInUniqueNamedChunks(vars) {
      var startState = [[]];
      return vars.reduce(function (chunks, variable) {
        var current = chunks[chunks.length - 1]; // check if variable with same name exists already
        // if so create a new chunk of variables.

        var variableNameAlreadyExists = current.some(function (v) {
          return v.name === variable.name;
        });

        if (variableNameAlreadyExists) {
          // start new chunk with current variable
          chunks.push([variable]);
        } else {
          // else add it to current chunk
          current.push(variable);
        }

        return chunks;
      }, startState);
    }
  }]);

  return JavascriptGenerator;
}();

module.exports = JavascriptGenerator;