/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ConstDependency = require("./dependencies/ConstDependency");

var NullFactory = require("./NullFactory");

var ParserHelpers = require("./ParserHelpers");

var getQuery = function getQuery(request) {
  var i = request.indexOf("?");
  return i !== -1 ? request.substr(i) : "";
};

var collectDeclaration = function collectDeclaration(declarations, pattern) {
  var stack = [pattern];

  while (stack.length > 0) {
    var node = stack.pop();

    switch (node.type) {
      case "Identifier":
        declarations.add(node.name);
        break;

      case "ArrayPattern":
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = node.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var element = _step.value;

            if (element) {
              stack.push(element);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        break;

      case "AssignmentPattern":
        stack.push(node.left);
        break;

      case "ObjectPattern":
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var property = _step2.value;
            stack.push(property.value);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        break;

      case "RestElement":
        stack.push(node.argument);
        break;
    }
  }
};

var getHoistedDeclarations = function getHoistedDeclarations(branch, includeFunctionDeclarations) {
  var declarations = new Set();
  var stack = [branch];

  while (stack.length > 0) {
    var node = stack.pop(); // Some node could be `null` or `undefined`.

    if (!node) continue;

    switch (node.type) {
      // Walk through control statements to look for hoisted declarations.
      // Some branches are skipped since they do not allow declarations.
      case "BlockStatement":
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = node.body[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var stmt = _step3.value;
            stack.push(stmt);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        break;

      case "IfStatement":
        stack.push(node.consequent);
        stack.push(node.alternate);
        break;

      case "ForStatement":
        stack.push(node.init);
        stack.push(node.body);
        break;

      case "ForInStatement":
      case "ForOfStatement":
        stack.push(node.left);
        stack.push(node.body);
        break;

      case "DoWhileStatement":
      case "WhileStatement":
      case "LabeledStatement":
        stack.push(node.body);
        break;

      case "SwitchStatement":
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = node.cases[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var cs = _step4.value;
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = cs.consequent[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var consequent = _step5.value;
                stack.push(consequent);
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                  _iterator5["return"]();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        break;

      case "TryStatement":
        stack.push(node.block);

        if (node.handler) {
          stack.push(node.handler.body);
        }

        stack.push(node.finalizer);
        break;

      case "FunctionDeclaration":
        if (includeFunctionDeclarations) {
          collectDeclaration(declarations, node.id);
        }

        break;

      case "VariableDeclaration":
        if (node.kind === "var") {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = node.declarations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var decl = _step6.value;
              collectDeclaration(declarations, decl.id);
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }

        break;
    }
  }

  return Array.from(declarations);
};

var ConstPlugin =
/*#__PURE__*/
function () {
  function ConstPlugin() {
    _classCallCheck(this, ConstPlugin);
  }

  _createClass(ConstPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      compiler.hooks.compilation.tap("ConstPlugin", function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;
        compilation.dependencyFactories.set(ConstDependency, new NullFactory());
        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

        var handler = function handler(parser) {
          parser.hooks.statementIf.tap("ConstPlugin", function (statement) {
            if (parser.scope.isAsmJs) return;
            var param = parser.evaluateExpression(statement.test);
            var bool = param.asBool();

            if (typeof bool === "boolean") {
              if (statement.test.type !== "Literal") {
                var dep = new ConstDependency("".concat(bool), param.range);
                dep.loc = statement.loc;
                parser.state.current.addDependency(dep);
              }

              var branchToRemove = bool ? statement.alternate : statement.consequent;

              if (branchToRemove) {
                // Before removing the dead branch, the hoisted declarations
                // must be collected.
                //
                // Given the following code:
                //
                //     if (true) f() else g()
                //     if (false) {
                //       function f() {}
                //       const g = function g() {}
                //       if (someTest) {
                //         let a = 1
                //         var x, {y, z} = obj
                //       }
                //     } else {
                //       …
                //     }
                //
                // the generated code is:
                //
                //     if (true) f() else {}
                //     if (false) {
                //       var f, x, y, z;   (in loose mode)
                //       var x, y, z;      (in strict mode)
                //     } else {
                //       …
                //     }
                //
                // NOTE: When code runs in strict mode, `var` declarations
                // are hoisted but `function` declarations don't.
                //
                var declarations;

                if (parser.scope.isStrict) {
                  // If the code runs in strict mode, variable declarations
                  // using `var` must be hoisted.
                  declarations = getHoistedDeclarations(branchToRemove, false);
                } else {
                  // Otherwise, collect all hoisted declaration.
                  declarations = getHoistedDeclarations(branchToRemove, true);
                }

                var replacement;

                if (declarations.length > 0) {
                  replacement = "{ var ".concat(declarations.join(", "), "; }");
                } else {
                  replacement = "{}";
                }

                var _dep = new ConstDependency(replacement, branchToRemove.range);

                _dep.loc = branchToRemove.loc;
                parser.state.current.addDependency(_dep);
              }

              return bool;
            }
          });
          parser.hooks.expressionConditionalOperator.tap("ConstPlugin", function (expression) {
            if (parser.scope.isAsmJs) return;
            var param = parser.evaluateExpression(expression.test);
            var bool = param.asBool();

            if (typeof bool === "boolean") {
              if (expression.test.type !== "Literal") {
                var _dep2 = new ConstDependency(" ".concat(bool), param.range);

                _dep2.loc = expression.loc;
                parser.state.current.addDependency(_dep2);
              } // Expressions do not hoist.
              // It is safe to remove the dead branch.
              //
              // Given the following code:
              //
              //   false ? someExpression() : otherExpression();
              //
              // the generated code is:
              //
              //   false ? undefined : otherExpression();
              //


              var branchToRemove = bool ? expression.alternate : expression.consequent;
              var dep = new ConstDependency("undefined", branchToRemove.range);
              dep.loc = branchToRemove.loc;
              parser.state.current.addDependency(dep);
              return bool;
            }
          });
          parser.hooks.expressionLogicalOperator.tap("ConstPlugin", function (expression) {
            if (parser.scope.isAsmJs) return;

            if (expression.operator === "&&" || expression.operator === "||") {
              var param = parser.evaluateExpression(expression.left);
              var bool = param.asBool();

              if (typeof bool === "boolean") {
                // Expressions do not hoist.
                // It is safe to remove the dead branch.
                //
                // ------------------------------------------
                //
                // Given the following code:
                //
                //   falsyExpression() && someExpression();
                //
                // the generated code is:
                //
                //   falsyExpression() && false;
                //
                // ------------------------------------------
                //
                // Given the following code:
                //
                //   truthyExpression() && someExpression();
                //
                // the generated code is:
                //
                //   true && someExpression();
                //
                // ------------------------------------------
                //
                // Given the following code:
                //
                //   truthyExpression() || someExpression();
                //
                // the generated code is:
                //
                //   truthyExpression() || false;
                //
                // ------------------------------------------
                //
                // Given the following code:
                //
                //   falsyExpression() || someExpression();
                //
                // the generated code is:
                //
                //   false && someExpression();
                //
                var keepRight = expression.operator === "&&" && bool || expression.operator === "||" && !bool;

                if (param.isBoolean() || keepRight) {
                  // for case like
                  //
                  //   return'development'===process.env.NODE_ENV&&'foo'
                  //
                  // we need a space before the bool to prevent result like
                  //
                  //   returnfalse&&'foo'
                  //
                  var dep = new ConstDependency(" ".concat(bool), param.range);
                  dep.loc = expression.loc;
                  parser.state.current.addDependency(dep);
                } else {
                  parser.walkExpression(expression.left);
                }

                if (!keepRight) {
                  var _dep3 = new ConstDependency("false", expression.right.range);

                  _dep3.loc = expression.loc;
                  parser.state.current.addDependency(_dep3);
                }

                return keepRight;
              }
            }
          });
          parser.hooks.evaluateIdentifier["for"]("__resourceQuery").tap("ConstPlugin", function (expr) {
            if (parser.scope.isAsmJs) return;
            if (!parser.state.module) return;
            return ParserHelpers.evaluateToString(getQuery(parser.state.module.resource))(expr);
          });
          parser.hooks.expression["for"]("__resourceQuery").tap("ConstPlugin", function () {
            if (parser.scope.isAsmJs) return;
            if (!parser.state.module) return;
            parser.state.current.addVariable("__resourceQuery", JSON.stringify(getQuery(parser.state.module.resource)));
            return true;
          });
        };

        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("ConstPlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/dynamic").tap("ConstPlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/esm").tap("ConstPlugin", handler);
      });
    }
  }]);

  return ConstPlugin;
}();

module.exports = ConstPlugin;