/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Jason Anderson @diurnalist
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var REGEXP_HASH = /\[hash(?::(\d+))?\]/gi,
    REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/gi,
    REGEXP_MODULEHASH = /\[modulehash(?::(\d+))?\]/gi,
    REGEXP_CONTENTHASH = /\[contenthash(?::(\d+))?\]/gi,
    REGEXP_NAME = /\[name\]/gi,
    REGEXP_ID = /\[id\]/gi,
    REGEXP_MODULEID = /\[moduleid\]/gi,
    REGEXP_FILE = /\[file\]/gi,
    REGEXP_QUERY = /\[query\]/gi,
    REGEXP_FILEBASE = /\[filebase\]/gi,
    REGEXP_URL = /\[url\]/gi; // Using global RegExp for .test is dangerous
// We use a normal RegExp instead of .test

var REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, "i"),
    REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, "i"),
    REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, "i"),
    REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, "i");

var withHashLength = function withHashLength(replacer, handlerFn, assetInfo) {
  var fn = function fn(match, hashLength) {
    if (assetInfo) assetInfo.immutable = true;
    var length = hashLength && parseInt(hashLength, 10);

    if (length && handlerFn) {
      return handlerFn(length);
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var hash = replacer.apply(void 0, [match, hashLength].concat(args));
    return length ? hash.slice(0, length) : hash;
  };

  return fn;
};

var getReplacer = function getReplacer(value, allowEmpty) {
  var fn = function fn(match) {
    var _ref;

    // last argument in replacer is the entire input string
    var input = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);

    if (value === null || value === undefined) {
      if (!allowEmpty) {
        throw new Error("Path variable ".concat(match, " not implemented in this context: ").concat(input));
      }

      return "";
    } else {
      return "".concat(escapePathVariables(value));
    }
  };

  return fn;
};

var escapePathVariables = function escapePathVariables(value) {
  return typeof value === "string" ? value.replace(/\[(\\*[\w:]+\\*)\]/gi, "[\\$1\\]") : value;
};

var replacePathVariables = function replacePathVariables(path, data, assetInfo) {
  var chunk = data.chunk;
  var chunkId = chunk && chunk.id;
  var chunkName = chunk && (chunk.name || chunk.id);
  var chunkHash = chunk && (chunk.renderedHash || chunk.hash);
  var chunkHashWithLength = chunk && chunk.hashWithLength;
  var contentHashType = data.contentHashType;
  var contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;
  var contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;
  var module = data.module;
  var moduleId = module && module.id;
  var moduleHash = module && (module.renderedHash || module.hash);
  var moduleHashWithLength = module && module.hashWithLength;

  if (typeof path === "function") {
    path = path(data);
  }

  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {
    throw new Error("Cannot use [chunkhash] or [contenthash] for chunk in '".concat(path, "' (use [hash] instead)"));
  }

  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength, assetInfo)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename)) // query is optional, it's OK if it's in a path but there's nothing to replace it with
  .replace(REGEXP_QUERY, getReplacer(data.query, true)) // only available in sourceMappingURLComment
  .replace(REGEXP_URL, getReplacer(data.url)).replace(/\[\\(\\*[\w:]+\\*)\\\]/gi, "[$1]");
};

var TemplatedPathPlugin =
/*#__PURE__*/
function () {
  function TemplatedPathPlugin() {
    _classCallCheck(this, TemplatedPathPlugin);
  }

  _createClass(TemplatedPathPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      compiler.hooks.compilation.tap("TemplatedPathPlugin", function (compilation) {
        var mainTemplate = compilation.mainTemplate;
        mainTemplate.hooks.assetPath.tap("TemplatedPathPlugin", replacePathVariables);
        mainTemplate.hooks.globalHash.tap("TemplatedPathPlugin", function (chunk, paths) {
          var outputOptions = mainTemplate.outputOptions;
          var publicPath = outputOptions.publicPath || "";
          var filename = outputOptions.filename || "";
          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;
          if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;
          if (REGEXP_HASH_FOR_TEST.test(filename)) return true;
          if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;
          if (REGEXP_HASH_FOR_TEST.test(paths.join("|"))) return true;
        });
        mainTemplate.hooks.hashForChunk.tap("TemplatedPathPlugin", function (hash, chunk) {
          var outputOptions = mainTemplate.outputOptions;
          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;

          if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {
            hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));
          }

          if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {
            hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));
          }

          if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {
            hash.update(JSON.stringify(chunk.getChunkMaps(true).name));
          }
        });
      });
    }
  }]);

  return TemplatedPathPlugin;
}();

module.exports = TemplatedPathPlugin;