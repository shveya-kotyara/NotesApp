/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require("webpack-sources"),
    RawSource = _require.RawSource,
    ReplaceSource = _require.ReplaceSource;
/** @typedef {import("./Dependency")} Dependency */

/** @typedef {import("./Dependency").DependencyTemplate} DependencyTemplate */

/** @typedef {import("./RuntimeTemplate")} RuntimeTemplate */

/** @typedef {import("./util/createHash").Hash} Hash */

/** @typedef {(d: Dependency) => boolean} DependencyFilterFunction */

/** @typedef {Map<Function, DependencyTemplate>} DependencyTemplates */


var DependenciesBlockVariable =
/*#__PURE__*/
function () {
  /**
   * Creates an instance of DependenciesBlockVariable.
   * @param {string} name name of DependenciesBlockVariable
   * @param {string} expression expression string
   * @param {Dependency[]=} dependencies dependencies tied to this varaiable
   */
  function DependenciesBlockVariable(name, expression, dependencies) {
    _classCallCheck(this, DependenciesBlockVariable);

    this.name = name;
    this.expression = expression;
    this.dependencies = dependencies || [];
  }
  /**
   * @param {Hash} hash hash for instance to update
   * @returns {void}
   */


  _createClass(DependenciesBlockVariable, [{
    key: "updateHash",
    value: function updateHash(hash) {
      hash.update(this.name);
      hash.update(this.expression);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var d = _step.value;
          d.updateHash(hash);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * @param {DependencyTemplates} dependencyTemplates Dependency constructors and templates Map.
     * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate to generate expression souce
     * @returns {ReplaceSource} returns constructed source for expression via templates
     */

  }, {
    key: "expressionSource",
    value: function expressionSource(dependencyTemplates, runtimeTemplate) {
      var source = new ReplaceSource(new RawSource(this.expression));
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.dependencies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var dep = _step2.value;
          var template = dependencyTemplates.get(dep.constructor);

          if (!template) {
            throw new Error("No template for dependency: ".concat(dep.constructor.name));
          }

          template.apply(dep, source, runtimeTemplate, dependencyTemplates);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return source;
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.dependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var d = _step3.value;
          d.disconnect();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "hasDependencies",
    value: function hasDependencies(filter) {
      if (filter) {
        return this.dependencies.some(filter);
      }

      return this.dependencies.length > 0;
    }
  }]);

  return DependenciesBlockVariable;
}();

module.exports = DependenciesBlockVariable;