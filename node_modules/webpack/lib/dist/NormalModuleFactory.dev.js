/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var path = require("path");

var asyncLib = require("neo-async");

var _require = require("tapable"),
    Tapable = _require.Tapable,
    AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,
    SyncWaterfallHook = _require.SyncWaterfallHook,
    SyncBailHook = _require.SyncBailHook,
    SyncHook = _require.SyncHook,
    HookMap = _require.HookMap;

var NormalModule = require("./NormalModule");

var RawModule = require("./RawModule");

var RuleSet = require("./RuleSet");

var _require2 = require("./util/cleverMerge"),
    cachedCleverMerge = _require2.cachedCleverMerge;

var EMPTY_RESOLVE_OPTIONS = {};
var MATCH_RESOURCE_REGEX = /^([^!]+)!=!/;

var loaderToIdent = function loaderToIdent(data) {
  if (!data.options) {
    return data.loader;
  }

  if (typeof data.options === "string") {
    return data.loader + "?" + data.options;
  }

  if (_typeof(data.options) !== "object") {
    throw new Error("loader options must be string or object");
  }

  if (data.ident) {
    return data.loader + "??" + data.ident;
  }

  return data.loader + "?" + JSON.stringify(data.options);
};

var identToLoaderRequest = function identToLoaderRequest(resultString) {
  var idx = resultString.indexOf("?");

  if (idx >= 0) {
    var loader = resultString.substr(0, idx);
    var options = resultString.substr(idx + 1);
    return {
      loader: loader,
      options: options
    };
  } else {
    return {
      loader: resultString,
      options: undefined
    };
  }
};

var dependencyCache = new WeakMap();

var NormalModuleFactory =
/*#__PURE__*/
function (_Tapable) {
  _inherits(NormalModuleFactory, _Tapable);

  function NormalModuleFactory(context, resolverFactory, options) {
    var _this;

    _classCallCheck(this, NormalModuleFactory);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NormalModuleFactory).call(this));
    _this.hooks = {
      resolver: new SyncWaterfallHook(["resolver"]),
      factory: new SyncWaterfallHook(["factory"]),
      beforeResolve: new AsyncSeriesWaterfallHook(["data"]),
      afterResolve: new AsyncSeriesWaterfallHook(["data"]),
      createModule: new SyncBailHook(["data"]),
      module: new SyncWaterfallHook(["module", "data"]),
      createParser: new HookMap(function () {
        return new SyncBailHook(["parserOptions"]);
      }),
      parser: new HookMap(function () {
        return new SyncHook(["parser", "parserOptions"]);
      }),
      createGenerator: new HookMap(function () {
        return new SyncBailHook(["generatorOptions"]);
      }),
      generator: new HookMap(function () {
        return new SyncHook(["generator", "generatorOptions"]);
      })
    };

    _this._pluginCompat.tap("NormalModuleFactory", function (options) {
      switch (options.name) {
        case "before-resolve":
        case "after-resolve":
          options.async = true;
          break;

        case "parser":
          _this.hooks.parser["for"]("javascript/auto").tap(options.fn.name || "unnamed compat plugin", options.fn);

          return true;
      }

      var match;
      match = /^parser (.+)$/.exec(options.name);

      if (match) {
        _this.hooks.parser["for"](match[1]).tap(options.fn.name || "unnamed compat plugin", options.fn.bind(_assertThisInitialized(_this)));

        return true;
      }

      match = /^create-parser (.+)$/.exec(options.name);

      if (match) {
        _this.hooks.createParser["for"](match[1]).tap(options.fn.name || "unnamed compat plugin", options.fn.bind(_assertThisInitialized(_this)));

        return true;
      }
    });

    _this.resolverFactory = resolverFactory;
    _this.ruleSet = new RuleSet(options.defaultRules.concat(options.rules));
    _this.cachePredicate = typeof options.unsafeCache === "function" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);
    _this.context = context || "";
    _this.parserCache = Object.create(null);
    _this.generatorCache = Object.create(null);

    _this.hooks.factory.tap("NormalModuleFactory", function () {
      return function (result, callback) {
        var resolver = _this.hooks.resolver.call(null); // Ignored


        if (!resolver) return callback();
        resolver(result, function (err, data) {
          if (err) return callback(err); // Ignored

          if (!data) return callback(); // direct module

          if (typeof data.source === "function") return callback(null, data);

          _this.hooks.afterResolve.callAsync(data, function (err, result) {
            if (err) return callback(err); // Ignored

            if (!result) return callback();

            var createdModule = _this.hooks.createModule.call(result);

            if (!createdModule) {
              if (!result.request) {
                return callback(new Error("Empty dependency (no request)"));
              }

              createdModule = new NormalModule(result);
            }

            createdModule = _this.hooks.module.call(createdModule, result);
            return callback(null, createdModule);
          });
        });
      };
    });

    _this.hooks.resolver.tap("NormalModuleFactory", function () {
      return function (data, callback) {
        var contextInfo = data.contextInfo;
        var context = data.context;
        var request = data.request;

        var loaderResolver = _this.getResolver("loader");

        var normalResolver = _this.getResolver("normal", data.resolveOptions);

        var matchResource = undefined;
        var requestWithoutMatchResource = request;
        var matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);

        if (matchResourceMatch) {
          matchResource = matchResourceMatch[1];

          if (/^\.\.?\//.test(matchResource)) {
            matchResource = path.join(context, matchResource);
          }

          requestWithoutMatchResource = request.substr(matchResourceMatch[0].length);
        }

        var noPreAutoLoaders = requestWithoutMatchResource.startsWith("-!");
        var noAutoLoaders = noPreAutoLoaders || requestWithoutMatchResource.startsWith("!");
        var noPrePostAutoLoaders = requestWithoutMatchResource.startsWith("!!");
        var elements = requestWithoutMatchResource.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
        var resource = elements.pop();
        elements = elements.map(identToLoaderRequest);
        asyncLib.parallel([function (callback) {
          return _this.resolveRequestArray(contextInfo, context, elements, loaderResolver, callback);
        }, function (callback) {
          if (resource === "" || resource[0] === "?") {
            return callback(null, {
              resource: resource
            });
          }

          normalResolver.resolve(contextInfo, context, resource, {}, function (err, resource, resourceResolveData) {
            if (err) return callback(err);
            callback(null, {
              resourceResolveData: resourceResolveData,
              resource: resource
            });
          });
        }], function (err, results) {
          if (err) return callback(err);
          var loaders = results[0];
          var resourceResolveData = results[1].resourceResolveData;
          resource = results[1].resource; // translate option idents

          try {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = loaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var item = _step.value;

                if (typeof item.options === "string" && item.options[0] === "?") {
                  var ident = item.options.substr(1);
                  item.options = _this.ruleSet.findOptionsByIdent(ident);
                  item.ident = ident;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          } catch (e) {
            return callback(e);
          }

          if (resource === false) {
            // ignored
            return callback(null, new RawModule("/* (ignored) */", "ignored ".concat(context, " ").concat(request), "".concat(request, " (ignored)")));
          }

          var userRequest = (matchResource !== undefined ? "".concat(matchResource, "!=!") : "") + loaders.map(loaderToIdent).concat([resource]).join("!");
          var resourcePath = matchResource !== undefined ? matchResource : resource;
          var resourceQuery = "";
          var queryIndex = resourcePath.indexOf("?");

          if (queryIndex >= 0) {
            resourceQuery = resourcePath.substr(queryIndex);
            resourcePath = resourcePath.substr(0, queryIndex);
          }

          var result = _this.ruleSet.exec({
            resource: resourcePath,
            realResource: matchResource !== undefined ? resource.replace(/\?.*/, "") : resourcePath,
            resourceQuery: resourceQuery,
            issuer: contextInfo.issuer,
            compiler: contextInfo.compiler
          });

          var settings = {};
          var useLoadersPost = [];
          var useLoaders = [];
          var useLoadersPre = [];
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = result[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var r = _step2.value;

              if (r.type === "use") {
                if (r.enforce === "post" && !noPrePostAutoLoaders) {
                  useLoadersPost.push(r.value);
                } else if (r.enforce === "pre" && !noPreAutoLoaders && !noPrePostAutoLoaders) {
                  useLoadersPre.push(r.value);
                } else if (!r.enforce && !noAutoLoaders && !noPrePostAutoLoaders) {
                  useLoaders.push(r.value);
                }
              } else if (_typeof(r.value) === "object" && r.value !== null && _typeof(settings[r.type]) === "object" && settings[r.type] !== null) {
                settings[r.type] = cachedCleverMerge(settings[r.type], r.value);
              } else {
                settings[r.type] = r.value;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          asyncLib.parallel([_this.resolveRequestArray.bind(_assertThisInitialized(_this), contextInfo, _this.context, useLoadersPost, loaderResolver), _this.resolveRequestArray.bind(_assertThisInitialized(_this), contextInfo, _this.context, useLoaders, loaderResolver), _this.resolveRequestArray.bind(_assertThisInitialized(_this), contextInfo, _this.context, useLoadersPre, loaderResolver)], function (err, results) {
            if (err) return callback(err);

            if (matchResource === undefined) {
              loaders = results[0].concat(loaders, results[1], results[2]);
            } else {
              loaders = results[0].concat(results[1], loaders, results[2]);
            }

            process.nextTick(function () {
              var type = settings.type;
              var resolveOptions = settings.resolve;
              callback(null, {
                context: context,
                request: loaders.map(loaderToIdent).concat([resource]).join("!"),
                dependencies: data.dependencies,
                userRequest: userRequest,
                rawRequest: request,
                loaders: loaders,
                resource: resource,
                matchResource: matchResource,
                resourceResolveData: resourceResolveData,
                settings: settings,
                type: type,
                parser: _this.getParser(type, settings.parser),
                generator: _this.getGenerator(type, settings.generator),
                resolveOptions: resolveOptions
              });
            });
          });
        });
      };
    });

    return _this;
  }

  _createClass(NormalModuleFactory, [{
    key: "create",
    value: function create(data, callback) {
      var _this2 = this;

      var dependencies = data.dependencies;
      var cacheEntry = dependencyCache.get(dependencies[0]);
      if (cacheEntry) return callback(null, cacheEntry);
      var context = data.context || this.context;
      var resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS;
      var request = dependencies[0].request;
      var contextInfo = data.contextInfo || {};
      this.hooks.beforeResolve.callAsync({
        contextInfo: contextInfo,
        resolveOptions: resolveOptions,
        context: context,
        request: request,
        dependencies: dependencies
      }, function (err, result) {
        if (err) return callback(err); // Ignored

        if (!result) return callback();

        var factory = _this2.hooks.factory.call(null); // Ignored


        if (!factory) return callback();
        factory(result, function (err, module) {
          if (err) return callback(err);

          if (module && _this2.cachePredicate(module)) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = dependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var d = _step3.value;
                dependencyCache.set(d, module);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }

          callback(null, module);
        });
      });
    }
  }, {
    key: "resolveRequestArray",
    value: function resolveRequestArray(contextInfo, context, array, resolver, callback) {
      if (array.length === 0) return callback(null, []);
      asyncLib.map(array, function (item, callback) {
        resolver.resolve(contextInfo, context, item.loader, {}, function (err, result) {
          if (err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) {
            return resolver.resolve(contextInfo, context, item.loader + "-loader", {}, function (err2) {
              if (!err2) {
                err.message = err.message + "\n" + "BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n" + "                 You need to specify '".concat(item.loader, "-loader' instead of '").concat(item.loader, "',\n") + "                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed";
              }

              callback(err);
            });
          }

          if (err) return callback(err);
          var optionsOnly = item.options ? {
            options: item.options
          } : undefined;
          return callback(null, Object.assign({}, item, identToLoaderRequest(result), optionsOnly));
        });
      }, callback);
    }
  }, {
    key: "getParser",
    value: function getParser(type, parserOptions) {
      var ident = type;

      if (parserOptions) {
        if (parserOptions.ident) {
          ident = "".concat(type, "|").concat(parserOptions.ident);
        } else {
          ident = JSON.stringify([type, parserOptions]);
        }
      }

      if (ident in this.parserCache) {
        return this.parserCache[ident];
      }

      return this.parserCache[ident] = this.createParser(type, parserOptions);
    }
  }, {
    key: "createParser",
    value: function createParser(type) {
      var parserOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var parser = this.hooks.createParser["for"](type).call(parserOptions);

      if (!parser) {
        throw new Error("No parser registered for ".concat(type));
      }

      this.hooks.parser["for"](type).call(parser, parserOptions);
      return parser;
    }
  }, {
    key: "getGenerator",
    value: function getGenerator(type, generatorOptions) {
      var ident = type;

      if (generatorOptions) {
        if (generatorOptions.ident) {
          ident = "".concat(type, "|").concat(generatorOptions.ident);
        } else {
          ident = JSON.stringify([type, generatorOptions]);
        }
      }

      if (ident in this.generatorCache) {
        return this.generatorCache[ident];
      }

      return this.generatorCache[ident] = this.createGenerator(type, generatorOptions);
    }
  }, {
    key: "createGenerator",
    value: function createGenerator(type) {
      var generatorOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var generator = this.hooks.createGenerator["for"](type).call(generatorOptions);

      if (!generator) {
        throw new Error("No generator registered for ".concat(type));
      }

      this.hooks.generator["for"](type).call(generator, generatorOptions);
      return generator;
    }
  }, {
    key: "getResolver",
    value: function getResolver(type, resolveOptions) {
      return this.resolverFactory.get(type, resolveOptions || EMPTY_RESOLVE_OPTIONS);
    }
  }]);

  return NormalModuleFactory;
}(Tapable);

module.exports = NormalModuleFactory;