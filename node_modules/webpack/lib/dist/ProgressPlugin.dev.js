/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var validateOptions = require("schema-utils");

var schema = require("../schemas/plugins/ProgressPlugin.json");
/** @typedef {import("../declarations/plugins/ProgressPlugin").ProgressPluginArgument} ProgressPluginArgument */

/** @typedef {import("../declarations/plugins/ProgressPlugin").ProgressPluginOptions} ProgressPluginOptions */


var createDefaultHandler = function createDefaultHandler(profile, logger) {
  var lastState;
  var lastStateTime;

  var defaultHandler = function defaultHandler(percentage, msg) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    logger.status.apply(logger, ["".concat(Math.floor(percentage * 100), "%"), msg].concat(args));

    if (profile) {
      var state = msg;
      state = state.replace(/^\d+\/\d+\s+/, "");

      if (percentage === 0) {
        lastState = null;
        lastStateTime = Date.now();
      } else if (state !== lastState || percentage === 1) {
        var now = Date.now();

        if (lastState) {
          var diff = now - lastStateTime;
          var stateMsg = "".concat(diff, "ms ").concat(lastState);

          if (diff > 1000) {
            logger.warn(stateMsg);
          } else if (diff > 10) {
            logger.info(stateMsg);
          } else if (diff > 0) {
            logger.log(stateMsg);
          } else {
            logger.debug(stateMsg);
          }
        }

        lastState = state;
        lastStateTime = now;
      }
    }

    if (percentage === 1) logger.status();
  };

  return defaultHandler;
};

var ProgressPlugin =
/*#__PURE__*/
function () {
  /**
   * @param {ProgressPluginArgument} options options
   */
  function ProgressPlugin(options) {
    _classCallCheck(this, ProgressPlugin);

    if (typeof options === "function") {
      options = {
        handler: options
      };
    }

    options = options || {};
    validateOptions(schema, options, "Progress Plugin");
    options = Object.assign({}, ProgressPlugin.defaultOptions, options);
    this.profile = options.profile;
    this.handler = options.handler;
    this.modulesCount = options.modulesCount;
    this.showEntries = options.entries;
    this.showModules = options.modules;
    this.showActiveModules = options.activeModules;
  }

  _createClass(ProgressPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var modulesCount = this.modulesCount;
      var handler = this.handler || createDefaultHandler(this.profile, compiler.getInfrastructureLogger("webpack.Progress"));
      var showEntries = this.showEntries;
      var showModules = this.showModules;
      var showActiveModules = this.showActiveModules;

      if (compiler.compilers) {
        var states = new Array(compiler.compilers.length);
        compiler.compilers.forEach(function (compiler, idx) {
          new ProgressPlugin(function (p, msg) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }

            states[idx] = [p, msg].concat(args);
            handler.apply(void 0, [states.map(function (state) {
              return state && state[0] || 0;
            }).reduce(function (a, b) {
              return a + b;
            }) / states.length, "[".concat(idx, "] ").concat(msg)].concat(args));
          }).apply(compiler);
        });
      } else {
        var lastModulesCount = 0;
        var lastEntriesCount = 0;
        var moduleCount = modulesCount;
        var entriesCount = 1;
        var doneModules = 0;
        var doneEntries = 0;
        var activeModules = new Set();
        var lastActiveModule = "";

        var update = function update() {
          var percentByModules = doneModules / Math.max(lastModulesCount, moduleCount);
          var percentByEntries = doneEntries / Math.max(lastEntriesCount, entriesCount);
          var items = [0.1 + Math.max(percentByModules, percentByEntries) * 0.6, "building"];

          if (showEntries) {
            items.push("".concat(doneEntries, "/").concat(entriesCount, " entries"));
          }

          if (showModules) {
            items.push("".concat(doneModules, "/").concat(moduleCount, " modules"));
          }

          if (showActiveModules) {
            items.push("".concat(activeModules.size, " active"));
            items.push(lastActiveModule);
          }

          handler.apply(void 0, items);
        };

        var moduleAdd = function moduleAdd(module) {
          moduleCount++;

          if (showActiveModules) {
            var ident = module.identifier();

            if (ident) {
              activeModules.add(ident);
              lastActiveModule = ident;
            }
          }

          update();
        };

        var entryAdd = function entryAdd(entry, name) {
          entriesCount++;
          update();
        };

        var moduleDone = function moduleDone(module) {
          doneModules++;

          if (showActiveModules) {
            var ident = module.identifier();

            if (ident) {
              activeModules["delete"](ident);

              if (lastActiveModule === ident) {
                lastActiveModule = "";
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                  for (var _iterator = activeModules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var m = _step.value;
                    lastActiveModule = m;
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                      _iterator["return"]();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }
              }
            }
          }

          update();
        };

        var entryDone = function entryDone(entry, name) {
          doneEntries++;
          update();
        };

        compiler.hooks.compilation.tap("ProgressPlugin", function (compilation) {
          if (compilation.compiler.isChild()) return;
          lastModulesCount = moduleCount;
          lastEntriesCount = entriesCount;
          moduleCount = entriesCount = 0;
          doneModules = doneEntries = 0;
          handler(0, "compiling");
          compilation.hooks.buildModule.tap("ProgressPlugin", moduleAdd);
          compilation.hooks.failedModule.tap("ProgressPlugin", moduleDone);
          compilation.hooks.succeedModule.tap("ProgressPlugin", moduleDone);
          compilation.hooks.addEntry.tap("ProgressPlugin", entryAdd);
          compilation.hooks.failedEntry.tap("ProgressPlugin", entryDone);
          compilation.hooks.succeedEntry.tap("ProgressPlugin", entryDone);
          var hooks = {
            finishModules: "finish module graph",
            seal: "sealing",
            beforeChunks: "chunk graph",
            afterChunks: "after chunk graph",
            optimizeDependenciesBasic: "basic dependencies optimization",
            optimizeDependencies: "dependencies optimization",
            optimizeDependenciesAdvanced: "advanced dependencies optimization",
            afterOptimizeDependencies: "after dependencies optimization",
            optimize: "optimizing",
            optimizeModulesBasic: "basic module optimization",
            optimizeModules: "module optimization",
            optimizeModulesAdvanced: "advanced module optimization",
            afterOptimizeModules: "after module optimization",
            optimizeChunksBasic: "basic chunk optimization",
            optimizeChunks: "chunk optimization",
            optimizeChunksAdvanced: "advanced chunk optimization",
            afterOptimizeChunks: "after chunk optimization",
            optimizeTree: "module and chunk tree optimization",
            afterOptimizeTree: "after module and chunk tree optimization",
            optimizeChunkModulesBasic: "basic chunk modules optimization",
            optimizeChunkModules: "chunk modules optimization",
            optimizeChunkModulesAdvanced: "advanced chunk modules optimization",
            afterOptimizeChunkModules: "after chunk modules optimization",
            reviveModules: "module reviving",
            optimizeModuleOrder: "module order optimization",
            advancedOptimizeModuleOrder: "advanced module order optimization",
            beforeModuleIds: "before module ids",
            moduleIds: "module ids",
            optimizeModuleIds: "module id optimization",
            afterOptimizeModuleIds: "module id optimization",
            reviveChunks: "chunk reviving",
            optimizeChunkOrder: "chunk order optimization",
            beforeChunkIds: "before chunk ids",
            optimizeChunkIds: "chunk id optimization",
            afterOptimizeChunkIds: "after chunk id optimization",
            recordModules: "record modules",
            recordChunks: "record chunks",
            beforeHash: "hashing",
            afterHash: "after hashing",
            recordHash: "record hash",
            beforeModuleAssets: "module assets processing",
            beforeChunkAssets: "chunk assets processing",
            additionalChunkAssets: "additional chunk assets processing",
            record: "recording",
            additionalAssets: "additional asset processing",
            optimizeChunkAssets: "chunk asset optimization",
            afterOptimizeChunkAssets: "after chunk asset optimization",
            optimizeAssets: "asset optimization",
            afterOptimizeAssets: "after asset optimization",
            afterSeal: "after seal"
          };
          var numberOfHooks = Object.keys(hooks).length;
          Object.keys(hooks).forEach(function (name, idx) {
            var title = hooks[name];
            var percentage = idx / numberOfHooks * 0.25 + 0.7;
            compilation.hooks[name].intercept({
              name: "ProgressPlugin",
              context: true,
              call: function call() {
                handler(percentage, title);
              },
              tap: function tap(context, _tap) {
                if (context) {
                  // p is percentage from 0 to 1
                  // args is any number of messages in a hierarchical matter
                  context.reportProgress = function (p) {
                    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                      args[_key3 - 1] = arguments[_key3];
                    }

                    handler.apply(void 0, [percentage, title, _tap.name].concat(args));
                  };
                }

                handler(percentage, title, _tap.name);
              }
            });
          });
        });
        compiler.hooks.emit.intercept({
          name: "ProgressPlugin",
          context: true,
          call: function call() {
            handler(0.95, "emitting");
          },
          tap: function tap(context, _tap2) {
            if (context) {
              context.reportProgress = function (p) {
                for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                  args[_key4 - 1] = arguments[_key4];
                }

                handler.apply(void 0, [0.95, "emitting", _tap2.name].concat(args));
              };
            }

            handler(0.95, "emitting", _tap2.name);
          }
        });
        compiler.hooks.afterEmit.intercept({
          name: "ProgressPlugin",
          context: true,
          call: function call() {
            handler(0.98, "after emitting");
          },
          tap: function tap(context, _tap3) {
            if (context) {
              context.reportProgress = function (p) {
                for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                  args[_key5 - 1] = arguments[_key5];
                }

                handler.apply(void 0, [0.98, "after emitting", _tap3.name].concat(args));
              };
            }

            handler(0.98, "after emitting", _tap3.name);
          }
        });
        compiler.hooks.done.tap("ProgressPlugin", function () {
          handler(1, "");
        });
      }
    }
  }]);

  return ProgressPlugin;
}();

ProgressPlugin.defaultOptions = {
  profile: false,
  modulesCount: 500,
  modules: true,
  activeModules: true,
  // TODO webpack 5 default this to true
  entries: false
};
module.exports = ProgressPlugin;