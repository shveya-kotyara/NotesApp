/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var NativeModule = require("module");

var _require = require("webpack-sources"),
    CachedSource = _require.CachedSource,
    LineToLineMappedSource = _require.LineToLineMappedSource,
    OriginalSource = _require.OriginalSource,
    RawSource = _require.RawSource,
    SourceMapSource = _require.SourceMapSource;

var _require2 = require("loader-runner"),
    getContext = _require2.getContext,
    runLoaders = _require2.runLoaders;

var WebpackError = require("./WebpackError");

var Module = require("./Module");

var ModuleParseError = require("./ModuleParseError");

var ModuleBuildError = require("./ModuleBuildError");

var ModuleError = require("./ModuleError");

var ModuleWarning = require("./ModuleWarning");

var createHash = require("./util/createHash");

var contextify = require("./util/identifier").contextify;
/** @typedef {import("./util/createHash").Hash} Hash */


var asString = function asString(buf) {
  if (Buffer.isBuffer(buf)) {
    return buf.toString("utf-8");
  }

  return buf;
};

var asBuffer = function asBuffer(str) {
  if (!Buffer.isBuffer(str)) {
    return Buffer.from(str, "utf-8");
  }

  return str;
};

var NonErrorEmittedError =
/*#__PURE__*/
function (_WebpackError) {
  _inherits(NonErrorEmittedError, _WebpackError);

  function NonErrorEmittedError(error) {
    var _this;

    _classCallCheck(this, NonErrorEmittedError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NonErrorEmittedError).call(this));
    _this.name = "NonErrorEmittedError";
    _this.message = "(Emitted value instead of an instance of Error) " + error;
    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    return _this;
  }

  return NonErrorEmittedError;
}(WebpackError);
/**
 * @typedef {Object} CachedSourceEntry
 * @property {TODO} source the generated source
 * @property {string} hash the hash value
 */


var NormalModule =
/*#__PURE__*/
function (_Module) {
  _inherits(NormalModule, _Module);

  function NormalModule(_ref) {
    var _this2;

    var type = _ref.type,
        request = _ref.request,
        userRequest = _ref.userRequest,
        rawRequest = _ref.rawRequest,
        loaders = _ref.loaders,
        resource = _ref.resource,
        matchResource = _ref.matchResource,
        parser = _ref.parser,
        generator = _ref.generator,
        resolveOptions = _ref.resolveOptions;

    _classCallCheck(this, NormalModule);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(NormalModule).call(this, type, getContext(resource))); // Info from Factory

    _this2.request = request;
    _this2.userRequest = userRequest;
    _this2.rawRequest = rawRequest;
    _this2.binary = type.startsWith("webassembly");
    _this2.parser = parser;
    _this2.generator = generator;
    _this2.resource = resource;
    _this2.matchResource = matchResource;
    _this2.loaders = loaders;
    if (resolveOptions !== undefined) _this2.resolveOptions = resolveOptions; // Info from Build

    _this2.error = null;
    _this2._source = null;
    _this2._sourceSize = null;
    _this2._buildHash = "";
    _this2.buildTimestamp = undefined;
    /** @private @type {Map<string, CachedSourceEntry>} */

    _this2._cachedSources = new Map(); // Options for the NormalModule set by plugins
    // TODO refactor this -> options object filled from Factory

    _this2.useSourceMap = false;
    _this2.lineToLine = false; // Cache

    _this2._lastSuccessfulBuildMeta = {};
    return _this2;
  }

  _createClass(NormalModule, [{
    key: "identifier",
    value: function identifier() {
      return this.request;
    }
  }, {
    key: "readableIdentifier",
    value: function readableIdentifier(requestShortener) {
      return requestShortener.shorten(this.userRequest);
    }
  }, {
    key: "libIdent",
    value: function libIdent(options) {
      return contextify(options.context, this.userRequest);
    }
  }, {
    key: "nameForCondition",
    value: function nameForCondition() {
      var resource = this.matchResource || this.resource;
      var idx = resource.indexOf("?");
      if (idx >= 0) return resource.substr(0, idx);
      return resource;
    }
  }, {
    key: "updateCacheModule",
    value: function updateCacheModule(module) {
      this.type = module.type;
      this.request = module.request;
      this.userRequest = module.userRequest;
      this.rawRequest = module.rawRequest;
      this.parser = module.parser;
      this.generator = module.generator;
      this.resource = module.resource;
      this.matchResource = module.matchResource;
      this.loaders = module.loaders;
      this.resolveOptions = module.resolveOptions;
    }
  }, {
    key: "createSourceForAsset",
    value: function createSourceForAsset(name, content, sourceMap) {
      if (!sourceMap) {
        return new RawSource(content);
      }

      if (typeof sourceMap === "string") {
        return new OriginalSource(content, sourceMap);
      }

      return new SourceMapSource(content, name, sourceMap);
    }
  }, {
    key: "createLoaderContext",
    value: function createLoaderContext(resolver, options, compilation, fs) {
      var _this3 = this;

      var requestShortener = compilation.runtimeTemplate.requestShortener;

      var getCurrentLoaderName = function getCurrentLoaderName() {
        var currentLoader = _this3.getCurrentLoader(loaderContext);

        if (!currentLoader) return "(not in loader scope)";
        return requestShortener.shorten(currentLoader.loader);
      };

      var loaderContext = {
        version: 2,
        emitWarning: function emitWarning(warning) {
          if (!(warning instanceof Error)) {
            warning = new NonErrorEmittedError(warning);
          }

          _this3.warnings.push(new ModuleWarning(_this3, warning, {
            from: getCurrentLoaderName()
          }));
        },
        emitError: function emitError(error) {
          if (!(error instanceof Error)) {
            error = new NonErrorEmittedError(error);
          }

          _this3.errors.push(new ModuleError(_this3, error, {
            from: getCurrentLoaderName()
          }));
        },
        getLogger: function getLogger(name) {
          var currentLoader = _this3.getCurrentLoader(loaderContext);

          return compilation.getLogger(function () {
            return [currentLoader && currentLoader.loader, name, _this3.identifier()].filter(Boolean).join("|");
          });
        },
        // TODO remove in webpack 5
        exec: function exec(code, filename) {
          // @ts-ignore Argument of type 'this' is not assignable to parameter of type 'Module'.
          var module = new NativeModule(filename, _this3); // @ts-ignore _nodeModulePaths is deprecated and undocumented Node.js API

          module.paths = NativeModule._nodeModulePaths(_this3.context);
          module.filename = filename;

          module._compile(code, filename);

          return module.exports;
        },
        resolve: function resolve(context, request, callback) {
          resolver.resolve({}, context, request, {}, callback);
        },
        getResolve: function getResolve(options) {
          var child = options ? resolver.withOptions(options) : resolver;
          return function (context, request, callback) {
            if (callback) {
              child.resolve({}, context, request, {}, callback);
            } else {
              return new Promise(function (resolve, reject) {
                child.resolve({}, context, request, {}, function (err, result) {
                  if (err) reject(err);else resolve(result);
                });
              });
            }
          };
        },
        emitFile: function emitFile(name, content, sourceMap, assetInfo) {
          if (!_this3.buildInfo.assets) {
            _this3.buildInfo.assets = Object.create(null);
            _this3.buildInfo.assetsInfo = new Map();
          }

          _this3.buildInfo.assets[name] = _this3.createSourceForAsset(name, content, sourceMap);

          _this3.buildInfo.assetsInfo.set(name, assetInfo);
        },
        rootContext: options.context,
        webpack: true,
        sourceMap: !!this.useSourceMap,
        mode: options.mode || "production",
        _module: this,
        _compilation: compilation,
        _compiler: compilation.compiler,
        fs: fs
      };
      compilation.hooks.normalModuleLoader.call(loaderContext, this);

      if (options.loader) {
        Object.assign(loaderContext, options.loader);
      }

      return loaderContext;
    }
  }, {
    key: "getCurrentLoader",
    value: function getCurrentLoader(loaderContext) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : loaderContext.loaderIndex;

      if (this.loaders && this.loaders.length && index < this.loaders.length && index >= 0 && this.loaders[index]) {
        return this.loaders[index];
      }

      return null;
    }
  }, {
    key: "createSource",
    value: function createSource(source, resourceBuffer, sourceMap) {
      // if there is no identifier return raw source
      if (!this.identifier) {
        return new RawSource(source);
      } // from here on we assume we have an identifier


      var identifier = this.identifier();

      if (this.lineToLine && resourceBuffer) {
        return new LineToLineMappedSource(source, identifier, asString(resourceBuffer));
      }

      if (this.useSourceMap && sourceMap) {
        return new SourceMapSource(source, identifier, sourceMap);
      }

      if (Buffer.isBuffer(source)) {
        // @ts-ignore
        // TODO We need to fix @types/webpack-sources to allow RawSource to take a Buffer | string
        return new RawSource(source);
      }

      return new OriginalSource(source, identifier);
    }
  }, {
    key: "doBuild",
    value: function doBuild(options, compilation, resolver, fs, callback) {
      var _this4 = this;

      var loaderContext = this.createLoaderContext(resolver, options, compilation, fs);
      runLoaders({
        resource: this.resource,
        loaders: this.loaders,
        context: loaderContext,
        readResource: fs.readFile.bind(fs)
      }, function (err, result) {
        if (result) {
          _this4.buildInfo.cacheable = result.cacheable;
          _this4.buildInfo.fileDependencies = new Set(result.fileDependencies);
          _this4.buildInfo.contextDependencies = new Set(result.contextDependencies);
        }

        if (err) {
          if (!(err instanceof Error)) {
            err = new NonErrorEmittedError(err);
          }

          var currentLoader = _this4.getCurrentLoader(loaderContext);

          var error = new ModuleBuildError(_this4, err, {
            from: currentLoader && compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader)
          });
          return callback(error);
        }

        var resourceBuffer = result.resourceBuffer;
        var source = result.result[0];
        var sourceMap = result.result.length >= 1 ? result.result[1] : null;
        var extraInfo = result.result.length >= 2 ? result.result[2] : null;

        if (!Buffer.isBuffer(source) && typeof source !== "string") {
          var _currentLoader = _this4.getCurrentLoader(loaderContext, 0);

          var _err = new Error("Final loader (".concat(_currentLoader ? compilation.runtimeTemplate.requestShortener.shorten(_currentLoader.loader) : "unknown", ") didn't return a Buffer or String"));

          var _error = new ModuleBuildError(_this4, _err);

          return callback(_error);
        }

        _this4._source = _this4.createSource(_this4.binary ? asBuffer(source) : asString(source), resourceBuffer, sourceMap);
        _this4._sourceSize = null;
        _this4._ast = _typeof(extraInfo) === "object" && extraInfo !== null && extraInfo.webpackAST !== undefined ? extraInfo.webpackAST : null;
        return callback();
      });
    }
  }, {
    key: "markModuleAsErrored",
    value: function markModuleAsErrored(error) {
      // Restore build meta from successful build to keep importing state
      this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta);
      this.error = error;
      this.errors.push(this.error);
      this._source = new RawSource("throw new Error(" + JSON.stringify(this.error.message) + ");");
      this._sourceSize = null;
      this._ast = null;
    }
  }, {
    key: "applyNoParseRule",
    value: function applyNoParseRule(rule, content) {
      // must start with "rule" if rule is a string
      if (typeof rule === "string") {
        return content.indexOf(rule) === 0;
      }

      if (typeof rule === "function") {
        return rule(content);
      } // we assume rule is a regexp


      return rule.test(content);
    } // check if module should not be parsed
    // returns "true" if the module should !not! be parsed
    // returns "false" if the module !must! be parsed

  }, {
    key: "shouldPreventParsing",
    value: function shouldPreventParsing(noParseRule, request) {
      // if no noParseRule exists, return false
      // the module !must! be parsed.
      if (!noParseRule) {
        return false;
      } // we only have one rule to check


      if (!Array.isArray(noParseRule)) {
        // returns "true" if the module is !not! to be parsed
        return this.applyNoParseRule(noParseRule, request);
      }

      for (var i = 0; i < noParseRule.length; i++) {
        var rule = noParseRule[i]; // early exit on first truthy match
        // this module is !not! to be parsed

        if (this.applyNoParseRule(rule, request)) {
          return true;
        }
      } // no match found, so this module !should! be parsed


      return false;
    }
  }, {
    key: "_initBuildHash",
    value: function _initBuildHash(compilation) {
      var hash = createHash(compilation.outputOptions.hashFunction);

      if (this._source) {
        hash.update("source");

        this._source.updateHash(hash);
      }

      hash.update("meta");
      hash.update(JSON.stringify(this.buildMeta));
      this._buildHash =
      /** @type {string} */
      hash.digest("hex");
    }
  }, {
    key: "build",
    value: function build(options, compilation, resolver, fs, callback) {
      var _this5 = this;

      this.buildTimestamp = Date.now();
      this.built = true;
      this._source = null;
      this._sourceSize = null;
      this._ast = null;
      this._buildHash = "";
      this.error = null;
      this.errors.length = 0;
      this.warnings.length = 0;
      this.buildMeta = {};
      this.buildInfo = {
        cacheable: false,
        fileDependencies: new Set(),
        contextDependencies: new Set(),
        assets: undefined,
        assetsInfo: undefined
      };
      return this.doBuild(options, compilation, resolver, fs, function (err) {
        _this5._cachedSources.clear(); // if we have an error mark module as failed and exit


        if (err) {
          _this5.markModuleAsErrored(err);

          _this5._initBuildHash(compilation);

          return callback();
        } // check if this module should !not! be parsed.
        // if so, exit here;


        var noParseRule = options.module && options.module.noParse;

        if (_this5.shouldPreventParsing(noParseRule, _this5.request)) {
          _this5._initBuildHash(compilation);

          return callback();
        }

        var handleParseError = function handleParseError(e) {
          var source = _this5._source.source();

          var loaders = _this5.loaders.map(function (item) {
            return contextify(options.context, item.loader);
          });

          var error = new ModuleParseError(_this5, source, e, loaders);

          _this5.markModuleAsErrored(error);

          _this5._initBuildHash(compilation);

          return callback();
        };

        var handleParseResult = function handleParseResult(result) {
          _this5._lastSuccessfulBuildMeta = _this5.buildMeta;

          _this5._initBuildHash(compilation);

          return callback();
        };

        try {
          var result = _this5.parser.parse(_this5._ast || _this5._source.source(), {
            current: _this5,
            module: _this5,
            compilation: compilation,
            options: options
          }, function (err, result) {
            if (err) {
              handleParseError(err);
            } else {
              handleParseResult(result);
            }
          });

          if (result !== undefined) {
            // parse is sync
            handleParseResult(result);
          }
        } catch (e) {
          handleParseError(e);
        }
      });
    }
  }, {
    key: "getHashDigest",
    value: function getHashDigest(dependencyTemplates) {
      // TODO webpack 5 refactor
      var dtHash = dependencyTemplates.get("hash");
      return "".concat(this.hash, "-").concat(dtHash);
    }
  }, {
    key: "source",
    value: function source(dependencyTemplates, runtimeTemplate) {
      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "javascript";
      var hashDigest = this.getHashDigest(dependencyTemplates);

      var cacheEntry = this._cachedSources.get(type);

      if (cacheEntry !== undefined && cacheEntry.hash === hashDigest) {
        // We can reuse the cached source
        return cacheEntry.source;
      }

      var source = this.generator.generate(this, dependencyTemplates, runtimeTemplate, type);
      var cachedSource = new CachedSource(source);

      this._cachedSources.set(type, {
        source: cachedSource,
        hash: hashDigest
      });

      return cachedSource;
    }
  }, {
    key: "originalSource",
    value: function originalSource() {
      return this._source;
    }
  }, {
    key: "needRebuild",
    value: function needRebuild(fileTimestamps, contextTimestamps) {
      // always try to rebuild in case of an error
      if (this.error) return true; // always rebuild when module is not cacheable

      if (!this.buildInfo.cacheable) return true; // Check timestamps of all dependencies
      // Missing timestamp -> need rebuild
      // Timestamp bigger than buildTimestamp -> need rebuild

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.buildInfo.fileDependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var file = _step.value;
          var timestamp = fileTimestamps.get(file);
          if (!timestamp) return true;
          if (timestamp >= this.buildTimestamp) return true;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.buildInfo.contextDependencies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _file = _step2.value;

          var _timestamp = contextTimestamps.get(_file);

          if (!_timestamp) return true;
          if (_timestamp >= this.buildTimestamp) return true;
        } // elsewise -> no rebuild needed

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return false;
    }
  }, {
    key: "size",
    value: function size() {
      if (this._sourceSize === null) {
        this._sourceSize = this._source ? this._source.size() : -1;
      }

      return this._sourceSize;
    }
    /**
     * @param {Hash} hash the hash used to track dependencies
     * @returns {void}
     */

  }, {
    key: "updateHash",
    value: function updateHash(hash) {
      hash.update(this._buildHash);

      _get(_getPrototypeOf(NormalModule.prototype), "updateHash", this).call(this, hash);
    }
  }]);

  return NormalModule;
}(Module);

module.exports = NormalModule;