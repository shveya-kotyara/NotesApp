/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require("tapable"),
    SyncBailHook = _require.SyncBailHook;

var _require2 = require("webpack-sources"),
    RawSource = _require2.RawSource;

var Template = require("./Template");

var ModuleHotAcceptDependency = require("./dependencies/ModuleHotAcceptDependency");

var ModuleHotDeclineDependency = require("./dependencies/ModuleHotDeclineDependency");

var ConstDependency = require("./dependencies/ConstDependency");

var NullFactory = require("./NullFactory");

var ParserHelpers = require("./ParserHelpers");

module.exports =
/*#__PURE__*/
function () {
  function HotModuleReplacementPlugin(options) {
    _classCallCheck(this, HotModuleReplacementPlugin);

    this.options = options || {};
    this.multiStep = this.options.multiStep;
    this.fullBuildTimeout = this.options.fullBuildTimeout || 200;
    this.requestTimeout = this.options.requestTimeout || 10000;
  }

  _createClass(HotModuleReplacementPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var multiStep = this.multiStep;
      var fullBuildTimeout = this.fullBuildTimeout;
      var requestTimeout = this.requestTimeout;
      var hotUpdateChunkFilename = compiler.options.output.hotUpdateChunkFilename;
      var hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;
      compiler.hooks.additionalPass.tapAsync("HotModuleReplacementPlugin", function (callback) {
        if (multiStep) return setTimeout(callback, fullBuildTimeout);
        return callback();
      });

      var addParserPlugins = function addParserPlugins(parser, parserOptions) {
        parser.hooks.expression["for"]("__webpack_hash__").tap("HotModuleReplacementPlugin", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, "__webpack_require__.h()"));
        parser.hooks.evaluateTypeof["for"]("__webpack_hash__").tap("HotModuleReplacementPlugin", ParserHelpers.evaluateToString("string"));
        parser.hooks.evaluateIdentifier["for"]("module.hot").tap({
          name: "HotModuleReplacementPlugin",
          before: "NodeStuffPlugin"
        }, function (expr) {
          return ParserHelpers.evaluateToIdentifier("module.hot", !!parser.state.compilation.hotUpdateChunkTemplate)(expr);
        }); // TODO webpack 5: refactor this, no custom hooks

        if (!parser.hooks.hotAcceptCallback) {
          parser.hooks.hotAcceptCallback = new SyncBailHook(["expression", "requests"]);
        }

        if (!parser.hooks.hotAcceptWithoutCallback) {
          parser.hooks.hotAcceptWithoutCallback = new SyncBailHook(["expression", "requests"]);
        }

        parser.hooks.call["for"]("module.hot.accept").tap("HotModuleReplacementPlugin", function (expr) {
          if (!parser.state.compilation.hotUpdateChunkTemplate) {
            return false;
          }

          if (expr.arguments.length >= 1) {
            var arg = parser.evaluateExpression(expr.arguments[0]);
            var params = [];
            var requests = [];

            if (arg.isString()) {
              params = [arg];
            } else if (arg.isArray()) {
              params = arg.items.filter(function (param) {
                return param.isString();
              });
            }

            if (params.length > 0) {
              params.forEach(function (param, idx) {
                var request = param.string;
                var dep = new ModuleHotAcceptDependency(request, param.range);
                dep.optional = true;
                dep.loc = Object.create(expr.loc);
                dep.loc.index = idx;
                parser.state.module.addDependency(dep);
                requests.push(request);
              });

              if (expr.arguments.length > 1) {
                parser.hooks.hotAcceptCallback.call(expr.arguments[1], requests);
                parser.walkExpression(expr.arguments[1]); // other args are ignored

                return true;
              } else {
                parser.hooks.hotAcceptWithoutCallback.call(expr, requests);
                return true;
              }
            }
          }
        });
        parser.hooks.call["for"]("module.hot.decline").tap("HotModuleReplacementPlugin", function (expr) {
          if (!parser.state.compilation.hotUpdateChunkTemplate) {
            return false;
          }

          if (expr.arguments.length === 1) {
            var arg = parser.evaluateExpression(expr.arguments[0]);
            var params = [];

            if (arg.isString()) {
              params = [arg];
            } else if (arg.isArray()) {
              params = arg.items.filter(function (param) {
                return param.isString();
              });
            }

            params.forEach(function (param, idx) {
              var dep = new ModuleHotDeclineDependency(param.string, param.range);
              dep.optional = true;
              dep.loc = Object.create(expr.loc);
              dep.loc.index = idx;
              parser.state.module.addDependency(dep);
            });
          }
        });
        parser.hooks.expression["for"]("module.hot").tap("HotModuleReplacementPlugin", ParserHelpers.skipTraversal);
      };

      compiler.hooks.compilation.tap("HotModuleReplacementPlugin", function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;
        // This applies the HMR plugin only to the targeted compiler
        // It should not affect child compilations
        if (compilation.compiler !== compiler) return;
        var hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;
        if (!hotUpdateChunkTemplate) return;
        compilation.dependencyFactories.set(ConstDependency, new NullFactory());
        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
        compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);
        compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());
        compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);
        compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template());
        compilation.hooks.record.tap("HotModuleReplacementPlugin", function (compilation, records) {
          if (records.hash === compilation.hash) return;
          records.hash = compilation.hash;
          records.moduleHashs = {};
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = compilation.modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _module = _step.value;

              var identifier = _module.identifier();

              records.moduleHashs[identifier] = _module.hash;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          records.chunkHashs = {};
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = compilation.chunks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var chunk = _step2.value;
              records.chunkHashs[chunk.id] = chunk.hash;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          records.chunkModuleIds = {};
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = compilation.chunks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _chunk = _step3.value;
              records.chunkModuleIds[_chunk.id] = Array.from(_chunk.modulesIterable, function (m) {
                return m.id;
              });
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        });
        var initialPass = false;
        var recompilation = false;
        compilation.hooks.afterHash.tap("HotModuleReplacementPlugin", function () {
          var records = compilation.records;

          if (!records) {
            initialPass = true;
            return;
          }

          if (!records.hash) initialPass = true;
          var preHash = records.preHash || "x";
          var prepreHash = records.prepreHash || "x";

          if (preHash === compilation.hash) {
            recompilation = true;
            compilation.modifyHash(prepreHash);
            return;
          }

          records.prepreHash = records.hash || "x";
          records.preHash = compilation.hash;
          compilation.modifyHash(records.prepreHash);
        });
        compilation.hooks.shouldGenerateChunkAssets.tap("HotModuleReplacementPlugin", function () {
          if (multiStep && !recompilation && !initialPass) return false;
        });
        compilation.hooks.needAdditionalPass.tap("HotModuleReplacementPlugin", function () {
          if (multiStep && !recompilation && !initialPass) return true;
        });
        compilation.hooks.additionalChunkAssets.tap("HotModuleReplacementPlugin", function () {
          var records = compilation.records;
          if (records.hash === compilation.hash) return;
          if (!records.moduleHashs || !records.chunkHashs || !records.chunkModuleIds) return;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = compilation.modules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _module2 = _step4.value;

              var identifier = _module2.identifier();

              var hash = _module2.hash;
              _module2.hotUpdate = records.moduleHashs[identifier] !== hash;
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          var hotUpdateMainContent = {
            h: compilation.hash,
            c: {}
          };

          var _loop = function _loop() {
            var key = _Object$keys[_i];
            var chunkId = isNaN(+key) ? key : +key;
            var currentChunk = compilation.chunks.find(function (chunk) {
              return "".concat(chunk.id) === key;
            });

            if (currentChunk) {
              var newModules = currentChunk.getModules().filter(function (module) {
                return module.hotUpdate;
              });
              var allModules = new Set();
              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = currentChunk.modulesIterable[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var _module3 = _step5.value;
                  allModules.add(_module3.id);
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                    _iterator5["return"]();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }

              var removedModules = records.chunkModuleIds[chunkId].filter(function (id) {
                return !allModules.has(id);
              });

              if (newModules.length > 0 || removedModules.length > 0) {
                var _source = hotUpdateChunkTemplate.render(chunkId, newModules, removedModules, compilation.hash, compilation.moduleTemplates.javascript, compilation.dependencyTemplates);

                var _compilation$getPathW2 = compilation.getPathWithInfo(hotUpdateChunkFilename, {
                  hash: records.hash,
                  chunk: currentChunk
                }),
                    _filename = _compilation$getPathW2.path,
                    _assetInfo = _compilation$getPathW2.info;

                compilation.additionalChunkAssets.push(_filename);
                compilation.emitAsset(_filename, _source, Object.assign({
                  hotModuleReplacement: true
                }, _assetInfo));
                hotUpdateMainContent.c[chunkId] = true;
                currentChunk.files.push(_filename);
                compilation.hooks.chunkAsset.call(currentChunk, _filename);
              }
            } else {
              hotUpdateMainContent.c[chunkId] = false;
            }
          };

          for (var _i = 0, _Object$keys = Object.keys(records.chunkHashs); _i < _Object$keys.length; _i++) {
            _loop();
          }

          var source = new RawSource(JSON.stringify(hotUpdateMainContent));

          var _compilation$getPathW = compilation.getPathWithInfo(hotUpdateMainFilename, {
            hash: records.hash
          }),
              filename = _compilation$getPathW.path,
              assetInfo = _compilation$getPathW.info;

          compilation.emitAsset(filename, source, Object.assign({
            hotModuleReplacement: true
          }, assetInfo));
        });
        var mainTemplate = compilation.mainTemplate;
        mainTemplate.hooks.hash.tap("HotModuleReplacementPlugin", function (hash) {
          hash.update("HotMainTemplateDecorator");
        });
        mainTemplate.hooks.moduleRequire.tap("HotModuleReplacementPlugin", function (_, chunk, hash, varModuleId) {
          return "hotCreateRequire(".concat(varModuleId, ")");
        });
        mainTemplate.hooks.requireExtensions.tap("HotModuleReplacementPlugin", function (source) {
          var buf = [source];
          buf.push("");
          buf.push("// __webpack_hash__");
          buf.push(mainTemplate.requireFn + ".h = function() { return hotCurrentHash; };");
          return Template.asString(buf);
        });

        var needChunkLoadingCode = function needChunkLoadingCode(chunk) {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = chunk.groupsIterable[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var chunkGroup = _step6.value;
              if (chunkGroup.chunks.length > 1) return true;
              if (chunkGroup.getNumberOfChildren() > 0) return true;
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }

          return false;
        };

        mainTemplate.hooks.bootstrap.tap("HotModuleReplacementPlugin", function (source, chunk, hash) {
          source = mainTemplate.hooks.hotBootstrap.call(source, chunk, hash);
          return Template.asString([source, "", hotInitCode.replace(/\$require\$/g, mainTemplate.requireFn).replace(/\$hash\$/g, JSON.stringify(hash)).replace(/\$requestTimeout\$/g, requestTimeout).replace(/\/\*foreachInstalledChunks\*\//g, needChunkLoadingCode(chunk) ? "for(var chunkId in installedChunks)" : "var chunkId = ".concat(JSON.stringify(chunk.id), ";"))]);
        });
        mainTemplate.hooks.globalHash.tap("HotModuleReplacementPlugin", function () {
          return true;
        });
        mainTemplate.hooks.currentHash.tap("HotModuleReplacementPlugin", function (_, length) {
          if (isFinite(length)) {
            return "hotCurrentHash.substr(0, ".concat(length, ")");
          } else {
            return "hotCurrentHash";
          }
        });
        mainTemplate.hooks.moduleObj.tap("HotModuleReplacementPlugin", function (source, chunk, hash, varModuleId) {
          return Template.asString(["".concat(source, ","), "hot: hotCreateModule(".concat(varModuleId, "),"), "parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),", "children: []"]);
        }); // TODO add HMR support for javascript/esm

        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("HotModuleReplacementPlugin", addParserPlugins);
        normalModuleFactory.hooks.parser["for"]("javascript/dynamic").tap("HotModuleReplacementPlugin", addParserPlugins);
        compilation.hooks.normalModuleLoader.tap("HotModuleReplacementPlugin", function (context) {
          context.hot = true;
        });
      });
    }
  }]);

  return HotModuleReplacementPlugin;
}();

var hotInitCode = Template.getFunctionContent(require("./HotModuleReplacement.runtime"));