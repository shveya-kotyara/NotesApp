"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

/** @typedef {import("./Module")} Module */

/** @typedef {import("./Chunk")} Chunk */

/** @typedef {import("./ModuleTemplate")} ModuleTemplate */

/** @typedef {import("webpack-sources").ConcatSource} ConcatSource */
var _require = require("webpack-sources"),
    ConcatSource = _require.ConcatSource;

var HotUpdateChunk = require("./HotUpdateChunk");

var START_LOWERCASE_ALPHABET_CODE = "a".charCodeAt(0);
var START_UPPERCASE_ALPHABET_CODE = "A".charCodeAt(0);
var DELTA_A_TO_Z = "z".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1;
var FUNCTION_CONTENT_REGEX = /^function\s?\(\)\s?\{\r?\n?|\r?\n?\}$/g;
var INDENT_MULTILINE_REGEX = /^\t/gm;
var LINE_SEPARATOR_REGEX = /\r?\n/g;
var IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/;
var IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g;
var COMMENT_END_REGEX = /\*\//g;
var PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\-^°]+/g;
var MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g;
/** @typedef {import("webpack-sources").Source} Source */

/**
 * @typedef {Object} HasId
 * @property {number | string} id
 */

/**
 * @typedef {function(Module, number): boolean} ModuleFilterPredicate
 */

/**
 * @param {HasId} a first id object to be sorted
 * @param {HasId} b second id object to be sorted against
 * @returns {-1|0|1} the sort value
 */

var stringifyIdSortPredicate = function stringifyIdSortPredicate(a, b) {
  var aId = a.id + "";
  var bId = b.id + "";
  if (aId < bId) return -1;
  if (aId > bId) return 1;
  return 0;
};

var Template =
/*#__PURE__*/
function () {
  function Template() {
    _classCallCheck(this, Template);
  }

  _createClass(Template, null, [{
    key: "getFunctionContent",

    /**
     *
     * @param {Function} fn a runtime function (.runtime.js) "template"
     * @returns {string} the updated and normalized function string
     */
    value: function getFunctionContent(fn) {
      return fn.toString().replace(FUNCTION_CONTENT_REGEX, "").replace(INDENT_MULTILINE_REGEX, "").replace(LINE_SEPARATOR_REGEX, "\n");
    }
    /**
     * @param {string} str the string converted to identifier
     * @returns {string} created identifier
     */

  }, {
    key: "toIdentifier",
    value: function toIdentifier(str) {
      if (typeof str !== "string") return "";
      return str.replace(IDENTIFIER_NAME_REPLACE_REGEX, "_$1").replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, "_");
    }
    /**
     *
     * @param {string} str string to be converted to commented in bundle code
     * @returns {string} returns a commented version of string
     */

  }, {
    key: "toComment",
    value: function toComment(str) {
      if (!str) return "";
      return "/*! ".concat(str.replace(COMMENT_END_REGEX, "* /"), " */");
    }
    /**
     *
     * @param {string} str string to be converted to "normal comment"
     * @returns {string} returns a commented version of string
     */

  }, {
    key: "toNormalComment",
    value: function toNormalComment(str) {
      if (!str) return "";
      return "/* ".concat(str.replace(COMMENT_END_REGEX, "* /"), " */");
    }
    /**
     * @param {string} str string path to be normalized
     * @returns {string} normalized bundle-safe path
     */

  }, {
    key: "toPath",
    value: function toPath(str) {
      if (typeof str !== "string") return "";
      return str.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, "-").replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, "");
    } // map number to a single character a-z, A-Z or <_ + number> if number is too big

    /**
     *
     * @param {number} n number to convert to ident
     * @returns {string} returns single character ident
     */

  }, {
    key: "numberToIdentifer",
    value: function numberToIdentifer(n) {
      // lower case
      if (n < DELTA_A_TO_Z) {
        return String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n);
      } // upper case


      if (n < DELTA_A_TO_Z * 2) {
        return String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n - DELTA_A_TO_Z);
      } // use multiple letters


      return Template.numberToIdentifer(n % (2 * DELTA_A_TO_Z)) + Template.numberToIdentifer(Math.floor(n / (2 * DELTA_A_TO_Z)));
    }
    /**
     *
     * @param {string | string[]} s string to convert to identity
     * @returns {string} converted identity
     */

  }, {
    key: "indent",
    value: function indent(s) {
      if (Array.isArray(s)) {
        return s.map(Template.indent).join("\n");
      } else {
        var str = s.trimRight();
        if (!str) return "";
        var ind = str[0] === "\n" ? "" : "\t";
        return ind + str.replace(/\n([^\n])/g, "\n\t$1");
      }
    }
    /**
     *
     * @param {string|string[]} s string to create prefix for
     * @param {string} prefix prefix to compose
     * @returns {string} returns new prefix string
     */

  }, {
    key: "prefix",
    value: function prefix(s, _prefix) {
      var str = Template.asString(s).trim();
      if (!str) return "";
      var ind = str[0] === "\n" ? "" : _prefix;
      return ind + str.replace(/\n([^\n])/g, "\n" + _prefix + "$1");
    }
    /**
     *
     * @param {string|string[]} str string or string collection
     * @returns {string} returns a single string from array
     */

  }, {
    key: "asString",
    value: function asString(str) {
      if (Array.isArray(str)) {
        return str.join("\n");
      }

      return str;
    }
    /**
     * @typedef {Object} WithId
     * @property {string|number} id
     */

    /**
     * @param {WithId[]} modules a collection of modules to get array bounds for
     * @returns {[number, number] | false} returns the upper and lower array bounds
     * or false if not every module has a number based id
     */

  }, {
    key: "getModulesArrayBounds",
    value: function getModulesArrayBounds(modules) {
      var maxId = -Infinity;
      var minId = Infinity;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _module = _step.value;
          if (typeof _module.id !== "number") return false;
          if (maxId < _module.id) maxId =
          /** @type {number} */
          _module.id;
          if (minId > _module.id) minId =
          /** @type {number} */
          _module.id;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (minId < 16 + ("" + minId).length) {
        // add minId x ',' instead of 'Array(minId).concat(…)'
        minId = 0;
      }

      var objectOverhead = modules.map(function (module) {
        return (module.id + "").length + 2;
      }).reduce(function (a, b) {
        return a + b;
      }, -1);
      var arrayOverhead = minId === 0 ? maxId : 16 + ("" + minId).length + maxId;
      return arrayOverhead < objectOverhead ? [minId, maxId] : false;
    }
    /**
     * @param {Chunk} chunk chunk whose modules will be rendered
     * @param {ModuleFilterPredicate} filterFn function used to filter modules from chunk to render
     * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance used to render modules
     * @param {TODO | TODO[]} dependencyTemplates templates needed for each module to render dependencies
     * @param {string=} prefix applying prefix strings
     * @returns {ConcatSource} rendered chunk modules in a Source object
     */

  }, {
    key: "renderChunkModules",
    value: function renderChunkModules(chunk, filterFn, moduleTemplate, dependencyTemplates) {
      var prefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
      var source = new ConcatSource();
      var modules = chunk.getModules().filter(filterFn);
      var removedModules;

      if (chunk instanceof HotUpdateChunk) {
        removedModules = chunk.removedModules;
      }

      if (modules.length === 0 && (!removedModules || removedModules.length === 0)) {
        source.add("[]");
        return source;
      }
      /** @type {{id: string|number, source: Source|string}[]} */


      var allModules = modules.map(function (module) {
        return {
          id: module.id,
          source: moduleTemplate.render(module, dependencyTemplates, {
            chunk: chunk
          })
        };
      });

      if (removedModules && removedModules.length > 0) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = removedModules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var id = _step2.value;
            allModules.push({
              id: id,
              source: "false"
            });
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      var bounds = Template.getModulesArrayBounds(allModules);

      if (bounds) {
        // Render a spare array
        var minId = bounds[0];
        var maxId = bounds[1];

        if (minId !== 0) {
          source.add("Array(".concat(minId, ").concat("));
        }

        source.add("[\n");
        /** @type {Map<string|number, {id: string|number, source: Source|string}>} */

        var _modules = new Map();

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = allModules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _module3 = _step3.value;

            _modules.set(_module3.id, _module3);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        for (var idx = minId; idx <= maxId; idx++) {
          var _module2 = _modules.get(idx);

          if (idx !== minId) {
            source.add(",\n");
          }

          source.add("/* ".concat(idx, " */"));

          if (_module2) {
            source.add("\n");
            source.add(_module2.source);
          }
        }

        source.add("\n" + prefix + "]");

        if (minId !== 0) {
          source.add(")");
        }
      } else {
        // Render an object
        source.add("{\n");
        allModules.sort(stringifyIdSortPredicate).forEach(function (module, idx) {
          if (idx !== 0) {
            source.add(",\n");
          }

          source.add("\n/***/ ".concat(JSON.stringify(module.id), ":\n"));
          source.add(module.source);
        });
        source.add("\n\n".concat(prefix, "}"));
      }

      return source;
    }
  }]);

  return Template;
}();

module.exports = Template;