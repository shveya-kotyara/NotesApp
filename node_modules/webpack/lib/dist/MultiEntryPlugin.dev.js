/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MultiEntryDependency = require("./dependencies/MultiEntryDependency");

var SingleEntryDependency = require("./dependencies/SingleEntryDependency");

var MultiModuleFactory = require("./MultiModuleFactory");
/** @typedef {import("./Compiler")} Compiler */


var MultiEntryPlugin =
/*#__PURE__*/
function () {
  /**
   * The MultiEntryPlugin is invoked whenever this.options.entry value is an array of paths
   * @param {string} context context path
   * @param {string[]} entries array of entry paths
   * @param {string} name entry key name
   */
  function MultiEntryPlugin(context, entries, name) {
    _classCallCheck(this, MultiEntryPlugin);

    this.context = context;
    this.entries = entries;
    this.name = name;
  }
  /**
   * @param {Compiler} compiler the compiler instance
   * @returns {void}
   */


  _createClass(MultiEntryPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      compiler.hooks.compilation.tap("MultiEntryPlugin", function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;
        var multiModuleFactory = new MultiModuleFactory();
        compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
        compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
      });
      compiler.hooks.make.tapAsync("MultiEntryPlugin", function (compilation, callback) {
        var context = _this.context,
            entries = _this.entries,
            name = _this.name;
        var dep = MultiEntryPlugin.createDependency(entries, name);
        compilation.addEntry(context, dep, name, callback);
      });
    }
    /**
     * @param {string[]} entries each entry path string
     * @param {string} name name of the entry
     * @returns {MultiEntryDependency} returns a constructed Dependency
     */

  }], [{
    key: "createDependency",
    value: function createDependency(entries, name) {
      return new MultiEntryDependency(entries.map(function (e, idx) {
        var dep = new SingleEntryDependency(e); // Because entrypoints are not dependencies found in an
        // existing module, we give it a synthetic id

        dep.loc = {
          name: name,
          index: idx
        };
        return dep;
      }), name);
    }
  }]);

  return MultiEntryPlugin;
}();

module.exports = MultiEntryPlugin;