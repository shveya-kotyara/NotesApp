/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var WebpackError = require("./WebpackError");
/** @typedef {import("./Module")} Module */

/**
 * @param {Module[]} modules the modules to be sorted
 * @returns {Module[]} sorted version of original modules
 */


var sortModules = function sortModules(modules) {
  return modules.slice().sort(function (a, b) {
    var aIdent = a.identifier();
    var bIdent = b.identifier();
    /* istanbul ignore next */

    if (aIdent < bIdent) return -1;
    /* istanbul ignore next */

    if (aIdent > bIdent) return 1;
    /* istanbul ignore next */

    return 0;
  });
};
/**
 * @param {Module[]} modules each module from throw
 * @returns {string} each message from provided moduels
 */


var createModulesListMessage = function createModulesListMessage(modules) {
  return modules.map(function (m) {
    var message = "* ".concat(m.identifier());
    var validReasons = m.reasons.filter(function (reason) {
      return reason.module;
    });

    if (validReasons.length > 0) {
      message += "\n    Used by ".concat(validReasons.length, " module(s), i. e.");
      message += "\n    ".concat(validReasons[0].module.identifier());
    }

    return message;
  }).join("\n");
};

var CaseSensitiveModulesWarning =
/*#__PURE__*/
function (_WebpackError) {
  _inherits(CaseSensitiveModulesWarning, _WebpackError);

  /**
   * Creates an instance of CaseSensitiveModulesWarning.
   * @param {Module[]} modules modules that were detected
   */
  function CaseSensitiveModulesWarning(modules) {
    var _this;

    _classCallCheck(this, CaseSensitiveModulesWarning);

    var sortedModules = sortModules(modules);
    var modulesList = createModulesListMessage(sortedModules);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(CaseSensitiveModulesWarning).call(this, "There are multiple modules with names that only differ in casing.\nThis can lead to unexpected behavior when compiling on a filesystem with other case-semantic.\nUse equal casing. Compare these module identifiers:\n".concat(modulesList)));
    _this.name = "CaseSensitiveModulesWarning";
    _this.origin = _this.module = sortedModules[0];
    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    return _this;
  }

  return CaseSensitiveModulesWarning;
}(WebpackError);

module.exports = CaseSensitiveModulesWarning;