/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var asyncLib = require("neo-async");

var path = require("path");

var _require = require("tapable"),
    Tapable = _require.Tapable,
    AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,
    SyncWaterfallHook = _require.SyncWaterfallHook;

var ContextModule = require("./ContextModule");

var ContextElementDependency = require("./dependencies/ContextElementDependency");
/** @typedef {import("./Module")} Module */


var EMPTY_RESOLVE_OPTIONS = {};

module.exports =
/*#__PURE__*/
function (_Tapable) {
  _inherits(ContextModuleFactory, _Tapable);

  function ContextModuleFactory(resolverFactory) {
    var _this;

    _classCallCheck(this, ContextModuleFactory);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextModuleFactory).call(this));
    _this.hooks = {
      /** @type {AsyncSeriesWaterfallHook<TODO>} */
      beforeResolve: new AsyncSeriesWaterfallHook(["data"]),

      /** @type {AsyncSeriesWaterfallHook<TODO>} */
      afterResolve: new AsyncSeriesWaterfallHook(["data"]),

      /** @type {SyncWaterfallHook<string[]>} */
      contextModuleFiles: new SyncWaterfallHook(["files"]),

      /** @type {SyncWaterfallHook<TODO[]>} */
      alternatives: new AsyncSeriesWaterfallHook(["modules"])
    };

    _this._pluginCompat.tap("ContextModuleFactory", function (options) {
      switch (options.name) {
        case "before-resolve":
        case "after-resolve":
        case "alternatives":
          options.async = true;
          break;
      }
    });

    _this.resolverFactory = resolverFactory;
    return _this;
  }

  _createClass(ContextModuleFactory, [{
    key: "create",
    value: function create(data, callback) {
      var _this2 = this;

      var context = data.context;
      var dependencies = data.dependencies;
      var resolveOptions = data.resolveOptions;
      var dependency = dependencies[0];
      this.hooks.beforeResolve.callAsync(Object.assign({
        context: context,
        dependencies: dependencies,
        resolveOptions: resolveOptions
      }, dependency.options), function (err, beforeResolveResult) {
        if (err) return callback(err); // Ignored

        if (!beforeResolveResult) return callback();
        var context = beforeResolveResult.context;
        var request = beforeResolveResult.request;
        var resolveOptions = beforeResolveResult.resolveOptions;
        var loaders,
            resource,
            loadersPrefix = "";
        var idx = request.lastIndexOf("!");

        if (idx >= 0) {
          var loadersRequest = request.substr(0, idx + 1);
          var i;

          for (i = 0; i < loadersRequest.length && loadersRequest[i] === "!"; i++) {
            loadersPrefix += "!";
          }

          loadersRequest = loadersRequest.substr(i).replace(/!+$/, "").replace(/!!+/g, "!");

          if (loadersRequest === "") {
            loaders = [];
          } else {
            loaders = loadersRequest.split("!");
          }

          resource = request.substr(idx + 1);
        } else {
          loaders = [];
          resource = request;
        }

        var contextResolver = _this2.resolverFactory.get("context", resolveOptions || EMPTY_RESOLVE_OPTIONS);

        var loaderResolver = _this2.resolverFactory.get("loader", EMPTY_RESOLVE_OPTIONS);

        asyncLib.parallel([function (callback) {
          contextResolver.resolve({}, context, resource, {}, function (err, result) {
            if (err) return callback(err);
            callback(null, result);
          });
        }, function (callback) {
          asyncLib.map(loaders, function (loader, callback) {
            loaderResolver.resolve({}, context, loader, {}, function (err, result) {
              if (err) return callback(err);
              callback(null, result);
            });
          }, callback);
        }], function (err, result) {
          if (err) return callback(err);

          _this2.hooks.afterResolve.callAsync(Object.assign({
            addon: loadersPrefix + result[1].join("!") + (result[1].length > 0 ? "!" : ""),
            resource: result[0],
            resolveDependencies: _this2.resolveDependencies.bind(_this2)
          }, beforeResolveResult), function (err, result) {
            if (err) return callback(err); // Ignored

            if (!result) return callback();
            return callback(null, new ContextModule(result.resolveDependencies, result));
          });
        });
      });
    }
  }, {
    key: "resolveDependencies",
    value: function resolveDependencies(fs, options, callback) {
      var _this3 = this;

      var cmf = this;
      var resource = options.resource;
      var resourceQuery = options.resourceQuery;
      var recursive = options.recursive;
      var regExp = options.regExp;
      var include = options.include;
      var exclude = options.exclude;
      if (!regExp || !resource) return callback(null, []);

      var addDirectory = function addDirectory(directory, callback) {
        fs.readdir(directory, function (err, files) {
          if (err) return callback(err);
          files = cmf.hooks.contextModuleFiles.call(files);
          if (!files || files.length === 0) return callback(null, []);
          asyncLib.map(files.filter(function (p) {
            return p.indexOf(".") !== 0;
          }), function (segment, callback) {
            var subResource = path.join(directory, segment);

            if (!exclude || !subResource.match(exclude)) {
              fs.stat(subResource, function (err, stat) {
                if (err) {
                  if (err.code === "ENOENT") {
                    // ENOENT is ok here because the file may have been deleted between
                    // the readdir and stat calls.
                    return callback();
                  } else {
                    return callback(err);
                  }
                }

                if (stat.isDirectory()) {
                  if (!recursive) return callback();
                  addDirectory.call(_this3, subResource, callback);
                } else if (stat.isFile() && (!include || subResource.match(include))) {
                  var obj = {
                    context: resource,
                    request: "." + subResource.substr(resource.length).replace(/\\/g, "/")
                  };

                  _this3.hooks.alternatives.callAsync([obj], function (err, alternatives) {
                    if (err) return callback(err);
                    alternatives = alternatives.filter(function (obj) {
                      return regExp.test(obj.request);
                    }).map(function (obj) {
                      var dep = new ContextElementDependency(obj.request + resourceQuery, obj.request);
                      dep.optional = true;
                      return dep;
                    });
                    callback(null, alternatives);
                  });
                } else {
                  callback();
                }
              });
            } else {
              callback();
            }
          }, function (err, result) {
            if (err) return callback(err);
            if (!result) return callback(null, []);
            callback(null, result.filter(Boolean).reduce(function (a, i) {
              return a.concat(i);
            }, []));
          });
        });
      };

      addDirectory(resource, callback);
    }
  }]);

  return ContextModuleFactory;
}(Tapable);