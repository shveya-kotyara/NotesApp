/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ParserHelpers = require("./ParserHelpers");

var ConstDependency = require("./dependencies/ConstDependency");

var NullFactory = require("./NullFactory");

var ProvidePlugin =
/*#__PURE__*/
function () {
  function ProvidePlugin(definitions) {
    _classCallCheck(this, ProvidePlugin);

    this.definitions = definitions;
  }

  _createClass(ProvidePlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var definitions = this.definitions;
      compiler.hooks.compilation.tap("ProvidePlugin", function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;
        compilation.dependencyFactories.set(ConstDependency, new NullFactory());
        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

        var handler = function handler(parser, parserOptions) {
          Object.keys(definitions).forEach(function (name) {
            var request = [].concat(definitions[name]);
            var splittedName = name.split(".");

            if (splittedName.length > 0) {
              splittedName.slice(1).forEach(function (_, i) {
                var name = splittedName.slice(0, i + 1).join(".");
                parser.hooks.canRename["for"](name).tap("ProvidePlugin", ParserHelpers.approve);
              });
            }

            parser.hooks.expression["for"](name).tap("ProvidePlugin", function (expr) {
              var nameIdentifier = name;
              var scopedName = name.includes(".");
              var expression = "require(".concat(JSON.stringify(request[0]), ")");

              if (scopedName) {
                nameIdentifier = "__webpack_provided_".concat(name.replace(/\./g, "_dot_"));
              }

              if (request.length > 1) {
                expression += request.slice(1).map(function (r) {
                  return "[".concat(JSON.stringify(r), "]");
                }).join("");
              }

              if (!ParserHelpers.addParsedVariableToModule(parser, nameIdentifier, expression)) {
                return false;
              }

              if (scopedName) {
                ParserHelpers.toConstantDependency(parser, nameIdentifier)(expr);
              }

              return true;
            });
          });
        };

        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("ProvidePlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/dynamic").tap("ProvidePlugin", handler); // Disable ProvidePlugin for javascript/esm, see https://github.com/webpack/webpack/issues/7032
      });
    }
  }]);

  return ProvidePlugin;
}();

module.exports = ProvidePlugin;