/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require("path");

var _require = require("webpack-sources"),
    ConcatSource = _require.ConcatSource,
    RawSource = _require.RawSource;

var ModuleFilenameHelpers = require("./ModuleFilenameHelpers");

var SourceMapDevToolModuleOptionsPlugin = require("./SourceMapDevToolModuleOptionsPlugin");

var createHash = require("./util/createHash");

var _require2 = require("./util/identifier"),
    absolutify = _require2.absolutify;

var validateOptions = require("schema-utils");

var schema = require("../schemas/plugins/SourceMapDevToolPlugin.json");
/** @typedef {import("../declarations/plugins/SourceMapDevToolPlugin").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */

/** @typedef {import("./Chunk")} Chunk */

/** @typedef {import("webpack-sources").Source} Source */

/** @typedef {import("source-map").RawSourceMap} SourceMap */

/** @typedef {import("./Module")} Module */

/** @typedef {import("./Compilation")} Compilation */

/** @typedef {import("./Compiler")} Compiler */

/** @typedef {import("./Compilation")} SourceMapDefinition */

/**
 * @typedef {object} SourceMapTask
 * @property {Source} asset
 * @property {Array<string | Module>} [modules]
 * @property {string} source
 * @property {string} file
 * @property {SourceMap} sourceMap
 * @property {Chunk} chunk
 */

/**
 * @param {string} name file path
 * @returns {string} file name
 */


var basename = function basename(name) {
  if (!name.includes("/")) return name;
  return name.substr(name.lastIndexOf("/") + 1);
};
/**
 * @type {WeakMap<Source, {file: string, assets: {[k: string]: ConcatSource | RawSource}}>}
 */


var assetsCache = new WeakMap();
/**
 * Creating {@link SourceMapTask} for given file
 * @param {string} file current compiled file
 * @param {Source} asset the asset
 * @param {Chunk} chunk related chunk
 * @param {SourceMapDevToolPluginOptions} options source map options
 * @param {Compilation} compilation compilation instance
 * @returns {SourceMapTask | undefined} created task instance or `undefined`
 */

var getTaskForFile = function getTaskForFile(file, asset, chunk, options, compilation) {
  var source, sourceMap;
  /**
   * Check if asset can build source map
   */

  if (asset.sourceAndMap) {
    var sourceAndMap = asset.sourceAndMap(options);
    sourceMap = sourceAndMap.map;
    source = sourceAndMap.source;
  } else {
    sourceMap = asset.map(options);
    source = asset.source();
  }

  if (!sourceMap || typeof source !== "string") return;
  var context = compilation.options.context;
  var modules = sourceMap.sources.map(function (source) {
    if (source.startsWith("webpack://")) {
      source = absolutify(context, source.slice(10));
    }

    var module = compilation.findModule(source);
    return module || source;
  });
  return {
    chunk: chunk,
    file: file,
    asset: asset,
    source: source,
    sourceMap: sourceMap,
    modules: modules
  };
};

var SourceMapDevToolPlugin =
/*#__PURE__*/
function () {
  /**
   * @param {SourceMapDevToolPluginOptions} [options] options object
   * @throws {Error} throws error, if got more than 1 arguments
   */
  function SourceMapDevToolPlugin(options) {
    _classCallCheck(this, SourceMapDevToolPlugin);

    if (arguments.length > 1) {
      throw new Error("SourceMapDevToolPlugin only takes one argument (pass an options object)");
    }

    if (!options) options = {};
    validateOptions(schema, options, "SourceMap DevTool Plugin");
    /** @type {string | false} */

    this.sourceMapFilename = options.filename;
    /** @type {string | false} */

    this.sourceMappingURLComment = options.append === false ? false : options.append || "\n//# sourceMappingURL=[url]";
    /** @type {string | Function} */

    this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack://[namespace]/[resourcePath]";
    /** @type {string | Function} */

    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || "webpack://[namespace]/[resourcePath]?[hash]";
    /** @type {string} */

    this.namespace = options.namespace || "";
    /** @type {SourceMapDevToolPluginOptions} */

    this.options = options;
  }
  /**
   * Apply compiler
   * @param {Compiler} compiler compiler instance
   * @returns {void}
   */


  _createClass(SourceMapDevToolPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var sourceMapFilename = this.sourceMapFilename;
      var sourceMappingURLComment = this.sourceMappingURLComment;
      var moduleFilenameTemplate = this.moduleFilenameTemplate;
      var namespace = this.namespace;
      var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;
      var requestShortener = compiler.requestShortener;
      var options = this.options;
      options.test = options.test || /\.(m?js|css)($|\?)/i;
      var matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);
      compiler.hooks.compilation.tap("SourceMapDevToolPlugin", function (compilation) {
        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
        compilation.hooks.afterOptimizeChunkAssets.tap(
        /** @type {TODO} */
        {
          name: "SourceMapDevToolPlugin",
          context: true
        },
        /**
         * @param {object} context hook context
         * @param {Array<Chunk>} chunks resulted chunks
         * @throws {Error} throws error, if `sourceMapFilename === false && sourceMappingURLComment === false`
         * @returns {void}
         */
        function (context, chunks) {
          /** @type {Map<string | Module, string>} */
          var moduleToSourceNameMapping = new Map();
          /**
           * @type {Function}
           * @returns {void}
           */

          var reportProgress = context && context.reportProgress ? context.reportProgress : function () {};
          var files = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var chunk = _step.value;
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = chunk.files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var file = _step2.value;

                  if (matchObject(file)) {
                    files.push({
                      file: file,
                      chunk: chunk
                    });
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          reportProgress(0.0);
          var tasks = [];
          files.forEach(function (_ref, idx) {
            var file = _ref.file,
                chunk = _ref.chunk;
            var asset = compilation.getAsset(file).source;
            var cache = assetsCache.get(asset);
            /**
             * If presented in cache, reassigns assets. Cache assets already have source maps.
             */

            if (cache && cache.file === file) {
              for (var cachedFile in cache.assets) {
                if (cachedFile === file) {
                  compilation.updateAsset(cachedFile, cache.assets[cachedFile]);
                } else {
                  compilation.emitAsset(cachedFile, cache.assets[cachedFile], {
                    development: true
                  });
                }
                /**
                 * Add file to chunk, if not presented there
                 */


                if (cachedFile !== file) chunk.files.push(cachedFile);
              }

              return;
            }

            reportProgress(0.5 * idx / files.length, file, "generate SourceMap");
            /** @type {SourceMapTask | undefined} */

            var task = getTaskForFile(file, asset, chunk, options, compilation);

            if (task) {
              var modules = task.modules;

              for (var _idx = 0; _idx < modules.length; _idx++) {
                var _module = modules[_idx];

                if (!moduleToSourceNameMapping.get(_module)) {
                  moduleToSourceNameMapping.set(_module, ModuleFilenameHelpers.createFilename(_module, {
                    moduleFilenameTemplate: moduleFilenameTemplate,
                    namespace: namespace
                  }, requestShortener));
                }
              }

              tasks.push(task);
            }
          });
          reportProgress(0.5, "resolve sources");
          /** @type {Set<string>} */

          var usedNamesSet = new Set(moduleToSourceNameMapping.values());
          /** @type {Set<string>} */

          var conflictDetectionSet = new Set();
          /**
           * all modules in defined order (longest identifier first)
           * @type {Array<string | Module>}
           */

          var allModules = Array.from(moduleToSourceNameMapping.keys()).sort(function (a, b) {
            var ai = typeof a === "string" ? a : a.identifier();
            var bi = typeof b === "string" ? b : b.identifier();
            return ai.length - bi.length;
          }); // find modules with conflicting source names

          for (var idx = 0; idx < allModules.length; idx++) {
            var _module2 = allModules[idx];
            var sourceName = moduleToSourceNameMapping.get(_module2);
            var hasName = conflictDetectionSet.has(sourceName);

            if (!hasName) {
              conflictDetectionSet.add(sourceName);
              continue;
            } // try the fallback name first


            sourceName = ModuleFilenameHelpers.createFilename(_module2, {
              moduleFilenameTemplate: fallbackModuleFilenameTemplate,
              namespace: namespace
            }, requestShortener);
            hasName = usedNamesSet.has(sourceName);

            if (!hasName) {
              moduleToSourceNameMapping.set(_module2, sourceName);
              usedNamesSet.add(sourceName);
              continue;
            } // elsewise just append stars until we have a valid name


            while (hasName) {
              sourceName += "*";
              hasName = usedNamesSet.has(sourceName);
            }

            moduleToSourceNameMapping.set(_module2, sourceName);
            usedNamesSet.add(sourceName);
          }

          tasks.forEach(function (task, index) {
            reportProgress(0.5 + 0.5 * index / tasks.length, task.file, "attach SourceMap");
            var assets = Object.create(null);
            var chunk = task.chunk;
            var file = task.file;
            var asset = task.asset;
            var sourceMap = task.sourceMap;
            var source = task.source;
            var modules = task.modules;
            var moduleFilenames = modules.map(function (m) {
              return moduleToSourceNameMapping.get(m);
            });
            sourceMap.sources = moduleFilenames;

            if (options.noSources) {
              sourceMap.sourcesContent = undefined;
            }

            sourceMap.sourceRoot = options.sourceRoot || "";
            sourceMap.file = file;
            assetsCache.set(asset, {
              file: file,
              assets: assets
            });
            /** @type {string | false} */

            var currentSourceMappingURLComment = sourceMappingURLComment;

            if (currentSourceMappingURLComment !== false && /\.css($|\?)/i.test(file)) {
              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\n\/\/(.*)$/, "\n/*$1*/");
            }

            var sourceMapString = JSON.stringify(sourceMap);

            if (sourceMapFilename) {
              var filename = file;
              var query = "";

              var _idx2 = filename.indexOf("?");

              if (_idx2 >= 0) {
                query = filename.substr(_idx2);
                filename = filename.substr(0, _idx2);
              }

              var pathParams = {
                chunk: chunk,
                filename: options.fileContext ? path.relative(options.fileContext, filename) : filename,
                query: query,
                basename: basename(filename),
                contentHash: createHash("md4").update(sourceMapString).digest("hex")
              };
              var sourceMapFile = compilation.getPath(sourceMapFilename, pathParams);
              var sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile.replace(/\\/g, "/") : path.relative(path.dirname(file), sourceMapFile).replace(/\\/g, "/");
              /**
               * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented
               */

              if (currentSourceMappingURLComment !== false) {
                var _asset2 = new ConcatSource(new RawSource(source), compilation.getPath(currentSourceMappingURLComment, Object.assign({
                  url: sourceMapUrl
                }, pathParams)));

                assets[file] = _asset2;
                compilation.updateAsset(file, _asset2);
              }
              /**
               * Add source map file to compilation assets and chunk files
               */


              var _asset = new RawSource(sourceMapString);

              assets[sourceMapFile] = _asset;
              compilation.emitAsset(sourceMapFile, _asset, {
                development: true
              });
              chunk.files.push(sourceMapFile);
            } else {
              if (currentSourceMappingURLComment === false) {
                throw new Error("SourceMapDevToolPlugin: append can't be false when no filename is provided");
              }
              /**
               * Add source map as data url to asset
               */


              var _asset3 = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\[map\]/g, function () {
                return sourceMapString;
              }).replace(/\[url\]/g, function () {
                return "data:application/json;charset=utf-8;base64,".concat(Buffer.from(sourceMapString, "utf-8").toString("base64"));
              }));

              assets[file] = _asset3;
              compilation.updateAsset(file, _asset3);
            }
          });
          reportProgress(1.0);
        });
      });
    }
  }]);

  return SourceMapDevToolPlugin;
}();

module.exports = SourceMapDevToolPlugin;