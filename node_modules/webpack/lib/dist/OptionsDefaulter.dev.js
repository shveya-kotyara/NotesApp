/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";
/**
 * Gets the value at path of object
 * @param {object} obj object to query
 * @param {string} path query path
 * @returns {any} - if {@param path} requests element from array, then `undefined` will be returned
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var getProperty = function getProperty(obj, path) {
  var name = path.split(".");

  for (var i = 0; i < name.length - 1; i++) {
    obj = obj[name[i]];
    if (_typeof(obj) !== "object" || !obj || Array.isArray(obj)) return;
  }

  return obj[name.pop()];
};
/**
 * Sets the value at path of object. Stops execution, if {@param path} requests element from array to be set
 * @param {object} obj object to query
 * @param {string} path query path
 * @param {any} value value to be set
 * @returns {void}
 */


var setProperty = function setProperty(obj, path, value) {
  var name = path.split(".");

  for (var i = 0; i < name.length - 1; i++) {
    if (_typeof(obj[name[i]]) !== "object" && obj[name[i]] !== undefined) return;
    if (Array.isArray(obj[name[i]])) return;
    if (!obj[name[i]]) obj[name[i]] = {};
    obj = obj[name[i]];
  }

  obj[name.pop()] = value;
};
/**
 * @typedef {'call' | 'make' | 'append'} ConfigType
 */

/**
 * @typedef {(options: object) => any} MakeConfigHandler
 */

/**
 * @typedef {(value: any, options: object) => any} CallConfigHandler
 */

/**
 * @typedef {any[]} AppendConfigValues
 */


var OptionsDefaulter =
/*#__PURE__*/
function () {
  function OptionsDefaulter() {
    _classCallCheck(this, OptionsDefaulter);

    /**
     * Stores default options settings or functions for computing them
     */
    this.defaults = {};
    /**
     * Stores configuration for options
     * @type {{[key: string]: ConfigType}}
     */

    this.config = {};
  }
  /**
   * Enhancing {@param options} with default values
   * @param {object} options provided options
   * @returns {object} - enhanced options
   * @throws {Error} - will throw error, if configuration value is other then `undefined` or {@link ConfigType}
   */


  _createClass(OptionsDefaulter, [{
    key: "process",
    value: function process(options) {
      options = Object.assign({}, options);

      for (var name in this.defaults) {
        switch (this.config[name]) {
          /**
           * If {@link ConfigType} doesn't specified and current value is `undefined`, then default value will be assigned
           */
          case undefined:
            if (getProperty(options, name) === undefined) {
              setProperty(options, name, this.defaults[name]);
            }

            break;

          /**
           * Assign result of {@link CallConfigHandler}
           */

          case "call":
            setProperty(options, name, this.defaults[name].call(this, getProperty(options, name), options));
            break;

          /**
           * Assign result of {@link MakeConfigHandler}, if current value is `undefined`
           */

          case "make":
            if (getProperty(options, name) === undefined) {
              setProperty(options, name, this.defaults[name].call(this, options));
            }

            break;

          /**
           * Adding {@link AppendConfigValues} at the end of the current array
           */

          case "append":
            {
              var _oldValue;

              var oldValue = getProperty(options, name);

              if (!Array.isArray(oldValue)) {
                oldValue = [];
              }

              (_oldValue = oldValue).push.apply(_oldValue, _toConsumableArray(this.defaults[name]));

              setProperty(options, name, oldValue);
              break;
            }

          default:
            throw new Error("OptionsDefaulter cannot process " + this.config[name]);
        }
      }

      return options;
    }
    /**
     * Builds up default values
     * @param {string} name option path
     * @param {ConfigType | any} config if {@param def} is provided, then only {@link ConfigType} is allowed
     * @param {MakeConfigHandler | CallConfigHandler | AppendConfigValues} [def] defaults
     * @returns {void}
     */

  }, {
    key: "set",
    value: function set(name, config, def) {
      if (def !== undefined) {
        this.defaults[name] = def;
        this.config[name] = config;
      } else {
        this.defaults[name] = config;
        delete this.config[name];
      }
    }
  }]);

  return OptionsDefaulter;
}();

module.exports = OptionsDefaulter;