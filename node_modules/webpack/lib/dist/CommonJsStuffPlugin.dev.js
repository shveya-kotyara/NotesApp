/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require("path");

var ParserHelpers = require("./ParserHelpers");

var CommonJsStuffPlugin =
/*#__PURE__*/
function () {
  function CommonJsStuffPlugin() {
    _classCallCheck(this, CommonJsStuffPlugin);
  }

  _createClass(CommonJsStuffPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      compiler.hooks.compilation.tap("CommonJsStuffPlugin", function (compilation, _ref) {
        var normalModuleFactory = _ref.normalModuleFactory;

        var handler = function handler(parser, parserOptions) {
          parser.hooks.expression["for"]("require.main.require").tap("CommonJsStuffPlugin", ParserHelpers.expressionIsUnsupported(parser, "require.main.require is not supported by webpack."));
          parser.hooks.expression["for"]("module.parent.require").tap("CommonJsStuffPlugin", ParserHelpers.expressionIsUnsupported(parser, "module.parent.require is not supported by webpack."));
          parser.hooks.expression["for"]("require.main").tap("CommonJsStuffPlugin", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, "__webpack_require__.c[__webpack_require__.s]"));
          parser.hooks.expression["for"]("module.loaded").tap("CommonJsStuffPlugin", function (expr) {
            parser.state.module.buildMeta.moduleConcatenationBailout = "module.loaded";
            return ParserHelpers.toConstantDependency(parser, "module.l")(expr);
          });
          parser.hooks.expression["for"]("module.id").tap("CommonJsStuffPlugin", function (expr) {
            parser.state.module.buildMeta.moduleConcatenationBailout = "module.id";
            return ParserHelpers.toConstantDependency(parser, "module.i")(expr);
          });
          parser.hooks.expression["for"]("module.exports").tap("CommonJsStuffPlugin", function () {
            var module = parser.state.module;
            var isHarmony = module.buildMeta && module.buildMeta.exportsType;
            if (!isHarmony) return true;
          });
          parser.hooks.evaluateIdentifier["for"]("module.hot").tap("CommonJsStuffPlugin", ParserHelpers.evaluateToIdentifier("module.hot", false));
          parser.hooks.expression["for"]("module").tap("CommonJsStuffPlugin", function () {
            var module = parser.state.module;
            var isHarmony = module.buildMeta && module.buildMeta.exportsType;
            var moduleJsPath = path.join(__dirname, "..", "buildin", isHarmony ? "harmony-module.js" : "module.js");

            if (module.context) {
              moduleJsPath = path.relative(parser.state.module.context, moduleJsPath);

              if (!/^[A-Z]:/i.test(moduleJsPath)) {
                moduleJsPath = "./".concat(moduleJsPath.replace(/\\/g, "/"));
              }
            }

            return ParserHelpers.addParsedVariableToModule(parser, "module", "require(".concat(JSON.stringify(moduleJsPath), ")(module)"));
          });
        };

        normalModuleFactory.hooks.parser["for"]("javascript/auto").tap("CommonJsStuffPlugin", handler);
        normalModuleFactory.hooks.parser["for"]("javascript/dynamic").tap("CommonJsStuffPlugin", handler);
      });
    }
  }]);

  return CommonJsStuffPlugin;
}();

module.exports = CommonJsStuffPlugin;