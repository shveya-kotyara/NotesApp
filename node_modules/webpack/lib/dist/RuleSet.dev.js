/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

/*
<rules>: <rule>
<rules>: [<rule>]
<rule>: {
	resource: {
		test: <condition>,
		include: <condition>,
		exclude: <condition>,
	},
	resource: <condition>, -> resource.test
	test: <condition>, -> resource.test
	include: <condition>, -> resource.include
	exclude: <condition>, -> resource.exclude
	resourceQuery: <condition>,
	compiler: <condition>,
	issuer: <condition>,
	use: "loader", -> use[0].loader
	loader: <>, -> use[0].loader
	loaders: <>, -> use
	options: {}, -> use[0].options,
	query: {}, -> options
	parser: {},
	use: [
		"loader" -> use[x].loader
	],
	use: [
		{
			loader: "loader",
			options: {}
		}
	],
	rules: [
		<rule>
	],
	oneOf: [
		<rule>
	]
}

<condition>: /regExp/
<condition>: function(arg) {}
<condition>: "starting"
<condition>: [<condition>] // or
<condition>: { and: [<condition>] }
<condition>: { or: [<condition>] }
<condition>: { not: [<condition>] }
<condition>: { test: <condition>, include: <condition>, exclude: <condition> }


normalized:

{
	resource: function(),
	resourceQuery: function(),
	compiler: function(),
	issuer: function(),
	use: [
		{
			loader: string,
			options: string,
			<any>: <any>
		}
	],
	rules: [<rule>],
	oneOf: [<rule>],
	<any>: <any>,
}

*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var notMatcher = function notMatcher(matcher) {
  return function (str) {
    return !matcher(str);
  };
};

var orMatcher = function orMatcher(items) {
  return function (str) {
    for (var i = 0; i < items.length; i++) {
      if (items[i](str)) return true;
    }

    return false;
  };
};

var andMatcher = function andMatcher(items) {
  return function (str) {
    for (var i = 0; i < items.length; i++) {
      if (!items[i](str)) return false;
    }

    return true;
  };
};

module.exports =
/*#__PURE__*/
function () {
  function RuleSet(rules) {
    _classCallCheck(this, RuleSet);

    this.references = Object.create(null);
    this.rules = RuleSet.normalizeRules(rules, this.references, "ref-");
  }

  _createClass(RuleSet, [{
    key: "exec",
    value: function exec(data) {
      var result = [];

      this._run(data, {
        rules: this.rules
      }, result);

      return result;
    }
  }, {
    key: "_run",
    value: function _run(data, rule, result) {
      // test conditions
      if (rule.resource && !data.resource) return false;
      if (rule.realResource && !data.realResource) return false;
      if (rule.resourceQuery && !data.resourceQuery) return false;
      if (rule.compiler && !data.compiler) return false;
      if (rule.issuer && !data.issuer) return false;
      if (rule.resource && !rule.resource(data.resource)) return false;
      if (rule.realResource && !rule.realResource(data.realResource)) return false;
      if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;

      if (data.resourceQuery && rule.resourceQuery && !rule.resourceQuery(data.resourceQuery)) {
        return false;
      }

      if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {
        return false;
      } // apply


      var keys = Object.keys(rule).filter(function (key) {
        return !["resource", "realResource", "resourceQuery", "compiler", "issuer", "rules", "oneOf", "use", "enforce"].includes(key);
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;
          result.push({
            type: key,
            value: rule[key]
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (rule.use) {
        var process = function process(use) {
          if (typeof use === "function") {
            process(use(data));
          } else if (Array.isArray(use)) {
            use.forEach(process);
          } else {
            result.push({
              type: "use",
              value: use,
              enforce: rule.enforce
            });
          }
        };

        process(rule.use);
      }

      if (rule.rules) {
        for (var i = 0; i < rule.rules.length; i++) {
          this._run(data, rule.rules[i], result);
        }
      }

      if (rule.oneOf) {
        for (var _i = 0; _i < rule.oneOf.length; _i++) {
          if (this._run(data, rule.oneOf[_i], result)) break;
        }
      }

      return true;
    }
  }, {
    key: "findOptionsByIdent",
    value: function findOptionsByIdent(ident) {
      var options = this.references[ident];

      if (!options) {
        throw new Error("Can't find options with ident '" + ident + "'");
      }

      return options;
    }
  }], [{
    key: "normalizeRules",
    value: function normalizeRules(rules, refs, ident) {
      if (Array.isArray(rules)) {
        return rules.map(function (rule, idx) {
          return RuleSet.normalizeRule(rule, refs, "".concat(ident, "-").concat(idx));
        });
      } else if (rules) {
        return [RuleSet.normalizeRule(rules, refs, ident)];
      } else {
        return [];
      }
    }
  }, {
    key: "normalizeRule",
    value: function normalizeRule(rule, refs, ident) {
      if (typeof rule === "string") {
        return {
          use: [{
            loader: rule
          }]
        };
      }

      if (!rule) {
        throw new Error("Unexcepted null when object was expected as rule");
      }

      if (_typeof(rule) !== "object") {
        throw new Error("Unexcepted " + _typeof(rule) + " when object was expected as rule (" + rule + ")");
      }

      var newRule = {};
      var useSource;
      var resourceSource;
      var condition;

      var checkUseSource = function checkUseSource(newSource) {
        if (useSource && useSource !== newSource) {
          throw new Error(RuleSet.buildErrorMessage(rule, new Error("Rule can only have one result source (provided " + newSource + " and " + useSource + ")")));
        }

        useSource = newSource;
      };

      var checkResourceSource = function checkResourceSource(newSource) {
        if (resourceSource && resourceSource !== newSource) {
          throw new Error(RuleSet.buildErrorMessage(rule, new Error("Rule can only have one resource source (provided " + newSource + " and " + resourceSource + ")")));
        }

        resourceSource = newSource;
      };

      if (rule.test || rule.include || rule.exclude) {
        checkResourceSource("test + include + exclude");
        condition = {
          test: rule.test,
          include: rule.include,
          exclude: rule.exclude
        };

        try {
          newRule.resource = RuleSet.normalizeCondition(condition);
        } catch (error) {
          throw new Error(RuleSet.buildErrorMessage(condition, error));
        }
      }

      if (rule.resource) {
        checkResourceSource("resource");

        try {
          newRule.resource = RuleSet.normalizeCondition(rule.resource);
        } catch (error) {
          throw new Error(RuleSet.buildErrorMessage(rule.resource, error));
        }
      }

      if (rule.realResource) {
        try {
          newRule.realResource = RuleSet.normalizeCondition(rule.realResource);
        } catch (error) {
          throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));
        }
      }

      if (rule.resourceQuery) {
        try {
          newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);
        } catch (error) {
          throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));
        }
      }

      if (rule.compiler) {
        try {
          newRule.compiler = RuleSet.normalizeCondition(rule.compiler);
        } catch (error) {
          throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));
        }
      }

      if (rule.issuer) {
        try {
          newRule.issuer = RuleSet.normalizeCondition(rule.issuer);
        } catch (error) {
          throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));
        }
      }

      if (rule.loader && rule.loaders) {
        throw new Error(RuleSet.buildErrorMessage(rule, new Error("Provided loader and loaders for rule (use only one of them)")));
      }

      var loader = rule.loaders || rule.loader;

      if (typeof loader === "string" && !rule.options && !rule.query) {
        checkUseSource("loader");
        newRule.use = RuleSet.normalizeUse(loader.split("!"), ident);
      } else if (typeof loader === "string" && (rule.options || rule.query)) {
        checkUseSource("loader + options/query");
        newRule.use = RuleSet.normalizeUse({
          loader: loader,
          options: rule.options,
          query: rule.query
        }, ident);
      } else if (loader && (rule.options || rule.query)) {
        throw new Error(RuleSet.buildErrorMessage(rule, new Error("options/query cannot be used with loaders (use options for each array item)")));
      } else if (loader) {
        checkUseSource("loaders");
        newRule.use = RuleSet.normalizeUse(loader, ident);
      } else if (rule.options || rule.query) {
        throw new Error(RuleSet.buildErrorMessage(rule, new Error("options/query provided without loader (use loader + options)")));
      }

      if (rule.use) {
        checkUseSource("use");
        newRule.use = RuleSet.normalizeUse(rule.use, ident);
      }

      if (rule.rules) {
        newRule.rules = RuleSet.normalizeRules(rule.rules, refs, "".concat(ident, "-rules"));
      }

      if (rule.oneOf) {
        newRule.oneOf = RuleSet.normalizeRules(rule.oneOf, refs, "".concat(ident, "-oneOf"));
      }

      var keys = Object.keys(rule).filter(function (key) {
        return !["resource", "resourceQuery", "compiler", "test", "include", "exclude", "issuer", "loader", "options", "query", "loaders", "use", "rules", "oneOf"].includes(key);
      });
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;
          newRule[key] = rule[key];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (Array.isArray(newRule.use)) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = newRule.use[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var item = _step3.value;

            if (item.ident) {
              refs[item.ident] = item.options;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      return newRule;
    }
  }, {
    key: "buildErrorMessage",
    value: function buildErrorMessage(condition, error) {
      var conditionAsText = JSON.stringify(condition, function (key, value) {
        return value === undefined ? "undefined" : value;
      }, 2);
      return error.message + " in " + conditionAsText;
    }
  }, {
    key: "normalizeUse",
    value: function normalizeUse(use, ident) {
      if (typeof use === "function") {
        return function (data) {
          return RuleSet.normalizeUse(use(data), ident);
        };
      }

      if (Array.isArray(use)) {
        return use.map(function (item, idx) {
          return RuleSet.normalizeUse(item, "".concat(ident, "-").concat(idx));
        }).reduce(function (arr, items) {
          return arr.concat(items);
        }, []);
      }

      return [RuleSet.normalizeUseItem(use, ident)];
    }
  }, {
    key: "normalizeUseItemString",
    value: function normalizeUseItemString(useItemString) {
      var idx = useItemString.indexOf("?");

      if (idx >= 0) {
        return {
          loader: useItemString.substr(0, idx),
          options: useItemString.substr(idx + 1)
        };
      }

      return {
        loader: useItemString,
        options: undefined
      };
    }
  }, {
    key: "normalizeUseItem",
    value: function normalizeUseItem(item, ident) {
      if (typeof item === "string") {
        return RuleSet.normalizeUseItemString(item);
      }

      var newItem = {};

      if (item.options && item.query) {
        throw new Error("Provided options and query in use");
      }

      if (!item.loader) {
        throw new Error("No loader specified");
      }

      newItem.options = item.options || item.query;

      if (_typeof(newItem.options) === "object" && newItem.options) {
        if (newItem.options.ident) {
          newItem.ident = newItem.options.ident;
        } else {
          newItem.ident = ident;
        }
      }

      var keys = Object.keys(item).filter(function (key) {
        return !["options", "query"].includes(key);
      });
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = keys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var key = _step4.value;
          newItem[key] = item[key];
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return newItem;
    }
  }, {
    key: "normalizeCondition",
    value: function normalizeCondition(condition) {
      if (!condition) throw new Error("Expected condition but got falsy value");

      if (typeof condition === "string") {
        return function (str) {
          return str.indexOf(condition) === 0;
        };
      }

      if (typeof condition === "function") {
        return condition;
      }

      if (condition instanceof RegExp) {
        return condition.test.bind(condition);
      }

      if (Array.isArray(condition)) {
        var items = condition.map(function (c) {
          return RuleSet.normalizeCondition(c);
        });
        return orMatcher(items);
      }

      if (_typeof(condition) !== "object") {
        throw Error("Unexcepted " + _typeof(condition) + " when condition was expected (" + condition + ")");
      }

      var matchers = [];
      Object.keys(condition).forEach(function (key) {
        var value = condition[key];

        switch (key) {
          case "or":
          case "include":
          case "test":
            if (value) matchers.push(RuleSet.normalizeCondition(value));
            break;

          case "and":
            if (value) {
              var _items = value.map(function (c) {
                return RuleSet.normalizeCondition(c);
              });

              matchers.push(andMatcher(_items));
            }

            break;

          case "not":
          case "exclude":
            if (value) {
              var matcher = RuleSet.normalizeCondition(value);
              matchers.push(notMatcher(matcher));
            }

            break;

          default:
            throw new Error("Unexcepted property " + key + " in condition");
        }
      });

      if (matchers.length === 0) {
        throw new Error("Excepted condition but got " + condition);
      }

      if (matchers.length === 1) {
        return matchers[0];
      }

      return andMatcher(matchers);
    }
  }]);

  return RuleSet;
}();