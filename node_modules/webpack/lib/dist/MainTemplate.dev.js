/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require("webpack-sources"),
    ConcatSource = _require.ConcatSource,
    OriginalSource = _require.OriginalSource,
    PrefixSource = _require.PrefixSource,
    RawSource = _require.RawSource;

var _require2 = require("tapable"),
    Tapable = _require2.Tapable,
    SyncWaterfallHook = _require2.SyncWaterfallHook,
    SyncHook = _require2.SyncHook,
    SyncBailHook = _require2.SyncBailHook;

var Template = require("./Template");
/** @typedef {import("webpack-sources").ConcatSource} ConcatSource */

/** @typedef {import("webpack-sources").Source} Source */

/** @typedef {import("./ModuleTemplate")} ModuleTemplate */

/** @typedef {import("./Chunk")} Chunk */

/** @typedef {import("./Module")} Module} */

/** @typedef {import("./util/createHash").Hash} Hash} */

/** @typedef {import("./Dependency").DependencyTemplate} DependencyTemplate} */

/**
 * @typedef {Object} RenderManifestOptions
 * @property {Chunk} chunk the chunk used to render
 * @property {string} hash
 * @property {string} fullHash
 * @property {TODO} outputOptions
 * @property {{javascript: ModuleTemplate, webassembly: ModuleTemplate}} moduleTemplates
 * @property {Map<TODO, TODO>} dependencyTemplates
 */
// require function shortcuts:
// __webpack_require__.s = the module id of the entry point
// __webpack_require__.c = the module cache
// __webpack_require__.m = the module functions
// __webpack_require__.p = the bundle public path
// __webpack_require__.i = the identity function used for harmony imports
// __webpack_require__.e = the chunk ensure function
// __webpack_require__.d = the exported property define getter function
// __webpack_require__.o = Object.prototype.hasOwnProperty.call
// __webpack_require__.r = define compatibility on export
// __webpack_require__.t = create a fake namespace object
// __webpack_require__.n = compatibility get default export
// __webpack_require__.h = the webpack hash
// __webpack_require__.w = an object containing all installed WebAssembly.Instance export objects keyed by module id
// __webpack_require__.oe = the uncaught error handler for the webpack runtime
// __webpack_require__.nc = the script nonce


module.exports =
/*#__PURE__*/
function (_Tapable) {
  _inherits(MainTemplate, _Tapable);

  /**
   *
   * @param {TODO=} outputOptions output options for the MainTemplate
   */
  function MainTemplate(outputOptions) {
    var _this;

    _classCallCheck(this, MainTemplate);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MainTemplate).call(this));
    /** @type {TODO?} */

    _this.outputOptions = outputOptions || {};
    _this.hooks = {
      /** @type {SyncWaterfallHook<TODO[], RenderManifestOptions>} */
      renderManifest: new SyncWaterfallHook(["result", "options"]),
      modules: new SyncWaterfallHook(["modules", "chunk", "hash", "moduleTemplate", "dependencyTemplates"]),
      moduleObj: new SyncWaterfallHook(["source", "chunk", "hash", "moduleIdExpression"]),
      requireEnsure: new SyncWaterfallHook(["source", "chunk", "hash", "chunkIdExpression"]),
      bootstrap: new SyncWaterfallHook(["source", "chunk", "hash", "moduleTemplate", "dependencyTemplates"]),
      localVars: new SyncWaterfallHook(["source", "chunk", "hash"]),
      require: new SyncWaterfallHook(["source", "chunk", "hash"]),
      requireExtensions: new SyncWaterfallHook(["source", "chunk", "hash"]),

      /** @type {SyncWaterfallHook<string, Chunk, string>} */
      beforeStartup: new SyncWaterfallHook(["source", "chunk", "hash"]),

      /** @type {SyncWaterfallHook<string, Chunk, string>} */
      startup: new SyncWaterfallHook(["source", "chunk", "hash"]),

      /** @type {SyncWaterfallHook<string, Chunk, string>} */
      afterStartup: new SyncWaterfallHook(["source", "chunk", "hash"]),
      render: new SyncWaterfallHook(["source", "chunk", "hash", "moduleTemplate", "dependencyTemplates"]),
      renderWithEntry: new SyncWaterfallHook(["source", "chunk", "hash"]),
      moduleRequire: new SyncWaterfallHook(["source", "chunk", "hash", "moduleIdExpression"]),
      addModule: new SyncWaterfallHook(["source", "chunk", "hash", "moduleIdExpression", "moduleExpression"]),
      currentHash: new SyncWaterfallHook(["source", "requestedLength"]),
      assetPath: new SyncWaterfallHook(["path", "options", "assetInfo"]),
      hash: new SyncHook(["hash"]),
      hashForChunk: new SyncHook(["hash", "chunk"]),
      globalHashPaths: new SyncWaterfallHook(["paths"]),
      globalHash: new SyncBailHook(["chunk", "paths"]),
      // TODO this should be moved somewhere else
      // It's weird here
      hotBootstrap: new SyncWaterfallHook(["source", "chunk", "hash"])
    };

    _this.hooks.startup.tap("MainTemplate", function (source, chunk, hash) {
      /** @type {string[]} */
      var buf = [];

      if (chunk.entryModule) {
        buf.push("// Load entry module and return exports");
        buf.push("return ".concat(_this.renderRequireFunctionForModule(hash, chunk, JSON.stringify(chunk.entryModule.id)), "(").concat(_this.requireFn, ".s = ").concat(JSON.stringify(chunk.entryModule.id), ");"));
      }

      return Template.asString(buf);
    });

    _this.hooks.render.tap("MainTemplate", function (bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) {
      var source = new ConcatSource();
      source.add("/******/ (function(modules) { // webpackBootstrap\n");
      source.add(new PrefixSource("/******/", bootstrapSource));
      source.add("/******/ })\n");
      source.add("/************************************************************************/\n");
      source.add("/******/ (");
      source.add(_this.hooks.modules.call(new RawSource(""), chunk, hash, moduleTemplate, dependencyTemplates));
      source.add(")");
      return source;
    });

    _this.hooks.localVars.tap("MainTemplate", function (source, chunk, hash) {
      return Template.asString([source, "// The module cache", "var installedModules = {};"]);
    });

    _this.hooks.require.tap("MainTemplate", function (source, chunk, hash) {
      return Template.asString([source, "// Check if module is in cache", "if(installedModules[moduleId]) {", Template.indent("return installedModules[moduleId].exports;"), "}", "// Create a new module (and put it into the cache)", "var module = installedModules[moduleId] = {", Template.indent(_this.hooks.moduleObj.call("", chunk, hash, "moduleId")), "};", "", Template.asString(outputOptions.strictModuleExceptionHandling ? ["// Execute the module function", "var threw = true;", "try {", Template.indent(["modules[moduleId].call(module.exports, module, module.exports, ".concat(_this.renderRequireFunctionForModule(hash, chunk, "moduleId"), ");"), "threw = false;"]), "} finally {", Template.indent(["if(threw) delete installedModules[moduleId];"]), "}"] : ["// Execute the module function", "modules[moduleId].call(module.exports, module, module.exports, ".concat(_this.renderRequireFunctionForModule(hash, chunk, "moduleId"), ");")]), "", "// Flag the module as loaded", "module.l = true;", "", "// Return the exports of the module", "return module.exports;"]);
    });

    _this.hooks.moduleObj.tap("MainTemplate", function (source, chunk, hash, varModuleId) {
      return Template.asString(["i: moduleId,", "l: false,", "exports: {}"]);
    });

    _this.hooks.requireExtensions.tap("MainTemplate", function (source, chunk, hash) {
      var buf = [];
      var chunkMaps = chunk.getChunkMaps(); // Check if there are non initial chunks which need to be imported using require-ensure

      if (Object.keys(chunkMaps.hash).length) {
        buf.push("// This file contains only the entry chunk.");
        buf.push("// The chunk loading function for additional chunks");
        buf.push("".concat(_this.requireFn, ".e = function requireEnsure(chunkId) {"));
        buf.push(Template.indent("var promises = [];"));
        buf.push(Template.indent(_this.hooks.requireEnsure.call("", chunk, hash, "chunkId")));
        buf.push(Template.indent("return Promise.all(promises);"));
        buf.push("};");
      } else if (chunk.hasModuleInGraph(function (m) {
        return m.blocks.some(function (b) {
          return b.chunkGroup && b.chunkGroup.chunks.length > 0;
        });
      })) {
        // There async blocks in the graph, so we need to add an empty requireEnsure
        // function anyway. This can happen with multiple entrypoints.
        buf.push("// The chunk loading function for additional chunks");
        buf.push("// Since all referenced chunks are already included");
        buf.push("// in this file, this function is empty here.");
        buf.push("".concat(_this.requireFn, ".e = function requireEnsure() {"));
        buf.push(Template.indent("return Promise.resolve();"));
        buf.push("};");
      }

      buf.push("");
      buf.push("// expose the modules object (__webpack_modules__)");
      buf.push("".concat(_this.requireFn, ".m = modules;"));
      buf.push("");
      buf.push("// expose the module cache");
      buf.push("".concat(_this.requireFn, ".c = installedModules;"));
      buf.push("");
      buf.push("// define getter function for harmony exports");
      buf.push("".concat(_this.requireFn, ".d = function(exports, name, getter) {"));
      buf.push(Template.indent(["if(!".concat(_this.requireFn, ".o(exports, name)) {"), Template.indent(["Object.defineProperty(exports, name, { enumerable: true, get: getter });"]), "}"]));
      buf.push("};");
      buf.push("");
      buf.push("// define __esModule on exports");
      buf.push("".concat(_this.requireFn, ".r = function(exports) {"));
      buf.push(Template.indent(["if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {", Template.indent(["Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });"]), "}", "Object.defineProperty(exports, '__esModule', { value: true });"]));
      buf.push("};");
      buf.push("");
      buf.push("// create a fake namespace object");
      buf.push("// mode & 1: value is a module id, require it");
      buf.push("// mode & 2: merge all properties of value into the ns");
      buf.push("// mode & 4: return value when already ns object");
      buf.push("// mode & 8|1: behave like require");
      buf.push("".concat(_this.requireFn, ".t = function(value, mode) {"));
      buf.push(Template.indent(["if(mode & 1) value = ".concat(_this.requireFn, "(value);"), "if(mode & 8) return value;", "if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;", "var ns = Object.create(null);", "".concat(_this.requireFn, ".r(ns);"), "Object.defineProperty(ns, 'default', { enumerable: true, value: value });", "if(mode & 2 && typeof value != 'string') for(var key in value) " + "".concat(_this.requireFn, ".d(ns, key, function(key) { ") + "return value[key]; " + "}.bind(null, key));", "return ns;"]));
      buf.push("};");
      buf.push("");
      buf.push("// getDefaultExport function for compatibility with non-harmony modules");
      buf.push(_this.requireFn + ".n = function(module) {");
      buf.push(Template.indent(["var getter = module && module.__esModule ?", Template.indent(["function getDefault() { return module['default']; } :", "function getModuleExports() { return module; };"]), "".concat(_this.requireFn, ".d(getter, 'a', getter);"), "return getter;"]));
      buf.push("};");
      buf.push("");
      buf.push("// Object.prototype.hasOwnProperty.call");
      buf.push("".concat(_this.requireFn, ".o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };"));

      var publicPath = _this.getPublicPath({
        hash: hash
      });

      buf.push("");
      buf.push("// __webpack_public_path__");
      buf.push("".concat(_this.requireFn, ".p = ").concat(JSON.stringify(publicPath), ";"));
      return Template.asString(buf);
    });

    _this.requireFn = "__webpack_require__";
    return _this;
  }
  /**
   *
   * @param {RenderManifestOptions} options render manifest options
   * @returns {TODO[]} returns render manifest
   */


  _createClass(MainTemplate, [{
    key: "getRenderManifest",
    value: function getRenderManifest(options) {
      var result = [];
      this.hooks.renderManifest.call(result, options);
      return result;
    }
    /**
     * TODO webpack 5: remove moduleTemplate and dependencyTemplates
     * @param {string} hash hash to be used for render call
     * @param {Chunk} chunk Chunk instance
     * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render
     * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates
     * @returns {string[]} the generated source of the bootstrap code
     */

  }, {
    key: "renderBootstrap",
    value: function renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates) {
      var buf = [];
      buf.push(this.hooks.bootstrap.call("", chunk, hash, moduleTemplate, dependencyTemplates));
      buf.push(this.hooks.localVars.call("", chunk, hash));
      buf.push("");
      buf.push("// The require function");
      buf.push("function ".concat(this.requireFn, "(moduleId) {"));
      buf.push(Template.indent(this.hooks.require.call("", chunk, hash)));
      buf.push("}");
      buf.push("");
      buf.push(Template.asString(this.hooks.requireExtensions.call("", chunk, hash)));
      buf.push("");
      buf.push(Template.asString(this.hooks.beforeStartup.call("", chunk, hash)));
      var afterStartupCode = Template.asString(this.hooks.afterStartup.call("", chunk, hash));

      if (afterStartupCode) {
        // TODO webpack 5: this is a bit hacky to avoid a breaking change
        // change it to a better way
        buf.push("var startupResult = (function() {");
      }

      buf.push(Template.asString(this.hooks.startup.call("", chunk, hash)));

      if (afterStartupCode) {
        buf.push("})();");
        buf.push(afterStartupCode);
        buf.push("return startupResult;");
      }

      return buf;
    }
    /**
     * @param {string} hash hash to be used for render call
     * @param {Chunk} chunk Chunk instance
     * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render
     * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates
     * @returns {ConcatSource} the newly generated source from rendering
     */

  }, {
    key: "render",
    value: function render(hash, chunk, moduleTemplate, dependencyTemplates) {
      var buf = this.renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates);
      var source = this.hooks.render.call(new OriginalSource(Template.prefix(buf, " \t") + "\n", "webpack/bootstrap"), chunk, hash, moduleTemplate, dependencyTemplates);

      if (chunk.hasEntryModule()) {
        source = this.hooks.renderWithEntry.call(source, chunk, hash);
      }

      if (!source) {
        throw new Error("Compiler error: MainTemplate plugin 'render' should return something");
      }

      chunk.rendered = true;
      return new ConcatSource(source, ";");
    }
    /**
     *
     * @param {string} hash hash for render fn
     * @param {Chunk} chunk Chunk instance for require
     * @param {(number|string)=} varModuleId module id
     * @returns {TODO} the moduleRequire hook call return signature
     */

  }, {
    key: "renderRequireFunctionForModule",
    value: function renderRequireFunctionForModule(hash, chunk, varModuleId) {
      return this.hooks.moduleRequire.call(this.requireFn, chunk, hash, varModuleId);
    }
    /**
     *
     * @param {string} hash hash for render add fn
     * @param {Chunk} chunk Chunk instance for require add fn
     * @param {(string|number)=} varModuleId module id
     * @param {Module} varModule Module instance
     * @returns {TODO} renderAddModule call
     */

  }, {
    key: "renderAddModule",
    value: function renderAddModule(hash, chunk, varModuleId, varModule) {
      return this.hooks.addModule.call("modules[".concat(varModuleId, "] = ").concat(varModule, ";"), chunk, hash, varModuleId, varModule);
    }
    /**
     *
     * @param {string} hash string hash
     * @param {number=} length length
     * @returns {string} call hook return
     */

  }, {
    key: "renderCurrentHashCode",
    value: function renderCurrentHashCode(hash, length) {
      length = length || Infinity;
      return this.hooks.currentHash.call(JSON.stringify(hash.substr(0, length)), length);
    }
    /**
     *
     * @param {object} options get public path options
     * @returns {string} hook call
     */

  }, {
    key: "getPublicPath",
    value: function getPublicPath(options) {
      return this.hooks.assetPath.call(this.outputOptions.publicPath || "", options);
    }
  }, {
    key: "getAssetPath",
    value: function getAssetPath(path, options) {
      return this.hooks.assetPath.call(path, options);
    }
  }, {
    key: "getAssetPathWithInfo",
    value: function getAssetPathWithInfo(path, options) {
      var assetInfo = {}; // TODO webpack 5: refactor assetPath hook to receive { path, info } object

      var newPath = this.hooks.assetPath.call(path, options, assetInfo);
      return {
        path: newPath,
        info: assetInfo
      };
    }
    /**
     * Updates hash with information from this template
     * @param {Hash} hash the hash to update
     * @returns {void}
     */

  }, {
    key: "updateHash",
    value: function updateHash(hash) {
      hash.update("maintemplate");
      hash.update("3");
      this.hooks.hash.call(hash);
    }
    /**
     * TODO webpack 5: remove moduleTemplate and dependencyTemplates
     * Updates hash with chunk-specific information from this template
     * @param {Hash} hash the hash to update
     * @param {Chunk} chunk the chunk
     * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render
     * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates
     * @returns {void}
     */

  }, {
    key: "updateHashForChunk",
    value: function updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {
      this.updateHash(hash);
      this.hooks.hashForChunk.call(hash, chunk);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.renderBootstrap("0000", chunk, moduleTemplate, dependencyTemplates)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var line = _step.value;
          hash.update(line);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "useChunkHash",
    value: function useChunkHash(chunk) {
      var paths = this.hooks.globalHashPaths.call([]);
      return !this.hooks.globalHash.call(chunk, paths);
    }
  }]);

  return MainTemplate;
}(Tapable);