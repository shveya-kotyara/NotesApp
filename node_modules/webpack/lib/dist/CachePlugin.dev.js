/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var asyncLib = require("neo-async");

var CachePlugin =
/*#__PURE__*/
function () {
  function CachePlugin(cache) {
    _classCallCheck(this, CachePlugin);

    this.cache = cache || {};
    this.FS_ACCURACY = 2000;
  }

  _createClass(CachePlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      if (Array.isArray(compiler.compilers)) {
        compiler.compilers.forEach(function (c, idx) {
          new CachePlugin(_this.cache[idx] = _this.cache[idx] || {}).apply(c);
        });
      } else {
        var registerCacheToCompiler = function registerCacheToCompiler(compiler, cache) {
          compiler.hooks.thisCompilation.tap("CachePlugin", function (compilation) {
            compilation.cache = cache;
            compilation.hooks.childCompiler.tap("CachePlugin", function (childCompiler, compilerName, compilerIndex) {
              var childCache;

              if (!cache.children) {
                cache.children = {};
              }

              if (!cache.children[compilerName]) {
                cache.children[compilerName] = [];
              }

              if (cache.children[compilerName][compilerIndex]) {
                childCache = cache.children[compilerName][compilerIndex];
              } else {
                cache.children[compilerName].push(childCache = {});
              }

              registerCacheToCompiler(childCompiler, childCache);
            });
          });
        };

        registerCacheToCompiler(compiler, this.cache);
        compiler.hooks.watchRun.tap("CachePlugin", function () {
          _this.watching = true;
        });
        compiler.hooks.run.tapAsync("CachePlugin", function (compiler, callback) {
          if (!compiler._lastCompilationFileDependencies) {
            return callback();
          }

          var fs = compiler.inputFileSystem;
          var fileTs = compiler.fileTimestamps = new Map();
          asyncLib.forEach(compiler._lastCompilationFileDependencies, function (file, callback) {
            fs.stat(file, function (err, stat) {
              if (err) {
                if (err.code === "ENOENT") return callback();
                return callback(err);
              }

              if (stat.mtime) _this.applyMtime(+stat.mtime);
              fileTs.set(file, +stat.mtime || Infinity);
              callback();
            });
          }, function (err) {
            if (err) return callback(err);
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = fileTs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2),
                    file = _step$value[0],
                    ts = _step$value[1];

                fileTs.set(file, ts + _this.FS_ACCURACY);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            callback();
          });
        });
        compiler.hooks.afterCompile.tap("CachePlugin", function (compilation) {
          compilation.compiler._lastCompilationFileDependencies = compilation.fileDependencies;
          compilation.compiler._lastCompilationContextDependencies = compilation.contextDependencies;
        });
      }
    }
    /* istanbul ignore next */

  }, {
    key: "applyMtime",
    value: function applyMtime(mtime) {
      if (this.FS_ACCURACY > 1 && mtime % 2 !== 0) this.FS_ACCURACY = 1;else if (this.FS_ACCURACY > 10 && mtime % 20 !== 0) this.FS_ACCURACY = 10;else if (this.FS_ACCURACY > 100 && mtime % 200 !== 0) this.FS_ACCURACY = 100;else if (this.FS_ACCURACY > 1000 && mtime % 2000 !== 0) this.FS_ACCURACY = 1000;
    }
  }]);

  return CachePlugin;
}();

module.exports = CachePlugin;