/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var Generator = require("../Generator");

var Template = require("../Template");

var WebAssemblyUtils = require("./WebAssemblyUtils");

var _require = require("webpack-sources"),
    RawSource = _require.RawSource;

var _require2 = require("@webassemblyjs/wasm-edit"),
    editWithAST = _require2.editWithAST,
    addWithAST = _require2.addWithAST;

var _require3 = require("@webassemblyjs/wasm-parser"),
    decode = _require3.decode;

var t = require("@webassemblyjs/ast");

var _require4 = require("@webassemblyjs/helper-module-context"),
    moduleContextFromModuleAST = _require4.moduleContextFromModuleAST;

var WebAssemblyExportImportedDependency = require("../dependencies/WebAssemblyExportImportedDependency");
/** @typedef {import("../Module")} Module */

/** @typedef {import("./WebAssemblyUtils").UsedWasmDependency} UsedWasmDependency */

/** @typedef {import("../NormalModule")} NormalModule */

/** @typedef {import("../RuntimeTemplate")} RuntimeTemplate */

/** @typedef {import("webpack-sources").Source} Source */

/** @typedef {import("../Dependency").DependencyTemplate} DependencyTemplate */

/**
 * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform
 */

/**
 * @template T
 * @param {Function[]} fns transforms
 * @returns {Function} composed transform
 */


var compose = function compose() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return fns.reduce(function (prevFn, nextFn) {
    return function (value) {
      return nextFn(prevFn(value));
    };
  }, function (value) {
    return value;
  });
}; // TODO replace with @callback

/**
 * Removes the start instruction
 *
 * @param {Object} state unused state
 * @returns {ArrayBufferTransform} transform
 */


var removeStartFunc = function removeStartFunc(state) {
  return function (bin) {
    return editWithAST(state.ast, bin, {
      Start: function Start(path) {
        path.remove();
      }
    });
  };
};
/**
 * Get imported globals
 *
 * @param {Object} ast Module's AST
 * @returns {Array<t.ModuleImport>} - nodes
 */


var getImportedGlobals = function getImportedGlobals(ast) {
  var importedGlobals = [];
  t.traverse(ast, {
    ModuleImport: function ModuleImport(_ref) {
      var node = _ref.node;

      if (t.isGlobalType(node.descr)) {
        importedGlobals.push(node);
      }
    }
  });
  return importedGlobals;
};
/**
 * Get the count for imported func
 *
 * @param {Object} ast Module's AST
 * @returns {Number} - count
 */


var getCountImportedFunc = function getCountImportedFunc(ast) {
  var count = 0;
  t.traverse(ast, {
    ModuleImport: function ModuleImport(_ref2) {
      var node = _ref2.node;

      if (t.isFuncImportDescr(node.descr)) {
        count++;
      }
    }
  });
  return count;
};
/**
 * Get next type index
 *
 * @param {Object} ast Module's AST
 * @returns {t.Index} - index
 */


var getNextTypeIndex = function getNextTypeIndex(ast) {
  var typeSectionMetadata = t.getSectionMetadata(ast, "type");

  if (typeSectionMetadata === undefined) {
    return t.indexLiteral(0);
  }

  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);
};
/**
 * Get next func index
 *
 * The Func section metadata provide informations for implemented funcs
 * in order to have the correct index we shift the index by number of external
 * functions.
 *
 * @param {Object} ast Module's AST
 * @param {Number} countImportedFunc number of imported funcs
 * @returns {t.Index} - index
 */


var getNextFuncIndex = function getNextFuncIndex(ast, countImportedFunc) {
  var funcSectionMetadata = t.getSectionMetadata(ast, "func");

  if (funcSectionMetadata === undefined) {
    return t.indexLiteral(0 + countImportedFunc);
  }

  var vectorOfSize = funcSectionMetadata.vectorOfSize.value;
  return t.indexLiteral(vectorOfSize + countImportedFunc);
};
/**
 * Creates an init instruction for a global type
 * @param {t.GlobalType} globalType the global type
 * @returns {t.Instruction} init expression
 */


var createDefaultInitForGlobal = function createDefaultInitForGlobal(globalType) {
  if (globalType.valtype[0] === "i") {
    // create NumberLiteral global initializer
    return t.objectInstruction("const", globalType.valtype, [t.numberLiteralFromRaw(66)]);
  } else if (globalType.valtype[0] === "f") {
    // create FloatLiteral global initializer
    return t.objectInstruction("const", globalType.valtype, [t.floatLiteral(66, false, false, "66")]);
  } else {
    throw new Error("unknown type: " + globalType.valtype);
  }
};
/**
 * Rewrite the import globals:
 * - removes the ModuleImport instruction
 * - injects at the same offset a mutable global of the same type
 *
 * Since the imported globals are before the other global declarations, our
 * indices will be preserved.
 *
 * Note that globals will become mutable.
 *
 * @param {Object} state unused state
 * @returns {ArrayBufferTransform} transform
 */


var rewriteImportedGlobals = function rewriteImportedGlobals(state) {
  return function (bin) {
    var additionalInitCode = state.additionalInitCode;
    var newGlobals = [];
    bin = editWithAST(state.ast, bin, {
      ModuleImport: function ModuleImport(path) {
        if (t.isGlobalType(path.node.descr)) {
          var globalType = path.node.descr;
          globalType.mutability = "var";
          var init = [createDefaultInitForGlobal(globalType), t.instruction("end")];
          newGlobals.push(t.global(globalType, init));
          path.remove();
        }
      },
      // in order to preserve non-imported global's order we need to re-inject
      // those as well
      Global: function Global(path) {
        var node = path.node;

        var _node$init = _slicedToArray(node.init, 1),
            init = _node$init[0];

        if (init.id === "get_global") {
          node.globalType.mutability = "var";
          var initialGlobalidx = init.args[0];
          node.init = [createDefaultInitForGlobal(node.globalType), t.instruction("end")];
          additionalInitCode.push(
          /**
           * get_global in global initializer only works for imported globals.
           * They have the same indices as the init params, so use the
           * same index.
           */
          t.instruction("get_local", [initialGlobalidx]), t.instruction("set_global", [t.indexLiteral(newGlobals.length)]));
        }

        newGlobals.push(node);
        path.remove();
      }
    }); // Add global declaration instructions

    return addWithAST(state.ast, bin, newGlobals);
  };
};
/**
 * Rewrite the export names
 * @param {Object} state state
 * @param {Object} state.ast Module's ast
 * @param {Module} state.module Module
 * @param {Set<string>} state.externalExports Module
 * @returns {ArrayBufferTransform} transform
 */


var rewriteExportNames = function rewriteExportNames(_ref3) {
  var ast = _ref3.ast,
      module = _ref3.module,
      externalExports = _ref3.externalExports;
  return function (bin) {
    return editWithAST(ast, bin, {
      ModuleExport: function ModuleExport(path) {
        var isExternal = externalExports.has(path.node.name);

        if (isExternal) {
          path.remove();
          return;
        }

        var usedName = module.isUsed(path.node.name);

        if (!usedName) {
          path.remove();
          return;
        }

        path.node.name = usedName;
      }
    });
  };
};
/**
 * Mangle import names and modules
 * @param {Object} state state
 * @param {Object} state.ast Module's ast
 * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names
 * @returns {ArrayBufferTransform} transform
 */


var rewriteImports = function rewriteImports(_ref4) {
  var ast = _ref4.ast,
      usedDependencyMap = _ref4.usedDependencyMap;
  return function (bin) {
    return editWithAST(ast, bin, {
      ModuleImport: function ModuleImport(path) {
        var result = usedDependencyMap.get(path.node.module + ":" + path.node.name);

        if (result !== undefined) {
          path.node.module = result.module;
          path.node.name = result.name;
        }
      }
    });
  };
};
/**
 * Add an init function.
 *
 * The init function fills the globals given input arguments.
 *
 * @param {Object} state transformation state
 * @param {Object} state.ast Module's ast
 * @param {t.Identifier} state.initFuncId identifier of the init function
 * @param {t.Index} state.startAtFuncOffset index of the start function
 * @param {t.ModuleImport[]} state.importedGlobals list of imported globals
 * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function
 * @param {t.Index} state.nextFuncIndex index of the next function
 * @param {t.Index} state.nextTypeIndex index of the next type
 * @returns {ArrayBufferTransform} transform
 */


var addInitFunction = function addInitFunction(_ref5) {
  var ast = _ref5.ast,
      initFuncId = _ref5.initFuncId,
      startAtFuncOffset = _ref5.startAtFuncOffset,
      importedGlobals = _ref5.importedGlobals,
      additionalInitCode = _ref5.additionalInitCode,
      nextFuncIndex = _ref5.nextFuncIndex,
      nextTypeIndex = _ref5.nextTypeIndex;
  return function (bin) {
    var funcParams = importedGlobals.map(function (importedGlobal) {
      // used for debugging
      var id = t.identifier("".concat(importedGlobal.module, ".").concat(importedGlobal.name));
      return t.funcParam(importedGlobal.descr.valtype, id);
    });
    var funcBody = importedGlobals.reduce(function (acc, importedGlobal, index) {
      var args = [t.indexLiteral(index)];
      var body = [t.instruction("get_local", args), t.instruction("set_global", args)];
      return [].concat(_toConsumableArray(acc), body);
    }, []);

    if (typeof startAtFuncOffset === "number") {
      funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = additionalInitCode[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var instr = _step.value;
        funcBody.push(instr);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    funcBody.push(t.instruction("end"));
    var funcResults = []; // Code section

    var funcSignature = t.signature(funcParams, funcResults);
    var func = t.func(initFuncId, funcSignature, funcBody); // Type section

    var functype = t.typeInstruction(undefined, funcSignature); // Func section

    var funcindex = t.indexInFuncSection(nextTypeIndex); // Export section

    var moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr("Func", nextFuncIndex));
    return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);
  };
};
/**
 * Extract mangle mappings from module
 * @param {Module} module current module
 * @param {boolean} mangle mangle imports
 * @returns {Map<string, UsedWasmDependency>} mappings to mangled names
 */


var getUsedDependencyMap = function getUsedDependencyMap(module, mangle) {
  /** @type {Map<string, UsedWasmDependency>} */
  var map = new Map();
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = WebAssemblyUtils.getUsedDependencies(module, mangle)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var usedDep = _step2.value;
      var dep = usedDep.dependency;
      var request = dep.request;
      var exportName = dep.name;
      map.set(request + ":" + exportName, usedDep);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return map;
};

var WebAssemblyGenerator =
/*#__PURE__*/
function (_Generator) {
  _inherits(WebAssemblyGenerator, _Generator);

  function WebAssemblyGenerator(options) {
    var _this;

    _classCallCheck(this, WebAssemblyGenerator);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebAssemblyGenerator).call(this));
    _this.options = options;
    return _this;
  }
  /**
   * @param {NormalModule} module module for which the code should be generated
   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates
   * @param {RuntimeTemplate} runtimeTemplate the runtime template
   * @param {string} type which kind of code should be generated
   * @returns {Source} generated code
   */


  _createClass(WebAssemblyGenerator, [{
    key: "generate",
    value: function generate(module, dependencyTemplates, runtimeTemplate, type) {
      var bin = module.originalSource().source();
      var initFuncId = t.identifier(Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : "__webpack_init__"); // parse it

      var ast = decode(bin, {
        ignoreDataSection: true,
        ignoreCodeSection: true,
        ignoreCustomNameSection: true
      });
      var moduleContext = moduleContextFromModuleAST(ast.body[0]);
      var importedGlobals = getImportedGlobals(ast);
      var countImportedFunc = getCountImportedFunc(ast);
      var startAtFuncOffset = moduleContext.getStart();
      var nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);
      var nextTypeIndex = getNextTypeIndex(ast);
      var usedDependencyMap = getUsedDependencyMap(module, this.options.mangleImports);
      var externalExports = new Set(module.dependencies.filter(function (d) {
        return d instanceof WebAssemblyExportImportedDependency;
      }).map(function (d) {
        var wasmDep =
        /** @type {WebAssemblyExportImportedDependency} */
        d;
        return wasmDep.exportName;
      }));
      /** @type {t.Instruction[]} */

      var additionalInitCode = [];
      var transform = compose(rewriteExportNames({
        ast: ast,
        module: module,
        externalExports: externalExports
      }), removeStartFunc({
        ast: ast
      }), rewriteImportedGlobals({
        ast: ast,
        additionalInitCode: additionalInitCode
      }), rewriteImports({
        ast: ast,
        usedDependencyMap: usedDependencyMap
      }), addInitFunction({
        ast: ast,
        initFuncId: initFuncId,
        importedGlobals: importedGlobals,
        additionalInitCode: additionalInitCode,
        startAtFuncOffset: startAtFuncOffset,
        nextFuncIndex: nextFuncIndex,
        nextTypeIndex: nextTypeIndex
      }));
      var newBin = transform(bin);
      return new RawSource(newBin);
    }
  }]);

  return WebAssemblyGenerator;
}(Generator);

module.exports = WebAssemblyGenerator;