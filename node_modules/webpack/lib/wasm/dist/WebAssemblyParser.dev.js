/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var t = require("@webassemblyjs/ast");

var _require = require("@webassemblyjs/wasm-parser"),
    decode = _require.decode;

var _require2 = require("@webassemblyjs/helper-module-context"),
    moduleContextFromModuleAST = _require2.moduleContextFromModuleAST;

var _require3 = require("tapable"),
    Tapable = _require3.Tapable;

var WebAssemblyImportDependency = require("../dependencies/WebAssemblyImportDependency");

var WebAssemblyExportImportedDependency = require("../dependencies/WebAssemblyExportImportedDependency");
/** @typedef {import("../Module")} Module */


var JS_COMPAT_TYPES = new Set(["i32", "f32", "f64"]);
/**
 * @param {t.Signature} signature the func signature
 * @returns {null | string} the type incompatible with js types
 */

var getJsIncompatibleType = function getJsIncompatibleType(signature) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = signature.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var param = _step.value;

      if (!JS_COMPAT_TYPES.has(param.valtype)) {
        return "".concat(param.valtype, " as parameter");
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = signature.results[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var type = _step2.value;
      if (!JS_COMPAT_TYPES.has(type)) return "".concat(type, " as result");
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return null;
};
/**
 * TODO why are there two different Signature types?
 * @param {t.FuncSignature} signature the func signature
 * @returns {null | string} the type incompatible with js types
 */


var getJsIncompatibleTypeOfFuncSignature = function getJsIncompatibleTypeOfFuncSignature(signature) {
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = signature.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var param = _step3.value;

      if (!JS_COMPAT_TYPES.has(param)) {
        return "".concat(param, " as parameter");
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = signature.result[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var type = _step4.value;
      if (!JS_COMPAT_TYPES.has(type)) return "".concat(type, " as result");
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return null;
};

var decoderOpts = {
  ignoreCodeSection: true,
  ignoreDataSection: true,
  // this will avoid having to lookup with identifiers in the ModuleContext
  ignoreCustomNameSection: true
};

var WebAssemblyParser =
/*#__PURE__*/
function (_Tapable) {
  _inherits(WebAssemblyParser, _Tapable);

  function WebAssemblyParser(options) {
    var _this;

    _classCallCheck(this, WebAssemblyParser);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebAssemblyParser).call(this));
    _this.hooks = {};
    _this.options = options;
    return _this;
  }

  _createClass(WebAssemblyParser, [{
    key: "parse",
    value: function parse(binary, state) {
      // flag it as ESM
      state.module.buildMeta.exportsType = "namespace"; // parse it

      var program = decode(binary, decoderOpts);
      var module = program.body[0];
      var moduleContext = moduleContextFromModuleAST(module); // extract imports and exports

      var exports = state.module.buildMeta.providedExports = [];
      var jsIncompatibleExports = state.module.buildMeta.jsIncompatibleExports = [];
      var importedGlobals = [];
      t.traverse(module, {
        ModuleExport: function ModuleExport(_ref) {
          var node = _ref.node;
          var descriptor = node.descr;

          if (descriptor.exportType === "Func") {
            var funcidx = descriptor.id.value;
            /** @type {t.FuncSignature} */

            var funcSignature = moduleContext.getFunction(funcidx);
            var incompatibleType = getJsIncompatibleTypeOfFuncSignature(funcSignature);

            if (incompatibleType) {
              jsIncompatibleExports[node.name] = incompatibleType;
            }
          }

          exports.push(node.name);

          if (node.descr && node.descr.exportType === "Global") {
            var refNode = importedGlobals[node.descr.id.value];

            if (refNode) {
              var dep = new WebAssemblyExportImportedDependency(node.name, refNode.module, refNode.name, refNode.descr.valtype);
              state.module.addDependency(dep);
            }
          }
        },
        Global: function Global(_ref2) {
          var node = _ref2.node;
          var init = node.init[0];
          var importNode = null;

          if (init.id === "get_global") {
            var globalIdx = init.args[0].value;

            if (globalIdx < importedGlobals.length) {
              importNode = importedGlobals[globalIdx];
            }
          }

          importedGlobals.push(importNode);
        },
        ModuleImport: function ModuleImport(_ref3) {
          var node = _ref3.node;

          /** @type {false | string} */
          var onlyDirectImport = false;

          if (t.isMemory(node.descr) === true) {
            onlyDirectImport = "Memory";
          } else if (t.isTable(node.descr) === true) {
            onlyDirectImport = "Table";
          } else if (t.isFuncImportDescr(node.descr) === true) {
            var incompatibleType = getJsIncompatibleType(node.descr.signature);

            if (incompatibleType) {
              onlyDirectImport = "Non-JS-compatible Func Sigurature (".concat(incompatibleType, ")");
            }
          } else if (t.isGlobalType(node.descr) === true) {
            var type = node.descr.valtype;

            if (!JS_COMPAT_TYPES.has(type)) {
              onlyDirectImport = "Non-JS-compatible Global Type (".concat(type, ")");
            }
          }

          var dep = new WebAssemblyImportDependency(node.module, node.name, node.descr, onlyDirectImport);
          state.module.addDependency(dep);

          if (t.isGlobalType(node.descr)) {
            importedGlobals.push(node);
          }
        }
      });
      return state;
    }
  }]);

  return WebAssemblyParser;
}(Tapable);

module.exports = WebAssemblyParser;