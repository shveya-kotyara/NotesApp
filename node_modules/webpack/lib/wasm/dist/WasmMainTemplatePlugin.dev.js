/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var Template = require("../Template");

var WebAssemblyUtils = require("./WebAssemblyUtils");
/** @typedef {import("../Module")} Module */

/** @typedef {import("../MainTemplate")} MainTemplate */
// Get all wasm modules


var getAllWasmModules = function getAllWasmModules(chunk) {
  var wasmModules = chunk.getAllAsyncChunks();
  var array = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = wasmModules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _chunk = _step.value;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _chunk.modulesIterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var m = _step2.value;

          if (m.type.startsWith("webassembly")) {
            array.push(m);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return array;
};
/**
 * generates the import object function for a module
 * @param {Module} module the module
 * @param {boolean} mangle mangle imports
 * @returns {string} source code
 */


var generateImportObject = function generateImportObject(module, mangle) {
  var waitForInstances = new Map();
  var properties = [];
  var usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(module, mangle);
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = usedWasmDependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var usedDep = _step3.value;
      var dep = usedDep.dependency;
      var importedModule = dep.module;
      var exportName = dep.name;
      var usedName = importedModule && importedModule.isUsed(exportName);
      var description = dep.description;
      var direct = dep.onlyDirectImport;
      var _module = usedDep.module;
      var name = usedDep.name;

      if (direct) {
        var instanceVar = "m".concat(waitForInstances.size);
        waitForInstances.set(instanceVar, importedModule.id);
        properties.push({
          module: _module,
          name: name,
          value: "".concat(instanceVar, "[").concat(JSON.stringify(usedName), "]")
        });
      } else {
        var params = description.signature.params.map(function (param, k) {
          return "p" + k + param.valtype;
        });
        var mod = "installedModules[".concat(JSON.stringify(importedModule.id), "]");
        var func = "".concat(mod, ".exports[").concat(JSON.stringify(usedName), "]");
        properties.push({
          module: _module,
          name: name,
          value: Template.asString([(importedModule.type.startsWith("webassembly") ? "".concat(mod, " ? ").concat(func, " : ") : "") + "function(".concat(params, ") {"), Template.indent(["return ".concat(func, "(").concat(params, ");")]), "}"])
        });
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var importObject;

  if (mangle) {
    importObject = ["return {", Template.indent([properties.map(function (p) {
      return "".concat(JSON.stringify(p.name), ": ").concat(p.value);
    }).join(",\n")]), "};"];
  } else {
    var propertiesByModule = new Map();
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var p = _step4.value;
        var list = propertiesByModule.get(p.module);

        if (list === undefined) {
          propertiesByModule.set(p.module, list = []);
        }

        list.push(p);
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    importObject = ["return {", Template.indent([Array.from(propertiesByModule, function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          module = _ref2[0],
          list = _ref2[1];

      return Template.asString(["".concat(JSON.stringify(module), ": {"), Template.indent([list.map(function (p) {
        return "".concat(JSON.stringify(p.name), ": ").concat(p.value);
      }).join(",\n")]), "}"]);
    }).join(",\n")]), "};"];
  }

  if (waitForInstances.size === 1) {
    var moduleId = Array.from(waitForInstances.values())[0];
    var promise = "installedWasmModules[".concat(JSON.stringify(moduleId), "]");
    var variable = Array.from(waitForInstances.keys())[0];
    return Template.asString(["".concat(JSON.stringify(module.id), ": function() {"), Template.indent(["return promiseResolve().then(function() { return ".concat(promise, "; }).then(function(").concat(variable, ") {"), Template.indent(importObject), "});"]), "},"]);
  } else if (waitForInstances.size > 0) {
    var promises = Array.from(waitForInstances.values(), function (id) {
      return "installedWasmModules[".concat(JSON.stringify(id), "]");
    }).join(", ");
    var variables = Array.from(waitForInstances.keys(), function (name, i) {
      return "".concat(name, " = array[").concat(i, "]");
    }).join(", ");
    return Template.asString(["".concat(JSON.stringify(module.id), ": function() {"), Template.indent(["return promiseResolve().then(function() { return Promise.all([".concat(promises, "]); }).then(function(array) {"), Template.indent(["var ".concat(variables, ";")].concat(_toConsumableArray(importObject))), "});"]), "},"]);
  } else {
    return Template.asString(["".concat(JSON.stringify(module.id), ": function() {"), Template.indent(importObject), "},"]);
  }
};

var WasmMainTemplatePlugin =
/*#__PURE__*/
function () {
  function WasmMainTemplatePlugin(_ref3) {
    var generateLoadBinaryCode = _ref3.generateLoadBinaryCode,
        supportsStreaming = _ref3.supportsStreaming,
        mangleImports = _ref3.mangleImports;

    _classCallCheck(this, WasmMainTemplatePlugin);

    this.generateLoadBinaryCode = generateLoadBinaryCode;
    this.supportsStreaming = supportsStreaming;
    this.mangleImports = mangleImports;
  }
  /**
   * @param {MainTemplate} mainTemplate main template
   * @returns {void}
   */


  _createClass(WasmMainTemplatePlugin, [{
    key: "apply",
    value: function apply(mainTemplate) {
      var _this = this;

      mainTemplate.hooks.localVars.tap("WasmMainTemplatePlugin", function (source, chunk) {
        var wasmModules = getAllWasmModules(chunk);
        if (wasmModules.length === 0) return source;
        var importObjects = wasmModules.map(function (module) {
          return generateImportObject(module, _this.mangleImports);
        });
        return Template.asString([source, "", "// object to store loaded and loading wasm modules", "var installedWasmModules = {};", "", // This function is used to delay reading the installed wasm module promises
        // by a microtask. Sorting them doesn't help because there are egdecases where
        // sorting is not possible (modules splitted into different chunks).
        // So we not even trying and solve this by a microtask delay.
        "function promiseResolve() { return Promise.resolve(); }", "", "var wasmImportObjects = {", Template.indent(importObjects), "};"]);
      });
      mainTemplate.hooks.requireEnsure.tap("WasmMainTemplatePlugin", function (source, chunk, hash) {
        var webassemblyModuleFilename = mainTemplate.outputOptions.webassemblyModuleFilename;
        var chunkModuleMaps = chunk.getChunkModuleMaps(function (m) {
          return m.type.startsWith("webassembly");
        });
        if (Object.keys(chunkModuleMaps.id).length === 0) return source;
        var wasmModuleSrcPath = mainTemplate.getAssetPath(JSON.stringify(webassemblyModuleFilename), {
          hash: "\" + ".concat(mainTemplate.renderCurrentHashCode(hash), " + \""),
          hashWithLength: function hashWithLength(length) {
            return "\" + ".concat(mainTemplate.renderCurrentHashCode(hash, length), " + \"");
          },
          module: {
            id: '" + wasmModuleId + "',
            hash: "\" + ".concat(JSON.stringify(chunkModuleMaps.hash), "[wasmModuleId] + \""),
            hashWithLength: function hashWithLength(length) {
              var shortChunkHashMap = Object.create(null);

              for (var _i2 = 0, _Object$keys = Object.keys(chunkModuleMaps.hash); _i2 < _Object$keys.length; _i2++) {
                var wasmModuleId = _Object$keys[_i2];

                if (typeof chunkModuleMaps.hash[wasmModuleId] === "string") {
                  shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[wasmModuleId].substr(0, length);
                }
              }

              return "\" + ".concat(JSON.stringify(shortChunkHashMap), "[wasmModuleId] + \"");
            }
          }
        });

        var createImportObject = function createImportObject(content) {
          return _this.mangleImports ? "{ ".concat(JSON.stringify(WebAssemblyUtils.MANGLED_MODULE), ": ").concat(content, " }") : content;
        };

        return Template.asString([source, "", "// Fetch + compile chunk loading for webassembly", "", "var wasmModules = ".concat(JSON.stringify(chunkModuleMaps.id), "[chunkId] || [];"), "", "wasmModules.forEach(function(wasmModuleId) {", Template.indent(["var installedWasmModuleData = installedWasmModules[wasmModuleId];", "", '// a Promise means "currently loading" or "already loaded".', "if(installedWasmModuleData)", Template.indent(["promises.push(installedWasmModuleData);"]), "else {", Template.indent(["var importObject = wasmImportObjects[wasmModuleId]();", "var req = ".concat(_this.generateLoadBinaryCode(wasmModuleSrcPath), ";"), "var promise;", _this.supportsStreaming ? Template.asString(["if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {", Template.indent(["promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {", Template.indent(["return WebAssembly.instantiate(items[0], ".concat(createImportObject("items[1]"), ");")]), "});"]), "} else if(typeof WebAssembly.instantiateStreaming === 'function') {", Template.indent(["promise = WebAssembly.instantiateStreaming(req, ".concat(createImportObject("importObject"), ");")])]) : Template.asString(["if(importObject instanceof Promise) {", Template.indent(["var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });", "promise = Promise.all([", Template.indent(["bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),", "importObject"]), "]).then(function(items) {", Template.indent(["return WebAssembly.instantiate(items[0], ".concat(createImportObject("items[1]"), ");")]), "});"])]), "} else {", Template.indent(["var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });", "promise = bytesPromise.then(function(bytes) {", Template.indent(["return WebAssembly.instantiate(bytes, ".concat(createImportObject("importObject"), ");")]), "});"]), "}", "promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {", Template.indent(["return ".concat(mainTemplate.requireFn, ".w[wasmModuleId] = (res.instance || res).exports;")]), "}));"]), "}"]), "});"]);
      });
      mainTemplate.hooks.requireExtensions.tap("WasmMainTemplatePlugin", function (source, chunk) {
        if (!chunk.hasModuleInGraph(function (m) {
          return m.type.startsWith("webassembly");
        })) {
          return source;
        }

        return Template.asString([source, "", "// object with all WebAssembly.instance exports", "".concat(mainTemplate.requireFn, ".w = {};")]);
      });
      mainTemplate.hooks.hash.tap("WasmMainTemplatePlugin", function (hash) {
        hash.update("WasmMainTemplatePlugin");
        hash.update("2");
      });
    }
  }]);

  return WasmMainTemplatePlugin;
}();

module.exports = WasmMainTemplatePlugin;