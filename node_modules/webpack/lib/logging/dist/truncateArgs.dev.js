/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */
"use strict";
/**
 * @param {any[]} args items to be truncated
 * @param {number} maxLength maximum length of args including spaces between
 * @returns {string[]} truncated args
 */

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var truncateArgs = function truncateArgs(args, maxLength) {
  var lengths = args.map(function (a) {
    return "".concat(a).length;
  });
  var availableLength = maxLength - lengths.length + 1;

  if (availableLength > 0 && args.length === 1) {
    if (availableLength >= args[0].length) {
      return args;
    } else if (availableLength > 3) {
      return ["..." + args[0].slice(-availableLength + 3)];
    } else {
      return [args[0].slice(-availableLength)];
    }
  } // Check if there is space for at least 4 chars per arg


  if (availableLength < lengths.reduce(function (s, i) {
    return s + Math.min(i, 6);
  }, 0)) {
    // remove args
    if (args.length > 1) return truncateArgs(args.slice(0, args.length - 1), maxLength);
    return [];
  }

  var currentLength = lengths.reduce(function (a, b) {
    return a + b;
  }, 0); // Check if all fits into maxLength

  if (currentLength <= availableLength) return args; // Try to remove chars from the longest items until it fits

  var _loop = function _loop() {
    var maxLength = Math.max.apply(Math, _toConsumableArray(lengths));
    var shorterItems = lengths.filter(function (l) {
      return l !== maxLength;
    });
    var nextToMaxLength = shorterItems.length > 0 ? Math.max.apply(Math, _toConsumableArray(shorterItems)) : 0;
    var maxReduce = maxLength - nextToMaxLength;
    var maxItems = lengths.length - shorterItems.length;
    var overrun = currentLength - availableLength;

    for (var i = 0; i < lengths.length; i++) {
      if (lengths[i] === maxLength) {
        var reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);
        lengths[i] -= reduce;
        currentLength -= reduce;
        overrun -= reduce;
        maxItems--;
      }
    }
  };

  while (currentLength > availableLength) {
    _loop();
  } // Return args reduced to length in lengths


  return args.map(function (a, i) {
    var str = "".concat(a);
    var length = lengths[i];

    if (str.length === length) {
      return str;
    } else if (length > 5) {
      return "..." + str.slice(-length + 3);
    } else if (length > 0) {
      return str.slice(-length);
    } else {
      return "";
    }
  });
};

module.exports = truncateArgs;