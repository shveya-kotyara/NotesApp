/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SortableSet = require("./SortableSet");
/**
 * @template T
 * @template K
 * Multi layer bucket sorted set
 * Supports adding non-existing items (DO NOT ADD ITEM TWICE)
 * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET)
 * Supports popping the first items according to defined order
 * Supports iterating all items without order
 * Supports updating an item in an efficient way
 * Supports size property, which is the number of items
 * Items are lazy partially sorted when needed
 */


var LazyBucketSortedSet =
/*#__PURE__*/
function () {
  /**
   * @param {function(T): K} getKey function to get key from item
   * @param {function(K, K): number} comparator comparator to sort keys
   * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer
   */
  function LazyBucketSortedSet(getKey, comparator) {
    _classCallCheck(this, LazyBucketSortedSet);

    this._getKey = getKey;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this._innerArgs = args;
    this._leaf = args.length <= 1;
    this._keys = new SortableSet(undefined, comparator);
    /** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */

    this._map = new Map();
    this._unsortedItems = new Set();
    this.size = 0;
  }
  /**
   * @param {T} item an item
   * @returns {void}
   */


  _createClass(LazyBucketSortedSet, [{
    key: "add",
    value: function add(item) {
      this.size++;

      this._unsortedItems.add(item);
    }
    /**
     * @param {K} key key of item
     * @param {T} item the item
     * @returns {void}
     */

  }, {
    key: "_addInternal",
    value: function _addInternal(key, item) {
      var entry = this._map.get(key);

      if (entry === undefined) {
        entry = this._leaf ? new SortableSet(undefined, this._innerArgs[0]) : _construct(
        /** @type {any} */
        LazyBucketSortedSet, _toConsumableArray(this._innerArgs));

        this._keys.add(key);

        this._map.set(key, entry);
      }

      entry.add(item);
    }
    /**
     * @param {T} item an item
     * @returns {void}
     */

  }, {
    key: "delete",
    value: function _delete(item) {
      this.size--;

      if (this._unsortedItems.has(item)) {
        this._unsortedItems["delete"](item);

        return;
      }

      var key = this._getKey(item);

      var entry = this._map.get(key);

      entry["delete"](item);

      if (entry.size === 0) {
        this._deleteKey(key);
      }
    }
    /**
     * @param {K} key key to be removed
     * @returns {void}
     */

  }, {
    key: "_deleteKey",
    value: function _deleteKey(key) {
      this._keys["delete"](key);

      this._map["delete"](key);
    }
    /**
     * @returns {T | undefined} an item
     */

  }, {
    key: "popFirst",
    value: function popFirst() {
      if (this.size === 0) return undefined;
      this.size--;

      if (this._unsortedItems.size > 0) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._unsortedItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            var _key2 = this._getKey(item);

            this._addInternal(_key2, item);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this._unsortedItems.clear();
      }

      this._keys.sort();

      var key = this._keys.values().next().value;

      var entry = this._map.get(key);

      if (this._leaf) {
        var leafEntry =
        /** @type {SortableSet<T>} */
        entry;
        leafEntry.sort();
        var _item = leafEntry.values().next().value;
        leafEntry["delete"](_item);

        if (leafEntry.size === 0) {
          this._deleteKey(key);
        }

        return _item;
      } else {
        var nodeEntry =
        /** @type {LazyBucketSortedSet<T, any>} */
        entry;

        var _item2 = nodeEntry.popFirst();

        if (nodeEntry.size === 0) {
          this._deleteKey(key);
        }

        return _item2;
      }
    }
    /**
     * @param {T} item to be updated item
     * @returns {function(true=): void} finish update
     */

  }, {
    key: "startUpdate",
    value: function startUpdate(item) {
      var _this = this;

      if (this._unsortedItems.has(item)) {
        return function (remove) {
          if (remove) {
            _this._unsortedItems["delete"](item);

            _this.size--;
            return;
          }
        };
      }

      var key = this._getKey(item);

      if (this._leaf) {
        var oldEntry =
        /** @type {SortableSet<T>} */
        this._map.get(key);

        return function (remove) {
          if (remove) {
            _this.size--;
            oldEntry["delete"](item);

            if (oldEntry.size === 0) {
              _this._deleteKey(key);
            }

            return;
          }

          var newKey = _this._getKey(item);

          if (key === newKey) {
            // This flags the sortable set as unordered
            oldEntry.add(item);
          } else {
            oldEntry["delete"](item);

            if (oldEntry.size === 0) {
              _this._deleteKey(key);
            }

            _this._addInternal(newKey, item);
          }
        };
      } else {
        var _oldEntry =
        /** @type {LazyBucketSortedSet<T, any>} */
        this._map.get(key);

        var finishUpdate = _oldEntry.startUpdate(item);

        return function (remove) {
          if (remove) {
            _this.size--;
            finishUpdate(true);

            if (_oldEntry.size === 0) {
              _this._deleteKey(key);
            }

            return;
          }

          var newKey = _this._getKey(item);

          if (key === newKey) {
            finishUpdate();
          } else {
            finishUpdate(true);

            if (_oldEntry.size === 0) {
              _this._deleteKey(key);
            }

            _this._addInternal(newKey, item);
          }
        };
      }
    }
    /**
     * @param {Iterator<T>[]} iterators list of iterators to append to
     * @returns {void}
     */

  }, {
    key: "_appendIterators",
    value: function _appendIterators(iterators) {
      if (this._unsortedItems.size > 0) iterators.push(this._unsortedItems[Symbol.iterator]());
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          var entry = this._map.get(key);

          if (this._leaf) {
            var leafEntry =
            /** @type {SortableSet<T>} */
            entry;
            var iterator = leafEntry[Symbol.iterator]();
            iterators.push(iterator);
          } else {
            var nodeEntry =
            /** @type {LazyBucketSortedSet<T, any>} */
            entry;

            nodeEntry._appendIterators(iterators);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * @returns {Iterator<T>} the iterator
     */

  }, {
    key: Symbol.iterator,
    value: function value() {
      var iterators = [];

      this._appendIterators(iterators);

      iterators.reverse();
      var currentIterator = iterators.pop();
      return {
        next: function next() {
          var res = currentIterator.next();

          if (res.done) {
            if (iterators.length === 0) return res;
            currentIterator = iterators.pop();
            return currentIterator.next();
          }

          return res;
        }
      };
    }
  }]);

  return LazyBucketSortedSet;
}();

module.exports = LazyBucketSortedSet;