/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

var mergeCache = new WeakMap();
/**
 * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.
 * @example
 * // performs cleverMerge(first, second), stores the result in WeakMap and returns result
 * cachedCleverMerge({a: 1}, {a: 2})
 * {a: 2}
 *  // when same arguments passed, gets the result from WeakMap and returns it.
 * cachedCleverMerge({a: 1}, {a: 2})
 * {a: 2}
 * @param {object} first first object
 * @param {object} second second object
 * @returns {object} merged object of first and second object
 */

var cachedCleverMerge = function cachedCleverMerge(first, second) {
  var innerCache = mergeCache.get(first);

  if (innerCache === undefined) {
    innerCache = new WeakMap();
    mergeCache.set(first, innerCache);
  }

  var prevMerge = innerCache.get(second);
  if (prevMerge !== undefined) return prevMerge;
  var newMerge = cleverMerge(first, second);
  innerCache.set(second, newMerge);
  return newMerge;
};
/**
 * Merges two objects. Objects are not deeply merged.
 * TODO webpack 5: merge objects deeply clever.
 * Arrays might reference the old value with "..."
 * @param {object} first first object
 * @param {object} second second object
 * @returns {object} merged object of first and second object
 */


var cleverMerge = function cleverMerge(first, second) {
  var newObject = Object.assign({}, first);

  for (var _i = 0, _Object$keys = Object.keys(second); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (!(key in newObject)) {
      newObject[key] = second[key];
      continue;
    }

    var secondValue = second[key];

    if (!Array.isArray(secondValue)) {
      newObject[key] = secondValue;
      continue;
    }

    var firstValue = newObject[key];

    if (Array.isArray(firstValue)) {
      var newArray = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = secondValue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          if (item === "...") {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = firstValue[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _item = _step2.value;
                newArray.push(_item);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          } else {
            newArray.push(item);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      newObject[key] = newArray;
    } else {
      newObject[key] = secondValue;
    }
  }

  return newObject;
};

exports.cachedCleverMerge = cachedCleverMerge;
exports.cleverMerge = cleverMerge;