"use strict"; // Simulations show these probabilities for a single change
// 93.1% that one group is invalidated
// 4.8% that two groups are invalidated
// 1.1% that 3 groups are invalidated
// 0.1% that 4 or more groups are invalidated
//
// And these for removing/adding 10 lexically adjacent files
// 64.5% that one group is invalidated
// 24.8% that two groups are invalidated
// 7.8% that 3 groups are invalidated
// 2.7% that 4 or more groups are invalidated
//
// And these for removing/adding 3 random files
// 0% that one group is invalidated
// 3.7% that two groups are invalidated
// 80.8% that 3 groups are invalidated
// 12.3% that 4 groups are invalidated
// 3.2% that 5 or more groups are invalidated

/**
 *
 * @param {string} a key
 * @param {string} b key
 * @returns {number} the similarity as number
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var similarity = function similarity(a, b) {
  var l = Math.min(a.length, b.length);
  var dist = 0;

  for (var i = 0; i < l; i++) {
    var ca = a.charCodeAt(i);
    var cb = b.charCodeAt(i);
    dist += Math.max(0, 10 - Math.abs(ca - cb));
  }

  return dist;
};
/**
 * @param {string} a key
 * @param {string} b key
 * @returns {string} the common part and a single char for the difference
 */


var getName = function getName(a, b) {
  var l = Math.min(a.length, b.length);
  var r = "";

  for (var i = 0; i < l; i++) {
    var ca = a.charAt(i);
    var cb = b.charAt(i);
    r += ca;

    if (ca === cb) {
      continue;
    }

    return r;
  }

  return a;
};
/**
 * @template T
 */


var Node =
/**
 * @param {T} item item
 * @param {string} key key
 * @param {number} size size
 */
function Node(item, key, size) {
  _classCallCheck(this, Node);

  this.item = item;
  this.key = key;
  this.size = size;
};
/**
 * @template T
 */


var Group =
/**
 * @param {Node<T>[]} nodes nodes
 * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)
 */
function Group(nodes, similarities) {
  _classCallCheck(this, Group);

  this.nodes = nodes;
  this.similarities = similarities;
  this.size = nodes.reduce(function (size, node) {
    return size + node.size;
  }, 0);
  /** @type {string} */

  this.key = undefined;
};
/**
 * @template T
 * @typedef {Object} GroupedItems<T>
 * @property {string} key
 * @property {T[]} items
 * @property {number} size
 */

/**
 * @template T
 * @typedef {Object} Options
 * @property {number} maxSize maximum size of a group
 * @property {number} minSize minimum size of a group (preferred over maximum size)
 * @property {Iterable<T>} items a list of items
 * @property {function(T): number} getSize function to get size of an item
 * @property {function(T): string} getKey function to get the key of an item
 */

/**
 * @template T
 * @param {Options<T>} options options object
 * @returns {GroupedItems<T>[]} grouped items
 */


module.exports = function (_ref) {
  var maxSize = _ref.maxSize,
      minSize = _ref.minSize,
      items = _ref.items,
      getSize = _ref.getSize,
      getKey = _ref.getKey;

  /** @type {Group<T>[]} */
  var result = [];
  var nodes = Array.from(items, function (item) {
    return new Node(item, getKey(item), getSize(item));
  });
  /** @type {Node<T>[]} */

  var initialNodes = []; // lexically ordering of keys

  nodes.sort(function (a, b) {
    if (a.key < b.key) return -1;
    if (a.key > b.key) return 1;
    return 0;
  }); // return nodes bigger than maxSize directly as group

  for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
    var _node = _nodes[_i];

    if (_node.size >= maxSize) {
      result.push(new Group([_node], []));
    } else {
      initialNodes.push(_node);
    }
  }

  if (initialNodes.length > 0) {
    // calculate similarities between lexically adjacent nodes

    /** @type {number[]} */
    var similarities = [];

    for (var i = 1; i < initialNodes.length; i++) {
      var a = initialNodes[i - 1];
      var b = initialNodes[i];
      similarities.push(similarity(a.key, b.key));
    }

    var initialGroup = new Group(initialNodes, similarities);

    if (initialGroup.size < minSize) {
      // We hit an edgecase where the working set is already smaller than minSize
      // We merge it with the smallest result node to keep minSize intact
      if (result.length > 0) {
        var smallestGroup = result.reduce(function (min, group) {
          return min.size > group.size ? group : min;
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = initialGroup.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;
            smallestGroup.nodes.push(node);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        smallestGroup.nodes.sort(function (a, b) {
          if (a.key < b.key) return -1;
          if (a.key > b.key) return 1;
          return 0;
        });
      } else {
        // There are no other nodes
        // We use all nodes and have to accept that it's smaller than minSize
        result.push(initialGroup);
      }
    } else {
      var queue = [initialGroup];

      while (queue.length) {
        var group = queue.pop(); // only groups bigger than maxSize need to be splitted

        if (group.size < maxSize) {
          result.push(group);
          continue;
        } // find unsplittable area from left and right
        // going minSize from left and right
        // at least one node need to be included otherwise we get stuck


        var left = 0;
        var leftSize = 0;

        while (leftSize <= minSize) {
          leftSize += group.nodes[left].size;
          left++;
        }

        var right = group.nodes.length - 1;
        var rightSize = 0;

        while (rightSize <= minSize) {
          rightSize += group.nodes[right].size;
          right--;
        }

        if (left - 1 > right) {
          // can't split group while holding minSize
          // because minSize is preferred of maxSize we return
          // the group here even while it's too big
          // To avoid this make sure maxSize > minSize * 3
          result.push(group);
          continue;
        }

        if (left <= right) {
          // when there is a area between left and right
          // we look for best split point
          // we split at the minimum similarity
          // here key space is separated the most
          var best = left - 1;
          var bestSimilarity = group.similarities[best];

          for (var _i2 = left; _i2 <= right; _i2++) {
            var _similarity = group.similarities[_i2];

            if (_similarity < bestSimilarity) {
              best = _i2;
              bestSimilarity = _similarity;
            }
          }

          left = best + 1;
          right = best;
        } // create two new groups for left and right area
        // and queue them up


        var rightNodes = [group.nodes[right + 1]];
        /** @type {number[]} */

        var rightSimilaries = [];

        for (var _i3 = right + 2; _i3 < group.nodes.length; _i3++) {
          rightSimilaries.push(group.similarities[_i3 - 1]);
          rightNodes.push(group.nodes[_i3]);
        }

        queue.push(new Group(rightNodes, rightSimilaries));
        var leftNodes = [group.nodes[0]];
        /** @type {number[]} */

        var leftSimilaries = [];

        for (var _i4 = 1; _i4 < left; _i4++) {
          leftSimilaries.push(group.similarities[_i4 - 1]);
          leftNodes.push(group.nodes[_i4]);
        }

        queue.push(new Group(leftNodes, leftSimilaries));
      }
    }
  } // lexically ordering


  result.sort(function (a, b) {
    if (a.nodes[0].key < b.nodes[0].key) return -1;
    if (a.nodes[0].key > b.nodes[0].key) return 1;
    return 0;
  }); // give every group a name

  for (var _i5 = 0; _i5 < result.length; _i5++) {
    var _group = result[_i5];
    var first = _group.nodes[0];
    var last = _group.nodes[_group.nodes.length - 1];
    var name = getName(first.key, last.key);
    _group.key = name;
  } // return the results


  return result.map(function (group) {
    /** @type {GroupedItems} */
    return {
      key: group.key,
      items: group.nodes.map(function (node) {
        return node.item;
      }),
      size: group.size
    };
  });
};