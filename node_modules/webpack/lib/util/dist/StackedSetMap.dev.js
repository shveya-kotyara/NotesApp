/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var util = require("util");

var TOMBSTONE = {};
var UNDEFINED_MARKER = {};

var StackedSetMap =
/*#__PURE__*/
function () {
  function StackedSetMap(parentStack) {
    _classCallCheck(this, StackedSetMap);

    this.stack = parentStack === undefined ? [] : parentStack.slice();
    this.map = new Map();
    this.stack.push(this.map);
  }

  _createClass(StackedSetMap, [{
    key: "add",
    value: function add(item) {
      this.map.set(item, true);
    }
  }, {
    key: "set",
    value: function set(item, value) {
      this.map.set(item, value === undefined ? UNDEFINED_MARKER : value);
    }
  }, {
    key: "delete",
    value: function _delete(item) {
      if (this.stack.length > 1) {
        this.map.set(item, TOMBSTONE);
      } else {
        this.map["delete"](item);
      }
    }
  }, {
    key: "has",
    value: function has(item) {
      var topValue = this.map.get(item);
      if (topValue !== undefined) return topValue !== TOMBSTONE;

      if (this.stack.length > 1) {
        for (var i = this.stack.length - 2; i >= 0; i--) {
          var value = this.stack[i].get(item);

          if (value !== undefined) {
            this.map.set(item, value);
            return value !== TOMBSTONE;
          }
        }

        this.map.set(item, TOMBSTONE);
      }

      return false;
    }
  }, {
    key: "get",
    value: function get(item) {
      var topValue = this.map.get(item);

      if (topValue !== undefined) {
        return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER ? undefined : topValue;
      }

      if (this.stack.length > 1) {
        for (var i = this.stack.length - 2; i >= 0; i--) {
          var value = this.stack[i].get(item);

          if (value !== undefined) {
            this.map.set(item, value);
            return value === TOMBSTONE || value === UNDEFINED_MARKER ? undefined : value;
          }
        }

        this.map.set(item, TOMBSTONE);
      }

      return undefined;
    }
  }, {
    key: "_compress",
    value: function _compress() {
      if (this.stack.length === 1) return;
      this.map = new Map();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.stack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var data = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var pair = _step2.value;

              if (pair[1] === TOMBSTONE) {
                this.map["delete"](pair[0]);
              } else {
                this.map.set(pair[0], pair[1]);
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.stack = [this.map];
    }
  }, {
    key: "asArray",
    value: function asArray() {
      this._compress();

      return Array.from(this.map.entries(), function (pair) {
        return pair[0];
      });
    }
  }, {
    key: "asSet",
    value: function asSet() {
      return new Set(this.asArray());
    }
  }, {
    key: "asPairArray",
    value: function asPairArray() {
      this._compress();

      return Array.from(this.map.entries(), function (pair) {
        return (
          /** @type {[TODO, TODO]} */
          pair[1] === UNDEFINED_MARKER ? [pair[0], undefined] : pair
        );
      });
    }
  }, {
    key: "asMap",
    value: function asMap() {
      return new Map(this.asPairArray());
    }
  }, {
    key: "createChild",
    value: function createChild() {
      return new StackedSetMap(this.stack);
    }
  }, {
    key: "size",
    get: function get() {
      this._compress();

      return this.map.size;
    }
  }, {
    key: "length",
    get: function get() {
      throw new Error("This is no longer an Array");
    },
    set: function set(value) {
      throw new Error("This is no longer an Array");
    }
  }]);

  return StackedSetMap;
}(); // TODO remove in webpack 5


StackedSetMap.prototype.push = util.deprecate(
/**
 * @deprecated
 * @this {StackedSetMap}
 * @param {any} item Item to add
 * @returns {void}
 */
function (item) {
  this.add(item);
}, "This is no longer an Array: Use add instead.");
module.exports = StackedSetMap;