/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var truncateArgs = require("../logging/truncateArgs");

var util = require("util");

var tty = process.stderr.isTTY && process.env.TERM !== "dumb";
var currentStatusMessage = undefined;
var hasStatusMessage = false;
var currentIndent = "";
var currentCollapsed = 0;

var indent = function indent(str, prefix, colorPrefix, colorSuffix) {
  if (str === "") return str;
  prefix = currentIndent + prefix;

  if (tty) {
    return prefix + colorPrefix + str.replace(/\n/g, colorSuffix + "\n" + prefix + colorPrefix) + colorSuffix;
  } else {
    return prefix + str.replace(/\n/g, "\n" + prefix);
  }
};

var clearStatusMessage = function clearStatusMessage() {
  if (hasStatusMessage) {
    process.stderr.write("\x1b[2K\r");
    hasStatusMessage = false;
  }
};

var writeStatusMessage = function writeStatusMessage() {
  if (!currentStatusMessage) return;
  var l = process.stderr.columns;
  var args = l ? truncateArgs(currentStatusMessage, l - 1) : currentStatusMessage;
  var str = args.join(" ");
  var coloredStr = "\x1B[1m".concat(str, "\x1B[39m\x1B[22m");
  process.stderr.write("\x1B[2K\r".concat(coloredStr));
  hasStatusMessage = true;
};

var writeColored = function writeColored(prefix, colorPrefix, colorSuffix) {
  return function () {
    if (currentCollapsed > 0) return;
    clearStatusMessage(); // @ts-ignore

    var str = indent(util.format.apply(util, arguments), prefix, colorPrefix, colorSuffix);
    process.stderr.write(str + "\n");
    writeStatusMessage();
  };
};

var writeGroupMessage = writeColored("<-> ", "\x1B[1m\x1B[36m", "\x1B[39m\x1B[22m");
var writeGroupCollapsedMessage = writeColored("<+> ", "\x1B[1m\x1B[36m", "\x1B[39m\x1B[22m");
module.exports = {
  log: writeColored("    ", "\x1B[1m", "\x1B[22m"),
  debug: writeColored("    ", "", ""),
  trace: writeColored("    ", "", ""),
  info: writeColored("<i> ", "\x1B[1m\x1B[32m", "\x1B[39m\x1B[22m"),
  warn: writeColored("<w> ", "\x1B[1m\x1B[33m", "\x1B[39m\x1B[22m"),
  error: writeColored("<e> ", "\x1B[1m\x1B[31m", "\x1B[39m\x1B[22m"),
  logTime: writeColored("<t> ", "\x1B[1m\x1B[35m", "\x1B[39m\x1B[22m"),
  group: function group() {
    writeGroupMessage.apply(void 0, arguments);

    if (currentCollapsed > 0) {
      currentCollapsed++;
    } else {
      currentIndent += "  ";
    }
  },
  groupCollapsed: function groupCollapsed() {
    writeGroupCollapsedMessage.apply(void 0, arguments);
    currentCollapsed++;
  },
  groupEnd: function groupEnd() {
    if (currentCollapsed > 0) currentCollapsed--;else if (currentIndent.length >= 2) currentIndent = currentIndent.slice(0, currentIndent.length - 2);
  },
  // eslint-disable-next-line node/no-unsupported-features/node-builtins
  profile: console.profile && function (name) {
    return console.profile(name);
  },
  // eslint-disable-next-line node/no-unsupported-features/node-builtins
  profileEnd: console.profileEnd && function (name) {
    return console.profileEnd(name);
  },
  clear: tty && // eslint-disable-next-line node/no-unsupported-features/node-builtins
  console.clear && function () {
    clearStatusMessage(); // eslint-disable-next-line node/no-unsupported-features/node-builtins

    console.clear();
    writeStatusMessage();
  },
  status: tty ? function (name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    args = args.filter(Boolean);

    if (name === undefined && args.length === 0) {
      clearStatusMessage();
      currentStatusMessage = undefined;
    } else if (typeof name === "string" && name.startsWith("[webpack.Progress] ")) {
      currentStatusMessage = [name.slice(19)].concat(_toConsumableArray(args));
      writeStatusMessage();
    } else if (name === "[webpack.Progress]") {
      currentStatusMessage = _toConsumableArray(args);
      writeStatusMessage();
    } else {
      currentStatusMessage = [name].concat(_toConsumableArray(args));
      writeStatusMessage();
    }
  } : writeColored("<s> ", "", "")
};