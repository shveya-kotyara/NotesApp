/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Template = require("../Template");

module.exports =
/*#__PURE__*/
function () {
  function NodeMainTemplatePlugin(asyncChunkLoading) {
    _classCallCheck(this, NodeMainTemplatePlugin);

    this.asyncChunkLoading = asyncChunkLoading;
  }

  _createClass(NodeMainTemplatePlugin, [{
    key: "apply",
    value: function apply(mainTemplate) {
      var needChunkOnDemandLoadingCode = function needChunkOnDemandLoadingCode(chunk) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = chunk.groupsIterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var chunkGroup = _step.value;
            if (chunkGroup.getNumberOfChildren() > 0) return true;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return false;
      };

      var asyncChunkLoading = this.asyncChunkLoading;
      mainTemplate.hooks.localVars.tap("NodeMainTemplatePlugin", function (source, chunk) {
        if (needChunkOnDemandLoadingCode(chunk)) {
          return Template.asString([source, "", "// object to store loaded chunks", '// "0" means "already loaded"', "var installedChunks = {", Template.indent(chunk.ids.map(function (id) {
            return "".concat(JSON.stringify(id), ": 0");
          }).join(",\n")), "};"]);
        }

        return source;
      });
      mainTemplate.hooks.requireExtensions.tap("NodeMainTemplatePlugin", function (source, chunk) {
        if (needChunkOnDemandLoadingCode(chunk)) {
          return Template.asString([source, "", "// uncaught error handler for webpack runtime", "".concat(mainTemplate.requireFn, ".oe = function(err) {"), Template.indent(["process.nextTick(function() {", Template.indent("throw err; // catch this error by using import().catch()"), "});"]), "};"]);
        }

        return source;
      });
      mainTemplate.hooks.requireEnsure.tap("NodeMainTemplatePlugin", function (source, chunk, hash) {
        var chunkFilename = mainTemplate.outputOptions.chunkFilename;
        var chunkMaps = chunk.getChunkMaps();
        var insertMoreModules = ["var moreModules = chunk.modules, chunkIds = chunk.ids;", "for(var moduleId in moreModules) {", Template.indent(mainTemplate.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")), "}"];

        if (asyncChunkLoading) {
          return Template.asString([source, "", "// ReadFile + VM.run chunk loading for javascript", "", "var installedChunkData = installedChunks[chunkId];", 'if(installedChunkData !== 0) { // 0 means "already installed".', Template.indent(['// array of [resolve, reject, promise] means "currently loading"', "if(installedChunkData) {", Template.indent(["promises.push(installedChunkData[2]);"]), "} else {", Template.indent(["// load the chunk and return promise to it", "var promise = new Promise(function(resolve, reject) {", Template.indent(["installedChunkData = installedChunks[chunkId] = [resolve, reject];", "var filename = require('path').join(__dirname, " + mainTemplate.getAssetPath(JSON.stringify("/".concat(chunkFilename)), {
            hash: "\" + ".concat(mainTemplate.renderCurrentHashCode(hash), " + \""),
            hashWithLength: function hashWithLength(length) {
              return "\" + ".concat(mainTemplate.renderCurrentHashCode(hash, length), " + \"");
            },
            chunk: {
              id: '" + chunkId + "',
              hash: "\" + ".concat(JSON.stringify(chunkMaps.hash), "[chunkId] + \""),
              hashWithLength: function hashWithLength(length) {
                var shortChunkHashMap = {};

                for (var _i = 0, _Object$keys = Object.keys(chunkMaps.hash); _i < _Object$keys.length; _i++) {
                  var chunkId = _Object$keys[_i];

                  if (typeof chunkMaps.hash[chunkId] === "string") {
                    shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
                  }
                }

                return "\" + ".concat(JSON.stringify(shortChunkHashMap), "[chunkId] + \"");
              },
              contentHash: {
                javascript: "\" + ".concat(JSON.stringify(chunkMaps.contentHash.javascript), "[chunkId] + \"")
              },
              contentHashWithLength: {
                javascript: function javascript(length) {
                  var shortContentHashMap = {};
                  var contentHash = chunkMaps.contentHash.javascript;

                  for (var _i2 = 0, _Object$keys2 = Object.keys(contentHash); _i2 < _Object$keys2.length; _i2++) {
                    var chunkId = _Object$keys2[_i2];

                    if (typeof contentHash[chunkId] === "string") {
                      shortContentHashMap[chunkId] = contentHash[chunkId].substr(0, length);
                    }
                  }

                  return "\" + ".concat(JSON.stringify(shortContentHashMap), "[chunkId] + \"");
                }
              },
              name: "\" + (".concat(JSON.stringify(chunkMaps.name), "[chunkId]||chunkId) + \"")
            },
            contentHashType: "javascript"
          }) + ");", "require('fs').readFile(filename, 'utf-8',  function(err, content) {", Template.indent(["if(err) return reject(err);", "var chunk = {};", "require('vm').runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\\n})', filename)" + "(chunk, require, require('path').dirname(filename), filename);"].concat(insertMoreModules).concat(["var callbacks = [];", "for(var i = 0; i < chunkIds.length; i++) {", Template.indent(["if(installedChunks[chunkIds[i]])", Template.indent(["callbacks = callbacks.concat(installedChunks[chunkIds[i]][0]);"]), "installedChunks[chunkIds[i]] = 0;"]), "}", "for(i = 0; i < callbacks.length; i++)", Template.indent("callbacks[i]();")])), "});"]), "});", "promises.push(installedChunkData[2] = promise);"]), "}"]), "}"]);
        } else {
          var request = mainTemplate.getAssetPath(JSON.stringify("./".concat(chunkFilename)), {
            hash: "\" + ".concat(mainTemplate.renderCurrentHashCode(hash), " + \""),
            hashWithLength: function hashWithLength(length) {
              return "\" + ".concat(mainTemplate.renderCurrentHashCode(hash, length), " + \"");
            },
            chunk: {
              id: '" + chunkId + "',
              hash: "\" + ".concat(JSON.stringify(chunkMaps.hash), "[chunkId] + \""),
              hashWithLength: function hashWithLength(length) {
                var shortChunkHashMap = {};

                for (var _i3 = 0, _Object$keys3 = Object.keys(chunkMaps.hash); _i3 < _Object$keys3.length; _i3++) {
                  var chunkId = _Object$keys3[_i3];

                  if (typeof chunkMaps.hash[chunkId] === "string") {
                    shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
                  }
                }

                return "\" + ".concat(JSON.stringify(shortChunkHashMap), "[chunkId] + \"");
              },
              contentHash: {
                javascript: "\" + ".concat(JSON.stringify(chunkMaps.contentHash.javascript), "[chunkId] + \"")
              },
              contentHashWithLength: {
                javascript: function javascript(length) {
                  var shortContentHashMap = {};
                  var contentHash = chunkMaps.contentHash.javascript;

                  for (var _i4 = 0, _Object$keys4 = Object.keys(contentHash); _i4 < _Object$keys4.length; _i4++) {
                    var chunkId = _Object$keys4[_i4];

                    if (typeof contentHash[chunkId] === "string") {
                      shortContentHashMap[chunkId] = contentHash[chunkId].substr(0, length);
                    }
                  }

                  return "\" + ".concat(JSON.stringify(shortContentHashMap), "[chunkId] + \"");
                }
              },
              name: "\" + (".concat(JSON.stringify(chunkMaps.name), "[chunkId]||chunkId) + \"")
            },
            contentHashType: "javascript"
          });
          return Template.asString([source, "", "// require() chunk loading for javascript", "", '// "0" is the signal for "already loaded"', "if(installedChunks[chunkId] !== 0) {", Template.indent(["var chunk = require(".concat(request, ");")].concat(insertMoreModules).concat(["for(var i = 0; i < chunkIds.length; i++)", Template.indent("installedChunks[chunkIds[i]] = 0;")])), "}"]);
        }
      });
      mainTemplate.hooks.hotBootstrap.tap("NodeMainTemplatePlugin", function (source, chunk, hash) {
        var hotUpdateChunkFilename = mainTemplate.outputOptions.hotUpdateChunkFilename;
        var hotUpdateMainFilename = mainTemplate.outputOptions.hotUpdateMainFilename;
        var chunkMaps = chunk.getChunkMaps();
        var currentHotUpdateChunkFilename = mainTemplate.getAssetPath(JSON.stringify(hotUpdateChunkFilename), {
          hash: "\" + ".concat(mainTemplate.renderCurrentHashCode(hash), " + \""),
          hashWithLength: function hashWithLength(length) {
            return "\" + ".concat(mainTemplate.renderCurrentHashCode(hash, length), " + \"");
          },
          chunk: {
            id: '" + chunkId + "',
            hash: "\" + ".concat(JSON.stringify(chunkMaps.hash), "[chunkId] + \""),
            hashWithLength: function hashWithLength(length) {
              var shortChunkHashMap = {};

              for (var _i5 = 0, _Object$keys5 = Object.keys(chunkMaps.hash); _i5 < _Object$keys5.length; _i5++) {
                var chunkId = _Object$keys5[_i5];

                if (typeof chunkMaps.hash[chunkId] === "string") {
                  shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
                }
              }

              return "\" + ".concat(JSON.stringify(shortChunkHashMap), "[chunkId] + \"");
            },
            name: "\" + (".concat(JSON.stringify(chunkMaps.name), "[chunkId]||chunkId) + \"")
          }
        });
        var currentHotUpdateMainFilename = mainTemplate.getAssetPath(JSON.stringify(hotUpdateMainFilename), {
          hash: "\" + ".concat(mainTemplate.renderCurrentHashCode(hash), " + \""),
          hashWithLength: function hashWithLength(length) {
            return "\" + ".concat(mainTemplate.renderCurrentHashCode(hash, length), " + \"");
          }
        });
        return Template.getFunctionContent(asyncChunkLoading ? require("./NodeMainTemplateAsync.runtime") : require("./NodeMainTemplate.runtime")).replace(/\$require\$/g, mainTemplate.requireFn).replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename).replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename);
      });
      mainTemplate.hooks.hash.tap("NodeMainTemplatePlugin", function (hash) {
        hash.update("node");
        hash.update("4");
      });
    }
  }]);

  return NodeMainTemplatePlugin;
}();