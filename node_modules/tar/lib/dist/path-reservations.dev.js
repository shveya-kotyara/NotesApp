"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// A path exclusive reservation system
// reserve([list, of, paths], fn)
// When the fn is first in line for all its paths, it
// is called with a cb that clears the reservation.
//
// Used by async unpack to avoid clobbering paths in use,
// while still allowing maximal safe parallelization.
var assert = require('assert');

module.exports = function () {
  // path => [function or Set]
  // A Set object means a directory reservation
  // A fn is a direct reservation on that path
  var queues = new Map(); // fn => {paths:[path,...], dirs:[path, ...]}

  var reservations = new Map(); // return a set of parent dirs for a given path

  var _require = require('path'),
      join = _require.join;

  var getDirs = function getDirs(path) {
    return join(path).split(/[\\\/]/).slice(0, -1).reduce(function (set, path) {
      return set.length ? set.concat(join(set[set.length - 1], path)) : [path];
    }, []);
  }; // functions currently running


  var running = new Set(); // return the queues for each path the function cares about
  // fn => {paths, dirs}

  var getQueues = function getQueues(fn) {
    var res = reservations.get(fn);
    /* istanbul ignore if - unpossible */

    if (!res) throw new Error('function does not have any path reservations');
    return {
      paths: res.paths.map(function (path) {
        return queues.get(path);
      }),
      dirs: _toConsumableArray(res.dirs).map(function (path) {
        return queues.get(path);
      })
    };
  }; // check if fn is first in line for all its paths, and is
  // included in the first set for all its dir queues


  var check = function check(fn) {
    var _getQueues = getQueues(fn),
        paths = _getQueues.paths,
        dirs = _getQueues.dirs;

    return paths.every(function (q) {
      return q[0] === fn;
    }) && dirs.every(function (q) {
      return q[0] instanceof Set && q[0].has(fn);
    });
  }; // run the function if it's first in line and not already running


  var run = function run(fn) {
    if (running.has(fn) || !check(fn)) return false;
    running.add(fn);
    fn(function () {
      return clear(fn);
    });
    return true;
  };

  var clear = function clear(fn) {
    if (!running.has(fn)) return false;

    var _reservations$get = reservations.get(fn),
        paths = _reservations$get.paths,
        dirs = _reservations$get.dirs;

    var next = new Set();
    paths.forEach(function (path) {
      var q = queues.get(path);
      assert.equal(q[0], fn);
      if (q.length === 1) queues["delete"](path);else {
        q.shift();
        if (typeof q[0] === 'function') next.add(q[0]);else q[0].forEach(function (fn) {
          return next.add(fn);
        });
      }
    });
    dirs.forEach(function (dir) {
      var q = queues.get(dir);
      assert(q[0] instanceof Set);

      if (q[0].size === 1 && q.length === 1) {
        queues["delete"](dir);
      } else if (q[0].size === 1) {
        q.shift(); // must be a function or else the Set would've been reused

        next.add(q[0]);
      } else q[0]["delete"](fn);
    });
    running["delete"](fn);
    next.forEach(function (fn) {
      return run(fn);
    });
    return true;
  };

  var reserve = function reserve(paths, fn) {
    var dirs = new Set(paths.map(function (path) {
      return getDirs(path);
    }).reduce(function (a, b) {
      return a.concat(b);
    }));
    reservations.set(fn, {
      dirs: dirs,
      paths: paths
    });
    paths.forEach(function (path) {
      var q = queues.get(path);
      if (!q) queues.set(path, [fn]);else q.push(fn);
    });
    dirs.forEach(function (dir) {
      var q = queues.get(dir);
      if (!q) queues.set(dir, [new Set([fn])]);else if (q[q.length - 1] instanceof Set) q[q.length - 1].add(fn);else q.push(new Set([fn]));
    });
    return run(fn);
  };

  return {
    check: check,
    reserve: reserve
  };
};