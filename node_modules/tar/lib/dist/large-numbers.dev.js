'use strict'; // Tar can encode large and negative numbers using a leading byte of
// 0xff for negative, and 0x80 for positive.

var encode = exports.encode = function (num, buf) {
  if (!Number.isSafeInteger(num)) // The number is so large that javascript cannot represent it with integer
    // precision.
    throw Error('cannot encode number outside of javascript safe integer range');else if (num < 0) encodeNegative(num, buf);else encodePositive(num, buf);
  return buf;
};

var encodePositive = function encodePositive(num, buf) {
  buf[0] = 0x80;

  for (var i = buf.length; i > 1; i--) {
    buf[i - 1] = num & 0xff;
    num = Math.floor(num / 0x100);
  }
};

var encodeNegative = function encodeNegative(num, buf) {
  buf[0] = 0xff;
  var flipped = false;
  num = num * -1;

  for (var i = buf.length; i > 1; i--) {
    var _byte = num & 0xff;

    num = Math.floor(num / 0x100);
    if (flipped) buf[i - 1] = onesComp(_byte);else if (_byte === 0) buf[i - 1] = 0;else {
      flipped = true;
      buf[i - 1] = twosComp(_byte);
    }
  }
};

var parse = exports.parse = function (buf) {
  var post = buf[buf.length - 1];
  var pre = buf[0];
  var value;
  if (pre === 0x80) value = pos(buf.slice(1, buf.length));else if (pre === 0xff) value = twos(buf);else throw Error('invalid base256 encoding');
  if (!Number.isSafeInteger(value)) // The number is so large that javascript cannot represent it with integer
    // precision.
    throw Error('parsed number outside of javascript safe integer range');
  return value;
};

var twos = function twos(buf) {
  var len = buf.length;
  var sum = 0;
  var flipped = false;

  for (var i = len - 1; i > -1; i--) {
    var _byte2 = buf[i];
    var f;
    if (flipped) f = onesComp(_byte2);else if (_byte2 === 0) f = _byte2;else {
      flipped = true;
      f = twosComp(_byte2);
    }
    if (f !== 0) sum -= f * Math.pow(256, len - i - 1);
  }

  return sum;
};

var pos = function pos(buf) {
  var len = buf.length;
  var sum = 0;

  for (var i = len - 1; i > -1; i--) {
    var _byte3 = buf[i];
    if (_byte3 !== 0) sum += _byte3 * Math.pow(256, len - i - 1);
  }

  return sum;
};

var onesComp = function onesComp(_byte4) {
  return (0xff ^ _byte4) & 0xff;
};

var twosComp = function twosComp(_byte5) {
  return (0xff ^ _byte5) + 1 & 0xff;
};