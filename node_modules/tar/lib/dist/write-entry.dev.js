'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var MiniPass = require('minipass');

var Pax = require('./pax.js');

var Header = require('./header.js');

var ReadEntry = require('./read-entry.js');

var fs = require('fs');

var path = require('path');

var types = require('./types.js');

var maxReadSize = 16 * 1024 * 1024;
var PROCESS = Symbol('process');
var FILE = Symbol('file');
var DIRECTORY = Symbol('directory');
var SYMLINK = Symbol('symlink');
var HARDLINK = Symbol('hardlink');
var HEADER = Symbol('header');
var READ = Symbol('read');
var LSTAT = Symbol('lstat');
var ONLSTAT = Symbol('onlstat');
var ONREAD = Symbol('onread');
var ONREADLINK = Symbol('onreadlink');
var OPENFILE = Symbol('openfile');
var ONOPENFILE = Symbol('onopenfile');
var CLOSE = Symbol('close');
var MODE = Symbol('mode');

var warner = require('./warn-mixin.js');

var winchars = require('./winchars.js');

var modeFix = require('./mode-fix.js');

var WriteEntry = warner(
/*#__PURE__*/
function (_MiniPass) {
  _inherits(WriteEntry, _MiniPass);

  function WriteEntry(p, opt) {
    var _this;

    _classCallCheck(this, WriteEntry);

    opt = opt || {};
    _this = _possibleConstructorReturn(this, _getPrototypeOf(WriteEntry).call(this, opt));
    if (typeof p !== 'string') throw new TypeError('path is required');
    _this.path = p; // suppress atime, ctime, uid, gid, uname, gname

    _this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do

    _this.myuid = process.getuid && process.getuid();
    _this.myuser = process.env.USER || '';
    _this.maxReadSize = opt.maxReadSize || maxReadSize;
    _this.linkCache = opt.linkCache || new Map();
    _this.statCache = opt.statCache || new Map();
    _this.preservePaths = !!opt.preservePaths;
    _this.cwd = opt.cwd || process.cwd();
    _this.strict = !!opt.strict;
    _this.noPax = !!opt.noPax;
    _this.noMtime = !!opt.noMtime;
    _this.mtime = opt.mtime || null;
    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);
    var pathWarn = false;

    if (!_this.preservePaths && path.win32.isAbsolute(p)) {
      // absolutes on posix are also absolutes on win32
      // so we only need to test this one to get both
      var parsed = path.win32.parse(p);
      _this.path = p.substr(parsed.root.length);
      pathWarn = parsed.root;
    }

    _this.win32 = !!opt.win32 || process.platform === 'win32';

    if (_this.win32) {
      _this.path = winchars.decode(_this.path.replace(/\\/g, '/'));
      p = p.replace(/\\/g, '/');
    }

    _this.absolute = opt.absolute || path.resolve(_this.cwd, p);
    if (_this.path === '') _this.path = './';

    if (pathWarn) {
      _this.warn('TAR_ENTRY_INFO', "stripping ".concat(pathWarn, " from absolute path"), {
        entry: _assertThisInitialized(_this),
        path: pathWarn + _this.path
      });
    }

    if (_this.statCache.has(_this.absolute)) _this[ONLSTAT](_this.statCache.get(_this.absolute));else _this[LSTAT]();
    return _this;
  }

  _createClass(WriteEntry, [{
    key: LSTAT,
    value: function value() {
      var _this2 = this;

      fs.lstat(this.absolute, function (er, stat) {
        if (er) return _this2.emit('error', er);

        _this2[ONLSTAT](stat);
      });
    }
  }, {
    key: ONLSTAT,
    value: function value(stat) {
      this.statCache.set(this.absolute, stat);
      this.stat = stat;
      if (!stat.isFile()) stat.size = 0;
      this.type = getType(stat);
      this.emit('stat', stat);
      this[PROCESS]();
    }
  }, {
    key: PROCESS,
    value: function value() {
      switch (this.type) {
        case 'File':
          return this[FILE]();

        case 'Directory':
          return this[DIRECTORY]();

        case 'SymbolicLink':
          return this[SYMLINK]();
        // unsupported types are ignored.

        default:
          return this.end();
      }
    }
  }, {
    key: MODE,
    value: function value(mode) {
      return modeFix(mode, this.type === 'Directory', this.portable);
    }
  }, {
    key: HEADER,
    value: function value() {
      if (this.type === 'Directory' && this.portable) this.noMtime = true;
      this.header = new Header({
        path: this.path,
        linkpath: this.linkpath,
        // only the permissions and setuid/setgid/sticky bitflags
        // not the higher-order bits that specify file type
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      });
      if (this.header.encode() && !this.noPax) this.write(new Pax({
        atime: this.portable ? null : this.header.atime,
        ctime: this.portable ? null : this.header.ctime,
        gid: this.portable ? null : this.header.gid,
        mtime: this.noMtime ? null : this.mtime || this.header.mtime,
        path: this.path,
        linkpath: this.linkpath,
        size: this.header.size,
        uid: this.portable ? null : this.header.uid,
        uname: this.portable ? null : this.header.uname,
        dev: this.portable ? null : this.stat.dev,
        ino: this.portable ? null : this.stat.ino,
        nlink: this.portable ? null : this.stat.nlink
      }).encode());
      this.write(this.header.block);
    }
  }, {
    key: DIRECTORY,
    value: function value() {
      if (this.path.substr(-1) !== '/') this.path += '/';
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
  }, {
    key: SYMLINK,
    value: function value() {
      var _this3 = this;

      fs.readlink(this.absolute, function (er, linkpath) {
        if (er) return _this3.emit('error', er);

        _this3[ONREADLINK](linkpath);
      });
    }
  }, {
    key: ONREADLINK,
    value: function value(linkpath) {
      this.linkpath = linkpath.replace(/\\/g, '/');
      this[HEADER]();
      this.end();
    }
  }, {
    key: HARDLINK,
    value: function value(linkpath) {
      this.type = 'Link';
      this.linkpath = path.relative(this.cwd, linkpath).replace(/\\/g, '/');
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
  }, {
    key: FILE,
    value: function value() {
      if (this.stat.nlink > 1) {
        var linkKey = this.stat.dev + ':' + this.stat.ino;

        if (this.linkCache.has(linkKey)) {
          var linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);
        }

        this.linkCache.set(linkKey, this.absolute);
      }

      this[HEADER]();
      if (this.stat.size === 0) return this.end();
      this[OPENFILE]();
    }
  }, {
    key: OPENFILE,
    value: function value() {
      var _this4 = this;

      fs.open(this.absolute, 'r', function (er, fd) {
        if (er) return _this4.emit('error', er);

        _this4[ONOPENFILE](fd);
      });
    }
  }, {
    key: ONOPENFILE,
    value: function value(fd) {
      var blockLen = 512 * Math.ceil(this.stat.size / 512);
      var bufLen = Math.min(blockLen, this.maxReadSize);
      var buf = Buffer.allocUnsafe(bufLen);
      this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);
    }
  }, {
    key: READ,
    value: function value(fd, buf, offset, length, pos, remain, blockRemain) {
      var _this5 = this;

      fs.read(fd, buf, offset, length, pos, function (er, bytesRead) {
        if (er) {
          // ignoring the error from close(2) is a bad practice, but at
          // this point we already have an error, don't need another one
          return _this5[CLOSE](fd, function () {
            return _this5.emit('error', er);
          });
        }

        _this5[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
      });
    }
  }, {
    key: CLOSE,
    value: function value(fd, cb) {
      fs.close(fd, cb);
    }
  }, {
    key: ONREAD,
    value: function value(fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {
      var _this6 = this;

      if (bytesRead <= 0 && remain > 0) {
        var er = new Error('encountered unexpected EOF');
        er.path = this.absolute;
        er.syscall = 'read';
        er.code = 'EOF';
        return this[CLOSE](fd, function () {
          return _this6.emit('error', er);
        });
      }

      if (bytesRead > remain) {
        var _er = new Error('did not encounter expected EOF');

        _er.path = this.absolute;
        _er.syscall = 'read';
        _er.code = 'EOF';
        return this[CLOSE](fd, function () {
          return _this6.emit('error', _er);
        });
      } // null out the rest of the buffer, if we could fit the block padding


      if (bytesRead === remain) {
        for (var i = bytesRead; i < length && bytesRead < blockRemain; i++) {
          buf[i + offset] = 0;
          bytesRead++;
          remain++;
        }
      }

      var writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);
      remain -= bytesRead;
      blockRemain -= bytesRead;
      pos += bytesRead;
      offset += bytesRead;
      this.write(writeBuf);

      if (!remain) {
        if (blockRemain) this.write(Buffer.alloc(blockRemain));
        return this[CLOSE](fd, function (er) {
          return er ? _this6.emit('error', er) : _this6.end();
        });
      }

      if (offset >= length) {
        buf = Buffer.allocUnsafe(length);
        offset = 0;
      }

      length = buf.length - offset;
      this[READ](fd, buf, offset, length, pos, remain, blockRemain);
    }
  }]);

  return WriteEntry;
}(MiniPass));

var WriteEntrySync =
/*#__PURE__*/
function (_WriteEntry) {
  _inherits(WriteEntrySync, _WriteEntry);

  function WriteEntrySync(path, opt) {
    _classCallCheck(this, WriteEntrySync);

    return _possibleConstructorReturn(this, _getPrototypeOf(WriteEntrySync).call(this, path, opt));
  }

  _createClass(WriteEntrySync, [{
    key: LSTAT,
    value: function value() {
      this[ONLSTAT](fs.lstatSync(this.absolute));
    }
  }, {
    key: SYMLINK,
    value: function value() {
      this[ONREADLINK](fs.readlinkSync(this.absolute));
    }
  }, {
    key: OPENFILE,
    value: function value() {
      this[ONOPENFILE](fs.openSync(this.absolute, 'r'));
    }
  }, {
    key: READ,
    value: function value(fd, buf, offset, length, pos, remain, blockRemain) {
      var threw = true;

      try {
        var bytesRead = fs.readSync(fd, buf, offset, length, pos);
        this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
        threw = false;
      } finally {
        // ignoring the error from close(2) is a bad practice, but at
        // this point we already have an error, don't need another one
        if (threw) try {
          this[CLOSE](fd, function () {});
        } catch (er) {}
      }
    }
  }, {
    key: CLOSE,
    value: function value(fd, cb) {
      fs.closeSync(fd);
      cb();
    }
  }]);

  return WriteEntrySync;
}(WriteEntry);

var WriteEntryTar = warner(
/*#__PURE__*/
function (_MiniPass2) {
  _inherits(WriteEntryTar, _MiniPass2);

  function WriteEntryTar(readEntry, opt) {
    var _this7;

    _classCallCheck(this, WriteEntryTar);

    opt = opt || {};
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(WriteEntryTar).call(this, opt));
    _this7.preservePaths = !!opt.preservePaths;
    _this7.portable = !!opt.portable;
    _this7.strict = !!opt.strict;
    _this7.noPax = !!opt.noPax;
    _this7.noMtime = !!opt.noMtime;
    _this7.readEntry = readEntry;
    _this7.type = readEntry.type;
    if (_this7.type === 'Directory' && _this7.portable) _this7.noMtime = true;
    _this7.path = readEntry.path;
    _this7.mode = _this7[MODE](readEntry.mode);
    _this7.uid = _this7.portable ? null : readEntry.uid;
    _this7.gid = _this7.portable ? null : readEntry.gid;
    _this7.uname = _this7.portable ? null : readEntry.uname;
    _this7.gname = _this7.portable ? null : readEntry.gname;
    _this7.size = readEntry.size;
    _this7.mtime = _this7.noMtime ? null : opt.mtime || readEntry.mtime;
    _this7.atime = _this7.portable ? null : readEntry.atime;
    _this7.ctime = _this7.portable ? null : readEntry.ctime;
    _this7.linkpath = readEntry.linkpath;
    if (typeof opt.onwarn === 'function') _this7.on('warn', opt.onwarn);
    var pathWarn = false;

    if (path.isAbsolute(_this7.path) && !_this7.preservePaths) {
      var parsed = path.parse(_this7.path);
      pathWarn = parsed.root;
      _this7.path = _this7.path.substr(parsed.root.length);
    }

    _this7.remain = readEntry.size;
    _this7.blockRemain = readEntry.startBlockSize;
    _this7.header = new Header({
      path: _this7.path,
      linkpath: _this7.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: _this7.mode,
      uid: _this7.portable ? null : _this7.uid,
      gid: _this7.portable ? null : _this7.gid,
      size: _this7.size,
      mtime: _this7.noMtime ? null : _this7.mtime,
      type: _this7.type,
      uname: _this7.portable ? null : _this7.uname,
      atime: _this7.portable ? null : _this7.atime,
      ctime: _this7.portable ? null : _this7.ctime
    });

    if (pathWarn) {
      _this7.warn('TAR_ENTRY_INFO', "stripping ".concat(pathWarn, " from absolute path"), {
        entry: _assertThisInitialized(_this7),
        path: pathWarn + _this7.path
      });
    }

    if (_this7.header.encode() && !_this7.noPax) _get(_getPrototypeOf(WriteEntryTar.prototype), "write", _assertThisInitialized(_this7)).call(_assertThisInitialized(_this7), new Pax({
      atime: _this7.portable ? null : _this7.atime,
      ctime: _this7.portable ? null : _this7.ctime,
      gid: _this7.portable ? null : _this7.gid,
      mtime: _this7.noMtime ? null : _this7.mtime,
      path: _this7.path,
      linkpath: _this7.linkpath,
      size: _this7.size,
      uid: _this7.portable ? null : _this7.uid,
      uname: _this7.portable ? null : _this7.uname,
      dev: _this7.portable ? null : _this7.readEntry.dev,
      ino: _this7.portable ? null : _this7.readEntry.ino,
      nlink: _this7.portable ? null : _this7.readEntry.nlink
    }).encode());

    _get(_getPrototypeOf(WriteEntryTar.prototype), "write", _assertThisInitialized(_this7)).call(_assertThisInitialized(_this7), _this7.header.block);

    readEntry.pipe(_assertThisInitialized(_this7));
    return _this7;
  }

  _createClass(WriteEntryTar, [{
    key: MODE,
    value: function value(mode) {
      return modeFix(mode, this.type === 'Directory', this.portable);
    }
  }, {
    key: "write",
    value: function write(data) {
      var writeLen = data.length;
      if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');
      this.blockRemain -= writeLen;
      return _get(_getPrototypeOf(WriteEntryTar.prototype), "write", this).call(this, data);
    }
  }, {
    key: "end",
    value: function end() {
      if (this.blockRemain) this.write(Buffer.alloc(this.blockRemain));
      return _get(_getPrototypeOf(WriteEntryTar.prototype), "end", this).call(this);
    }
  }]);

  return WriteEntryTar;
}(MiniPass));
WriteEntry.Sync = WriteEntrySync;
WriteEntry.Tar = WriteEntryTar;

var getType = function getType(stat) {
  return stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';
};

module.exports = WriteEntry;