'use strict'; // the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.
// but the path reservations are required to avoid race conditions where
// parallelized unpack ops may mess with one another, due to dependencies
// (like a Link depending on its target) or destructive operations (like
// clobbering an fs object to create one of a different type.)

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var assert = require('assert');

var EE = require('events').EventEmitter;

var Parser = require('./parse.js');

var fs = require('fs');

var fsm = require('fs-minipass');

var path = require('path');

var mkdir = require('./mkdir.js');

var mkdirSync = mkdir.sync;

var wc = require('./winchars.js');

var pathReservations = require('./path-reservations.js');

var ONENTRY = Symbol('onEntry');
var CHECKFS = Symbol('checkFs');
var CHECKFS2 = Symbol('checkFs2');
var ISREUSABLE = Symbol('isReusable');
var MAKEFS = Symbol('makeFs');
var FILE = Symbol('file');
var DIRECTORY = Symbol('directory');
var LINK = Symbol('link');
var SYMLINK = Symbol('symlink');
var HARDLINK = Symbol('hardlink');
var UNSUPPORTED = Symbol('unsupported');
var UNKNOWN = Symbol('unknown');
var CHECKPATH = Symbol('checkPath');
var MKDIR = Symbol('mkdir');
var ONERROR = Symbol('onError');
var PENDING = Symbol('pending');
var PEND = Symbol('pend');
var UNPEND = Symbol('unpend');
var ENDED = Symbol('ended');
var MAYBECLOSE = Symbol('maybeClose');
var SKIP = Symbol('skip');
var DOCHOWN = Symbol('doChown');
var UID = Symbol('uid');
var GID = Symbol('gid');

var crypto = require('crypto');

var getFlag = require('./get-write-flag.js');
/* istanbul ignore next */


var neverCalled = function neverCalled() {
  throw new Error('sync function called cb somehow?!?');
}; // Unlinks on Windows are not atomic.
//
// This means that if you have a file entry, followed by another
// file entry with an identical name, and you cannot re-use the file
// (because it's a hardlink, or because unlink:true is set, or it's
// Windows, which does not have useful nlink values), then the unlink
// will be committed to the disk AFTER the new file has been written
// over the old one, deleting the new file.
//
// To work around this, on Windows systems, we rename the file and then
// delete the renamed file.  It's a sloppy kludge, but frankly, I do not
// know of a better way to do this, given windows' non-atomic unlink
// semantics.
//
// See: https://github.com/npm/node-tar/issues/183

/* istanbul ignore next */


var unlinkFile = function unlinkFile(path, cb) {
  if (process.platform !== 'win32') return fs.unlink(path, cb);
  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');
  fs.rename(path, name, function (er) {
    if (er) return cb(er);
    fs.unlink(name, cb);
  });
};
/* istanbul ignore next */


var unlinkFileSync = function unlinkFileSync(path) {
  if (process.platform !== 'win32') return fs.unlinkSync(path);
  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');
  fs.renameSync(path, name);
  fs.unlinkSync(name);
}; // this.gid, entry.gid, this.processUid


var uint32 = function uint32(a, b, c) {
  return a === a >>> 0 ? a : b === b >>> 0 ? b : c;
};

var Unpack =
/*#__PURE__*/
function (_Parser) {
  _inherits(Unpack, _Parser);

  function Unpack(opt) {
    var _this;

    _classCallCheck(this, Unpack);

    if (!opt) opt = {};

    opt.ondone = function (_) {
      _this[ENDED] = true;

      _this[MAYBECLOSE]();
    };

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Unpack).call(this, opt));
    _this.reservations = pathReservations();
    _this.transform = typeof opt.transform === 'function' ? opt.transform : null;
    _this.writable = true;
    _this.readable = false;
    _this[PENDING] = 0;
    _this[ENDED] = false;
    _this.dirCache = opt.dirCache || new Map();

    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {
      // need both or neither
      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') throw new TypeError('cannot set owner without number uid and gid');
      if (opt.preserveOwner) throw new TypeError('cannot preserve owner in archive and also set owner explicitly');
      _this.uid = opt.uid;
      _this.gid = opt.gid;
      _this.setOwner = true;
    } else {
      _this.uid = null;
      _this.gid = null;
      _this.setOwner = false;
    } // default true for root


    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') _this.preserveOwner = process.getuid && process.getuid() === 0;else _this.preserveOwner = !!opt.preserveOwner;
    _this.processUid = (_this.preserveOwner || _this.setOwner) && process.getuid ? process.getuid() : null;
    _this.processGid = (_this.preserveOwner || _this.setOwner) && process.getgid ? process.getgid() : null; // mostly just for testing, but useful in some cases.
    // Forcibly trigger a chown on every entry, no matter what

    _this.forceChown = opt.forceChown === true; // turn ><?| in filenames into 0xf000-higher encoded forms

    _this.win32 = !!opt.win32 || process.platform === 'win32'; // do not unpack over files that are newer than what's in the archive

    _this.newer = !!opt.newer; // do not unpack over ANY files

    _this.keep = !!opt.keep; // do not set mtime/atime of extracted entries

    _this.noMtime = !!opt.noMtime; // allow .., absolute path entries, and unpacking through symlinks
    // without this, warn and skip .., relativize absolutes, and error
    // on symlinks in extraction path

    _this.preservePaths = !!opt.preservePaths; // unlink files and links before writing. This breaks existing hard
    // links, and removes symlink directories rather than erroring

    _this.unlink = !!opt.unlink;
    _this.cwd = path.resolve(opt.cwd || process.cwd());
    _this.strip = +opt.strip || 0;
    _this.processUmask = process.umask();
    _this.umask = typeof opt.umask === 'number' ? opt.umask : _this.processUmask; // default mode for dirs created as parents

    _this.dmode = opt.dmode || 511 & ~_this.umask;
    _this.fmode = opt.fmode || 438 & ~_this.umask;

    _this.on('entry', function (entry) {
      return _this[ONENTRY](entry);
    });

    return _this;
  } // a bad or damaged archive is a warning for Parser, but an error
  // when extracting.  Mark those errors as unrecoverable, because
  // the Unpack contract cannot be met.


  _createClass(Unpack, [{
    key: "warn",
    value: function warn(code, msg) {
      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') data.recoverable = false;
      return _get(_getPrototypeOf(Unpack.prototype), "warn", this).call(this, code, msg, data);
    }
  }, {
    key: MAYBECLOSE,
    value: function value() {
      if (this[ENDED] && this[PENDING] === 0) {
        this.emit('prefinish');
        this.emit('finish');
        this.emit('end');
        this.emit('close');
      }
    }
  }, {
    key: CHECKPATH,
    value: function value(entry) {
      if (this.strip) {
        var parts = entry.path.split(/\/|\\/);
        if (parts.length < this.strip) return false;
        entry.path = parts.slice(this.strip).join('/');

        if (entry.type === 'Link') {
          var linkparts = entry.linkpath.split(/\/|\\/);
          if (linkparts.length >= this.strip) entry.linkpath = linkparts.slice(this.strip).join('/');
        }
      }

      if (!this.preservePaths) {
        var p = entry.path;

        if (p.match(/(^|\/|\\)\.\.(\\|\/|$)/)) {
          this.warn('TAR_ENTRY_ERROR', "path contains '..'", {
            entry: entry,
            path: p
          });
          return false;
        } // absolutes on posix are also absolutes on win32
        // so we only need to test this one to get both


        if (path.win32.isAbsolute(p)) {
          var parsed = path.win32.parse(p);
          entry.path = p.substr(parsed.root.length);
          var r = parsed.root;
          this.warn('TAR_ENTRY_INFO', "stripping ".concat(r, " from absolute path"), {
            entry: entry,
            path: p
          });
        }
      } // only encode : chars that aren't drive letter indicators


      if (this.win32) {
        var _parsed = path.win32.parse(entry.path);

        entry.path = _parsed.root === '' ? wc.encode(entry.path) : _parsed.root + wc.encode(entry.path.substr(_parsed.root.length));
      }

      if (path.isAbsolute(entry.path)) entry.absolute = entry.path;else entry.absolute = path.resolve(this.cwd, entry.path);
      return true;
    }
  }, {
    key: ONENTRY,
    value: function value(entry) {
      if (!this[CHECKPATH](entry)) return entry.resume();
      assert.equal(_typeof(entry.absolute), 'string');

      switch (entry.type) {
        case 'Directory':
        case 'GNUDumpDir':
          if (entry.mode) entry.mode = entry.mode | 448;

        case 'File':
        case 'OldFile':
        case 'ContiguousFile':
        case 'Link':
        case 'SymbolicLink':
          return this[CHECKFS](entry);

        case 'CharacterDevice':
        case 'BlockDevice':
        case 'FIFO':
          return this[UNSUPPORTED](entry);
      }
    }
  }, {
    key: ONERROR,
    value: function value(er, entry) {
      // Cwd has to exist, or else nothing works. That's serious.
      // Other errors are warnings, which raise the error in strict
      // mode, but otherwise continue on.
      if (er.name === 'CwdError') this.emit('error', er);else {
        this.warn('TAR_ENTRY_ERROR', er, {
          entry: entry
        });
        this[UNPEND]();
        entry.resume();
      }
    }
  }, {
    key: MKDIR,
    value: function value(dir, mode, cb) {
      mkdir(dir, {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode
      }, cb);
    }
  }, {
    key: DOCHOWN,
    value: function value(entry) {
      // in preserve owner mode, chown if the entry doesn't match process
      // in set owner mode, chown if setting doesn't match process
      return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;
    }
  }, {
    key: UID,
    value: function value(entry) {
      return uint32(this.uid, entry.uid, this.processUid);
    }
  }, {
    key: GID,
    value: function value(entry) {
      return uint32(this.gid, entry.gid, this.processGid);
    }
  }, {
    key: FILE,
    value: function value(entry, fullyDone) {
      var _this2 = this;

      var mode = entry.mode & 4095 || this.fmode;
      var stream = new fsm.WriteStream(entry.absolute, {
        flags: getFlag(entry.size),
        mode: mode,
        autoClose: false
      });
      stream.on('error', function (er) {
        return _this2[ONERROR](er, entry);
      });
      var actions = 1;

      var done = function done(er) {
        if (er) return _this2[ONERROR](er, entry);

        if (--actions === 0) {
          fs.close(stream.fd, function (er) {
            fullyDone();
            er ? _this2[ONERROR](er, entry) : _this2[UNPEND]();
          });
        }
      };

      stream.on('finish', function (_) {
        // if futimes fails, try utimes
        // if utimes fails, fail with the original error
        // same for fchown/chown
        var abs = entry.absolute;
        var fd = stream.fd;

        if (entry.mtime && !_this2.noMtime) {
          actions++;
          var atime = entry.atime || new Date();
          var mtime = entry.mtime;
          fs.futimes(fd, atime, mtime, function (er) {
            return er ? fs.utimes(abs, atime, mtime, function (er2) {
              return done(er2 && er);
            }) : done();
          });
        }

        if (_this2[DOCHOWN](entry)) {
          actions++;

          var uid = _this2[UID](entry);

          var gid = _this2[GID](entry);

          fs.fchown(fd, uid, gid, function (er) {
            return er ? fs.chown(abs, uid, gid, function (er2) {
              return done(er2 && er);
            }) : done();
          });
        }

        done();
      });
      var tx = this.transform ? this.transform(entry) || entry : entry;

      if (tx !== entry) {
        tx.on('error', function (er) {
          return _this2[ONERROR](er, entry);
        });
        entry.pipe(tx);
      }

      tx.pipe(stream);
    }
  }, {
    key: DIRECTORY,
    value: function value(entry, fullyDone) {
      var _this3 = this;

      var mode = entry.mode & 4095 || this.dmode;
      this[MKDIR](entry.absolute, mode, function (er) {
        if (er) {
          fullyDone();
          return _this3[ONERROR](er, entry);
        }

        var actions = 1;

        var done = function done(_) {
          if (--actions === 0) {
            fullyDone();

            _this3[UNPEND]();

            entry.resume();
          }
        };

        if (entry.mtime && !_this3.noMtime) {
          actions++;
          fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
        }

        if (_this3[DOCHOWN](entry)) {
          actions++;
          fs.chown(entry.absolute, _this3[UID](entry), _this3[GID](entry), done);
        }

        done();
      });
    }
  }, {
    key: UNSUPPORTED,
    value: function value(entry) {
      entry.unsupported = true;
      this.warn('TAR_ENTRY_UNSUPPORTED', "unsupported entry type: ".concat(entry.type), {
        entry: entry
      });
      entry.resume();
    }
  }, {
    key: SYMLINK,
    value: function value(entry, done) {
      this[LINK](entry, entry.linkpath, 'symlink', done);
    }
  }, {
    key: HARDLINK,
    value: function value(entry, done) {
      this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link', done);
    }
  }, {
    key: PEND,
    value: function value() {
      this[PENDING]++;
    }
  }, {
    key: UNPEND,
    value: function value() {
      this[PENDING]--;
      this[MAYBECLOSE]();
    }
  }, {
    key: SKIP,
    value: function value(entry) {
      this[UNPEND]();
      entry.resume();
    } // Check if we can reuse an existing filesystem entry safely and
    // overwrite it, rather than unlinking and recreating
    // Windows doesn't report a useful nlink, so we just never reuse entries

  }, {
    key: ISREUSABLE,
    value: function value(entry, st) {
      return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== 'win32';
    } // check if a thing is there, and if so, try to clobber it

  }, {
    key: CHECKFS,
    value: function value(entry) {
      var _this4 = this;

      this[PEND]();
      var paths = [entry.path];
      if (entry.linkpath) paths.push(entry.linkpath);
      this.reservations.reserve(paths, function (done) {
        return _this4[CHECKFS2](entry, done);
      });
    }
  }, {
    key: CHECKFS2,
    value: function value(entry, done) {
      var _this5 = this;

      this[MKDIR](path.dirname(entry.absolute), this.dmode, function (er) {
        if (er) {
          done();
          return _this5[ONERROR](er, entry);
        }

        fs.lstat(entry.absolute, function (er, st) {
          if (st && (_this5.keep || _this5.newer && st.mtime > entry.mtime)) {
            _this5[SKIP](entry);

            done();
          } else if (er || _this5[ISREUSABLE](entry, st)) {
            _this5[MAKEFS](null, entry, done);
          } else if (st.isDirectory()) {
            if (entry.type === 'Directory') {
              if (!entry.mode || (st.mode & 4095) === entry.mode) _this5[MAKEFS](null, entry, done);else fs.chmod(entry.absolute, entry.mode, function (er) {
                return _this5[MAKEFS](er, entry, done);
              });
            } else fs.rmdir(entry.absolute, function (er) {
              return _this5[MAKEFS](er, entry, done);
            });
          } else unlinkFile(entry.absolute, function (er) {
            return _this5[MAKEFS](er, entry, done);
          });
        });
      });
    }
  }, {
    key: MAKEFS,
    value: function value(er, entry, done) {
      if (er) return this[ONERROR](er, entry);

      switch (entry.type) {
        case 'File':
        case 'OldFile':
        case 'ContiguousFile':
          return this[FILE](entry, done);

        case 'Link':
          return this[HARDLINK](entry, done);

        case 'SymbolicLink':
          return this[SYMLINK](entry, done);

        case 'Directory':
        case 'GNUDumpDir':
          return this[DIRECTORY](entry, done);
      }
    }
  }, {
    key: LINK,
    value: function value(entry, linkpath, link, done) {
      var _this6 = this;

      // XXX: get the type ('file' or 'dir') for windows
      fs[link](linkpath, entry.absolute, function (er) {
        if (er) return _this6[ONERROR](er, entry);
        done();

        _this6[UNPEND]();

        entry.resume();
      });
    }
  }]);

  return Unpack;
}(Parser);

var UnpackSync =
/*#__PURE__*/
function (_Unpack) {
  _inherits(UnpackSync, _Unpack);

  function UnpackSync(opt) {
    _classCallCheck(this, UnpackSync);

    return _possibleConstructorReturn(this, _getPrototypeOf(UnpackSync).call(this, opt));
  }

  _createClass(UnpackSync, [{
    key: CHECKFS,
    value: function value(entry) {
      var er = this[MKDIR](path.dirname(entry.absolute), this.dmode, neverCalled);
      if (er) return this[ONERROR](er, entry);

      try {
        var st = fs.lstatSync(entry.absolute);
        if (this.keep || this.newer && st.mtime > entry.mtime) return this[SKIP](entry);else if (this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry, neverCalled);else {
          try {
            if (st.isDirectory()) {
              if (entry.type === 'Directory') {
                if (entry.mode && (st.mode & 4095) !== entry.mode) fs.chmodSync(entry.absolute, entry.mode);
              } else fs.rmdirSync(entry.absolute);
            } else unlinkFileSync(entry.absolute);

            return this[MAKEFS](null, entry, neverCalled);
          } catch (er) {
            return this[ONERROR](er, entry);
          }
        }
      } catch (er) {
        return this[MAKEFS](null, entry, neverCalled);
      }
    }
  }, {
    key: FILE,
    value: function value(entry, _) {
      var _this7 = this;

      var mode = entry.mode & 4095 || this.fmode;

      var oner = function oner(er) {
        var closeError;

        try {
          fs.closeSync(fd);
        } catch (e) {
          closeError = e;
        }

        if (er || closeError) _this7[ONERROR](er || closeError, entry);
      };

      var stream;
      var fd;

      try {
        fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);
      } catch (er) {
        return oner(er);
      }

      var tx = this.transform ? this.transform(entry) || entry : entry;

      if (tx !== entry) {
        tx.on('error', function (er) {
          return _this7[ONERROR](er, entry);
        });
        entry.pipe(tx);
      }

      tx.on('data', function (chunk) {
        try {
          fs.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      });
      tx.on('end', function (_) {
        var er = null; // try both, falling futimes back to utimes
        // if either fails, handle the first error

        if (entry.mtime && !_this7.noMtime) {
          var atime = entry.atime || new Date();
          var mtime = entry.mtime;

          try {
            fs.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs.utimesSync(entry.absolute, atime, mtime);
            } catch (utimeser) {
              er = futimeser;
            }
          }
        }

        if (_this7[DOCHOWN](entry)) {
          var uid = _this7[UID](entry);

          var gid = _this7[GID](entry);

          try {
            fs.fchownSync(fd, uid, gid);
          } catch (fchowner) {
            try {
              fs.chownSync(entry.absolute, uid, gid);
            } catch (chowner) {
              er = er || fchowner;
            }
          }
        }

        oner(er);
      });
    }
  }, {
    key: DIRECTORY,
    value: function value(entry, _) {
      var mode = entry.mode & 4095 || this.dmode;
      var er = this[MKDIR](entry.absolute, mode);
      if (er) return this[ONERROR](er, entry);

      if (entry.mtime && !this.noMtime) {
        try {
          fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
        } catch (er) {}
      }

      if (this[DOCHOWN](entry)) {
        try {
          fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
        } catch (er) {}
      }

      entry.resume();
    }
  }, {
    key: MKDIR,
    value: function value(dir, mode) {
      try {
        return mkdir.sync(dir, {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode: mode
        });
      } catch (er) {
        return er;
      }
    }
  }, {
    key: LINK,
    value: function value(entry, linkpath, link, _) {
      try {
        fs[link + 'Sync'](linkpath, entry.absolute);
        entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  }]);

  return UnpackSync;
}(Unpack);

Unpack.Sync = UnpackSync;
module.exports = Unpack;