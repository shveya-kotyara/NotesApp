'use strict'; // tar -x

var hlo = require('./high-level-opt.js');

var Unpack = require('./unpack.js');

var fs = require('fs');

var fsm = require('fs-minipass');

var path = require('path');

var x = module.exports = function (opt_, files, cb) {
  if (typeof opt_ === 'function') cb = opt_, files = null, opt_ = {};else if (Array.isArray(opt_)) files = opt_, opt_ = {};
  if (typeof files === 'function') cb = files, files = null;
  if (!files) files = [];else files = Array.from(files);
  var opt = hlo(opt_);
  if (opt.sync && typeof cb === 'function') throw new TypeError('callback not supported for sync tar functions');
  if (!opt.file && typeof cb === 'function') throw new TypeError('callback only supported with file option');
  if (files.length) filesFilter(opt, files);
  return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
}; // construct a filter that limits the file entries listed
// include child entries if a dir is included


var filesFilter = function filesFilter(opt, files) {
  var map = new Map(files.map(function (f) {
    return [f.replace(/\/+$/, ''), true];
  }));
  var filter = opt.filter;

  var mapHas = function mapHas(file, r) {
    var root = r || path.parse(file).root || '.';
    var ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path.dirname(file), root);
    map.set(file, ret);
    return ret;
  };

  opt.filter = filter ? function (file, entry) {
    return filter(file, entry) && mapHas(file.replace(/\/+$/, ''));
  } : function (file) {
    return mapHas(file.replace(/\/+$/, ''));
  };
};

var extractFileSync = function extractFileSync(opt) {
  var u = new Unpack.Sync(opt);
  var file = opt.file;
  var threw = true;
  var fd;
  var stat = fs.statSync(file); // This trades a zero-byte read() syscall for a stat
  // However, it will usually result in less memory allocation

  var readSize = opt.maxReadSize || 16 * 1024 * 1024;
  var stream = new fsm.ReadStreamSync(file, {
    readSize: readSize,
    size: stat.size
  });
  stream.pipe(u);
};

var extractFile = function extractFile(opt, cb) {
  var u = new Unpack(opt);
  var readSize = opt.maxReadSize || 16 * 1024 * 1024;
  var file = opt.file;
  var p = new Promise(function (resolve, reject) {
    u.on('error', reject);
    u.on('close', resolve); // This trades a zero-byte read() syscall for a stat
    // However, it will usually result in less memory allocation

    fs.stat(file, function (er, stat) {
      if (er) reject(er);else {
        var stream = new fsm.ReadStream(file, {
          readSize: readSize,
          size: stat.size
        });
        stream.on('error', reject);
        stream.pipe(u);
      }
    });
  });
  return cb ? p.then(cb, cb) : p;
};

var extractSync = function extractSync(opt) {
  return new Unpack.Sync(opt);
};

var extract = function extract(opt) {
  return new Unpack(opt);
};