'use strict'; // this[BUFFER] is the remainder of a chunk if we're waiting for
// the full 512 bytes of a header to come in.  We will Buffer.concat()
// it to the next write(), which is a mem copy, but a small one.
//
// this[QUEUE] is a Yallist of entries that haven't been emitted
// yet this can only get filled up if the user keeps write()ing after
// a write() returns false, or does a write() with more than one entry
//
// We don't buffer chunks, we always parse them and either create an
// entry, or push it into the active entry.  The ReadEntry class knows
// to throw data away if .ignore=true
//
// Shift entry off the buffer when it emits 'end', and emit 'entry' for
// the next one in the list.
//
// At any time, we're pushing body chunks into the entry at WRITEENTRY,
// and waiting for 'end' on the entry at READENTRY
//
// ignored entries get .resume() called on them straight away

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var warner = require('./warn-mixin.js');

var path = require('path');

var Header = require('./header.js');

var EE = require('events');

var Yallist = require('yallist');

var maxMetaEntrySize = 1024 * 1024;

var Entry = require('./read-entry.js');

var Pax = require('./pax.js');

var zlib = require('minizlib');

var gzipHeader = Buffer.from([0x1f, 0x8b]);
var STATE = Symbol('state');
var WRITEENTRY = Symbol('writeEntry');
var READENTRY = Symbol('readEntry');
var NEXTENTRY = Symbol('nextEntry');
var PROCESSENTRY = Symbol('processEntry');
var EX = Symbol('extendedHeader');
var GEX = Symbol('globalExtendedHeader');
var META = Symbol('meta');
var EMITMETA = Symbol('emitMeta');
var BUFFER = Symbol('buffer');
var QUEUE = Symbol('queue');
var ENDED = Symbol('ended');
var EMITTEDEND = Symbol('emittedEnd');
var EMIT = Symbol('emit');
var UNZIP = Symbol('unzip');
var CONSUMECHUNK = Symbol('consumeChunk');
var CONSUMECHUNKSUB = Symbol('consumeChunkSub');
var CONSUMEBODY = Symbol('consumeBody');
var CONSUMEMETA = Symbol('consumeMeta');
var CONSUMEHEADER = Symbol('consumeHeader');
var CONSUMING = Symbol('consuming');
var BUFFERCONCAT = Symbol('bufferConcat');
var MAYBEEND = Symbol('maybeEnd');
var WRITING = Symbol('writing');
var ABORTED = Symbol('aborted');
var DONE = Symbol('onDone');
var SAW_VALID_ENTRY = Symbol('sawValidEntry');
var SAW_NULL_BLOCK = Symbol('sawNullBlock');
var SAW_EOF = Symbol('sawEOF');

var noop = function noop(_) {
  return true;
};

module.exports = warner(
/*#__PURE__*/
function (_EE) {
  _inherits(Parser, _EE);

  function Parser(opt) {
    var _this;

    _classCallCheck(this, Parser);

    opt = opt || {};
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Parser).call(this, opt));
    _this.file = opt.file || ''; // set to boolean false when an entry starts.  1024 bytes of \0
    // is technically a valid tarball, albeit a boring one.

    _this[SAW_VALID_ENTRY] = null; // these BADARCHIVE errors can't be detected early. listen on DONE.

    _this.on(DONE, function (_) {
      if (_this[STATE] === 'begin' || _this[SAW_VALID_ENTRY] === false) {
        // either less than 1 block of data, or all entries were invalid.
        // Either way, probably not even a tarball.
        _this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');
      }
    });

    if (opt.ondone) _this.on(DONE, opt.ondone);else _this.on(DONE, function (_) {
      _this.emit('prefinish');

      _this.emit('finish');

      _this.emit('end');

      _this.emit('close');
    });
    _this.strict = !!opt.strict;
    _this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
    _this.filter = typeof opt.filter === 'function' ? opt.filter : noop; // have to set this so that streams are ok piping into it

    _this.writable = true;
    _this.readable = false;
    _this[QUEUE] = new Yallist();
    _this[BUFFER] = null;
    _this[READENTRY] = null;
    _this[WRITEENTRY] = null;
    _this[STATE] = 'begin';
    _this[META] = '';
    _this[EX] = null;
    _this[GEX] = null;
    _this[ENDED] = false;
    _this[UNZIP] = null;
    _this[ABORTED] = false;
    _this[SAW_NULL_BLOCK] = false;
    _this[SAW_EOF] = false;
    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);
    if (typeof opt.onentry === 'function') _this.on('entry', opt.onentry);
    return _this;
  }

  _createClass(Parser, [{
    key: CONSUMEHEADER,
    value: function value(chunk, position) {
      var _this2 = this;

      if (this[SAW_VALID_ENTRY] === null) this[SAW_VALID_ENTRY] = false;
      var header;

      try {
        header = new Header(chunk, position, this[EX], this[GEX]);
      } catch (er) {
        return this.warn('TAR_ENTRY_INVALID', er);
      }

      if (header.nullBlock) {
        if (this[SAW_NULL_BLOCK]) {
          this[SAW_EOF] = true; // ending an archive with no entries.  pointless, but legal.

          if (this[STATE] === 'begin') this[STATE] = 'header';
          this[EMIT]('eof');
        } else {
          this[SAW_NULL_BLOCK] = true;
          this[EMIT]('nullBlock');
        }
      } else {
        this[SAW_NULL_BLOCK] = false;
        if (!header.cksumValid) this.warn('TAR_ENTRY_INVALID', 'checksum failure', {
          header: header
        });else if (!header.path) this.warn('TAR_ENTRY_INVALID', 'path is required', {
          header: header
        });else {
          var type = header.type;
          if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) this.warn('TAR_ENTRY_INVALID', 'linkpath required', {
            header: header
          });else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {
            header: header
          });else {
            var entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]); // we do this for meta & ignored entries as well, because they
            // are still valid tar, or else we wouldn't know to ignore them

            if (!this[SAW_VALID_ENTRY]) {
              if (entry.remain) {
                // this might be the one!
                var onend = function onend() {
                  if (!entry.invalid) _this2[SAW_VALID_ENTRY] = true;
                };

                entry.on('end', onend);
              } else {
                this[SAW_VALID_ENTRY] = true;
              }
            }

            if (entry.meta) {
              if (entry.size > this.maxMetaEntrySize) {
                entry.ignore = true;
                this[EMIT]('ignoredEntry', entry);
                this[STATE] = 'ignore';
                entry.resume();
              } else if (entry.size > 0) {
                this[META] = '';
                entry.on('data', function (c) {
                  return _this2[META] += c;
                });
                this[STATE] = 'meta';
              }
            } else {
              this[EX] = null;
              entry.ignore = entry.ignore || !this.filter(entry.path, entry);

              if (entry.ignore) {
                // probably valid, just not something we care about
                this[EMIT]('ignoredEntry', entry);
                this[STATE] = entry.remain ? 'ignore' : 'header';
                entry.resume();
              } else {
                if (entry.remain) this[STATE] = 'body';else {
                  this[STATE] = 'header';
                  entry.end();
                }

                if (!this[READENTRY]) {
                  this[QUEUE].push(entry);
                  this[NEXTENTRY]();
                } else this[QUEUE].push(entry);
              }
            }
          }
        }
      }
    }
  }, {
    key: PROCESSENTRY,
    value: function value(entry) {
      var _this3 = this;

      var go = true;

      if (!entry) {
        this[READENTRY] = null;
        go = false;
      } else if (Array.isArray(entry)) this.emit.apply(this, entry);else {
        this[READENTRY] = entry;
        this.emit('entry', entry);

        if (!entry.emittedEnd) {
          entry.on('end', function (_) {
            return _this3[NEXTENTRY]();
          });
          go = false;
        }
      }

      return go;
    }
  }, {
    key: NEXTENTRY,
    value: function value() {
      var _this4 = this;

      do {} while (this[PROCESSENTRY](this[QUEUE].shift()));

      if (!this[QUEUE].length) {
        // At this point, there's nothing in the queue, but we may have an
        // entry which is being consumed (readEntry).
        // If we don't, then we definitely can handle more data.
        // If we do, and either it's flowing, or it has never had any data
        // written to it, then it needs more.
        // The only other possibility is that it has returned false from a
        // write() call, so we wait for the next drain to continue.
        var re = this[READENTRY];
        var drainNow = !re || re.flowing || re.size === re.remain;

        if (drainNow) {
          if (!this[WRITING]) this.emit('drain');
        } else re.once('drain', function (_) {
          return _this4.emit('drain');
        });
      }
    }
  }, {
    key: CONSUMEBODY,
    value: function value(chunk, position) {
      // write up to but no  more than writeEntry.blockRemain
      var entry = this[WRITEENTRY];
      var br = entry.blockRemain;
      var c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
      entry.write(c);

      if (!entry.blockRemain) {
        this[STATE] = 'header';
        this[WRITEENTRY] = null;
        entry.end();
      }

      return c.length;
    }
  }, {
    key: CONSUMEMETA,
    value: function value(chunk, position) {
      var entry = this[WRITEENTRY];
      var ret = this[CONSUMEBODY](chunk, position); // if we finished, then the entry is reset

      if (!this[WRITEENTRY]) this[EMITMETA](entry);
      return ret;
    }
  }, {
    key: EMIT,
    value: function value(ev, data, extra) {
      if (!this[QUEUE].length && !this[READENTRY]) this.emit(ev, data, extra);else this[QUEUE].push([ev, data, extra]);
    }
  }, {
    key: EMITMETA,
    value: function value(entry) {
      this[EMIT]('meta', this[META]);

      switch (entry.type) {
        case 'ExtendedHeader':
        case 'OldExtendedHeader':
          this[EX] = Pax.parse(this[META], this[EX], false);
          break;

        case 'GlobalExtendedHeader':
          this[GEX] = Pax.parse(this[META], this[GEX], true);
          break;

        case 'NextFileHasLongPath':
        case 'OldGnuLongPath':
          this[EX] = this[EX] || Object.create(null);
          this[EX].path = this[META].replace(/\0.*/, '');
          break;

        case 'NextFileHasLongLinkpath':
          this[EX] = this[EX] || Object.create(null);
          this[EX].linkpath = this[META].replace(/\0.*/, '');
          break;

        /* istanbul ignore next */

        default:
          throw new Error('unknown meta: ' + entry.type);
      }
    }
  }, {
    key: "abort",
    value: function abort(error) {
      this[ABORTED] = true;
      this.emit('abort', error); // always throws, even in non-strict mode

      this.warn('TAR_ABORT', error, {
        recoverable: false
      });
    }
  }, {
    key: "write",
    value: function write(chunk) {
      var _this5 = this;

      if (this[ABORTED]) return; // first write, might be gzipped

      if (this[UNZIP] === null && chunk) {
        if (this[BUFFER]) {
          chunk = Buffer.concat([this[BUFFER], chunk]);
          this[BUFFER] = null;
        }

        if (chunk.length < gzipHeader.length) {
          this[BUFFER] = chunk;
          return true;
        }

        for (var i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
          if (chunk[i] !== gzipHeader[i]) this[UNZIP] = false;
        }

        if (this[UNZIP] === null) {
          var ended = this[ENDED];
          this[ENDED] = false;
          this[UNZIP] = new zlib.Unzip();
          this[UNZIP].on('data', function (chunk) {
            return _this5[CONSUMECHUNK](chunk);
          });
          this[UNZIP].on('error', function (er) {
            return _this5.abort(er);
          });
          this[UNZIP].on('end', function (_) {
            _this5[ENDED] = true;

            _this5[CONSUMECHUNK]();
          });
          this[WRITING] = true;

          var _ret = this[UNZIP][ended ? 'end' : 'write'](chunk);

          this[WRITING] = false;
          return _ret;
        }
      }

      this[WRITING] = true;
      if (this[UNZIP]) this[UNZIP].write(chunk);else this[CONSUMECHUNK](chunk);
      this[WRITING] = false; // return false if there's a queue, or if the current entry isn't flowing

      var ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true; // if we have no queue, then that means a clogged READENTRY

      if (!ret && !this[QUEUE].length) this[READENTRY].once('drain', function (_) {
        return _this5.emit('drain');
      });
      return ret;
    }
  }, {
    key: BUFFERCONCAT,
    value: function value(c) {
      if (c && !this[ABORTED]) this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
    }
  }, {
    key: MAYBEEND,
    value: function value() {
      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
        this[EMITTEDEND] = true;
        var entry = this[WRITEENTRY];

        if (entry && entry.blockRemain) {
          // truncated, likely a damaged file
          var have = this[BUFFER] ? this[BUFFER].length : 0;
          this.warn('TAR_BAD_ARCHIVE', "Truncated input (needed ".concat(entry.blockRemain, " more bytes, only ").concat(have, " available)"), {
            entry: entry
          });
          if (this[BUFFER]) entry.write(this[BUFFER]);
          entry.end();
        }

        this[EMIT](DONE);
      }
    }
  }, {
    key: CONSUMECHUNK,
    value: function value(chunk) {
      if (this[CONSUMING]) this[BUFFERCONCAT](chunk);else if (!chunk && !this[BUFFER]) this[MAYBEEND]();else {
        this[CONSUMING] = true;

        if (this[BUFFER]) {
          this[BUFFERCONCAT](chunk);
          var c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        } else {
          this[CONSUMECHUNKSUB](chunk);
        }

        while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
          var _c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](_c);
        }

        this[CONSUMING] = false;
      }
      if (!this[BUFFER] || this[ENDED]) this[MAYBEEND]();
    }
  }, {
    key: CONSUMECHUNKSUB,
    value: function value(chunk) {
      // we know that we are in CONSUMING mode, so anything written goes into
      // the buffer.  Advance the position and put any remainder in the buffer.
      var position = 0;
      var length = chunk.length;

      while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
        switch (this[STATE]) {
          case 'begin':
          case 'header':
            this[CONSUMEHEADER](chunk, position);
            position += 512;
            break;

          case 'ignore':
          case 'body':
            position += this[CONSUMEBODY](chunk, position);
            break;

          case 'meta':
            position += this[CONSUMEMETA](chunk, position);
            break;

          /* istanbul ignore next */

          default:
            throw new Error('invalid state: ' + this[STATE]);
        }
      }

      if (position < length) {
        if (this[BUFFER]) this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);else this[BUFFER] = chunk.slice(position);
      }
    }
  }, {
    key: "end",
    value: function end(chunk) {
      if (!this[ABORTED]) {
        if (this[UNZIP]) this[UNZIP].end(chunk);else {
          this[ENDED] = true;
          this.write(chunk);
        }
      }
    }
  }]);

  return Parser;
}(EE));