'use strict'; // A readable tar stream creator
// Technically, this is a transform stream that you write paths into,
// and tar format comes out of.
// The `add()` method is like `write()` but returns this,
// and end() return `this` as well, so you can
// do `new Pack(opt).add('files').add('dir').end().pipe(output)
// You could also do something like:
// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PackJob = function PackJob(path, absolute) {
  _classCallCheck(this, PackJob);

  this.path = path || './';
  this.absolute = absolute;
  this.entry = null;
  this.stat = null;
  this.readdir = null;
  this.pending = false;
  this.ignore = false;
  this.piped = false;
};

var MiniPass = require('minipass');

var zlib = require('minizlib');

var ReadEntry = require('./read-entry.js');

var WriteEntry = require('./write-entry.js');

var WriteEntrySync = WriteEntry.Sync;
var WriteEntryTar = WriteEntry.Tar;

var Yallist = require('yallist');

var EOF = Buffer.alloc(1024);
var ONSTAT = Symbol('onStat');
var ENDED = Symbol('ended');
var QUEUE = Symbol('queue');
var CURRENT = Symbol('current');
var PROCESS = Symbol('process');
var PROCESSING = Symbol('processing');
var PROCESSJOB = Symbol('processJob');
var JOBS = Symbol('jobs');
var JOBDONE = Symbol('jobDone');
var ADDFSENTRY = Symbol('addFSEntry');
var ADDTARENTRY = Symbol('addTarEntry');
var STAT = Symbol('stat');
var READDIR = Symbol('readdir');
var ONREADDIR = Symbol('onreaddir');
var PIPE = Symbol('pipe');
var ENTRY = Symbol('entry');
var ENTRYOPT = Symbol('entryOpt');
var WRITEENTRYCLASS = Symbol('writeEntryClass');
var WRITE = Symbol('write');
var ONDRAIN = Symbol('ondrain');

var fs = require('fs');

var path = require('path');

var warner = require('./warn-mixin.js');

var Pack = warner(
/*#__PURE__*/
function (_MiniPass) {
  _inherits(Pack, _MiniPass);

  function Pack(opt) {
    var _this;

    _classCallCheck(this, Pack);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pack).call(this, opt));
    opt = opt || Object.create(null);
    _this.opt = opt;
    _this.file = opt.file || '';
    _this.cwd = opt.cwd || process.cwd();
    _this.maxReadSize = opt.maxReadSize;
    _this.preservePaths = !!opt.preservePaths;
    _this.strict = !!opt.strict;
    _this.noPax = !!opt.noPax;
    _this.prefix = (opt.prefix || '').replace(/(\\|\/)+$/, '');
    _this.linkCache = opt.linkCache || new Map();
    _this.statCache = opt.statCache || new Map();
    _this.readdirCache = opt.readdirCache || new Map();
    _this[WRITEENTRYCLASS] = WriteEntry;
    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);
    _this.portable = !!opt.portable;
    _this.zip = null;

    if (opt.gzip) {
      if (_typeof(opt.gzip) !== 'object') opt.gzip = {};
      if (_this.portable) opt.gzip.portable = true;
      _this.zip = new zlib.Gzip(opt.gzip);

      _this.zip.on('data', function (chunk) {
        return _get(_getPrototypeOf(Pack.prototype), "write", _assertThisInitialized(_this)).call(_assertThisInitialized(_this), chunk);
      });

      _this.zip.on('end', function (_) {
        return _get(_getPrototypeOf(Pack.prototype), "end", _assertThisInitialized(_this)).call(_assertThisInitialized(_this));
      });

      _this.zip.on('drain', function (_) {
        return _this[ONDRAIN]();
      });

      _this.on('resume', function (_) {
        return _this.zip.resume();
      });
    } else _this.on('drain', _this[ONDRAIN]);

    _this.noDirRecurse = !!opt.noDirRecurse;
    _this.follow = !!opt.follow;
    _this.noMtime = !!opt.noMtime;
    _this.mtime = opt.mtime || null;
    _this.filter = typeof opt.filter === 'function' ? opt.filter : function (_) {
      return true;
    };
    _this[QUEUE] = new Yallist();
    _this[JOBS] = 0;
    _this.jobs = +opt.jobs || 4;
    _this[PROCESSING] = false;
    _this[ENDED] = false;
    return _this;
  }

  _createClass(Pack, [{
    key: WRITE,
    value: function value(chunk) {
      return _get(_getPrototypeOf(Pack.prototype), "write", this).call(this, chunk);
    }
  }, {
    key: "add",
    value: function add(path) {
      this.write(path);
      return this;
    }
  }, {
    key: "end",
    value: function end(path) {
      if (path) this.write(path);
      this[ENDED] = true;
      this[PROCESS]();
      return this;
    }
  }, {
    key: "write",
    value: function write(path) {
      if (this[ENDED]) throw new Error('write after end');
      if (path instanceof ReadEntry) this[ADDTARENTRY](path);else this[ADDFSENTRY](path);
      return this.flowing;
    }
  }, {
    key: ADDTARENTRY,
    value: function value(p) {
      var _this2 = this;

      var absolute = path.resolve(this.cwd, p.path);
      if (this.prefix) p.path = this.prefix + '/' + p.path.replace(/^\.(\/+|$)/, ''); // in this case, we don't have to wait for the stat

      if (!this.filter(p.path, p)) p.resume();else {
        var job = new PackJob(p.path, absolute, false);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
        job.entry.on('end', function (_) {
          return _this2[JOBDONE](job);
        });
        this[JOBS] += 1;
        this[QUEUE].push(job);
      }
      this[PROCESS]();
    }
  }, {
    key: ADDFSENTRY,
    value: function value(p) {
      var absolute = path.resolve(this.cwd, p);
      if (this.prefix) p = this.prefix + '/' + p.replace(/^\.(\/+|$)/, '');
      this[QUEUE].push(new PackJob(p, absolute));
      this[PROCESS]();
    }
  }, {
    key: STAT,
    value: function value(job) {
      var _this3 = this;

      job.pending = true;
      this[JOBS] += 1;
      var stat = this.follow ? 'stat' : 'lstat';
      fs[stat](job.absolute, function (er, stat) {
        job.pending = false;
        _this3[JOBS] -= 1;
        if (er) _this3.emit('error', er);else _this3[ONSTAT](job, stat);
      });
    }
  }, {
    key: ONSTAT,
    value: function value(job, stat) {
      this.statCache.set(job.absolute, stat);
      job.stat = stat; // now we have the stat, we can filter it.

      if (!this.filter(job.path, stat)) job.ignore = true;
      this[PROCESS]();
    }
  }, {
    key: READDIR,
    value: function value(job) {
      var _this4 = this;

      job.pending = true;
      this[JOBS] += 1;
      fs.readdir(job.absolute, function (er, entries) {
        job.pending = false;
        _this4[JOBS] -= 1;
        if (er) return _this4.emit('error', er);

        _this4[ONREADDIR](job, entries);
      });
    }
  }, {
    key: ONREADDIR,
    value: function value(job, entries) {
      this.readdirCache.set(job.absolute, entries);
      job.readdir = entries;
      this[PROCESS]();
    }
  }, {
    key: PROCESS,
    value: function value() {
      if (this[PROCESSING]) return;
      this[PROCESSING] = true;

      for (var w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
        this[PROCESSJOB](w.value);

        if (w.value.ignore) {
          var p = w.next;
          this[QUEUE].removeNode(w);
          w.next = p;
        }
      }

      this[PROCESSING] = false;

      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
        if (this.zip) this.zip.end(EOF);else {
          _get(_getPrototypeOf(Pack.prototype), "write", this).call(this, EOF);

          _get(_getPrototypeOf(Pack.prototype), "end", this).call(this);
        }
      }
    }
  }, {
    key: JOBDONE,
    value: function value(job) {
      this[QUEUE].shift();
      this[JOBS] -= 1;
      this[PROCESS]();
    }
  }, {
    key: PROCESSJOB,
    value: function value(job) {
      if (job.pending) return;

      if (job.entry) {
        if (job === this[CURRENT] && !job.piped) this[PIPE](job);
        return;
      }

      if (!job.stat) {
        if (this.statCache.has(job.absolute)) this[ONSTAT](job, this.statCache.get(job.absolute));else this[STAT](job);
      }

      if (!job.stat) return; // filtered out!

      if (job.ignore) return;

      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
        if (this.readdirCache.has(job.absolute)) this[ONREADDIR](job, this.readdirCache.get(job.absolute));else this[READDIR](job);
        if (!job.readdir) return;
      } // we know it doesn't have an entry, because that got checked above


      job.entry = this[ENTRY](job);

      if (!job.entry) {
        job.ignore = true;
        return;
      }

      if (job === this[CURRENT] && !job.piped) this[PIPE](job);
    }
  }, {
    key: ENTRYOPT,
    value: function value(job) {
      var _this5 = this;

      return {
        onwarn: function onwarn(code, msg, data) {
          return _this5.warn(code, msg, data);
        },
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime
      };
    }
  }, {
    key: ENTRY,
    value: function value(job) {
      var _this6 = this;

      this[JOBS] += 1;

      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', function () {
          return _this6[JOBDONE](job);
        }).on('error', function (er) {
          return _this6.emit('error', er);
        });
      } catch (er) {
        this.emit('error', er);
      }
    }
  }, {
    key: ONDRAIN,
    value: function value() {
      if (this[CURRENT] && this[CURRENT].entry) this[CURRENT].entry.resume();
    } // like .pipe() but using super, because our write() is special

  }, {
    key: PIPE,
    value: function value(job) {
      var _this7 = this;

      job.piped = true;
      if (job.readdir) job.readdir.forEach(function (entry) {
        var p = _this7.prefix ? job.path.slice(_this7.prefix.length + 1) || './' : job.path;
        var base = p === './' ? '' : p.replace(/\/*$/, '/');

        _this7[ADDFSENTRY](base + entry);
      });
      var source = job.entry;
      var zip = this.zip;
      if (zip) source.on('data', function (chunk) {
        if (!zip.write(chunk)) source.pause();
      });else source.on('data', function (chunk) {
        if (!_get(_getPrototypeOf(Pack.prototype), "write", _this7).call(_this7, chunk)) source.pause();
      });
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this.zip) this.zip.pause();
      return _get(_getPrototypeOf(Pack.prototype), "pause", this).call(this);
    }
  }, {
    key: CURRENT,
    get: function get() {
      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
    }
  }]);

  return Pack;
}(MiniPass));

var PackSync =
/*#__PURE__*/
function (_Pack) {
  _inherits(PackSync, _Pack);

  function PackSync(opt) {
    var _this8;

    _classCallCheck(this, PackSync);

    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(PackSync).call(this, opt));
    _this8[WRITEENTRYCLASS] = WriteEntrySync;
    return _this8;
  } // pause/resume are no-ops in sync streams.


  _createClass(PackSync, [{
    key: "pause",
    value: function pause() {}
  }, {
    key: "resume",
    value: function resume() {}
  }, {
    key: STAT,
    value: function value(job) {
      var stat = this.follow ? 'statSync' : 'lstatSync';
      this[ONSTAT](job, fs[stat](job.absolute));
    }
  }, {
    key: READDIR,
    value: function value(job, stat) {
      this[ONREADDIR](job, fs.readdirSync(job.absolute));
    } // gotta get it all in this tick

  }, {
    key: PIPE,
    value: function value(job) {
      var _this9 = this;

      var source = job.entry;
      var zip = this.zip;
      if (job.readdir) job.readdir.forEach(function (entry) {
        var p = _this9.prefix ? job.path.slice(_this9.prefix.length + 1) || './' : job.path;
        var base = p === './' ? '' : p.replace(/\/*$/, '/');

        _this9[ADDFSENTRY](base + entry);
      });
      if (zip) source.on('data', function (chunk) {
        zip.write(chunk);
      });else source.on('data', function (chunk) {
        _get(_getPrototypeOf(PackSync.prototype), WRITE, _this9).call(_this9, chunk);
      });
    }
  }]);

  return PackSync;
}(Pack);

Pack.Sync = PackSync;
module.exports = Pack;