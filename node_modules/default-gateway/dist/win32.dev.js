"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var execa = require("execa");

var os = require("os");

var net = require("net");

var gwArgs = "path Win32_NetworkAdapterConfiguration where IPEnabled=true get DefaultIPGateway,GatewayCostMetric,IPConnectionMetric,Index /format:table".split(" ");

var ifArgs = function ifArgs(index) {
  return "path Win32_NetworkAdapter where Index=".concat(index, " get NetConnectionID,MACAddress /format:table").split(" ");
};

var spawnOpts = {
  windowsHide: true
}; // Parsing tables like this. The final metric is GatewayCostMetric + IPConnectionMetric
//
// DefaultIPGateway             GatewayCostMetric  Index  IPConnectionMetric
// {"1.2.3.4", "2001:db8::1"}   {0, 256}           12     25
// {"2.3.4.5"}                  {25}               12     55

function parseGwTable(gwTable, family) {
  var bestGw = null,
      bestMetric = null,
      bestId = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (gwTable || "").trim().split(/\r?\n/).splice(1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;
      line = line.trim();

      var _ref = /({.+?}) +?({.+?}) +?([0-9]+) +?([0-9]+)/g.exec(line) || [],
          _ref2 = _slicedToArray(_ref, 5),
          _ = _ref2[0],
          gwArr = _ref2[1],
          gwCostsArr = _ref2[2],
          id = _ref2[3],
          ipMetric = _ref2[4];

      if (!gwArr) continue;
      var gateways = (gwArr.match(/"(.+?)"/g) || []).map(function (match) {
        return match.substring(1, match.length - 1);
      });
      var gatewayCosts = gwCostsArr.match(/[0-9]+/g) || [];

      for (var _i2 = 0, _Object$entries = Object.entries(gateways); _i2 < _Object$entries.length; _i2++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
            index = _Object$entries$_i[0],
            gateway = _Object$entries$_i[1];

        if (!gateway || "v".concat(net.isIP(gateway)) !== family) continue;
        var metric = parseInt(gatewayCosts[index]) + parseInt(ipMetric);

        if (!bestGw || metric < bestMetric) {
          bestGw = gateway;
          bestMetric = metric;
          bestId = id;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (bestGw) return [bestGw, bestId];
}

function parseIfTable(ifTable) {
  var line = (ifTable || "").trim().split("\n")[1];

  var _line$trim$split = line.trim().split(/\s+/),
      _line$trim$split2 = _slicedToArray(_line$trim$split, 2),
      mac = _line$trim$split2[0],
      name = _line$trim$split2[1];

  mac = mac.toLowerCase(); // try to get the interface name by matching the mac to os.networkInterfaces to avoid wmic's encoding issues
  // https://github.com/silverwind/default-gateway/issues/14

  for (var _i3 = 0, _Object$entries2 = Object.entries(os.networkInterfaces()); _i3 < _Object$entries2.length; _i3++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),
        osname = _Object$entries2$_i[0],
        addrs = _Object$entries2$_i[1];

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = addrs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var addr = _step2.value;

        if (addr && addr.mac && addr.mac.toLowerCase() === mac) {
          return osname;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  return name;
}

var promise = function promise(family) {
  var _ref3, stdout, _ref4, _ref5, gateway, id, name, _ref6, _stdout;

  return regeneratorRuntime.async(function promise$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(execa("wmic", gwArgs, spawnOpts));

        case 2:
          _ref3 = _context.sent;
          stdout = _ref3.stdout;
          _ref4 = parseGwTable(stdout, family) || [], _ref5 = _slicedToArray(_ref4, 2), gateway = _ref5[0], id = _ref5[1];

          if (gateway) {
            _context.next = 7;
            break;
          }

          throw new Error("Unable to determine default gateway");

        case 7:
          if (!id) {
            _context.next = 13;
            break;
          }

          _context.next = 10;
          return regeneratorRuntime.awrap(execa("wmic", ifArgs(id), spawnOpts));

        case 10:
          _ref6 = _context.sent;
          _stdout = _ref6.stdout;
          name = parseIfTable(_stdout);

        case 13:
          return _context.abrupt("return", {
            gateway: gateway,
            "interface": name ? name : null
          });

        case 14:
        case "end":
          return _context.stop();
      }
    }
  });
};

var sync = function sync(family) {
  var _execa$sync = execa.sync("wmic", gwArgs, spawnOpts),
      stdout = _execa$sync.stdout;

  var _ref7 = parseGwTable(stdout, family) || [],
      _ref8 = _slicedToArray(_ref7, 2),
      gateway = _ref8[0],
      id = _ref8[1];

  if (!gateway) {
    throw new Error("Unable to determine default gateway");
  }

  var name;

  if (id) {
    var _execa$sync2 = execa.sync("wmic", ifArgs(id), spawnOpts),
        _stdout2 = _execa$sync2.stdout;

    name = parseIfTable(_stdout2);
  }

  return {
    gateway: gateway,
    "interface": name ? name : null
  };
};

module.exports.v4 = function () {
  return promise("v4");
};

module.exports.v6 = function () {
  return promise("v6");
};

module.exports.v4.sync = function () {
  return sync("v4");
};

module.exports.v6.sync = function () {
  return sync("v6");
};