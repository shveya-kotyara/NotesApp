'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var os = require('os');

var onExit = require('signal-exit');

var pFinally = require('p-finally');

var DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5; // Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior

var spawnedKill = function spawnedKill(kill) {
  var signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'SIGTERM';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var killResult = kill(signal);
  setKillTimeout(kill, signal, options, killResult);
  return killResult;
};

var setKillTimeout = function setKillTimeout(kill, signal, options, killResult) {
  if (!shouldForceKill(signal, options, killResult)) {
    return;
  }

  var timeout = getForceKillAfterTimeout(options);
  setTimeout(function () {
    kill('SIGKILL');
  }, timeout).unref();
};

var shouldForceKill = function shouldForceKill(signal, _ref, killResult) {
  var forceKillAfterTimeout = _ref.forceKillAfterTimeout;
  return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
};

var isSigterm = function isSigterm(signal) {
  return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';
};

var getForceKillAfterTimeout = function getForceKillAfterTimeout(_ref2) {
  var _ref2$forceKillAfterT = _ref2.forceKillAfterTimeout,
      forceKillAfterTimeout = _ref2$forceKillAfterT === void 0 ? true : _ref2$forceKillAfterT;

  if (forceKillAfterTimeout === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }

  if (!Number.isInteger(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
    throw new TypeError("Expected the `forceKillAfterTimeout` option to be a non-negative integer, got `".concat(forceKillAfterTimeout, "` (").concat(_typeof(forceKillAfterTimeout), ")"));
  }

  return forceKillAfterTimeout;
}; // `childProcess.cancel()`


var spawnedCancel = function spawnedCancel(spawned, context) {
  var killResult = spawned.kill();

  if (killResult) {
    context.isCanceled = true;
  }
};

var timeoutKill = function timeoutKill(spawned, signal, reject) {
  spawned.kill(signal);
  reject(Object.assign(new Error('Timed out'), {
    timedOut: true,
    signal: signal
  }));
}; // `timeout` option handling


var setupTimeout = function setupTimeout(spawned, _ref3, spawnedPromise) {
  var timeout = _ref3.timeout,
      _ref3$killSignal = _ref3.killSignal,
      killSignal = _ref3$killSignal === void 0 ? 'SIGTERM' : _ref3$killSignal;

  if (timeout === 0 || timeout === undefined) {
    return spawnedPromise;
  }

  if (!Number.isInteger(timeout) || timeout < 0) {
    throw new TypeError("Expected the `timeout` option to be a non-negative integer, got `".concat(timeout, "` (").concat(_typeof(timeout), ")"));
  }

  var timeoutId;
  var timeoutPromise = new Promise(function (resolve, reject) {
    timeoutId = setTimeout(function () {
      timeoutKill(spawned, killSignal, reject);
    }, timeout);
  });
  var safeSpawnedPromise = pFinally(spawnedPromise, function () {
    clearTimeout(timeoutId);
  });
  return Promise.race([timeoutPromise, safeSpawnedPromise]);
}; // `cleanup` option handling


var setExitHandler = function setExitHandler(spawned, _ref4, timedPromise) {
  var cleanup = _ref4.cleanup,
      detached = _ref4.detached;

  if (!cleanup || detached) {
    return timedPromise;
  }

  var removeExitHandler = onExit(function () {
    spawned.kill();
  }); // TODO: Use native "finally" syntax when targeting Node.js 10

  return pFinally(timedPromise, removeExitHandler);
};

module.exports = {
  spawnedKill: spawnedKill,
  spawnedCancel: spawnedCancel,
  setupTimeout: setupTimeout,
  setExitHandler: setExitHandler
};