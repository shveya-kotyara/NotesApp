'use strict';

var mergePromiseProperty = function mergePromiseProperty(spawned, promise, property) {
  // Starting the main `promise` is deferred to avoid consuming streams
  var value = typeof promise === 'function' ? function () {
    var _promise;

    return (_promise = promise())[property].apply(_promise, arguments);
  } : promise[property].bind(promise);
  Object.defineProperty(spawned, property, {
    value: value,
    writable: true,
    enumerable: false,
    configurable: true
  });
}; // The return value is a mixin of `childProcess` and `Promise`


var mergePromise = function mergePromise(spawned, promise) {
  mergePromiseProperty(spawned, promise, 'then');
  mergePromiseProperty(spawned, promise, 'catch'); // TODO: Remove the `if`-guard when targeting Node.js 10

  if (Promise.prototype["finally"]) {
    mergePromiseProperty(spawned, promise, 'finally');
  }

  return spawned;
}; // Use promises instead of `child_process` events


var getSpawnedPromise = function getSpawnedPromise(spawned) {
  return new Promise(function (resolve, reject) {
    spawned.on('exit', function (exitCode, signal) {
      resolve({
        exitCode: exitCode,
        signal: signal
      });
    });
    spawned.on('error', function (error) {
      reject(error);
    });

    if (spawned.stdin) {
      spawned.stdin.on('error', function (error) {
        reject(error);
      });
    }
  });
};

module.exports = {
  mergePromise: mergePromise,
  getSpawnedPromise: getSpawnedPromise
};