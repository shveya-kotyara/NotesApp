'use strict';

var isStream = require('is-stream');

var getStream = require('get-stream');

var mergeStream = require('merge-stream'); // `input` option


var handleInput = function handleInput(spawned, input) {
  // Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852
  // TODO: Remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0
  if (input === undefined || spawned.stdin === undefined) {
    return;
  }

  if (isStream(input)) {
    input.pipe(spawned.stdin);
  } else {
    spawned.stdin.end(input);
  }
}; // `all` interleaves `stdout` and `stderr`


var makeAllStream = function makeAllStream(spawned, _ref) {
  var all = _ref.all;

  if (!all || !spawned.stdout && !spawned.stderr) {
    return;
  }

  var mixed = mergeStream();

  if (spawned.stdout) {
    mixed.add(spawned.stdout);
  }

  if (spawned.stderr) {
    mixed.add(spawned.stderr);
  }

  return mixed;
}; // On failure, `result.stdout|stderr|all` should contain the currently buffered stream


var getBufferedData = function getBufferedData(stream, streamPromise) {
  return regeneratorRuntime.async(function getBufferedData$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (stream) {
            _context.next = 2;
            break;
          }

          return _context.abrupt("return");

        case 2:
          stream.destroy();
          _context.prev = 3;
          _context.next = 6;
          return regeneratorRuntime.awrap(streamPromise);

        case 6:
          return _context.abrupt("return", _context.sent);

        case 9:
          _context.prev = 9;
          _context.t0 = _context["catch"](3);
          return _context.abrupt("return", _context.t0.bufferedData);

        case 12:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[3, 9]]);
};

var getStreamPromise = function getStreamPromise(stream, _ref2) {
  var encoding = _ref2.encoding,
      buffer = _ref2.buffer,
      maxBuffer = _ref2.maxBuffer;

  if (!stream || !buffer) {
    return;
  }

  if (encoding) {
    return getStream(stream, {
      encoding: encoding,
      maxBuffer: maxBuffer
    });
  }

  return getStream.buffer(stream, {
    maxBuffer: maxBuffer
  });
}; // Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)


var getSpawnedResult = function getSpawnedResult(_ref3, _ref4, processDone) {
  var stdout, stderr, all, encoding, buffer, maxBuffer, stdoutPromise, stderrPromise, allPromise;
  return regeneratorRuntime.async(function getSpawnedResult$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          stdout = _ref3.stdout, stderr = _ref3.stderr, all = _ref3.all;
          encoding = _ref4.encoding, buffer = _ref4.buffer, maxBuffer = _ref4.maxBuffer;
          stdoutPromise = getStreamPromise(stdout, {
            encoding: encoding,
            buffer: buffer,
            maxBuffer: maxBuffer
          });
          stderrPromise = getStreamPromise(stderr, {
            encoding: encoding,
            buffer: buffer,
            maxBuffer: maxBuffer
          });
          allPromise = getStreamPromise(all, {
            encoding: encoding,
            buffer: buffer,
            maxBuffer: maxBuffer * 2
          });
          _context2.prev = 5;
          _context2.next = 8;
          return regeneratorRuntime.awrap(Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]));

        case 8:
          return _context2.abrupt("return", _context2.sent);

        case 11:
          _context2.prev = 11;
          _context2.t0 = _context2["catch"](5);
          return _context2.abrupt("return", Promise.all([{
            error: _context2.t0,
            signal: _context2.t0.signal,
            timedOut: _context2.t0.timedOut
          }, getBufferedData(stdout, stdoutPromise), getBufferedData(stderr, stderrPromise), getBufferedData(all, allPromise)]));

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[5, 11]]);
};

var validateInputSync = function validateInputSync(_ref5) {
  var input = _ref5.input;

  if (isStream(input)) {
    throw new TypeError('The `input` option cannot be a stream in sync mode');
  }
};

module.exports = {
  handleInput: handleInput,
  makeAllStream: makeAllStream,
  getSpawnedResult: getSpawnedResult,
  validateInputSync: validateInputSync
};