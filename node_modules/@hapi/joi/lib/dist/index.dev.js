'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var Hoek = require('@hapi/hoek');

var Any = require('./types/any');

var Cast = require('./cast');

var Errors = require('./errors');

var Lazy = require('./types/lazy');

var Ref = require('./ref');

var internals = {
  alternatives: require('./types/alternatives'),
  array: require('./types/array'),
  "boolean": require('./types/boolean'),
  binary: require('./types/binary'),
  date: require('./types/date'),
  func: require('./types/func'),
  number: require('./types/number'),
  object: require('./types/object'),
  string: require('./types/string'),
  symbol: require('./types/symbol')
};

internals.callWithDefaults = function (schema, args) {
  var _schema;

  Hoek.assert(this, 'Must be invoked on a Joi instance.');

  if (this._defaults) {
    schema = this._defaults(schema);
  }

  schema._currentJoi = this;
  return (_schema = schema)._init.apply(_schema, _toConsumableArray(args));
};

internals.root = function () {
  var any = new Any();
  var root = any.clone();
  Any.prototype._currentJoi = root;
  root._currentJoi = root;
  root._binds = new Set(['any', 'alternatives', 'alt', 'array', 'bool', 'boolean', 'binary', 'date', 'func', 'number', 'object', 'string', 'symbol', 'validate', 'describe', 'compile', 'assert', 'attempt', 'lazy', 'defaults', 'extend', 'allow', 'valid', 'only', 'equal', 'invalid', 'disallow', 'not', 'required', 'exist', 'optional', 'forbidden', 'strip', 'when', 'empty', 'default']);

  root.any = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');
    return internals.callWithDefaults.call(this, any, args);
  };

  root.alternatives = root.alt = function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return internals.callWithDefaults.call(this, internals.alternatives, args);
  };

  root.array = function () {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');
    return internals.callWithDefaults.call(this, internals.array, args);
  };

  root["boolean"] = root.bool = function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');
    return internals.callWithDefaults.call(this, internals["boolean"], args);
  };

  root.binary = function () {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');
    return internals.callWithDefaults.call(this, internals.binary, args);
  };

  root.date = function () {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');
    return internals.callWithDefaults.call(this, internals.date, args);
  };

  root.func = function () {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');
    return internals.callWithDefaults.call(this, internals.func, args);
  };

  root.number = function () {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');
    return internals.callWithDefaults.call(this, internals.number, args);
  };

  root.object = function () {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    return internals.callWithDefaults.call(this, internals.object, args);
  };

  root.string = function () {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }

    Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');
    return internals.callWithDefaults.call(this, internals.string, args);
  };

  root.symbol = function () {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }

    Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');
    return internals.callWithDefaults.call(this, internals.symbol, args);
  };

  root.ref = function () {
    return Ref.create.apply(Ref, arguments);
  };

  root.isRef = function (ref) {
    return Ref.isRef(ref);
  };

  root.validate = function (value)
  /*, [schema], [options], callback */
  {
    var _ref;

    var last = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);
    var callback = typeof last === 'function' ? last : null;
    var count = (arguments.length <= 1 ? 0 : arguments.length - 1) - (callback ? 1 : 0);

    if (count === 0) {
      return any.validate(value, callback);
    }

    var options = count === 2 ? arguments.length <= 2 ? undefined : arguments[2] : undefined;
    var schema = this.compile(arguments.length <= 1 ? undefined : arguments[1]);
    return schema._validateWithOptions(value, options, callback);
  };

  root.describe = function () {
    var schema = arguments.length ? this.compile(arguments.length <= 0 ? undefined : arguments[0]) : any;
    return schema.describe();
  };

  root.compile = function (schema) {
    try {
      return Cast.schema(this, schema);
    } catch (err) {
      if (err.hasOwnProperty('path')) {
        err.message = err.message + '(' + err.path + ')';
      }

      throw err;
    }
  };

  root.assert = function (value, schema, message) {
    this.attempt(value, schema, message);
  };

  root.attempt = function (value, schema, message) {
    var result = this.validate(value, schema);
    var error = result.error;

    if (error) {
      if (!message) {
        if (typeof error.annotate === 'function') {
          error.message = error.annotate();
        }

        throw error;
      }

      if (!(message instanceof Error)) {
        if (typeof error.annotate === 'function') {
          error.message = "".concat(message, " ").concat(error.annotate());
        }

        throw error;
      }

      throw message;
    }

    return result.value;
  };

  root.reach = function (schema, path) {
    Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');
    Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');

    var reach = function reach(sourceSchema, schemaPath) {
      if (!schemaPath.length) {
        return sourceSchema;
      }

      var children = sourceSchema._inner.children;

      if (!children) {
        return;
      }

      var key = schemaPath.shift();

      for (var i = 0; i < children.length; ++i) {
        var child = children[i];

        if (child.key === key) {
          return reach(child.schema, schemaPath);
        }
      }
    };

    var schemaPath = typeof path === 'string' ? path ? path.split('.') : [] : path.slice();
    return reach(schema, schemaPath);
  };

  root.lazy = function () {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }

    return internals.callWithDefaults.call(this, Lazy, args);
  };

  root.defaults = function (fn) {
    var _this = this;

    Hoek.assert(typeof fn === 'function', 'Defaults must be a function');
    var joi = Object.create(this.any());
    joi = fn(joi);
    Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');
    Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults

    joi._defaults = function (schema) {
      if (_this._defaults) {
        schema = _this._defaults(schema);
        Hoek.assert(schema instanceof _this.constructor, 'defaults() must return a schema');
      }

      schema = fn(schema);
      Hoek.assert(schema instanceof _this.constructor, 'defaults() must return a schema');
      return schema;
    };

    return joi;
  };

  root.bind = function () {
    var joi = Object.create(this);

    joi._binds.forEach(function (bind) {
      joi[bind] = joi[bind].bind(joi);
    });

    return joi;
  };

  root.extend = function () {
    var _this2 = this;

    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      args[_key13] = arguments[_key13];
    }

    var extensions = Hoek.flatten(args);
    Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');
    this.assert(extensions, root.extensionsSchema);
    var joi = Object.create(this.any());
    Object.assign(joi, this);
    joi._currentJoi = joi;
    joi._binds = new Set(joi._binds);

    var _loop = function _loop(i) {
      var extension = extensions[i];

      if (typeof extension === 'function') {
        extension = extension(joi);
      }

      _this2.assert(extension, root.extensionSchema);

      var base = (extension.base || _this2.any()).clone(); // Cloning because we're going to override language afterwards


      var ctor = base.constructor;

      var type =
      /*#__PURE__*/
      function (_ctor) {
        _inherits(type, _ctor);

        // eslint-disable-line no-loop-func
        function type() {
          var _this3;

          _classCallCheck(this, type);

          _this3 = _possibleConstructorReturn(this, _getPrototypeOf(type).call(this));

          if (extension.base) {
            Object.assign(_assertThisInitialized(_this3), base);
          }

          _this3._type = extension.name;
          return _this3;
        }

        return type;
      }(ctor);

      if (extension.language) {
        var lang = _defineProperty({}, extension.name, extension.language);

        type.prototype._language = Hoek.applyToDefaults(type.prototype._language || base._settings && base._settings.language || {}, lang);
      }

      if (extension.coerce) {
        type.prototype._coerce = function (value, state, options) {
          if (ctor.prototype._coerce) {
            var baseRet = ctor.prototype._coerce.call(this, value, state, options);

            if (baseRet.errors) {
              return baseRet;
            }

            value = baseRet.value;
          }

          var ret = extension.coerce.call(this, value, state, options);

          if (ret instanceof Errors.Err) {
            return {
              value: value,
              errors: ret
            };
          }

          return {
            value: ret
          };
        };
      }

      if (extension.pre) {
        type.prototype._base = function (value, state, options) {
          if (ctor.prototype._base) {
            var baseRet = ctor.prototype._base.call(this, value, state, options);

            if (baseRet.errors) {
              return baseRet;
            }

            value = baseRet.value;
          }

          var ret = extension.pre.call(this, value, state, options);

          if (ret instanceof Errors.Err) {
            return {
              value: value,
              errors: ret
            };
          }

          return {
            value: ret
          };
        };
      }

      if (extension.rules) {
        var _loop2 = function _loop2(j) {
          var rule = extension.rules[j];
          var ruleArgs = rule.params ? rule.params instanceof Any ? rule.params._inner.children.map(function (k) {
            return k.key;
          }) : Object.keys(rule.params) : [];
          var validateArgs = rule.params ? Cast.schema(_this2, rule.params) : null;

          type.prototype[rule.name] = function () {
            for (var _len14 = arguments.length, rArgs = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
              rArgs[_key14] = arguments[_key14];
            }

            // eslint-disable-line no-loop-func
            if (rArgs.length > ruleArgs.length) {
              throw new Error('Unexpected number of arguments');
            }

            var hasRef = false;
            var arg = {};

            for (var k = 0; k < ruleArgs.length; ++k) {
              arg[ruleArgs[k]] = rArgs[k];

              if (!hasRef && Ref.isRef(rArgs[k])) {
                hasRef = true;
              }
            }

            if (validateArgs) {
              arg = joi.attempt(arg, validateArgs);
            }

            var schema;

            if (rule.validate && !rule.setup) {
              var validate = function validate(value, state, options) {
                return rule.validate.call(this, arg, value, state, options);
              };

              schema = this._test(rule.name, arg, validate, {
                description: rule.description,
                hasRef: hasRef
              });
            } else {
              schema = this.clone();
            }

            if (rule.setup) {
              var newSchema = rule.setup.call(schema, arg);

              if (newSchema !== undefined) {
                Hoek.assert(newSchema instanceof Any, "Setup of extension Joi.".concat(this._type, "().").concat(rule.name, "() must return undefined or a Joi object"));
                schema = newSchema;
              }

              if (rule.validate) {
                var _validate = function _validate(value, state, options) {
                  return rule.validate.call(this, arg, value, state, options);
                };

                schema = schema._test(rule.name, arg, _validate, {
                  description: rule.description,
                  hasRef: hasRef
                });
              }
            }

            return schema;
          };
        };

        for (var j = 0; j < extension.rules.length; ++j) {
          _loop2(j);
        }
      }

      if (extension.describe) {
        type.prototype.describe = function () {
          var description = ctor.prototype.describe.call(this);
          return extension.describe.call(this, description);
        };
      }

      var instance = new type();

      joi[extension.name] = function () {
        for (var _len15 = arguments.length, extArgs = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
          extArgs[_key15] = arguments[_key15];
        }

        return internals.callWithDefaults.call(this, instance, extArgs);
      };

      joi._binds.add(extension.name);
    };

    for (var i = 0; i < extensions.length; ++i) {
      _loop(i);
    }

    return joi;
  };

  root.extensionSchema = internals.object.keys({
    base: internals.object.type(Any, 'Joi object'),
    name: internals.string.required(),
    coerce: internals.func.arity(3),
    pre: internals.func.arity(3),
    language: internals.object,
    describe: internals.func.arity(1),
    rules: internals.array.items(internals.object.keys({
      name: internals.string.required(),
      setup: internals.func.arity(1),
      validate: internals.func.arity(4),
      params: [internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')), internals.object.type(internals.object.constructor, 'Joi object')],
      description: [internals.string, internals.func.arity(1)]
    }).or('setup', 'validate'))
  }).strict();
  root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();
  root.version = require('../package.json').version;
  return root;
};

module.exports = internals.root();