'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Hoek = require('@hapi/hoek');

var Any = require('../any');

var Cast = require('../../cast');

var Ref = require('../../ref');

var internals = {};

internals.Alternatives =
/*#__PURE__*/
function (_Any) {
  _inherits(_class, _Any);

  function _class() {
    var _this;

    _classCallCheck(this, _class);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));
    _this._type = 'alternatives';

    _this._invalids.remove(null);

    _this._inner.matches = [];
    return _this;
  }

  _createClass(_class, [{
    key: "_init",
    value: function _init() {
      return arguments.length ? this["try"].apply(this, arguments) : this;
    }
  }, {
    key: "_base",
    value: function _base(value, state, options) {
      var errors = [];
      var il = this._inner.matches.length;
      var baseType = this._baseType;

      for (var i = 0; i < il; ++i) {
        var item = this._inner.matches[i];

        if (!item.schema) {
          var schema = item.peek || item.is;
          var input = item.is ? item.ref(state.reference || state.parent, options) : value;

          var failed = schema._validate(input, null, options, state.parent).errors;

          if (failed) {
            if (item.otherwise) {
              return item.otherwise._validate(value, state, options);
            }
          } else if (item.then) {
            return item.then._validate(value, state, options);
          }

          if (i === il - 1 && baseType) {
            return baseType._validate(value, state, options);
          }

          continue;
        }

        var result = item.schema._validate(value, state, options);

        if (!result.errors) {
          // Found a valid match
          return result;
        }

        errors.push.apply(errors, _toConsumableArray(result.errors));
      }

      if (errors.length) {
        return {
          errors: this.createError('alternatives.child', {
            reason: errors
          }, state, options)
        };
      }

      return {
        errors: this.createError('alternatives.base', null, state, options)
      };
    }
  }, {
    key: "try",
    value: function _try() {
      for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {
        schemas[_key] = arguments[_key];
      }

      schemas = Hoek.flatten(schemas);
      Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');
      var obj = this.clone();

      for (var i = 0; i < schemas.length; ++i) {
        var cast = Cast.schema(this._currentJoi, schemas[i]);

        if (cast._refs.length) {
          var _obj$_refs;

          (_obj$_refs = obj._refs).push.apply(_obj$_refs, _toConsumableArray(cast._refs));
        }

        obj._inner.matches.push({
          schema: cast
        });
      }

      return obj;
    }
  }, {
    key: "when",
    value: function when(condition, options) {
      var schemaCondition = false;
      Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);
      Hoek.assert(options, 'Missing options');
      Hoek.assert(_typeof(options) === 'object', 'Invalid options');

      if (schemaCondition) {
        Hoek.assert(!options.hasOwnProperty('is'), '"is" can not be used with a schema condition');
      } else {
        Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
      }

      Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');
      var obj = this.clone();
      var is;

      if (!schemaCondition) {
        is = Cast.schema(this._currentJoi, options.is);

        if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {
          // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing
          is = is.required();
        }
      }

      var item = {
        ref: schemaCondition ? null : Cast.ref(condition),
        peek: schemaCondition ? condition : null,
        is: is,
        then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,
        otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined
      };

      if (obj._baseType) {
        item.then = item.then && obj._baseType.concat(item.then);
        item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);
      }

      if (!schemaCondition) {
        var _obj$_refs2;

        Ref.push(obj._refs, item.ref);

        (_obj$_refs2 = obj._refs).push.apply(_obj$_refs2, _toConsumableArray(item.is._refs));
      }

      if (item.then && item.then._refs.length) {
        var _obj$_refs3;

        (_obj$_refs3 = obj._refs).push.apply(_obj$_refs3, _toConsumableArray(item.then._refs));
      }

      if (item.otherwise && item.otherwise._refs.length) {
        var _obj$_refs4;

        (_obj$_refs4 = obj._refs).push.apply(_obj$_refs4, _toConsumableArray(item.otherwise._refs));
      }

      obj._inner.matches.push(item);

      return obj;
    }
  }, {
    key: "label",
    value: function label(name) {
      var obj = _get(_getPrototypeOf(_class.prototype), "label", this).call(this, name);

      obj._inner.matches = obj._inner.matches.map(function (match) {
        if (match.schema) {
          return {
            schema: match.schema.label(name)
          };
        }

        match = Object.assign({}, match);

        if (match.then) {
          match.then = match.then.label(name);
        }

        if (match.otherwise) {
          match.otherwise = match.otherwise.label(name);
        }

        return match;
      });
      return obj;
    }
  }, {
    key: "describe",
    value: function describe() {
      var description = _get(_getPrototypeOf(_class.prototype), "describe", this).call(this);

      var alternatives = [];

      for (var i = 0; i < this._inner.matches.length; ++i) {
        var item = this._inner.matches[i];

        if (item.schema) {
          // try()
          alternatives.push(item.schema.describe());
        } else {
          // when()
          var when = item.is ? {
            ref: item.ref.toString(),
            is: item.is.describe()
          } : {
            peek: item.peek.describe()
          };

          if (item.then) {
            when.then = item.then.describe();
          }

          if (item.otherwise) {
            when.otherwise = item.otherwise.describe();
          }

          alternatives.push(when);
        }
      }

      description.alternatives = alternatives;
      return description;
    }
  }]);

  return _class;
}(Any);

module.exports = new internals.Alternatives();