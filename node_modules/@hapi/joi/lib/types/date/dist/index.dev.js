'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Hoek = require('@hapi/hoek');

var Any = require('../any');

var Ref = require('../../ref');

var internals = {};
internals.isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
internals.invalidDate = new Date('');

internals.isIsoDate = function () {
  var isoString = internals.isoDate.toString();
  return function (date) {
    return date && date.toString() === isoString;
  };
}();

internals.Date =
/*#__PURE__*/
function (_Any) {
  _inherits(_class, _Any);

  function _class() {
    var _this;

    _classCallCheck(this, _class);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));
    _this._type = 'date';
    return _this;
  }

  _createClass(_class, [{
    key: "_base",
    value: function _base(value, state, options) {
      var result = {
        value: options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier) || value
      };

      if (result.value instanceof Date && !isNaN(result.value.getTime())) {
        result.errors = null;
      } else if (!options.convert) {
        result.errors = this.createError('date.strict', {
          value: value
        }, state, options);
      } else {
        var type;

        if (internals.isIsoDate(this._flags.format)) {
          type = 'isoDate';
        } else if (this._flags.timestamp) {
          type = "timestamp.".concat(this._flags.timestamp);
        } else {
          type = 'base';
        }

        result.errors = this.createError("date.".concat(type), {
          value: value
        }, state, options);
      }

      return result;
    }
  }, {
    key: "iso",
    value: function iso() {
      if (this._flags.format === internals.isoDate) {
        return this;
      }

      var obj = this.clone();
      obj._flags.format = internals.isoDate;
      return obj;
    }
  }, {
    key: "timestamp",
    value: function timestamp() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'javascript';
      var allowed = ['javascript', 'unix'];
      Hoek.assert(allowed.includes(type), '"type" must be one of "' + allowed.join('", "') + '"');

      if (this._flags.timestamp === type) {
        return this;
      }

      var obj = this.clone();
      obj._flags.timestamp = type;
      obj._flags.multiplier = type === 'unix' ? 1000 : 1;
      return obj;
    }
  }, {
    key: "_isIsoDate",
    value: function _isIsoDate(value) {
      return internals.isoDate.test(value);
    }
  }], [{
    key: "toDate",
    value: function toDate(value, format, timestamp, multiplier) {
      if (value instanceof Date) {
        return value;
      }

      if (typeof value === 'string' || typeof value === 'number' && !isNaN(value) && isFinite(value)) {
        var isIsoDate = format && internals.isIsoDate(format);

        if (!isIsoDate && typeof value === 'string' && /^[+-]?\d+(\.\d+)?$/.test(value)) {
          value = parseFloat(value);
        }

        var date;

        if (isIsoDate) {
          date = format.test(value) ? new Date(value.toString()) : internals.invalidDate;
        } else if (timestamp) {
          date = /^\s*$/.test(value) ? internals.invalidDate : new Date(value * multiplier);
        } else {
          date = new Date(value);
        }

        if (!isNaN(date.getTime())) {
          return date;
        }
      }

      return null;
    }
  }]);

  return _class;
}(Any);

internals.compare = function (type, compare) {
  return function (date) {
    var isNow = date === 'now';
    var isRef = Ref.isRef(date);

    if (!isNow && !isRef) {
      date = internals.Date.toDate(date);
    }

    Hoek.assert(date, 'Invalid date format');
    return this._test(type, date, function (value, state, options) {
      var compareTo;

      if (isNow) {
        compareTo = Date.now();
      } else if (isRef) {
        var refValue = date(state.reference || state.parent, options);
        compareTo = internals.Date.toDate(refValue);

        if (!compareTo) {
          return this.createError('date.ref', {
            ref: date,
            value: refValue
          }, state, options);
        }

        compareTo = compareTo.getTime();
      } else {
        compareTo = date.getTime();
      }

      if (compare(value.getTime(), compareTo)) {
        return value;
      }

      return this.createError('date.' + type, {
        limit: new Date(compareTo),
        value: value
      }, state, options);
    });
  };
};

internals.Date.prototype.min = internals.compare('min', function (value, date) {
  return value >= date;
});
internals.Date.prototype.max = internals.compare('max', function (value, date) {
  return value <= date;
});
internals.Date.prototype.greater = internals.compare('greater', function (value, date) {
  return value > date;
});
internals.Date.prototype.less = internals.compare('less', function (value, date) {
  return value < date;
});
module.exports = new internals.Date();