'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Net = require('net');

var Address = require('@hapi/address');

var Hoek = require('@hapi/hoek');

var Any = require('../any');

var Ref = require('../../ref');

var JoiDate = require('../date');

var Uri = require('./uri');

var Ip = require('./ip');

var internals = {
  uriRegex: Uri.createUriRegex(),
  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),
  guidBrackets: {
    '{': '}',
    '[': ']',
    '(': ')',
    '': ''
  },
  guidVersions: {
    uuidv1: '1',
    uuidv2: '2',
    uuidv3: '3',
    uuidv4: '4',
    uuidv5: '5'
  },
  cidrPresences: ['required', 'optional', 'forbidden'],
  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};

internals.String =
/*#__PURE__*/
function (_Any) {
  _inherits(_class, _Any);

  function _class() {
    var _this;

    _classCallCheck(this, _class);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));
    _this._type = 'string';

    _this._invalids.add('');

    return _this;
  }

  _createClass(_class, [{
    key: "_base",
    value: function _base(value, state, options) {
      if (typeof value === 'string' && options.convert) {
        if (this._flags.normalize) {
          value = value.normalize(this._flags.normalize);
        }

        if (this._flags["case"]) {
          value = this._flags["case"] === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
        }

        if (this._flags.trim) {
          value = value.trim();
        }

        if (this._inner.replacements) {
          for (var i = 0; i < this._inner.replacements.length; ++i) {
            var replacement = this._inner.replacements[i];
            value = value.replace(replacement.pattern, replacement.replacement);
          }
        }

        if (this._flags.truncate) {
          for (var _i = 0; _i < this._tests.length; ++_i) {
            var test = this._tests[_i];

            if (test.name === 'max') {
              value = value.slice(0, test.arg);
              break;
            }
          }
        }

        if (this._flags.byteAligned && value.length % 2 !== 0) {
          value = "0".concat(value);
        }
      }

      return {
        value: value,
        errors: typeof value === 'string' ? null : this.createError('string.base', {
          value: value
        }, state, options)
      };
    }
  }, {
    key: "insensitive",
    value: function insensitive() {
      if (this._flags.insensitive) {
        return this;
      }

      var obj = this.clone();
      obj._flags.insensitive = true;
      return obj;
    }
  }, {
    key: "creditCard",
    value: function creditCard() {
      return this._test('creditCard', undefined, function (value, state, options) {
        var i = value.length;
        var sum = 0;
        var mul = 1;

        while (i--) {
          var _char = value.charAt(i) * mul;

          sum = sum + (_char - (_char > 9) * 9);
          mul = mul ^ 3;
        }

        var check = sum % 10 === 0 && sum > 0;
        return check ? value : this.createError('string.creditCard', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "regex",
    value: function regex(pattern, patternOptions) {
      Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
      Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
      var patternObject = {
        pattern: pattern
      };

      if (typeof patternOptions === 'string') {
        patternObject.name = patternOptions;
      } else if (_typeof(patternOptions) === 'object') {
        patternObject.invert = !!patternOptions.invert;

        if (patternOptions.name) {
          patternObject.name = patternOptions.name;
        }
      }

      var errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');
      return this._test('regex', patternObject, function (value, state, options) {
        var patternMatch = patternObject.pattern.test(value);

        if (patternMatch ^ patternObject.invert) {
          return value;
        }

        return this.createError(errorCode, {
          name: patternObject.name,
          pattern: patternObject.pattern,
          value: value
        }, state, options);
      });
    }
  }, {
    key: "alphanum",
    value: function alphanum() {
      return this._test('alphanum', undefined, function (value, state, options) {
        if (/^[a-zA-Z0-9]+$/.test(value)) {
          return value;
        }

        return this.createError('string.alphanum', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "token",
    value: function token() {
      return this._test('token', undefined, function (value, state, options) {
        if (/^\w+$/.test(value)) {
          return value;
        }

        return this.createError('string.token', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "email",
    value: function email(validationOptions) {
      if (validationOptions) {
        Hoek.assert(_typeof(validationOptions) === 'object', 'email options must be an object'); // Migration validation for unsupported options

        Hoek.assert(validationOptions.checkDNS === undefined, 'checkDNS option is not supported');
        Hoek.assert(validationOptions.errorLevel === undefined, 'errorLevel option is not supported');
        Hoek.assert(validationOptions.minDomainAtoms === undefined, 'minDomainAtoms option is not supported, use minDomainSegments instead');
        Hoek.assert(validationOptions.tldBlacklist === undefined, 'tldBlacklist option is not supported, use tlds.deny instead');
        Hoek.assert(validationOptions.tldWhitelist === undefined, 'tldWhitelist option is not supported, use tlds.allow instead'); // Validate options

        if (validationOptions.tlds && _typeof(validationOptions.tlds) === 'object') {
          Hoek.assert(validationOptions.tlds.allow === undefined || validationOptions.tlds.allow === false || validationOptions.tlds.allow === true || Array.isArray(validationOptions.tlds.allow) || validationOptions.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');
          Hoek.assert(validationOptions.tlds.deny === undefined || Array.isArray(validationOptions.tlds.deny) || validationOptions.tlds.deny instanceof Set, 'tlds.deny must be an array or Set');

          var normalizeTable = function normalizeTable(table) {
            if (table === undefined || typeof table === 'boolean' || table instanceof Set) {
              return table;
            }

            return new Set(table);
          };

          validationOptions = Object.assign({}, validationOptions); // Shallow cloned

          validationOptions.tlds = {
            allow: normalizeTable(validationOptions.tlds.allow),
            deny: normalizeTable(validationOptions.tlds.deny)
          };
        }

        Hoek.assert(validationOptions.minDomainSegments === undefined || Number.isSafeInteger(validationOptions.minDomainSegments) && validationOptions.minDomainSegments > 0, 'minDomainSegments must be a positive integer');
      }

      return this._test('email', validationOptions, function (value, state, options) {
        if (Address.email.isValid(value, validationOptions)) {
          return value;
        }

        return this.createError('string.email', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "ip",
    value: function ip() {
      var ipOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var regex = internals.ipRegex;
      Hoek.assert(_typeof(ipOptions) === 'object', 'options must be an object');

      if (ipOptions.cidr) {
        Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');
        ipOptions.cidr = ipOptions.cidr.toLowerCase();
        Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', ')); // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is "optional" since that is the default

        if (!ipOptions.version && ipOptions.cidr !== 'optional') {
          regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);
        }
      } else {
        // Set our default cidr strategy
        ipOptions.cidr = 'optional';
      }

      var versions;

      if (ipOptions.version) {
        if (!Array.isArray(ipOptions.version)) {
          ipOptions.version = [ipOptions.version];
        }

        Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');
        versions = [];

        for (var i = 0; i < ipOptions.version.length; ++i) {
          var version = ipOptions.version[i];
          Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
          version = version.toLowerCase();
          Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
          versions.push(version);
        } // Make sure we have a set of versions


        versions = Array.from(new Set(versions));
        regex = Ip.createIpRegex(versions, ipOptions.cidr);
      }

      return this._test('ip', ipOptions, function (value, state, options) {
        if (regex.test(value)) {
          return value;
        }

        if (versions) {
          return this.createError('string.ipVersion', {
            value: value,
            cidr: ipOptions.cidr,
            version: versions
          }, state, options);
        }

        return this.createError('string.ip', {
          value: value,
          cidr: ipOptions.cidr
        }, state, options);
      });
    }
  }, {
    key: "uri",
    value: function uri(uriOptions) {
      var customScheme = '';
      var allowRelative = false;
      var relativeOnly = false;
      var allowQuerySquareBrackets = false;
      var regex = internals.uriRegex;

      if (uriOptions) {
        Hoek.assert(_typeof(uriOptions) === 'object', 'options must be an object');
        var unknownOptions = Object.keys(uriOptions).filter(function (key) {
          return !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key);
        });
        Hoek.assert(unknownOptions.length === 0, "options contain unknown keys: ".concat(unknownOptions));

        if (uriOptions.scheme) {
          Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');

          if (!Array.isArray(uriOptions.scheme)) {
            uriOptions.scheme = [uriOptions.scheme];
          }

          Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified'); // Flatten the array into a string to be used to match the schemes.

          for (var i = 0; i < uriOptions.scheme.length; ++i) {
            var scheme = uriOptions.scheme[i];
            Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String'); // Add OR separators if a value already exists

            customScheme = customScheme + (customScheme ? '|' : ''); // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.

            if (scheme instanceof RegExp) {
              customScheme = customScheme + scheme.source;
            } else {
              Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
              customScheme = customScheme + Hoek.escapeRegex(scheme);
            }
          }
        }

        if (uriOptions.allowRelative) {
          allowRelative = true;
        }

        if (uriOptions.relativeOnly) {
          relativeOnly = true;
        }

        if (uriOptions.allowQuerySquareBrackets) {
          allowQuerySquareBrackets = true;
        }
      }

      if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {
        regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);
      }

      return this._test('uri', uriOptions, function (value, state, options) {
        if (regex.test(value)) {
          return value;
        }

        if (relativeOnly) {
          return this.createError('string.uriRelativeOnly', {
            value: value
          }, state, options);
        }

        if (customScheme) {
          return this.createError('string.uriCustomScheme', {
            scheme: customScheme,
            value: value
          }, state, options);
        }

        return this.createError('string.uri', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "isoDate",
    value: function isoDate() {
      return this._test('isoDate', undefined, function (value, state, options) {
        if (JoiDate._isIsoDate(value)) {
          if (!options.convert) {
            return value;
          }

          var d = new Date(value);

          if (!isNaN(d.getTime())) {
            return d.toISOString();
          }
        }

        return this.createError('string.isoDate', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "guid",
    value: function guid(guidOptions) {
      var versionNumbers = '';

      if (guidOptions && guidOptions.version) {
        if (!Array.isArray(guidOptions.version)) {
          guidOptions.version = [guidOptions.version];
        }

        Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');
        var versions = new Set();

        for (var i = 0; i < guidOptions.version.length; ++i) {
          var version = guidOptions.version[i];
          Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
          version = version.toLowerCase();
          var versionNumber = internals.guidVersions[version];
          Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
          Hoek.assert(!versions.has(versionNumber), 'version at position ' + i + ' must not be a duplicate.');
          versionNumbers += versionNumber;
          versions.add(versionNumber);
        }
      }

      var guidRegex = new RegExp("^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[".concat(versionNumbers || '0-9A-F', "][0-9A-F]{3}\\2?[").concat(versionNumbers ? '89AB' : '0-9A-F', "][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$"), 'i');
      return this._test('guid', guidOptions, function (value, state, options) {
        var results = guidRegex.exec(value);

        if (!results) {
          return this.createError('string.guid', {
            value: value
          }, state, options);
        } // Matching braces


        if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
          return this.createError('string.guid', {
            value: value
          }, state, options);
        }

        return value;
      });
    }
  }, {
    key: "hex",
    value: function hex() {
      var hexOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Hoek.assert(_typeof(hexOptions) === 'object', 'hex options must be an object');
      Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean', 'byteAligned must be boolean');
      var byteAligned = hexOptions.byteAligned === true;
      var regex = /^[a-f0-9]+$/i;

      var obj = this._test('hex', regex, function (value, state, options) {
        if (regex.test(value)) {
          if (byteAligned && value.length % 2 !== 0) {
            return this.createError('string.hexAlign', {
              value: value
            }, state, options);
          }

          return value;
        }

        return this.createError('string.hex', {
          value: value
        }, state, options);
      });

      if (byteAligned) {
        obj._flags.byteAligned = true;
      }

      return obj;
    }
  }, {
    key: "base64",
    value: function base64() {
      var base64Options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Validation.
      Hoek.assert(_typeof(base64Options) === 'object', 'base64 options must be an object');
      Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean', 'paddingRequired must be boolean'); // Determine if padding is required.

      var paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true; // Set validation based on preference.

      var regex = paddingRequired ? // Padding is required.
      /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/ // Padding is optional.
      : /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;
      return this._test('base64', regex, function (value, state, options) {
        if (regex.test(value)) {
          return value;
        }

        return this.createError('string.base64', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "dataUri",
    value: function dataUri() {
      var dataUriOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var regex = /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/; // Determine if padding is required.

      var paddingRequired = dataUriOptions.paddingRequired === false ? dataUriOptions.paddingRequired : dataUriOptions.paddingRequired || true;
      var base64regex = paddingRequired ? /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/ : /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;
      return this._test('dataUri', regex, function (value, state, options) {
        var matches = value.match(regex);

        if (matches) {
          if (!matches[2]) {
            return value;
          }

          if (matches[2] !== 'base64') {
            return value;
          }

          if (base64regex.test(matches[3])) {
            return value;
          }
        }

        return this.createError('string.dataUri', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "hostname",
    value: function hostname() {
      var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;
      return this._test('hostname', undefined, function (value, state, options) {
        if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {
          return value;
        }

        return this.createError('string.hostname', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NFC';
      Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

      var obj = this._test('normalize', form, function (value, state, options) {
        if (options.convert || value === value.normalize(form)) {
          return value;
        }

        return this.createError('string.normalize', {
          value: value,
          form: form
        }, state, options);
      });

      obj._flags.normalize = form;
      return obj;
    }
  }, {
    key: "lowercase",
    value: function lowercase() {
      var obj = this._test('lowercase', undefined, function (value, state, options) {
        if (options.convert || value === value.toLocaleLowerCase()) {
          return value;
        }

        return this.createError('string.lowercase', {
          value: value
        }, state, options);
      });

      obj._flags["case"] = 'lower';
      return obj;
    }
  }, {
    key: "uppercase",
    value: function uppercase() {
      var obj = this._test('uppercase', undefined, function (value, state, options) {
        if (options.convert || value === value.toLocaleUpperCase()) {
          return value;
        }

        return this.createError('string.uppercase', {
          value: value
        }, state, options);
      });

      obj._flags["case"] = 'upper';
      return obj;
    }
  }, {
    key: "trim",
    value: function trim() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');

      if (this._flags.trim && enabled || !this._flags.trim && !enabled) {
        return this;
      }

      var obj;

      if (enabled) {
        obj = this._test('trim', undefined, function (value, state, options) {
          if (options.convert || value === value.trim()) {
            return value;
          }

          return this.createError('string.trim', {
            value: value
          }, state, options);
        });
      } else {
        obj = this.clone();
        obj._tests = obj._tests.filter(function (test) {
          return test.name !== 'trim';
        });
      }

      obj._flags.trim = enabled;
      return obj;
    }
  }, {
    key: "replace",
    value: function replace(pattern, replacement) {
      if (typeof pattern === 'string') {
        pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');
      }

      Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
      Hoek.assert(typeof replacement === 'string', 'replacement must be a String'); // This can not be considere a test like trim, we can't "reject"
      // anything from this rule, so just clone the current object

      var obj = this.clone();

      if (!obj._inner.replacements) {
        obj._inner.replacements = [];
      }

      obj._inner.replacements.push({
        pattern: pattern,
        replacement: replacement
      });

      return obj;
    }
  }, {
    key: "truncate",
    value: function truncate(enabled) {
      var value = enabled === undefined ? true : !!enabled;

      if (this._flags.truncate === value) {
        return this;
      }

      var obj = this.clone();
      obj._flags.truncate = value;
      return obj;
    }
  }]);

  return _class;
}(Any);

internals.compare = function (type, compare) {
  return function (limit, encoding) {
    var isRef = Ref.isRef(limit);
    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');
    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);
    return this._test(type, limit, function (value, state, options) {
      var compareTo;

      if (isRef) {
        compareTo = limit(state.reference || state.parent, options);

        if (!Number.isSafeInteger(compareTo)) {
          return this.createError('string.ref', {
            ref: limit,
            value: compareTo
          }, state, options);
        }
      } else {
        compareTo = limit;
      }

      if (compare(value, compareTo, encoding)) {
        return value;
      }

      return this.createError('string.' + type, {
        limit: compareTo,
        value: value,
        encoding: encoding
      }, state, options);
    });
  };
};

internals.String.prototype.min = internals.compare('min', function (value, limit, encoding) {
  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
  return length >= limit;
});
internals.String.prototype.max = internals.compare('max', function (value, limit, encoding) {
  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
  return length <= limit;
});
internals.String.prototype.length = internals.compare('length', function (value, limit, encoding) {
  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
  return length === limit;
}); // Aliases

internals.String.prototype.uuid = internals.String.prototype.guid;
module.exports = new internals.String();