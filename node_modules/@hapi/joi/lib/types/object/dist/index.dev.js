'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Bourne = require('@hapi/bourne');

var Hoek = require('@hapi/hoek');

var Topo = require('@hapi/topo');

var Any = require('../any');

var Errors = require('../../errors');

var Cast = require('../../cast');

var State = require('../state');

var internals = {};

internals.Object =
/*#__PURE__*/
function (_Any) {
  _inherits(_class, _Any);

  function _class() {
    var _this;

    _classCallCheck(this, _class);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));
    _this._type = 'object';
    _this._inner.children = null;
    _this._inner.renames = [];
    _this._inner.dependencies = [];
    _this._inner.patterns = [];
    return _this;
  }

  _createClass(_class, [{
    key: "_init",
    value: function _init() {
      return arguments.length ? this.keys.apply(this, arguments) : this;
    }
  }, {
    key: "_base",
    value: function _base(value, state, options) {
      var target = value;
      var errors = [];

      var finish = function finish() {
        return {
          value: target,
          errors: errors.length ? errors : null
        };
      };

      if (typeof value === 'string' && options.convert) {
        if (value.length > 1 && (value[0] === '{' || /^\s*\{/.test(value))) {
          try {
            value = Bourne.parse(value);
          } catch (e) {}
        }
      }

      var type = this._flags.func ? 'function' : 'object';

      if (!value || _typeof(value) !== type || Array.isArray(value)) {
        errors.push(this.createError(type + '.base', {
          value: value
        }, state, options));
        return finish();
      } // Skip if there are no other rules to test


      if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys
      !this._inner.patterns.length) {
        target = value;
        return finish();
      } // Ensure target is a local copy (parsed) or shallow copy


      if (target === value) {
        if (type === 'object') {
          target = Object.create(Object.getPrototypeOf(value));
        } else {
          target = function target() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return value.apply(this, args);
          };

          target.prototype = Hoek.clone(value.prototype);
        }

        var valueKeys = Object.keys(value);

        for (var i = 0; i < valueKeys.length; ++i) {
          target[valueKeys[i]] = value[valueKeys[i]];
        }
      } else {
        target = value;
      } // Rename keys


      var renamed = {};

      for (var _i = 0; _i < this._inner.renames.length; ++_i) {
        var rename = this._inner.renames[_i];

        if (rename.isRegExp) {
          var targetKeys = Object.keys(target);
          var matchedTargetKeys = [];

          for (var j = 0; j < targetKeys.length; ++j) {
            if (rename.from.test(targetKeys[j])) {
              matchedTargetKeys.push(targetKeys[j]);
            }
          }

          var allUndefined = matchedTargetKeys.every(function (key) {
            return target[key] === undefined;
          });

          if (rename.options.ignoreUndefined && allUndefined) {
            continue;
          }

          if (!rename.options.multiple && renamed[rename.to]) {
            errors.push(this.createError('object.rename.regex.multiple', {
              from: matchedTargetKeys,
              to: rename.to
            }, state, options));

            if (options.abortEarly) {
              return finish();
            }
          }

          if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {
            errors.push(this.createError('object.rename.regex.override', {
              from: matchedTargetKeys,
              to: rename.to
            }, state, options));

            if (options.abortEarly) {
              return finish();
            }
          }

          if (allUndefined) {
            delete target[rename.to];
          } else {
            target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];
          }

          renamed[rename.to] = true;

          if (!rename.options.alias) {
            for (var _j = 0; _j < matchedTargetKeys.length; ++_j) {
              delete target[matchedTargetKeys[_j]];
            }
          }
        } else {
          if (rename.options.ignoreUndefined && target[rename.from] === undefined) {
            continue;
          }

          if (!rename.options.multiple && renamed[rename.to]) {
            errors.push(this.createError('object.rename.multiple', {
              from: rename.from,
              to: rename.to
            }, state, options));

            if (options.abortEarly) {
              return finish();
            }
          }

          if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {
            errors.push(this.createError('object.rename.override', {
              from: rename.from,
              to: rename.to
            }, state, options));

            if (options.abortEarly) {
              return finish();
            }
          }

          if (target[rename.from] === undefined) {
            delete target[rename.to];
          } else {
            target[rename.to] = target[rename.from];
          }

          renamed[rename.to] = true;

          if (!rename.options.alias) {
            delete target[rename.from];
          }
        }
      } // Validate schema


      if (!this._inner.children && // null allows any keys
      !this._inner.patterns.length && !this._inner.dependencies.length) {
        return finish();
      }

      var unprocessed = new Set(Object.keys(target));

      if (this._inner.children) {
        var stripProps = [];

        for (var _i2 = 0; _i2 < this._inner.children.length; ++_i2) {
          var child = this._inner.children[_i2];
          var key = child.key;
          var item = target[key];
          unprocessed["delete"](key);
          var localState = new State(key, [].concat(_toConsumableArray(state.path), [key]), target, state.reference);

          var result = child.schema._validate(item, localState, options);

          if (result.errors) {
            errors.push(this.createError('object.child', {
              key: key,
              child: child.schema._getLabel(key),
              reason: result.errors
            }, localState, options));

            if (options.abortEarly) {
              return finish();
            }
          } else {
            if (child.schema._flags.strip || result.value === undefined && result.value !== item) {
              stripProps.push(key);
              target[key] = result.finalValue;
            } else if (result.value !== undefined) {
              target[key] = result.value;
            }
          }
        }

        for (var _i3 = 0; _i3 < stripProps.length; ++_i3) {
          delete target[stripProps[_i3]];
        }
      } // Unknown keys


      if (unprocessed.size && this._inner.patterns.length) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = unprocessed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _key2 = _step.value;

            var _localState = new State(_key2, [].concat(_toConsumableArray(state.path), [_key2]), target, state.reference);

            var _item = target[_key2];

            for (var _i4 = 0; _i4 < this._inner.patterns.length; ++_i4) {
              var pattern = this._inner.patterns[_i4];

              if (pattern.regex ? pattern.regex.test(_key2) : !pattern.schema._validate(_key2, state, _objectSpread({}, options, {
                abortEarly: true
              })).errors) {
                unprocessed["delete"](_key2);

                var _result = pattern.rule._validate(_item, _localState, options);

                if (_result.errors) {
                  errors.push(this.createError('object.child', {
                    key: _key2,
                    child: pattern.rule._getLabel(_key2),
                    reason: _result.errors
                  }, _localState, options));

                  if (options.abortEarly) {
                    return finish();
                  }
                }

                target[_key2] = _result.value;
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {
        if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {
          var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = unprocessed[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _key3 = _step2.value;

              if (stripUnknown) {
                delete target[_key3];
                unprocessed["delete"](_key3);
              } else if (typeof target[_key3] === 'function') {
                unprocessed["delete"](_key3);
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = unprocessed[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var unprocessedKey = _step3.value;
              errors.push(this.createError('object.allowUnknown', {
                child: unprocessedKey,
                value: target[unprocessedKey]
              }, {
                key: unprocessedKey,
                path: [].concat(_toConsumableArray(state.path), [unprocessedKey])
              }, options, {}));
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } // Validate dependencies


      for (var _i5 = 0; _i5 < this._inner.dependencies.length; ++_i5) {
        var dep = this._inner.dependencies[_i5];
        var hasKey = dep.key !== null;
        var splitKey = hasKey && dep.key.split('.');

        var _localState2 = hasKey ? new State(splitKey[splitKey.length - 1], [].concat(_toConsumableArray(state.path), _toConsumableArray(splitKey))) : new State(null, state.path);

        var err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, {
          functions: true
        }), dep.peers, target, _localState2, options);

        if (err instanceof Errors.Err) {
          errors.push(err);

          if (options.abortEarly) {
            return finish();
          }
        }
      }

      return finish();
    }
  }, {
    key: "keys",
    value: function keys(schema) {
      Hoek.assert(schema === null || schema === undefined || _typeof(schema) === 'object', 'Object schema must be a valid object');
      Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');
      var obj = this.clone();

      if (!schema) {
        obj._inner.children = null;
        return obj;
      }

      var children = Object.keys(schema);

      if (!children.length) {
        obj._inner.children = [];
        return obj;
      }

      var topo = new Topo();

      if (obj._inner.children) {
        for (var i = 0; i < obj._inner.children.length; ++i) {
          var child = obj._inner.children[i]; // Only add the key if we are not going to replace it later

          if (!children.includes(child.key)) {
            topo.add(child, {
              after: child._refs,
              group: child.key
            });
          }
        }
      }

      for (var _i6 = 0; _i6 < children.length; ++_i6) {
        var key = children[_i6];
        var _child = schema[key];

        try {
          var cast = Cast.schema(this._currentJoi, _child);
          topo.add({
            key: key,
            schema: cast
          }, {
            after: cast._refs,
            group: key
          });
        } catch (castErr) {
          if (castErr.hasOwnProperty('path')) {
            castErr.path = key + '.' + castErr.path;
          } else {
            castErr.path = key;
          }

          throw castErr;
        }
      }

      obj._inner.children = topo.nodes;
      return obj;
    }
  }, {
    key: "append",
    value: function append(schema) {
      // Skip any changes
      if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
        return this;
      }

      return this.keys(schema);
    }
  }, {
    key: "unknown",
    value: function unknown(allow) {
      var value = allow !== false;

      if (this._flags.allowUnknown === value) {
        return this;
      }

      var obj = this.clone();
      obj._flags.allowUnknown = value;
      return obj;
    }
  }, {
    key: "length",
    value: function length(limit) {
      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');
      return this._test('length', limit, function (value, state, options) {
        if (Object.keys(value).length === limit) {
          return value;
        }

        return this.createError('object.length', {
          limit: limit,
          value: value
        }, state, options);
      });
    }
  }, {
    key: "min",
    value: function min(limit) {
      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');
      return this._test('min', limit, function (value, state, options) {
        if (Object.keys(value).length >= limit) {
          return value;
        }

        return this.createError('object.min', {
          limit: limit,
          value: value
        }, state, options);
      });
    }
  }, {
    key: "max",
    value: function max(limit) {
      Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');
      return this._test('max', limit, function (value, state, options) {
        if (Object.keys(value).length <= limit) {
          return value;
        }

        return this.createError('object.max', {
          limit: limit,
          value: value
        }, state, options);
      });
    }
  }, {
    key: "pattern",
    value: function pattern(_pattern, schema) {
      var isRegExp = _pattern instanceof RegExp;
      Hoek.assert(isRegExp || _pattern instanceof Any, 'pattern must be a regex or schema');
      Hoek.assert(schema !== undefined, 'Invalid rule');

      if (isRegExp) {
        Hoek.assert(!_pattern.flags.includes('g') && !_pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
      }

      try {
        schema = Cast.schema(this._currentJoi, schema);
      } catch (castErr) {
        if (castErr.hasOwnProperty('path')) {
          castErr.message = "".concat(castErr.message, "(").concat(castErr.path, ")");
        }

        throw castErr;
      }

      var obj = this.clone();

      if (isRegExp) {
        obj._inner.patterns.push({
          regex: _pattern,
          rule: schema
        });
      } else {
        obj._inner.patterns.push({
          schema: _pattern,
          rule: schema
        });
      }

      return obj;
    }
  }, {
    key: "schema",
    value: function schema() {
      return this._test('schema', null, function (value, state, options) {
        if (value instanceof Any) {
          return value;
        }

        return this.createError('object.schema', null, state, options);
      });
    }
  }, {
    key: "with",
    value: function _with(key, peers) {
      Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');
      return this._dependency('with', key, peers);
    }
  }, {
    key: "without",
    value: function without(key, peers) {
      Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');
      return this._dependency('without', key, peers);
    }
  }, {
    key: "xor",
    value: function xor() {
      for (var _len2 = arguments.length, peers = new Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {
        peers[_key4] = arguments[_key4];
      }

      peers = Hoek.flatten(peers);
      return this._dependency('xor', null, peers);
    }
  }, {
    key: "oxor",
    value: function oxor() {
      for (var _len3 = arguments.length, peers = new Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {
        peers[_key5] = arguments[_key5];
      }

      return this._dependency('oxor', null, peers);
    }
  }, {
    key: "or",
    value: function or() {
      for (var _len4 = arguments.length, peers = new Array(_len4), _key6 = 0; _key6 < _len4; _key6++) {
        peers[_key6] = arguments[_key6];
      }

      peers = Hoek.flatten(peers);
      return this._dependency('or', null, peers);
    }
  }, {
    key: "and",
    value: function and() {
      for (var _len5 = arguments.length, peers = new Array(_len5), _key7 = 0; _key7 < _len5; _key7++) {
        peers[_key7] = arguments[_key7];
      }

      peers = Hoek.flatten(peers);
      return this._dependency('and', null, peers);
    }
  }, {
    key: "nand",
    value: function nand() {
      for (var _len6 = arguments.length, peers = new Array(_len6), _key8 = 0; _key8 < _len6; _key8++) {
        peers[_key8] = arguments[_key8];
      }

      peers = Hoek.flatten(peers);
      return this._dependency('nand', null, peers);
    }
  }, {
    key: "requiredKeys",
    value: function requiredKeys() {
      for (var _len7 = arguments.length, children = new Array(_len7), _key9 = 0; _key9 < _len7; _key9++) {
        children[_key9] = arguments[_key9];
      }

      children = Hoek.flatten(children);
      return this.applyFunctionToChildren(children, 'required');
    }
  }, {
    key: "optionalKeys",
    value: function optionalKeys() {
      for (var _len8 = arguments.length, children = new Array(_len8), _key10 = 0; _key10 < _len8; _key10++) {
        children[_key10] = arguments[_key10];
      }

      children = Hoek.flatten(children);
      return this.applyFunctionToChildren(children, 'optional');
    }
  }, {
    key: "forbiddenKeys",
    value: function forbiddenKeys() {
      for (var _len9 = arguments.length, children = new Array(_len9), _key11 = 0; _key11 < _len9; _key11++) {
        children[_key11] = arguments[_key11];
      }

      children = Hoek.flatten(children);
      return this.applyFunctionToChildren(children, 'forbidden');
    }
  }, {
    key: "rename",
    value: function rename(from, to, options) {
      Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
      Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
      Hoek.assert(to !== from, 'Cannot rename key to same name:', from);

      for (var i = 0; i < this._inner.renames.length; ++i) {
        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
      }

      var obj = this.clone();

      obj._inner.renames.push({
        from: from,
        to: to,
        options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),
        isRegExp: from instanceof RegExp
      });

      return obj;
    }
  }, {
    key: "applyFunctionToChildren",
    value: function applyFunctionToChildren(children, fn) {
      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var root = arguments.length > 3 ? arguments[3] : undefined;
      children = [].concat(children);
      Hoek.assert(children.length > 0, 'expected at least one children');
      var groupedChildren = internals.groupChildren(children);
      var obj;

      if ('' in groupedChildren) {
        obj = this[fn].apply(this, _toConsumableArray(args));
        delete groupedChildren[''];
      } else {
        obj = this.clone();
      }

      if (obj._inner.children) {
        root = root ? root + '.' : '';

        for (var i = 0; i < obj._inner.children.length; ++i) {
          var child = obj._inner.children[i];
          var group = groupedChildren[child.key];

          if (group) {
            obj._inner.children[i] = {
              key: child.key,
              _refs: child._refs,
              schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
            };
            delete groupedChildren[child.key];
          }
        }
      }

      var remaining = Object.keys(groupedChildren);
      Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));
      return obj;
    }
  }, {
    key: "_dependency",
    value: function _dependency(type, key, peers) {
      peers = [].concat(peers);

      for (var i = 0; i < peers.length; ++i) {
        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
      }

      var obj = this.clone();

      obj._inner.dependencies.push({
        type: type,
        key: key,
        peers: peers
      });

      return obj;
    }
  }, {
    key: "describe",
    value: function describe(shallow) {
      var description = _get(_getPrototypeOf(_class.prototype), "describe", this).call(this);

      if (description.rules) {
        for (var i = 0; i < description.rules.length; ++i) {
          var rule = description.rules[i]; // Coverage off for future-proof descriptions, only object().assert() is use right now

          if (
          /* $lab:coverage:off$ */
          rule.arg && _typeof(rule.arg) === 'object' && rule.arg.schema && rule.arg.ref
          /* $lab:coverage:on$ */
          ) {
              rule.arg = {
                schema: rule.arg.schema.describe(),
                ref: rule.arg.ref.toString()
              };
            }
        }
      }

      if (this._inner.children && !shallow) {
        description.children = {};

        for (var _i7 = 0; _i7 < this._inner.children.length; ++_i7) {
          var child = this._inner.children[_i7];
          description.children[child.key] = child.schema.describe();
        }
      }

      if (this._inner.dependencies.length) {
        description.dependencies = Hoek.clone(this._inner.dependencies);
      }

      if (this._inner.patterns.length) {
        description.patterns = [];

        for (var _i8 = 0; _i8 < this._inner.patterns.length; ++_i8) {
          var pattern = this._inner.patterns[_i8];

          if (pattern.regex) {
            description.patterns.push({
              regex: pattern.regex.toString(),
              rule: pattern.rule.describe()
            });
          } else {
            description.patterns.push({
              schema: pattern.schema.describe(),
              rule: pattern.rule.describe()
            });
          }
        }
      }

      if (this._inner.renames.length > 0) {
        description.renames = Hoek.clone(this._inner.renames);
      }

      return description;
    }
  }, {
    key: "assert",
    value: function assert(ref, schema, message) {
      ref = Cast.ref(ref);
      Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
      message = message || 'pass the assertion test';
      Hoek.assert(typeof message === 'string', 'Message must be a string');

      try {
        schema = Cast.schema(this._currentJoi, schema);
      } catch (castErr) {
        if (castErr.hasOwnProperty('path')) {
          castErr.message = "".concat(castErr.message, "(").concat(castErr.path, ")");
        }

        throw castErr;
      }

      var key = ref.path[ref.path.length - 1];
      var path = ref.path.join('.');
      return this._test('assert', {
        schema: schema,
        ref: ref
      }, function (value, state, options) {
        var result = schema._validate(ref(value), null, options, value);

        if (!result.errors) {
          return value;
        }

        var localState = new State(key, ref.path, state.parent, state.reference);
        return this.createError('object.assert', {
          ref: path,
          message: message
        }, localState, options);
      });
    }
  }, {
    key: "type",
    value: function type(constructor) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constructor.name;
      Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
      var typeData = {
        name: name,
        ctor: constructor
      };
      return this._test('type', typeData, function (value, state, options) {
        if (value instanceof constructor) {
          return value;
        }

        return this.createError('object.type', {
          type: typeData.name,
          value: value
        }, state, options);
      });
    }
  }]);

  return _class;
}(Any);

internals.renameDefaults = {
  alias: false,
  // Keep old value in place
  multiple: false,
  // Allow renaming multiple keys into the same target
  override: false // Overrides an existing key

};

internals.groupChildren = function (children) {
  children.sort();
  var grouped = {};

  for (var i = 0; i < children.length; ++i) {
    var child = children[i];
    Hoek.assert(typeof child === 'string', 'children must be strings');
    var group = child.split('.')[0];
    var childGroup = grouped[group] = grouped[group] || [];
    childGroup.push(child.substring(group.length + 1));
  }

  return grouped;
};

internals.keysToLabels = function (schema, keys) {
  var children = schema._inner.children;

  if (!children) {
    return keys;
  }

  var findLabel = function findLabel(key) {
    var matchingChild = schema._currentJoi.reach(schema, key);

    return matchingChild ? matchingChild._getLabel(key) : key;
  };

  if (Array.isArray(keys)) {
    return keys.map(findLabel);
  }

  return findLabel(keys);
};

internals["with"] = function (key, value, peers, parent, state, options) {
  if (value === undefined) {
    return;
  }

  for (var i = 0; i < peers.length; ++i) {
    var peer = peers[i];
    var keysExist = Hoek.reach(parent, peer, {
      functions: true
    });

    if (keysExist === undefined) {
      return this.createError('object.with', {
        main: key,
        mainWithLabel: internals.keysToLabels(this, key),
        peer: peer,
        peerWithLabel: internals.keysToLabels(this, peer)
      }, state, options);
    }
  }
};

internals.without = function (key, value, peers, parent, state, options) {
  if (value === undefined) {
    return;
  }

  for (var i = 0; i < peers.length; ++i) {
    var peer = peers[i];
    var keysExist = Hoek.reach(parent, peer, {
      functions: true
    });

    if (keysExist !== undefined) {
      return this.createError('object.without', {
        main: key,
        mainWithLabel: internals.keysToLabels(this, key),
        peer: peer,
        peerWithLabel: internals.keysToLabels(this, peer)
      }, state, options);
    }
  }
};

internals.xor = function (key, value, peers, parent, state, options) {
  var present = [];

  for (var i = 0; i < peers.length; ++i) {
    var peer = peers[i];
    var keysExist = Hoek.reach(parent, peer, {
      functions: true
    });

    if (keysExist !== undefined) {
      present.push(peer);
    }
  }

  if (present.length === 1) {
    return;
  }

  var context = {
    peers: peers,
    peersWithLabels: internals.keysToLabels(this, peers)
  };

  if (present.length === 0) {
    return this.createError('object.missing', context, state, options);
  }

  context.present = present;
  context.presentWithLabels = internals.keysToLabels(this, present);
  return this.createError('object.xor', context, state, options);
};

internals.oxor = function (key, value, peers, parent, state, options) {
  var present = [];

  for (var i = 0; i < peers.length; ++i) {
    var peer = peers[i];
    var keysExist = Hoek.reach(parent, peer, {
      functions: true
    });

    if (keysExist !== undefined) {
      present.push(peer);
    }
  }

  if (!present.length || present.length === 1) {
    return;
  }

  var context = {
    peers: peers,
    peersWithLabels: internals.keysToLabels(this, peers)
  };
  context.present = present;
  context.presentWithLabels = internals.keysToLabels(this, present);
  return this.createError('object.oxor', context, state, options);
};

internals.or = function (key, value, peers, parent, state, options) {
  for (var i = 0; i < peers.length; ++i) {
    var peer = peers[i];
    var keysExist = Hoek.reach(parent, peer, {
      functions: true
    });

    if (keysExist !== undefined) {
      return;
    }
  }

  return this.createError('object.missing', {
    peers: peers,
    peersWithLabels: internals.keysToLabels(this, peers)
  }, state, options);
};

internals.and = function (key, value, peers, parent, state, options) {
  var missing = [];
  var present = [];
  var count = peers.length;

  for (var i = 0; i < count; ++i) {
    var peer = peers[i];
    var keysExist = Hoek.reach(parent, peer, {
      functions: true
    });

    if (keysExist === undefined) {
      missing.push(peer);
    } else {
      present.push(peer);
    }
  }

  var aon = missing.length === count || present.length === count;

  if (!aon) {
    return this.createError('object.and', {
      present: present,
      presentWithLabels: internals.keysToLabels(this, present),
      missing: missing,
      missingWithLabels: internals.keysToLabels(this, missing)
    }, state, options);
  }
};

internals.nand = function (key, value, peers, parent, state, options) {
  var present = [];

  for (var i = 0; i < peers.length; ++i) {
    var peer = peers[i];
    var keysExist = Hoek.reach(parent, peer, {
      functions: true
    });

    if (keysExist !== undefined) {
      present.push(peer);
    }
  }

  var main = peers[0];
  var values = peers.slice(1);
  var allPresent = present.length === peers.length;
  return allPresent ? this.createError('object.nand', {
    main: main,
    mainWithLabel: internals.keysToLabels(this, main),
    peers: values,
    peersWithLabels: internals.keysToLabels(this, values)
  }, state, options) : null;
};

module.exports = new internals.Object();