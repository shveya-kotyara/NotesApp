'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Hoek = require('@hapi/hoek');

var Any = require('../any');

var Ref = require('../../ref');

var internals = {
  precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
  normalizeExponent: function normalizeExponent(str) {
    return str.replace(/\.?0+e/, 'e').replace(/e\+/, 'e').replace(/^\+/, '').replace(/^(-?)0+([1-9])/, '$1$2');
  },
  normalizeDecimal: function normalizeDecimal(str) {
    str = str.replace(/^\+/, '').replace(/\.0+$/, '').replace(/^(-?)0+([1-9])/, '$1$2');

    if (str.includes('.') && str.endsWith('0')) {
      str = str.replace(/0+$/, '');
    }

    return str;
  }
};

internals.Number =
/*#__PURE__*/
function (_Any) {
  _inherits(_class, _Any);

  function _class() {
    var _this;

    _classCallCheck(this, _class);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));
    _this._type = 'number';
    _this._flags.unsafe = false;

    _this._invalids.add(Infinity);

    _this._invalids.add(-Infinity);

    return _this;
  }

  _createClass(_class, [{
    key: "_base",
    value: function _base(value, state, options) {
      var result = {
        errors: null,
        value: value
      };

      if (typeof value === 'string' && options.convert) {
        var matches = value.match(/^\s*[+-]?\d+(?:\.\d+)?(?:e([+-]?\d+))?\s*$/i);

        if (matches) {
          value = value.trim();
          result.value = parseFloat(value);

          if (!this._flags.unsafe) {
            if (value.includes('e')) {
              if (internals.normalizeExponent("".concat(result.value / Math.pow(10, matches[1]), "e").concat(matches[1])) !== internals.normalizeExponent(value)) {
                result.errors = this.createError('number.unsafe', {
                  value: value
                }, state, options);
                return result;
              }
            } else {
              if (result.value.toString() !== internals.normalizeDecimal(value)) {
                result.errors = this.createError('number.unsafe', {
                  value: value
                }, state, options);
                return result;
              }
            }
          }
        }
      }

      var isNumber = typeof result.value === 'number' && !isNaN(result.value);

      if (options.convert && 'precision' in this._flags && isNumber) {
        // This is conceptually equivalent to using toFixed but it should be much faster
        var precision = Math.pow(10, this._flags.precision);
        result.value = Math.round(result.value * precision) / precision;
      }

      if (isNumber) {
        if (!this._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = this.createError('number.unsafe', {
            value: value
          }, state, options);
        }
      } else {
        result.errors = this.createError('number.base', {
          value: value
        }, state, options);
      }

      return result;
    }
  }, {
    key: "multiple",
    value: function multiple(base) {
      var isRef = Ref.isRef(base);

      if (!isRef) {
        Hoek.assert(typeof base === 'number' && isFinite(base), 'multiple must be a number');
        Hoek.assert(base > 0, 'multiple must be greater than 0');
      }

      return this._test('multiple', base, function (value, state, options) {
        var divisor = isRef ? base(state.reference || state.parent, options) : base;

        if (isRef && (typeof divisor !== 'number' || !isFinite(divisor))) {
          return this.createError('number.ref', {
            ref: base.key
          }, state, options);
        }

        if (value % divisor === 0) {
          return value;
        }

        return this.createError('number.multiple', {
          multiple: base,
          value: value
        }, state, options);
      });
    }
  }, {
    key: "integer",
    value: function integer() {
      return this._test('integer', undefined, function (value, state, options) {
        return Math.trunc(value) - value === 0 ? value : this.createError('number.integer', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "unsafe",
    value: function unsafe() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      Hoek.assert(typeof enabled === 'boolean', 'enabled must be a boolean');

      if (this._flags.unsafe === enabled) {
        return this;
      }

      var obj = this.clone();
      obj._flags.unsafe = enabled;
      return obj;
    }
  }, {
    key: "negative",
    value: function negative() {
      return this._test('negative', undefined, function (value, state, options) {
        if (value < 0) {
          return value;
        }

        return this.createError('number.negative', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "positive",
    value: function positive() {
      return this._test('positive', undefined, function (value, state, options) {
        if (value > 0) {
          return value;
        }

        return this.createError('number.positive', {
          value: value
        }, state, options);
      });
    }
  }, {
    key: "precision",
    value: function precision(limit) {
      Hoek.assert(Number.isSafeInteger(limit), 'limit must be an integer');
      Hoek.assert(!('precision' in this._flags), 'precision already set');

      var obj = this._test('precision', limit, function (value, state, options) {
        var places = value.toString().match(internals.precisionRx);
        var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);

        if (decimals <= limit) {
          return value;
        }

        return this.createError('number.precision', {
          limit: limit,
          value: value
        }, state, options);
      });

      obj._flags.precision = limit;
      return obj;
    }
  }, {
    key: "port",
    value: function port() {
      return this._test('port', undefined, function (value, state, options) {
        if (!Number.isSafeInteger(value) || value < 0 || value > 65535) {
          return this.createError('number.port', {
            value: value
          }, state, options);
        }

        return value;
      });
    }
  }]);

  return _class;
}(Any);

internals.compare = function (type, compare) {
  return function (limit) {
    var isRef = Ref.isRef(limit);
    var isNumber = typeof limit === 'number' && !isNaN(limit);
    Hoek.assert(isNumber || isRef, 'limit must be a number or reference');
    return this._test(type, limit, function (value, state, options) {
      var compareTo;

      if (isRef) {
        compareTo = limit(state.reference || state.parent, options);

        if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {
          return this.createError('number.ref', {
            ref: limit.key
          }, state, options);
        }
      } else {
        compareTo = limit;
      }

      if (compare(value, compareTo)) {
        return value;
      }

      return this.createError('number.' + type, {
        limit: compareTo,
        value: value
      }, state, options);
    });
  };
};

internals.Number.prototype.min = internals.compare('min', function (value, limit) {
  return value >= limit;
});
internals.Number.prototype.max = internals.compare('max', function (value, limit) {
  return value <= limit;
});
internals.Number.prototype.greater = internals.compare('greater', function (value, limit) {
  return value > limit;
});
internals.Number.prototype.less = internals.compare('less', function (value, limit) {
  return value < limit;
});
module.exports = new internals.Number();