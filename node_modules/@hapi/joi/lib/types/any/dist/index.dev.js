'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Hoek = require('@hapi/hoek');

var Cast = require('../../cast');

var Settings = require('./settings');

var Ref = require('../../ref');

var Errors = require('../../errors');

var State = require('../state');

var Symbols = require('../symbols');

var Pkg = require('../../../package.json');

var Alternatives = null; // Delay-loaded to prevent circular dependencies

var Schemas = null;
var internals = {
  Set: require('../../set'),
  symbol: Symbol["for"]('@hapi/joi/schema')
};
internals.defaults = {
  abortEarly: true,
  convert: true,
  allowUnknown: false,
  skipFunctions: false,
  stripUnknown: false,
  language: {},
  presence: 'optional',
  noDefaults: false,
  escapeHtml: false // context: null

};

module.exports = internals.Any =
/*#__PURE__*/
function () {
  function _class() {
    _classCallCheck(this, _class);

    this.isJoi = true;
    this._type = 'any';
    this._settings = null;
    this._valids = new internals.Set();
    this._invalids = new internals.Set();
    this._tests = [];
    this._refs = [];
    this._flags = {
      /*
       presence: 'optional',                   // optional, required, forbidden, ignore
       allowOnly: false,
       allowUnknown: undefined,
       default: undefined,
       forbidden: false,
       encoding: undefined,
       insensitive: false,
       trim: false,
       normalize: undefined,                   // NFC, NFD, NFKC, NFKD
       case: undefined,                        // upper, lower
       empty: undefined,
       func: false,
       raw: false
       */
    };
    this._description = null;
    this._unit = null;
    this._notes = [];
    this._tags = [];
    this._examples = [];
    this._meta = [];
    this._inner = {}; // Hash of arrays of immutable objects
  }

  _createClass(_class, [{
    key: "_init",
    value: function _init() {
      return this;
    }
  }, {
    key: "createError",
    value: function createError(type, context, state, options) {
      var flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._flags;
      return Errors.create(type, context, state, options, flags);
    }
  }, {
    key: "createOverrideError",
    value: function createOverrideError(type, context, state, options, message, template) {
      return Errors.create(type, context, state, options, this._flags, message, template);
    }
  }, {
    key: "checkOptions",
    value: function checkOptions(options) {
      Schemas = Schemas || require('../../schemas');
      var result = Schemas.options.validate(options);

      if (result.error) {
        throw new Error(result.error.details[0].message);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      var obj = Object.create(Object.getPrototypeOf(this));
      obj.isJoi = true;
      obj._currentJoi = this._currentJoi;
      obj._type = this._type;
      obj._settings = this._settings;
      obj._baseType = this._baseType;
      obj._valids = this._valids.slice();
      obj._invalids = this._invalids.slice();
      obj._tests = this._tests.slice();
      obj._refs = this._refs.slice();
      obj._flags = Hoek.clone(this._flags);
      obj._description = this._description;
      obj._unit = this._unit;
      obj._notes = this._notes.slice();
      obj._tags = this._tags.slice();
      obj._examples = this._examples.slice();
      obj._meta = this._meta.slice();
      obj._inner = {};
      var inners = Object.keys(this._inner);

      for (var i = 0; i < inners.length; ++i) {
        var key = inners[i];
        obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
      }

      return obj;
    }
  }, {
    key: "concat",
    value: function concat(schema) {
      var _obj$_tests, _obj$_refs, _obj$_notes, _obj$_tags, _obj$_examples, _obj$_meta;

      Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');
      Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);
      var obj = this.clone();

      if (this._type === 'any' && schema._type !== 'any') {
        // Reset values as if we were "this"
        var tmpObj = schema.clone();
        var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];

        for (var i = 0; i < keysToRestore.length; ++i) {
          tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];
        }

        obj = tmpObj;
      }

      obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;

      obj._valids.merge(schema._valids, schema._invalids);

      obj._invalids.merge(schema._invalids, schema._valids);

      (_obj$_tests = obj._tests).push.apply(_obj$_tests, _toConsumableArray(schema._tests));

      (_obj$_refs = obj._refs).push.apply(_obj$_refs, _toConsumableArray(schema._refs));

      if (obj._flags.empty && schema._flags.empty) {
        obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);
        var flags = Object.assign({}, schema._flags);
        delete flags.empty;
        Hoek.merge(obj._flags, flags);
      } else if (schema._flags.empty) {
        obj._flags.empty = schema._flags.empty;

        var _flags = Object.assign({}, schema._flags);

        delete _flags.empty;
        Hoek.merge(obj._flags, _flags);
      } else {
        Hoek.merge(obj._flags, schema._flags);
      }

      obj._description = schema._description || obj._description;
      obj._unit = schema._unit || obj._unit;

      (_obj$_notes = obj._notes).push.apply(_obj$_notes, _toConsumableArray(schema._notes));

      (_obj$_tags = obj._tags).push.apply(_obj$_tags, _toConsumableArray(schema._tags));

      (_obj$_examples = obj._examples).push.apply(_obj$_examples, _toConsumableArray(schema._examples));

      (_obj$_meta = obj._meta).push.apply(_obj$_meta, _toConsumableArray(schema._meta));

      var inners = Object.keys(schema._inner);
      var isObject = obj._type === 'object';

      for (var _i = 0; _i < inners.length; ++_i) {
        var key = inners[_i];
        var source = schema._inner[key];

        if (source) {
          var target = obj._inner[key];

          if (target) {
            if (isObject && key === 'children') {
              var keys = {};

              for (var j = 0; j < target.length; ++j) {
                keys[target[j].key] = j;
              }

              for (var _j = 0; _j < source.length; ++_j) {
                var sourceKey = source[_j].key;

                if (keys[sourceKey] >= 0) {
                  target[keys[sourceKey]] = {
                    key: sourceKey,
                    schema: target[keys[sourceKey]].schema.concat(source[_j].schema)
                  };
                } else {
                  target.push(source[_j]);
                }
              }
            } else {
              obj._inner[key] = obj._inner[key].concat(source);
            }
          } else {
            obj._inner[key] = source.slice();
          }
        }
      }

      return obj;
    }
  }, {
    key: "_test",
    value: function _test(name, arg, func, options) {
      var obj = this.clone();

      obj._tests.push({
        func: func,
        name: name,
        arg: arg,
        options: options
      });

      return obj;
    }
  }, {
    key: "_testUnique",
    value: function _testUnique(name, arg, func, options) {
      var obj = this.clone();
      obj._tests = obj._tests.filter(function (test) {
        return test.name !== name;
      });

      obj._tests.push({
        func: func,
        name: name,
        arg: arg,
        options: options
      });

      return obj;
    }
  }, {
    key: "options",
    value: function options(_options) {
      Hoek.assert(!_options.context, 'Cannot override context');
      this.checkOptions(_options);
      var obj = this.clone();
      obj._settings = Settings.concat(obj._settings, _options);
      return obj;
    }
  }, {
    key: "strict",
    value: function strict(isStrict) {
      var obj = this.clone();
      var convert = isStrict === undefined ? false : !isStrict;
      obj._settings = Settings.concat(obj._settings, {
        convert: convert
      });
      return obj;
    }
  }, {
    key: "raw",
    value: function raw(isRaw) {
      var value = isRaw === undefined ? true : isRaw;

      if (this._flags.raw === value) {
        return this;
      }

      var obj = this.clone();
      obj._flags.raw = value;
      return obj;
    }
  }, {
    key: "error",
    value: function error(err) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        self: false
      };
      Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');
      var unknownKeys = Object.keys(options).filter(function (k) {
        return !['self'].includes(k);
      });
      Hoek.assert(unknownKeys.length === 0, "Options ".concat(unknownKeys, " are unknown"));
      var obj = this.clone();
      obj._flags.error = err;

      if (options.self) {
        obj._flags.selfError = true;
      }

      return obj;
    }
  }, {
    key: "allow",
    value: function allow() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      var obj = this.clone();
      values = Hoek.flatten(values);

      for (var i = 0; i < values.length; ++i) {
        var value = values[i];
        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');

        obj._invalids.remove(value);

        obj._valids.add(value, obj._refs);
      }

      return obj;
    }
  }, {
    key: "valid",
    value: function valid() {
      var obj = this.allow.apply(this, arguments);
      obj._flags.allowOnly = true;
      return obj;
    }
  }, {
    key: "invalid",
    value: function invalid() {
      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        values[_key2] = arguments[_key2];
      }

      var obj = this.clone();
      values = Hoek.flatten(values);

      for (var i = 0; i < values.length; ++i) {
        var value = values[i];
        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');

        obj._valids.remove(value);

        obj._invalids.add(value, obj._refs);
      }

      return obj;
    }
  }, {
    key: "required",
    value: function required() {
      if (this._flags.presence === 'required') {
        return this;
      }

      var obj = this.clone();
      obj._flags.presence = 'required';
      return obj;
    }
  }, {
    key: "optional",
    value: function optional() {
      if (this._flags.presence === 'optional') {
        return this;
      }

      var obj = this.clone();
      obj._flags.presence = 'optional';
      return obj;
    }
  }, {
    key: "forbidden",
    value: function forbidden() {
      if (this._flags.presence === 'forbidden') {
        return this;
      }

      var obj = this.clone();
      obj._flags.presence = 'forbidden';
      return obj;
    }
  }, {
    key: "strip",
    value: function strip() {
      if (this._flags.strip) {
        return this;
      }

      var obj = this.clone();
      obj._flags.strip = true;
      return obj;
    }
  }, {
    key: "applyFunctionToChildren",
    value: function applyFunctionToChildren(children, fn) {
      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var root = arguments.length > 3 ? arguments[3] : undefined;
      children = [].concat(children);

      if (children.length !== 1 || children[0] !== '') {
        root = root ? root + '.' : '';
        var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) {
          return root + child;
        });
        throw new Error('unknown key(s) ' + extraChildren.join(', '));
      }

      return this[fn].apply(this, _toConsumableArray(args));
    }
  }, {
    key: "default",
    value: function _default(value, description) {
      if (typeof value === 'function' && !Ref.isRef(value)) {
        if (!value.description && description) {
          value.description = description;
        }

        if (!this._flags.func) {
          Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');
        }
      }

      var obj = this.clone();
      obj._flags["default"] = value;
      Ref.push(obj._refs, value);
      return obj;
    }
  }, {
    key: "empty",
    value: function empty(schema) {
      var obj = this.clone();

      if (schema === undefined) {
        delete obj._flags.empty;
      } else {
        obj._flags.empty = Cast.schema(this._currentJoi, schema);
      }

      return obj;
    }
  }, {
    key: "when",
    value: function when(condition, options) {
      Hoek.assert(options && _typeof(options) === 'object', 'Invalid options');
      Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');
      var then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;
      var otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;
      Alternatives = Alternatives || require('../alternatives');
      var alternativeOptions = {
        then: then,
        otherwise: otherwise
      };

      if (Object.prototype.hasOwnProperty.call(options, 'is')) {
        alternativeOptions.is = options.is;
      }

      var obj = Alternatives.when(condition, alternativeOptions);
      obj._flags.presence = 'ignore';
      obj._baseType = this;
      return obj;
    }
  }, {
    key: "description",
    value: function description(desc) {
      Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');
      var obj = this.clone();
      obj._description = desc;
      return obj;
    }
  }, {
    key: "notes",
    value: function notes(_notes) {
      Hoek.assert(_notes && (typeof _notes === 'string' || Array.isArray(_notes)), 'Notes must be a non-empty string or array');
      var obj = this.clone();
      obj._notes = obj._notes.concat(_notes);
      return obj;
    }
  }, {
    key: "tags",
    value: function tags(_tags) {
      Hoek.assert(_tags && (typeof _tags === 'string' || Array.isArray(_tags)), 'Tags must be a non-empty string or array');
      var obj = this.clone();
      obj._tags = obj._tags.concat(_tags);
      return obj;
    }
  }, {
    key: "meta",
    value: function meta(_meta) {
      Hoek.assert(_meta !== undefined, 'Meta cannot be undefined');
      var obj = this.clone();
      obj._meta = obj._meta.concat(_meta);
      return obj;
    }
  }, {
    key: "example",
    value: function example() {
      Hoek.assert(arguments.length > 0, 'Missing examples');
      var processed = [];

      for (var i = 0; i < arguments.length; ++i) {
        var example = [].concat(i < 0 || arguments.length <= i ? undefined : arguments[i]);
        Hoek.assert(example.length <= 2, "Bad example format at index ".concat(i));
        var value = example[0];
        var options = example[1];

        if (options !== undefined) {
          Hoek.assert(options && _typeof(options) === 'object', "Options for example at index ".concat(i, " must be an object"));
          var unknownOptions = Object.keys(options).filter(function (option) {
            return !['parent', 'context'].includes(option);
          });
          Hoek.assert(unknownOptions.length === 0, "Unknown example options ".concat(unknownOptions, " at index ").concat(i));
        } else {
          options = {};
        }

        var localState = new State('', [], options.parent || null);

        var result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? {
          context: options.context
        } : null));

        Hoek.assert(!result.errors, "Bad example at index ".concat(i, ":"), result.errors && Errors.process(result.errors, value));
        var ex = {
          value: value
        };

        if (Object.keys(options).length) {
          ex.options = options;
        }

        processed.push(ex);
      }

      var obj = this.clone();
      obj._examples = processed;
      return obj;
    }
  }, {
    key: "unit",
    value: function unit(name) {
      Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');
      var obj = this.clone();
      obj._unit = name;
      return obj;
    }
  }, {
    key: "_prepareEmptyValue",
    value: function _prepareEmptyValue(value) {
      if (typeof value === 'string' && this._flags.trim) {
        return value.trim();
      }

      return value;
    }
  }, {
    key: "_validate",
    value: function _validate(value, state, options, reference) {
      var originalValue = value; // Setup state and settings

      state = state || new State('', [], null, reference);

      if (this._settings) {
        var isDefaultOptions = options === internals.defaults;

        if (isDefaultOptions && this._settings[Symbols.settingsCache]) {
          options = this._settings[Symbols.settingsCache];
        } else {
          options = Settings.concat(this._language ? Settings.concat({
            language: this._language
          }, options) : options, this._settings);

          if (isDefaultOptions) {
            this._settings[Symbols.settingsCache] = options;
          }
        }
      } else if (this._language) {
        options = Settings.concat({
          language: this._language
        }, options);
      }

      var errors = [];

      if (this._coerce) {
        var coerced = this._coerce(value, state, options);

        if (coerced.errors) {
          value = coerced.value;
          errors = errors.concat(coerced.errors);
          return this._finalizeValue(value, originalValue, errors, state, options); // Coerced error always aborts early
        }

        value = coerced.value;
      }

      if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {
        value = undefined;
      } // Check presence requirements


      var presence = this._flags.presence || options.presence;

      if (presence === 'optional') {
        if (value === undefined) {
          var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags["default"] === undefined;

          if (isDeepDefault && this._type === 'object') {
            value = {};
          } else {
            return this._finalizeValue(value, originalValue, errors, state, options);
          }
        }
      } else if (presence === 'required' && value === undefined) {
        errors.push(this.createError('any.required', null, state, options));
        return this._finalizeValue(value, originalValue, errors, state, options);
      } else if (presence === 'forbidden') {
        if (value === undefined) {
          return this._finalizeValue(value, originalValue, errors, state, options);
        }

        errors.push(this.createError('any.unknown', null, state, options));
        return this._finalizeValue(value, originalValue, errors, state, options);
      } // Check allowed and denied values using the original value


      var match = this._valids.get(value, state, options, this._flags.insensitive);

      if (match) {
        if (options.convert) {
          value = match.value;
        }

        return this._finalizeValue(value, originalValue, errors, state, options);
      }

      if (this._invalids.has(value, state, options, this._flags.insensitive)) {
        errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {
          value: value,
          invalids: this._invalids.values({
            stripUndefined: true
          })
        }, state, options));

        if (options.abortEarly) {
          return this._finalizeValue(value, originalValue, errors, state, options);
        }
      } // Convert value and validate type


      if (this._base) {
        var base = this._base(value, state, options);

        if (base.errors) {
          value = base.value;
          errors = errors.concat(base.errors);
          return this._finalizeValue(value, originalValue, errors, state, options); // Base error always aborts early
        }

        if (base.value !== value) {
          value = base.value; // Check allowed and denied values using the converted value

          match = this._valids.get(value, state, options, this._flags.insensitive);

          if (match) {
            value = match.value;
            return this._finalizeValue(value, originalValue, errors, state, options);
          }

          if (this._invalids.has(value, state, options, this._flags.insensitive)) {
            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {
              value: value,
              invalids: this._invalids.values({
                stripUndefined: true
              })
            }, state, options));

            if (options.abortEarly) {
              return this._finalizeValue(value, originalValue, errors, state, options);
            }
          }
        }
      } // Required values did not match


      if (this._flags.allowOnly) {
        errors.push(this.createError('any.allowOnly', {
          value: value,
          valids: this._valids.values({
            stripUndefined: true
          })
        }, state, options));

        if (options.abortEarly) {
          return this._finalizeValue(value, originalValue, errors, state, options);
        }
      } // Validate tests


      for (var i = 0; i < this._tests.length; ++i) {
        var test = this._tests[i];
        var ret = test.func.call(this, value, state, options);

        if (ret instanceof Errors.Err) {
          errors.push(ret);

          if (options.abortEarly) {
            return this._finalizeValue(value, originalValue, errors, state, options);
          }
        } else {
          value = ret;
        }
      }

      return this._finalizeValue(value, originalValue, errors, state, options);
    }
  }, {
    key: "_finalizeValue",
    value: function _finalizeValue(value, originalValue, errors, state, options) {
      var _this = this;

      var finalValue;

      if (value !== undefined) {
        finalValue = this._flags.raw ? originalValue : value;
      } else if (options.noDefaults) {
        finalValue = value;
      } else if (Ref.isRef(this._flags["default"])) {
        finalValue = this._flags["default"](state.parent, options);
      } else if (typeof this._flags["default"] === 'function' && !(this._flags.func && !this._flags["default"].description)) {
        var args;

        if (state.parent !== null && this._flags["default"].length > 0) {
          args = [Hoek.clone(state.parent), options];
        }

        var defaultValue = internals._try(this._flags["default"], args);

        finalValue = defaultValue.value;

        if (defaultValue.error) {
          errors.push(this.createError('any.default', {
            error: defaultValue.error
          }, state, options));
        }
      } else {
        finalValue = Hoek.clone(this._flags["default"]);
      }

      if (errors.length && typeof this._flags.error === 'function' && (!this._flags.selfError || errors.some(function (e) {
        return state.path.length === e.path.length;
      }))) {
        var change = this._flags.error.call(this, errors);

        if (typeof change === 'string') {
          errors = [this.createOverrideError('override', {
            reason: errors
          }, state, options, change)];
        } else {
          errors = [].concat(change).map(function (err) {
            return err instanceof Error ? err : _this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);
          });
        }
      }

      return {
        value: this._flags.strip ? undefined : finalValue,
        finalValue: finalValue,
        errors: errors.length ? errors : null
      };
    }
  }, {
    key: "_validateWithOptions",
    value: function _validateWithOptions(value, options, callback) {
      if (options) {
        this.checkOptions(options);
      }

      var settings = Settings.concat(internals.defaults, options);

      var result = this._validate(value, null, settings);

      var errors = Errors.process(result.errors, value);

      if (callback) {
        return callback(errors, result.value);
      }

      return {
        error: errors,
        value: result.value,
        then: function then(resolve, reject) {
          if (errors) {
            return Promise.reject(errors)["catch"](reject);
          }

          return Promise.resolve(result.value).then(resolve);
        },
        "catch": function _catch(reject) {
          if (errors) {
            return Promise.reject(errors)["catch"](reject);
          }

          return Promise.resolve(result.value);
        }
      };
    }
  }, {
    key: "validate",
    value: function validate(value, options, callback) {
      if (typeof options === 'function') {
        return this._validateWithOptions(value, null, options);
      }

      return this._validateWithOptions(value, options, callback);
    }
  }, {
    key: "describe",
    value: function describe() {
      var _this2 = this;

      var description = {
        type: this._type
      };
      var flags = Object.keys(this._flags);

      if (flags.length) {
        if (['empty', 'default', 'lazy', 'label'].some(function (flag) {
          return _this2._flags.hasOwnProperty(flag);
        })) {
          description.flags = {};

          for (var i = 0; i < flags.length; ++i) {
            var flag = flags[i];

            if (flag === 'empty') {
              description.flags[flag] = this._flags[flag].describe();
            } else if (flag === 'default') {
              if (Ref.isRef(this._flags[flag])) {
                description.flags[flag] = this._flags[flag].toString();
              } else if (typeof this._flags[flag] === 'function') {
                description.flags[flag] = {
                  description: this._flags[flag].description,
                  "function": this._flags[flag]
                };
              } else {
                description.flags[flag] = this._flags[flag];
              }
            } else if (flag === 'lazy' || flag === 'label') {// We don't want it in the description
            } else {
              description.flags[flag] = this._flags[flag];
            }
          }
        } else {
          description.flags = this._flags;
        }
      }

      if (this._settings) {
        description.options = Hoek.clone(this._settings);
      }

      if (this._baseType) {
        description.base = this._baseType.describe();
      }

      if (this._description) {
        description.description = this._description;
      }

      if (this._notes.length) {
        description.notes = this._notes;
      }

      if (this._tags.length) {
        description.tags = this._tags;
      }

      if (this._meta.length) {
        description.meta = this._meta;
      }

      if (this._examples.length) {
        description.examples = this._examples;
      }

      if (this._unit) {
        description.unit = this._unit;
      }

      var valids = this._valids.values();

      if (valids.length) {
        description.valids = valids.map(function (v) {
          return Ref.isRef(v) ? v.toString() : v;
        });
      }

      var invalids = this._invalids.values();

      if (invalids.length) {
        description.invalids = invalids.map(function (v) {
          return Ref.isRef(v) ? v.toString() : v;
        });
      }

      description.rules = [];

      for (var _i2 = 0; _i2 < this._tests.length; ++_i2) {
        var validator = this._tests[_i2];
        var item = {
          name: validator.name
        };

        if (validator.arg !== void 0) {
          item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;
        }

        var options = validator.options;

        if (options) {
          if (options.hasRef) {
            item.arg = {};
            var keys = Object.keys(validator.arg);

            for (var j = 0; j < keys.length; ++j) {
              var key = keys[j];
              var value = validator.arg[key];
              item.arg[key] = Ref.isRef(value) ? value.toString() : value;
            }
          }

          if (typeof options.description === 'string') {
            item.description = options.description;
          } else if (typeof options.description === 'function') {
            item.description = options.description(item.arg);
          }
        }

        description.rules.push(item);
      }

      if (!description.rules.length) {
        delete description.rules;
      }

      var label = this._getLabel();

      if (label) {
        description.label = label;
      }

      return description;
    }
  }, {
    key: "label",
    value: function label(name) {
      Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');
      var obj = this.clone();
      obj._flags.label = name;
      return obj;
    }
  }, {
    key: "_getLabel",
    value: function _getLabel(def) {
      return this._flags.label || def;
    }
  }, {
    key: "schemaType",
    get: function get() {
      return this._type;
    }
  }]);

  return _class;
}();

internals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects
// Aliases

internals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;
internals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;
internals.Any.prototype.exist = internals.Any.prototype.required;
internals.Any.prototype[internals.symbol] = {
  version: Pkg.version,
  compile: Cast.schema,
  root: '_currentJoi'
};

internals._try = function (fn) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var err;
  var result;

  try {
    result = fn.apply(void 0, _toConsumableArray(args));
  } catch (e) {
    err = e;
  }

  return {
    value: result,
    error: err
  };
};