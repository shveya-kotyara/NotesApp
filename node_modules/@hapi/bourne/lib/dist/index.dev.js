'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var internals = {
  suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
};

exports.parse = function (text, reviver, options) {
  // Normalize arguments
  if (!options) {
    if (reviver && _typeof(reviver) === 'object') {
      options = reviver;
      reviver = undefined;
    } else {
      options = {};
    }
  } // Parse normally, allowing exceptions


  var obj = JSON.parse(text, reviver); // options.protoAction: 'error' (default) / 'remove' / 'ignore'

  if (options.protoAction === 'ignore') {
    return obj;
  } // Ignore null and non-objects


  if (!obj || _typeof(obj) !== 'object') {
    return obj;
  } // Check original string for potential exploit


  if (!text.match(internals.suspectRx)) {
    return obj;
  } // Scan result for proto keys


  exports.scan(obj, options);
  return obj;
};

exports.scan = function (obj, options) {
  options = options || {};
  var next = [obj];

  while (next.length) {
    var nodes = next;
    next = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;

        if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {
          // Avoid calling node.hasOwnProperty directly
          if (options.protoAction !== 'remove') {
            throw new SyntaxError('Object contains forbidden prototype property');
          }

          delete node.__proto__;
        }

        for (var key in node) {
          var value = node[key];

          if (value && _typeof(value) === 'object') {
            next.push(node[key]);
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
};

exports.safeParse = function (text, reviver) {
  try {
    return exports.parse(text, reviver);
  } catch (ignoreError) {
    return null;
  }
};