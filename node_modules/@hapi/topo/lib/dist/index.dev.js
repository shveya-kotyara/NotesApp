'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Assert = require('@hapi/hoek/lib/assert');

var internals = {};

module.exports =
/*#__PURE__*/
function () {
  function Topo() {
    _classCallCheck(this, Topo);

    this._items = [];
    this.nodes = [];
  }

  _createClass(Topo, [{
    key: "add",
    value: function add(nodes, options) {
      options = options || {}; // Validate rules

      var before = [].concat(options.before || []);
      var after = [].concat(options.after || []);
      var group = options.group || '?';
      var sort = options.sort || 0; // Used for merging only

      Assert(!before.includes(group), "Item cannot come before itself: ".concat(group));
      Assert(!before.includes('?'), 'Item cannot come before unassociated items');
      Assert(!after.includes(group), "Item cannot come after itself: ".concat(group));
      Assert(!after.includes('?'), 'Item cannot come after unassociated items');

      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;
          var item = {
            seq: this._items.length,
            sort: sort,
            before: before,
            after: after,
            group: group,
            node: node
          };

          this._items.push(item);
        } // Insert event

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var valid = this._sort();

      Assert(valid, 'item', group !== '?' ? "added into group ".concat(group) : '', 'created a dependencies error');
      return this.nodes;
    }
  }, {
    key: "merge",
    value: function merge(others) {
      if (!Array.isArray(others)) {
        others = [others];
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = others[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var other = _step2.value;

          if (other) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = other._items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var item = _step3.value;

                this._items.push(Object.assign({}, item)); // Shallow cloned

              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        } // Sort items

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this._items.sort(internals.mergeSort);

      for (var i = 0; i < this._items.length; ++i) {
        this._items[i].seq = i;
      }

      var valid = this._sort();

      Assert(valid, 'merge created a dependencies error');
      return this.nodes;
    }
  }, {
    key: "_sort",
    value: function _sort() {
      // Construct graph
      var graph = {};
      var graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives

      var groups = Object.create(null);
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._items[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var item = _step4.value;
          var seq = item.seq; // Unique across all items

          var _group2 = item.group; // Determine Groups

          groups[_group2] = groups[_group2] || [];

          groups[_group2].push(seq); // Build intermediary graph using 'before'


          graph[seq] = item.before; // Build second intermediary graph with 'after'

          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = item.after[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var after = _step8.value;
              graphAfters[after] = graphAfters[after] || [];
              graphAfters[after].push(seq);
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                _iterator8["return"]();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        } // Expand intermediary graph

      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      for (var node in graph) {
        var expandedGroups = [];

        for (var graphNodeItem in graph[node]) {
          var group = graph[node][graphNodeItem];
          groups[group] = groups[group] || [];
          expandedGroups.push.apply(expandedGroups, _toConsumableArray(groups[group]));
        }

        graph[node] = expandedGroups;
      } // Merge intermediary graph using graphAfters into final graph


      for (var _group in graphAfters) {
        if (groups[_group]) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = groups[_group][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _graph$_node;

              var _node = _step5.value;

              (_graph$_node = graph[_node]).push.apply(_graph$_node, _toConsumableArray(graphAfters[_group]));
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      } // Compile ancestors


      var ancestors = {};

      for (var _node2 in graph) {
        var children = graph[_node2];
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = children[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var child = _step6.value;
            ancestors[child] = ancestors[child] || [];
            ancestors[child].push(_node2);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      } // Topo sort


      var visited = {};
      var sorted = [];

      for (var i = 0; i < this._items.length; ++i) {
        // Looping through item.seq values out of order
        var next = i;

        if (ancestors[i]) {
          next = null;

          for (var j = 0; j < this._items.length; ++j) {
            // As above, these are item.seq values
            if (visited[j] === true) {
              continue;
            }

            if (!ancestors[j]) {
              ancestors[j] = [];
            }

            var shouldSeeCount = ancestors[j].length;
            var seenCount = 0;

            for (var k = 0; k < shouldSeeCount; ++k) {
              if (visited[ancestors[j][k]]) {
                ++seenCount;
              }
            }

            if (seenCount === shouldSeeCount) {
              next = j;
              break;
            }
          }
        }

        if (next !== null) {
          visited[next] = true;
          sorted.push(next);
        }
      }

      if (sorted.length !== this._items.length) {
        return false;
      }

      var seqIndex = {};
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this._items[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _item = _step7.value;
          seqIndex[_item.seq] = _item;
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      this._items = [];
      this.nodes = [];

      for (var _i = 0, _sorted = sorted; _i < _sorted.length; _i++) {
        var value = _sorted[_i];
        var sortedItem = seqIndex[value];
        this.nodes.push(sortedItem.node);

        this._items.push(sortedItem);
      }

      return true;
    }
  }]);

  return Topo;
}();

internals.mergeSort = function (a, b) {
  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
};