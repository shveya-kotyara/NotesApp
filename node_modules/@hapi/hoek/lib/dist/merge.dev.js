'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Assert = require('./assert');

var Clone = require('./clone');

var Utils = require('./utils');

var internals = {};

module.exports = internals.merge = function (target, source, options) {
  Assert(target && _typeof(target) === 'object', 'Invalid target value: must be an object');
  Assert(source === null || source === undefined || _typeof(source) === 'object', 'Invalid source value: must be null, undefined, or an object');

  if (!source) {
    return target;
  }

  options = Object.assign({
    nullOverride: true,
    mergeArrays: true
  }, options);

  if (Array.isArray(source)) {
    Assert(Array.isArray(target), 'Cannot merge array onto an object');

    if (!options.mergeArrays) {
      target.length = 0; // Must not change target assignment
    }

    for (var i = 0; i < source.length; ++i) {
      target.push(Clone(source[i], {
        symbols: options.symbols
      }));
    }

    return target;
  }

  var keys = Utils.keys(source, options);

  for (var _i = 0; _i < keys.length; ++_i) {
    var key = keys[_i];

    if (key === '__proto__' || !Object.prototype.propertyIsEnumerable.call(source, key)) {
      continue;
    }

    var value = source[key];

    if (value && _typeof(value) === 'object') {
      if (!target[key] || _typeof(target[key]) !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || // $lab:coverage:ignore$
      value instanceof RegExp) {
        target[key] = Clone(value, {
          symbols: options.symbols
        });
      } else {
        internals.merge(target[key], value, options);
      }
    } else {
      if (value !== null && value !== undefined) {
        // Explicit to preserve empty strings
        target[key] = value;
      } else if (options.nullOverride) {
        target[key] = value;
      }
    }
  }

  return target;
};