'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Assert = require('./assert');

var DeepEqual = require('./deepEqual');

var EscapeRegex = require('./escapeRegex');

var Utils = require('./utils');

var internals = {};

module.exports = function (ref, values) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // options: { deep, once, only, part, symbols }

  /*
      string -> string(s)
      array -> item(s)
      object -> key(s)
      object -> object (key:value)
  */
  if (_typeof(values) !== 'object') {
    values = [values];
  }

  Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty'); // String

  if (typeof ref === 'string') {
    return internals.string(ref, values, options);
  } // Array


  if (Array.isArray(ref)) {
    return internals.array(ref, values, options);
  } // Object


  Assert(_typeof(ref) === 'object', 'Reference must be string or an object');
  return internals.object(ref, values, options);
};

internals.array = function (ref, values, options) {
  if (!Array.isArray(values)) {
    values = [values];
  }

  if (!ref.length) {
    return false;
  }

  if (options.only && options.once && ref.length !== values.length) {
    return false;
  }

  var compare; // Map values

  var map = new Map();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      if (!options.deep || !value || _typeof(value) !== 'object') {
        var existing = map.get(value);

        if (existing) {
          ++existing.allowed;
        } else {
          map.set(value, {
            allowed: 1,
            hits: 0
          });
        }
      } else {
        compare = compare || internals.compare(options);
        var found = false;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = map.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = _slicedToArray(_step4.value, 2),
                key = _step4$value[0],
                _existing = _step4$value[1];

            if (compare(key, value)) {
              ++_existing.allowed;
              found = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        if (!found) {
          map.set(value, {
            allowed: 1,
            hits: 0
          });
        }
      }
    } // Lookup values

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var hits = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = ref[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var item = _step2.value;
      var match = void 0;

      if (!options.deep || !item || _typeof(item) !== 'object') {
        match = map.get(item);
      } else {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = map.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _step5$value = _slicedToArray(_step5.value, 2),
                _key = _step5$value[0],
                _existing2 = _step5$value[1];

            if (compare(_key, item)) {
              match = _existing2;
              break;
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }

      if (match) {
        ++match.hits;
        ++hits;

        if (options.once && match.hits > match.allowed) {
          return false;
        }
      }
    } // Validate results

  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (options.only && hits !== ref.length) {
    return false;
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = map.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _match = _step3.value;

      if (_match.hits === _match.allowed) {
        continue;
      }

      if (_match.hits < _match.allowed && !options.part) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return !!hits;
};

internals.object = function (ref, values, options) {
  Assert(options.once === undefined, 'Cannot use option once with object');
  var keys = Utils.keys(ref, options);

  if (!keys.length) {
    return false;
  } // Keys list


  if (Array.isArray(values)) {
    return internals.array(keys, values, options);
  } // Key value pairs


  var symbols = Object.getOwnPropertySymbols(values).filter(function (sym) {
    return values.propertyIsEnumerable(sym);
  });
  var targets = [].concat(_toConsumableArray(Object.keys(values)), _toConsumableArray(symbols));
  var compare = internals.compare(options);
  var set = new Set(targets);
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = keys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var key = _step6.value;

      if (!set.has(key)) {
        if (options.only) {
          return false;
        }

        continue;
      }

      if (!compare(values[key], ref[key])) {
        return false;
      }

      set["delete"](key);
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  if (set.size) {
    return options.part ? set.size < targets.length : false;
  }

  return true;
};

internals.string = function (ref, values, options) {
  // Empty string
  if (ref === '') {
    return values.length === 1 && values[0] === '' || // '' contains ''
    !options.once && !values.some(function (v) {
      return v !== '';
    }); // '' contains multiple '' if !once
  } // Map values


  var map = new Map();
  var patterns = [];
  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = values[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var value = _step7.value;
      Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');

      if (value) {
        var existing = map.get(value);

        if (existing) {
          ++existing.allowed;
        } else {
          map.set(value, {
            allowed: 1,
            hits: 0
          });
          patterns.push(EscapeRegex(value));
        }
      } else if (options.once || options.only) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
        _iterator7["return"]();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  if (!patterns.length) {
    // Non-empty string contains unlimited empty string
    return true;
  } // Match patterns


  var regex = new RegExp("(".concat(patterns.join('|'), ")"), 'g');
  var leftovers = ref.replace(regex, function ($0, $1) {
    ++map.get($1).hits;
    return ''; // Remove from string
  }); // Validate results

  if (options.only && leftovers) {
    return false;
  }

  var any = false;
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = map.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var match = _step8.value;

      if (match.hits) {
        any = true;
      }

      if (match.hits === match.allowed) {
        continue;
      }

      if (match.hits < match.allowed && !options.part) {
        return false;
      } // match.hits > match.allowed


      if (options.once) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
        _iterator8["return"]();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  return !!any;
};

internals.compare = function (options) {
  if (!options.deep) {
    return internals.shallow;
  }

  var hasOnly = options.only !== undefined;
  var hasPart = options.part !== undefined;
  var flags = {
    prototype: hasOnly ? options.only : hasPart ? !options.part : false,
    part: hasOnly ? !options.only : hasPart ? options.part : false
  };
  return function (a, b) {
    return DeepEqual(a, b, flags);
  };
};

internals.shallow = function (a, b) {
  return a === b;
};