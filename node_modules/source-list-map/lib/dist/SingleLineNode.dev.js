/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var base64VLQ = require("./base64-vlq");

var getNumberOfLines = require("./helpers").getNumberOfLines;

var getUnfinishedLine = require("./helpers").getUnfinishedLine;

var LINE_MAPPING = ";AAAA";

var SingleLineNode =
/*#__PURE__*/
function () {
  function SingleLineNode(generatedCode, source, originalSource, line) {
    _classCallCheck(this, SingleLineNode);

    this.generatedCode = generatedCode;
    this.originalSource = originalSource;
    this.source = source;
    this.line = line || 1;
    this._numberOfLines = getNumberOfLines(this.generatedCode);
    this._endsWithNewLine = generatedCode[generatedCode.length - 1] === "\n";
  }

  _createClass(SingleLineNode, [{
    key: "clone",
    value: function clone() {
      return new SingleLineNode(this.generatedCode, this.source, this.originalSource, this.line);
    }
  }, {
    key: "getGeneratedCode",
    value: function getGeneratedCode() {
      return this.generatedCode;
    }
  }, {
    key: "getMappings",
    value: function getMappings(mappingsContext) {
      if (!this.generatedCode) return "";
      var lines = this._numberOfLines;
      var sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);
      var mappings = "A"; // generated column 0

      if (mappingsContext.unfinishedGeneratedLine) mappings = "," + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);
      mappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index

      mappings += base64VLQ.encode(this.line - mappingsContext.currentOriginalLine); // original line index

      mappings += "A"; // original column 0

      mappingsContext.currentSource = sourceIdx;
      mappingsContext.currentOriginalLine = this.line;
      var unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode);
      mappings += Array(lines).join(LINE_MAPPING);

      if (unfinishedGeneratedLine === 0) {
        mappings += ";";
      } else {
        if (lines !== 0) mappings += LINE_MAPPING;
      }

      return mappings;
    }
  }, {
    key: "getNormalizedNodes",
    value: function getNormalizedNodes() {
      return [this];
    }
  }, {
    key: "mapGeneratedCode",
    value: function mapGeneratedCode(fn) {
      var generatedCode = fn(this.generatedCode);
      return new SingleLineNode(generatedCode, this.source, this.originalSource, this.line);
    }
  }, {
    key: "merge",
    value: function merge(otherNode) {
      if (otherNode instanceof SingleLineNode) {
        return this.mergeSingleLineNode(otherNode);
      }

      return false;
    }
  }, {
    key: "mergeSingleLineNode",
    value: function mergeSingleLineNode(otherNode) {
      if (this.source === otherNode.source && this.originalSource === otherNode.originalSource) {
        if (this.line === otherNode.line) {
          this.generatedCode += otherNode.generatedCode;
          this._numberOfLines += otherNode._numberOfLines;
          this._endsWithNewLine = otherNode._endsWithNewLine;
          return this;
        } else if (this.line + 1 === otherNode.line && this._endsWithNewLine && this._numberOfLines === 1 && otherNode._numberOfLines <= 1) {
          return new SourceNode(this.generatedCode + otherNode.generatedCode, this.source, this.originalSource, this.line);
        }
      }

      return false;
    }
  }]);

  return SingleLineNode;
}();

module.exports = SingleLineNode;

var SourceNode = require("./SourceNode"); // circular dependency