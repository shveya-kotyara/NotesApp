/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var CodeNode = require("./CodeNode");

var SourceNode = require("./SourceNode");

var MappingsContext = require("./MappingsContext");

var getNumberOfLines = require("./helpers").getNumberOfLines;

var SourceListMap =
/*#__PURE__*/
function () {
  function SourceListMap(generatedCode, source, originalSource) {
    _classCallCheck(this, SourceListMap);

    if (Array.isArray(generatedCode)) {
      this.children = generatedCode;
    } else {
      this.children = [];
      if (generatedCode || source) this.add(generatedCode, source, originalSource);
    }
  }

  _createClass(SourceListMap, [{
    key: "add",
    value: function add(generatedCode, source, originalSource) {
      if (typeof generatedCode === "string") {
        if (source) {
          this.children.push(new SourceNode(generatedCode, source, originalSource));
        } else if (this.children.length > 0 && this.children[this.children.length - 1] instanceof CodeNode) {
          this.children[this.children.length - 1].addGeneratedCode(generatedCode);
        } else {
          this.children.push(new CodeNode(generatedCode));
        }
      } else if (generatedCode.getMappings && generatedCode.getGeneratedCode) {
        this.children.push(generatedCode);
      } else if (generatedCode.children) {
        generatedCode.children.forEach(function (sln) {
          this.children.push(sln);
        }, this);
      } else {
        throw new Error("Invalid arguments to SourceListMap.protfotype.add: Expected string, Node or SourceListMap");
      }
    }
  }, {
    key: "preprend",
    value: function preprend(generatedCode, source, originalSource) {
      if (typeof generatedCode === "string") {
        if (source) {
          this.children.unshift(new SourceNode(generatedCode, source, originalSource));
        } else if (this.children.length > 0 && this.children[this.children.length - 1].preprendGeneratedCode) {
          this.children[this.children.length - 1].preprendGeneratedCode(generatedCode);
        } else {
          this.children.unshift(new CodeNode(generatedCode));
        }
      } else if (generatedCode.getMappings && generatedCode.getGeneratedCode) {
        this.children.unshift(generatedCode);
      } else if (generatedCode.children) {
        generatedCode.children.slice().reverse().forEach(function (sln) {
          this.children.unshift(sln);
        }, this);
      } else {
        throw new Error("Invalid arguments to SourceListMap.protfotype.prerend: Expected string, Node or SourceListMap");
      }
    }
  }, {
    key: "mapGeneratedCode",
    value: function mapGeneratedCode(fn) {
      var normalizedNodes = [];
      this.children.forEach(function (sln) {
        sln.getNormalizedNodes().forEach(function (newNode) {
          normalizedNodes.push(newNode);
        });
      });
      var optimizedNodes = [];
      normalizedNodes.forEach(function (sln) {
        sln = sln.mapGeneratedCode(fn);

        if (optimizedNodes.length === 0) {
          optimizedNodes.push(sln);
        } else {
          var last = optimizedNodes[optimizedNodes.length - 1];
          var mergedNode = last.merge(sln);

          if (mergedNode) {
            optimizedNodes[optimizedNodes.length - 1] = mergedNode;
          } else {
            optimizedNodes.push(sln);
          }
        }
      });
      return new SourceListMap(optimizedNodes);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.children.map(function (sln) {
        return sln.getGeneratedCode();
      }).join("");
    }
  }, {
    key: "toStringWithSourceMap",
    value: function toStringWithSourceMap(options) {
      var mappingsContext = new MappingsContext();
      var source = this.children.map(function (sln) {
        return sln.getGeneratedCode();
      }).join("");
      var mappings = this.children.map(function (sln) {
        return sln.getMappings(mappingsContext);
      }).join("");
      var arrays = mappingsContext.getArrays();
      return {
        source: source,
        map: {
          version: 3,
          file: options && options.file,
          sources: arrays.sources,
          sourcesContent: mappingsContext.hasSourceContent ? arrays.sourcesContent : undefined,
          mappings: mappings
        }
      };
    }
  }]);

  return SourceListMap;
}();

module.exports = SourceListMap;