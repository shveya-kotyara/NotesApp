"use strict";

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file at
 * https://github.com/facebookincubator/create-react-app/blob/master/LICENSE
 *
 * Modified by Yuxi Evan You
 */
var fs = require('fs');

var os = require('os');

var path = require('path');

var chalk = require('chalk');

var childProcess = require('child_process');

var guessEditor = require('./guess');

var getArgumentsForPosition = require('./get-args');

function wrapErrorCallback(cb) {
  return function (fileName, errorMessage) {
    console.log();
    console.log(chalk.red('Could not open ' + path.basename(fileName) + ' in the editor.'));

    if (errorMessage) {
      if (errorMessage[errorMessage.length - 1] !== '.') {
        errorMessage += '.';
      }

      console.log(chalk.red('The editor process exited with an error: ' + errorMessage));
    }

    console.log();
    if (cb) cb(fileName, errorMessage);
  };
}

function isTerminalEditor(editor) {
  switch (editor) {
    case 'vim':
    case 'emacs':
    case 'nano':
      return true;
  }

  return false;
}

var positionRE = /:(\d+)(:(\d+))?$/;

function parseFile(file) {
  var fileName = file.replace(positionRE, '');
  var match = file.match(positionRE);
  var lineNumber = match && match[1];
  var columnNumber = match && match[3];
  return {
    fileName: fileName,
    lineNumber: lineNumber,
    columnNumber: columnNumber
  };
}

var _childProcess = null;

function launchEditor(file, specifiedEditor, onErrorCallback) {
  var parsed = parseFile(file);
  var fileName = parsed.fileName;
  var lineNumber = parsed.lineNumber,
      columnNumber = parsed.columnNumber;

  if (!fs.existsSync(fileName)) {
    return;
  }

  if (typeof specifiedEditor === 'function') {
    onErrorCallback = specifiedEditor;
    specifiedEditor = undefined;
  }

  onErrorCallback = wrapErrorCallback(onErrorCallback);

  var _guessEditor = guessEditor(specifiedEditor),
      _guessEditor2 = _toArray(_guessEditor),
      editor = _guessEditor2[0],
      args = _guessEditor2.slice(1);

  if (!editor) {
    onErrorCallback(fileName, null);
    return;
  }

  if (process.platform === 'linux' && fileName.startsWith('/mnt/') && /Microsoft/i.test(os.release())) {
    // Assume WSL / "Bash on Ubuntu on Windows" is being used, and
    // that the file exists on the Windows file system.
    // `os.release()` is "4.4.0-43-Microsoft" in the current release
    // build of WSL, see: https://github.com/Microsoft/BashOnWindows/issues/423#issuecomment-221627364
    // When a Windows editor is specified, interop functionality can
    // handle the path translation, but only if a relative path is used.
    fileName = path.relative('', fileName);
  }

  if (lineNumber) {
    var extraArgs = getArgumentsForPosition(editor, fileName, lineNumber, columnNumber);
    args.push.apply(args, extraArgs);
  } else {
    args.push(fileName);
  }

  if (_childProcess && isTerminalEditor(editor)) {
    // There's an existing editor process already and it's attached
    // to the terminal, so go kill it. Otherwise two separate editor
    // instances attach to the stdin/stdout which gets confusing.
    _childProcess.kill('SIGKILL');
  }

  if (process.platform === 'win32') {
    // On Windows, launch the editor in a shell because spawn can only
    // launch .exe files.
    _childProcess = childProcess.spawn('cmd.exe', ['/C', editor].concat(args), {
      stdio: 'inherit'
    });
  } else {
    _childProcess = childProcess.spawn(editor, args, {
      stdio: 'inherit'
    });
  }

  _childProcess.on('exit', function (errorCode) {
    _childProcess = null;

    if (errorCode) {
      onErrorCallback(fileName, '(code ' + errorCode + ')');
    }
  });

  _childProcess.on('error', function (error) {
    onErrorCallback(fileName, error.message);
  });
}

module.exports = launchEditor;