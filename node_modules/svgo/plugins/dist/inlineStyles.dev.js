'use strict';

exports.type = 'full';
exports.active = true;
exports.params = {
  onlyMatchedOnce: true,
  removeMatchedSelectors: true,
  useMqs: ['', 'screen'],
  usePseudos: ['']
};
exports.description = 'inline styles (additional options)';

var csstree = require('css-tree'),
    cssTools = require('../lib/css-tools');
/**
 * Moves + merges styles from style elements to element styles
 *
 * Options
 *   onlyMatchedOnce (default: true)
 *     inline only selectors that match once
 *
 *   removeMatchedSelectors (default: true)
 *     clean up matched selectors,
 *     leave selectors that hadn't matched
 *
 *   useMqs (default: ['', 'screen'])
 *     what media queries to be used
 *     empty string element for styles outside media queries
 *
 *   usePseudos (default: [''])
 *     what pseudo-classes/-elements to be used
 *     empty string element for all non-pseudo-classes and/or -elements
 *
 * @param {Object} document document element
 * @param {Object} opts plugin params
 *
 * @author strarsis <strarsis@gmail.com>
 */


exports.fn = function (document, opts) {
  // collect <style/>s
  var styleEls = document.querySelectorAll('style'); //no <styles/>s, nothing to do

  if (styleEls === null) {
    return document;
  }

  var styles = [],
      selectors = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = styleEls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var styleEl = _step.value;

      if (styleEl.isEmpty() || styleEl.closestElem('foreignObject')) {
        // skip empty <style/>s or <foreignObject> content.
        continue;
      }

      var cssStr = cssTools.getCssStr(styleEl); // collect <style/>s and their css ast

      var cssAst = {};

      try {
        cssAst = csstree.parse(cssStr, {
          parseValue: false,
          parseCustomProperty: false
        });
      } catch (parseError) {
        // console.warn('Warning: Parse error of styles of <style/> element, skipped. Error details: ' + parseError);
        continue;
      }

      styles.push({
        styleEl: styleEl,
        cssAst: cssAst
      });
      selectors = selectors.concat(cssTools.flattenToSelectors(cssAst));
    } // filter for mediaqueries to be used or without any mediaquery

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var selectorsMq = cssTools.filterByMqs(selectors, opts.useMqs); // filter for pseudo elements to be used

  var selectorsPseudo = cssTools.filterByPseudos(selectorsMq, opts.usePseudos); // remove PseudoClass from its SimpleSelector for proper matching

  cssTools.cleanPseudos(selectorsPseudo); // stable sort selectors

  var sortedSelectors = cssTools.sortSelectors(selectorsPseudo).reverse();
  var selector, selectedEl; // match selectors

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = sortedSelectors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      selector = _step2.value;
      var selectorStr = csstree.generate(selector.item.data),
          selectedEls = null;

      try {
        selectedEls = document.querySelectorAll(selectorStr);
      } catch (selectError) {
        if (selectError.constructor === SyntaxError) {
          // console.warn('Warning: Syntax error when trying to select \n\n' + selectorStr + '\n\n, skipped. Error details: ' + selectError);
          continue;
        }

        throw selectError;
      }

      if (selectedEls === null) {
        // nothing selected
        continue;
      }

      selector.selectedEls = selectedEls;
    } // apply <style/> styles to matched elements

  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = sortedSelectors[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      selector = _step3.value;

      if (!selector.selectedEls) {
        continue;
      }

      if (opts.onlyMatchedOnce && selector.selectedEls !== null && selector.selectedEls.length > 1) {
        // skip selectors that match more than once if option onlyMatchedOnce is enabled
        continue;
      } // apply <style/> to matched elements


      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = selector.selectedEls[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          selectedEl = _step5.value;

          if (selector.rule === null) {
            continue;
          } // merge declarations


          csstree.walk(selector.rule, {
            visit: 'Declaration',
            enter: function enter(styleCsstreeDeclaration) {
              // existing inline styles have higher priority
              // no inline styles, external styles,                                    external styles used
              // inline styles,    external styles same   priority as inline styles,   inline   styles used
              // inline styles,    external styles higher priority than inline styles, external styles used
              var styleDeclaration = cssTools.csstreeToStyleDeclaration(styleCsstreeDeclaration);

              if (selectedEl.style.getPropertyValue(styleDeclaration.name) !== null && selectedEl.style.getPropertyPriority(styleDeclaration.name) >= styleDeclaration.priority) {
                return;
              }

              selectedEl.style.setProperty(styleDeclaration.name, styleDeclaration.value, styleDeclaration.priority);
            }
          });
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      if (opts.removeMatchedSelectors && selector.selectedEls !== null && selector.selectedEls.length > 0) {
        // clean up matching simple selectors if option removeMatchedSelectors is enabled
        selector.rule.prelude.children.remove(selector.item);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (!opts.removeMatchedSelectors) {
    return document; // no further processing required
  } // clean up matched class + ID attribute values


  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = sortedSelectors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      selector = _step4.value;

      if (!selector.selectedEls) {
        continue;
      }

      if (opts.onlyMatchedOnce && selector.selectedEls !== null && selector.selectedEls.length > 1) {
        // skip selectors that match more than once if option onlyMatchedOnce is enabled
        continue;
      }

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = selector.selectedEls[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          selectedEl = _step6.value;
          // class
          var firstSubSelector = selector.item.data.children.first();

          if (firstSubSelector.type === 'ClassSelector') {
            selectedEl["class"].remove(firstSubSelector.name);
          } // clean up now empty class attributes


          if (typeof selectedEl["class"].item(0) === 'undefined') {
            selectedEl.removeAttr('class');
          } // ID


          if (firstSubSelector.type === 'IdSelector') {
            selectedEl.removeAttr('id', firstSubSelector.name);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    } // clean up now empty elements

  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  for (var _i = 0, _styles = styles; _i < _styles.length; _i++) {
    var style = _styles[_i];
    csstree.walk(style.cssAst, {
      visit: 'Rule',
      enter: function enter(node, item, list) {
        // clean up <style/> atrules without any rulesets left
        if (node.type === 'Atrule' && // only Atrules containing rulesets
        node.block !== null && node.block.children.isEmpty()) {
          list.remove(item);
          return;
        } // clean up <style/> rulesets without any css selectors left


        if (node.type === 'Rule' && node.prelude.children.isEmpty()) {
          list.remove(item);
        }
      }
    });

    if (style.cssAst.children.isEmpty()) {
      // clean up now emtpy <style/>s
      var styleParentEl = style.styleEl.parentNode;
      styleParentEl.spliceContent(styleParentEl.content.indexOf(style.styleEl), 1);

      if (styleParentEl.elem === 'defs' && styleParentEl.content.length === 0) {
        // also clean up now empty <def/>s
        var defsParentEl = styleParentEl.parentNode;
        defsParentEl.spliceContent(defsParentEl.content.indexOf(styleParentEl), 1);
      }

      continue;
    } // update existing, left over <style>s


    cssTools.setCssStr(style.styleEl, csstree.generate(style.cssAst));
  }

  return document;
};