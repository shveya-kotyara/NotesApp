'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var inspect = require('util').inspect;

var isPromise = require('./is-promise');

var _require = require('./middleware'),
    applyMiddleware = _require.applyMiddleware,
    commandMiddlewareFactory = _require.commandMiddlewareFactory;

var path = require('path');

var Parser = require('yargs-parser');

var DEFAULT_MARKER = /(^\*)|(^\$0)/; // handles parsing positional arguments,
// and populating argv with said positional
// arguments.

module.exports = function command(yargs, usage, validation, globalMiddleware) {
  var self = {};
  var handlers = {};
  var aliasMap = {};
  var defaultCommand;
  globalMiddleware = globalMiddleware || [];

  self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware) {
    var aliases = [];
    var middlewares = commandMiddlewareFactory(commandMiddleware);

    handler = handler || function () {};

    if (Array.isArray(cmd)) {
      aliases = cmd.slice(1);
      cmd = cmd[0];
    } else if (_typeof(cmd) === 'object') {
      var _command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);

      if (cmd.aliases) _command = [].concat(_command).concat(cmd.aliases);
      self.addHandler(_command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares);
      return;
    } // allow a module to be provided instead of separate builder and handler


    if (_typeof(builder) === 'object' && builder.builder && typeof builder.handler === 'function') {
      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares);
      return;
    } // parse positionals out of cmd string


    var parsedCommand = self.parseCommand(cmd); // remove positional args from aliases only

    aliases = aliases.map(function (alias) {
      return self.parseCommand(alias).cmd;
    }); // check for default and filter out '*''

    var isDefault = false;
    var parsedAliases = [parsedCommand.cmd].concat(aliases).filter(function (c) {
      if (DEFAULT_MARKER.test(c)) {
        isDefault = true;
        return false;
      }

      return true;
    }); // standardize on $0 for default command.

    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0'); // shift cmd and aliases after filtering out '*'

    if (isDefault) {
      parsedCommand.cmd = parsedAliases[0];
      aliases = parsedAliases.slice(1);
      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
    } // populate aliasMap


    aliases.forEach(function (alias) {
      aliasMap[alias] = parsedCommand.cmd;
    });

    if (description !== false) {
      usage.command(cmd, description, isDefault, aliases);
    }

    handlers[parsedCommand.cmd] = {
      original: cmd,
      description: description,
      handler: handler,
      builder: builder || {},
      middlewares: middlewares || [],
      demanded: parsedCommand.demanded,
      optional: parsedCommand.optional
    };
    if (isDefault) defaultCommand = handlers[parsedCommand.cmd];
  };

  self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {
    opts = opts || {}; // disable recursion to support nested directories of subcommands

    if (typeof opts.recurse !== 'boolean') opts.recurse = false; // exclude 'json', 'coffee' from require-directory defaults

    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']; // allow consumer to define their own visitor function

    var parentVisit = typeof opts.visit === 'function' ? opts.visit : function (o) {
      return o;
    }; // call addHandler via visitor function

    opts.visit = function visit(obj, joined, filename) {
      var visited = parentVisit(obj, joined, filename); // allow consumer to skip modules with their own visitor

      if (visited) {
        // check for cyclic reference
        // each command file path should only be seen once per execution
        if (~context.files.indexOf(joined)) return visited; // keep track of visited files in context.files

        context.files.push(joined);
        self.addHandler(visited);
      }

      return visited;
    };

    require('require-directory')({
      require: req,
      filename: callerFile
    }, dir, opts);
  }; // lookup module object from require()d command and derive name
  // if module was not require()d and no name given, throw error


  function moduleName(obj) {
    var mod = require('which-module')(obj);

    if (!mod) throw new Error("No command name given for module: ".concat(inspect(obj)));
    return commandFromFilename(mod.filename);
  } // derive command name from filename


  function commandFromFilename(filename) {
    return path.basename(filename, path.extname(filename));
  }

  function extractDesc(obj) {
    for (var keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {
      test = obj[keys[i]];
      if (typeof test === 'string' || typeof test === 'boolean') return test;
    }

    return false;
  }

  self.parseCommand = function parseCommand(cmd) {
    var extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
    var splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
    var bregex = /\.*[\][<>]/g;
    var parsedCommand = {
      cmd: splitCommand.shift().replace(bregex, ''),
      demanded: [],
      optional: []
    };
    splitCommand.forEach(function (cmd, i) {
      var variadic = false;
      cmd = cmd.replace(/\s/g, '');
      if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;

      if (/^\[/.test(cmd)) {
        parsedCommand.optional.push({
          cmd: cmd.replace(bregex, '').split('|'),
          variadic: variadic
        });
      } else {
        parsedCommand.demanded.push({
          cmd: cmd.replace(bregex, '').split('|'),
          variadic: variadic
        });
      }
    });
    return parsedCommand;
  };

  self.getCommands = function () {
    return Object.keys(handlers).concat(Object.keys(aliasMap));
  };

  self.getCommandHandlers = function () {
    return handlers;
  };

  self.hasDefaultCommand = function () {
    return !!defaultCommand;
  };

  self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {
    var aliases = parsed.aliases;
    var commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;
    var currentContext = yargs.getContext();
    var numFiles = currentContext.files.length;
    var parentCommands = currentContext.commands.slice(); // what does yargs look like after the buidler is run?

    var innerArgv = parsed.argv;
    var innerYargs = null;
    var positionalMap = {};

    if (command) {
      currentContext.commands.push(command);
      currentContext.fullCommands.push(commandHandler.original);
    }

    if (typeof commandHandler.builder === 'function') {
      // a function can be provided, which builds
      // up a yargs chain and possibly returns it.
      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases)); // if the builder function did not yet parse argv with reset yargs
      // and did not explicitly set a usage() string, then apply the
      // original command string as usage() for consistent behavior with
      // options object below.

      if (yargs.parsed === false) {
        if (shouldUpdateUsage(yargs)) {
          yargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
        }

        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex);
      } else {
        innerArgv = yargs.parsed.argv;
      }

      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases;else aliases = yargs.parsed.aliases;
    } else if (_typeof(commandHandler.builder) === 'object') {
      // as a short hand, an object can instead be provided, specifying
      // the options that a command takes.
      innerYargs = yargs.reset(parsed.aliases);

      if (shouldUpdateUsage(innerYargs)) {
        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
      }

      Object.keys(commandHandler.builder).forEach(function (key) {
        innerYargs.option(key, commandHandler.builder[key]);
      });
      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
      aliases = innerYargs.parsed.aliases;
    }

    if (!yargs._hasOutput()) {
      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs);
    }

    var middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares || []);
    applyMiddleware(innerArgv, yargs, middlewares, true); // we apply validation post-hoc, so that custom
    // checks get passed populated positional arguments.

    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error);

    if (commandHandler.handler && !yargs._hasOutput()) {
      yargs._setHasOutput();

      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
      var handlerResult = isPromise(innerArgv) ? innerArgv.then(function (argv) {
        return commandHandler.handler(argv);
      }) : commandHandler.handler(innerArgv);

      if (isPromise(handlerResult)) {
        handlerResult["catch"](function (error) {
          return yargs.getUsageInstance().fail(null, error);
        });
      }
    }

    if (command) {
      currentContext.commands.pop();
      currentContext.fullCommands.pop();
    }

    numFiles = currentContext.files.length - numFiles;
    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);
    return innerArgv;
  };

  function shouldUpdateUsage(yargs) {
    return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;
  }

  function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
    var c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;
    var pc = parentCommands.filter(function (c) {
      return !DEFAULT_MARKER.test(c);
    });
    pc.push(c);
    return "$0 ".concat(pc.join(' '));
  }

  self.runDefaultBuilderOn = function (yargs) {
    if (shouldUpdateUsage(yargs)) {
      // build the root-level command string from the default string.
      var commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
      yargs.getUsageInstance().usage(commandString, defaultCommand.description);
    }

    var builder = defaultCommand.builder;

    if (typeof builder === 'function') {
      builder(yargs);
    } else {
      Object.keys(builder).forEach(function (key) {
        yargs.option(key, builder[key]);
      });
    }
  }; // transcribe all positional arguments "command <foo> <bar> [apple]"
  // onto argv.


  function populatePositionals(commandHandler, argv, context, yargs) {
    argv._ = argv._.slice(context.commands.length); // nuke the current commands

    var demanded = commandHandler.demanded.slice(0);
    var optional = commandHandler.optional.slice(0);
    var positionalMap = {};
    validation.positionalCount(demanded.length, argv._.length);

    while (demanded.length) {
      var demand = demanded.shift();
      populatePositional(demand, argv, positionalMap);
    }

    while (optional.length) {
      var maybe = optional.shift();
      populatePositional(maybe, argv, positionalMap);
    }

    argv._ = context.commands.concat(argv._);
    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));
    return positionalMap;
  }

  function populatePositional(positional, argv, positionalMap, parseOptions) {
    var cmd = positional.cmd[0];

    if (positional.variadic) {
      positionalMap[cmd] = argv._.splice(0).map(String);
    } else {
      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];
    }
  } // we run yargs-parser against the positional arguments
  // applying the same parsing logic used for flags.


  function postProcessPositionals(argv, positionalMap, parseOptions) {
    // combine the parsing hints we've inferred from the command
    // string with explicitly configured parsing hints.
    var options = Object.assign({}, yargs.getOptions());
    options["default"] = Object.assign(parseOptions["default"], options["default"]);
    options.alias = Object.assign(parseOptions.alias, options.alias);
    options.array = options.array.concat(parseOptions.array);
    delete options.config; //  don't load config when processing positionals.

    var unparsed = [];
    Object.keys(positionalMap).forEach(function (key) {
      positionalMap[key].map(function (value) {
        unparsed.push("--".concat(key));
        unparsed.push(value);
      });
    }); // short-circuit parse.

    if (!unparsed.length) return;
    var parsed = Parser.detailed(unparsed, options);

    if (parsed.error) {
      yargs.getUsageInstance().fail(parsed.error.message, parsed.error);
    } else {
      // only copy over positional keys (don't overwrite
      // flag arguments that were already parsed).
      var positionalKeys = Object.keys(positionalMap);
      Object.keys(positionalMap).forEach(function (key) {
        [].push.apply(positionalKeys, parsed.aliases[key]);
      });
      Object.keys(parsed.argv).forEach(function (key) {
        if (positionalKeys.indexOf(key) !== -1) {
          // any new aliases need to be placed in positionalMap, which
          // is used for validation.
          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];
          argv[key] = parsed.argv[key];
        }
      });
    }
  }

  self.cmdToParseOptions = function (cmdString) {
    var parseOptions = {
      array: [],
      "default": {},
      alias: {},
      demand: {}
    };
    var parsed = self.parseCommand(cmdString);
    parsed.demanded.forEach(function (d) {
      var cmds = d.cmd.slice(0);
      var cmd = cmds.shift();

      if (d.variadic) {
        parseOptions.array.push(cmd);
        parseOptions["default"][cmd] = [];
      }

      cmds.forEach(function (c) {
        parseOptions.alias[cmd] = c;
      });
      parseOptions.demand[cmd] = true;
    });
    parsed.optional.forEach(function (o) {
      var cmds = o.cmd.slice(0);
      var cmd = cmds.shift();

      if (o.variadic) {
        parseOptions.array.push(cmd);
        parseOptions["default"][cmd] = [];
      }

      cmds.forEach(function (c) {
        parseOptions.alias[cmd] = c;
      });
    });
    return parseOptions;
  };

  self.reset = function () {
    handlers = {};
    aliasMap = {};
    defaultCommand = undefined;
    return self;
  }; // used by yargs.parse() to freeze
  // the state of commands such that
  // we can apply .parse() multiple times
  // with the same yargs instance.


  var frozen;

  self.freeze = function () {
    frozen = {};
    frozen.handlers = handlers;
    frozen.aliasMap = aliasMap;
    frozen.defaultCommand = defaultCommand;
  };

  self.unfreeze = function () {
    handlers = frozen.handlers;
    aliasMap = frozen.aliasMap;
    defaultCommand = frozen.defaultCommand;
    frozen = undefined;
  };

  return self;
};