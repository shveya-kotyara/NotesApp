'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var assert = require('assert');

var Buffer = require('buffer').Buffer;

var realZlib = require('zlib');

var constants = exports.constants = require('./constants.js');

var Minipass = require('minipass');

var OriginalBufferConcat = Buffer.concat;

var _superWrite = Symbol('_superWrite');

var ZlibError =
/*#__PURE__*/
function (_Error) {
  _inherits(ZlibError, _Error);

  function ZlibError(err) {
    var _this;

    _classCallCheck(this, ZlibError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZlibError).call(this, 'zlib: ' + err.message));
    _this.code = err.code;
    _this.errno = err.errno;
    /* istanbul ignore if */

    if (!_this.code) _this.code = 'ZLIB_ERROR';
    _this.message = 'zlib: ' + err.message;
    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    return _this;
  }

  _createClass(ZlibError, [{
    key: "name",
    get: function get() {
      return 'ZlibError';
    }
  }]);

  return ZlibError;
}(_wrapNativeSuper(Error)); // the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.


var _opts = Symbol('opts');

var _flushFlag = Symbol('flushFlag');

var _finishFlushFlag = Symbol('finishFlushFlag');

var _fullFlushFlag = Symbol('fullFlushFlag');

var _handle = Symbol('handle');

var _onError = Symbol('onError');

var _sawError = Symbol('sawError');

var _level = Symbol('level');

var _strategy = Symbol('strategy');

var _ended = Symbol('ended');

var _defaultFullFlush = Symbol('_defaultFullFlush');

var ZlibBase =
/*#__PURE__*/
function (_Minipass) {
  _inherits(ZlibBase, _Minipass);

  function ZlibBase(opts, mode) {
    var _this2;

    _classCallCheck(this, ZlibBase);

    if (!opts || _typeof(opts) !== 'object') throw new TypeError('invalid options for ZlibBase constructor');
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ZlibBase).call(this, opts));
    _this2[_sawError] = false;
    _this2[_ended] = false;
    _this2[_opts] = opts;
    _this2[_flushFlag] = opts.flush;
    _this2[_finishFlushFlag] = opts.finishFlush; // this will throw if any options are invalid for the class selected

    try {
      _this2[_handle] = new realZlib[mode](opts);
    } catch (er) {
      // make sure that all errors get decorated properly
      throw new ZlibError(er);
    }

    _this2[_onError] = function (err) {
      // no sense raising multiple errors, since we abort on the first one.
      if (_this2[_sawError]) return;
      _this2[_sawError] = true; // there is no way to cleanly recover.
      // continuing only obscures problems.

      _this2.close();

      _this2.emit('error', err);
    };

    _this2[_handle].on('error', function (er) {
      return _this2[_onError](new ZlibError(er));
    });

    _this2.once('end', function () {
      return _this2.close;
    });

    return _this2;
  }

  _createClass(ZlibBase, [{
    key: "close",
    value: function close() {
      if (this[_handle]) {
        this[_handle].close();

        this[_handle] = null;
        this.emit('close');
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      if (!this[_sawError]) {
        assert(this[_handle], 'zlib binding closed');
        return this[_handle].reset();
      }
    }
  }, {
    key: "flush",
    value: function flush(flushFlag) {
      if (this.ended) return;
      if (typeof flushFlag !== 'number') flushFlag = this[_fullFlushFlag];
      this.write(Object.assign(Buffer.alloc(0), _defineProperty({}, _flushFlag, flushFlag)));
    }
  }, {
    key: "end",
    value: function end(chunk, encoding, cb) {
      if (chunk) this.write(chunk, encoding);
      this.flush(this[_finishFlushFlag]);
      this[_ended] = true;
      return _get(_getPrototypeOf(ZlibBase.prototype), "end", this).call(this, null, null, cb);
    }
  }, {
    key: "write",
    value: function write(chunk, encoding, cb) {
      var _this3 = this;

      // process the chunk using the sync process
      // then super.write() all the outputted chunks
      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
      if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);
      if (this[_sawError]) return;
      assert(this[_handle], 'zlib binding closed'); // _processChunk tries to .close() the native handle after it's done, so we
      // intercept that by temporarily making it a no-op.

      var nativeHandle = this[_handle]._handle;
      var originalNativeClose = nativeHandle.close;

      nativeHandle.close = function () {};

      var originalClose = this[_handle].close;

      this[_handle].close = function () {}; // It also calls `Buffer.concat()` at the end, which may be convenient
      // for some, but which we are not interested in as it slows us down.


      Buffer.concat = function (args) {
        return args;
      };

      var result;

      try {
        var flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];
        result = this[_handle]._processChunk(chunk, flushFlag); // if we don't throw, reset it back how it was

        Buffer.concat = OriginalBufferConcat;
      } catch (err) {
        // or if we do, put Buffer.concat() back before we emit error
        // Error events call into user code, which may call Buffer.concat()
        Buffer.concat = OriginalBufferConcat;

        this[_onError](new ZlibError(err));
      } finally {
        if (this[_handle]) {
          // Core zlib resets `_handle` to null after attempting to close the
          // native handle. Our no-op handler prevented actual closure, but we
          // need to restore the `._handle` property.
          this[_handle]._handle = nativeHandle;
          nativeHandle.close = originalNativeClose;
          this[_handle].close = originalClose; // `_processChunk()` adds an 'error' listener. If we don't remove it
          // after each call, these handlers start piling up.

          this[_handle].removeAllListeners('error'); // make sure OUR error listener is still attached tho

        }
      }

      if (this[_handle]) this[_handle].on('error', function (er) {
        return _this3[_onError](new ZlibError(er));
      });
      var writeReturn;

      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          // The first buffer is always `handle._outBuffer`, which would be
          // re-used for later invocations; so, we always have to copy that one.
          writeReturn = this[_superWrite](Buffer.from(result[0]));

          for (var i = 1; i < result.length; i++) {
            writeReturn = this[_superWrite](result[i]);
          }
        } else {
          writeReturn = this[_superWrite](Buffer.from(result));
        }
      }

      if (cb) cb();
      return writeReturn;
    }
  }, {
    key: _superWrite,
    value: function value(data) {
      return _get(_getPrototypeOf(ZlibBase.prototype), "write", this).call(this, data);
    }
  }, {
    key: "ended",
    get: function get() {
      return this[_ended];
    }
  }]);

  return ZlibBase;
}(Minipass);

var Zlib =
/*#__PURE__*/
function (_ZlibBase) {
  _inherits(Zlib, _ZlibBase);

  function Zlib(opts, mode) {
    var _this4;

    _classCallCheck(this, Zlib);

    opts = opts || {};
    opts.flush = opts.flush || constants.Z_NO_FLUSH;
    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Zlib).call(this, opts, mode));
    _this4[_fullFlushFlag] = constants.Z_FULL_FLUSH;
    _this4[_level] = opts.level;
    _this4[_strategy] = opts.strategy;
    return _this4;
  }

  _createClass(Zlib, [{
    key: "params",
    value: function params(level, strategy) {
      var _this5 = this;

      if (this[_sawError]) return;
      if (!this[_handle]) throw new Error('cannot switch params when binding is closed'); // no way to test this without also not supporting params at all

      /* istanbul ignore if */

      if (!this[_handle].params) throw new Error('not supported in this implementation');

      if (this[_level] !== level || this[_strategy] !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH);
        assert(this[_handle], 'zlib binding closed'); // .params() calls .flush(), but the latter is always async in the
        // core zlib. We override .flush() temporarily to intercept that and
        // flush synchronously.

        var origFlush = this[_handle].flush;

        this[_handle].flush = function (flushFlag, cb) {
          _this5.flush(flushFlag);

          cb();
        };

        try {
          this[_handle].params(level, strategy);
        } finally {
          this[_handle].flush = origFlush;
        }
        /* istanbul ignore else */


        if (this[_handle]) {
          this[_level] = level;
          this[_strategy] = strategy;
        }
      }
    }
  }]);

  return Zlib;
}(ZlibBase); // minimal 2-byte header


var Deflate =
/*#__PURE__*/
function (_Zlib) {
  _inherits(Deflate, _Zlib);

  function Deflate(opts) {
    _classCallCheck(this, Deflate);

    return _possibleConstructorReturn(this, _getPrototypeOf(Deflate).call(this, opts, 'Deflate'));
  }

  return Deflate;
}(Zlib);

var Inflate =
/*#__PURE__*/
function (_Zlib2) {
  _inherits(Inflate, _Zlib2);

  function Inflate(opts) {
    _classCallCheck(this, Inflate);

    return _possibleConstructorReturn(this, _getPrototypeOf(Inflate).call(this, opts, 'Inflate'));
  }

  return Inflate;
}(Zlib); // gzip - bigger header, same deflate compression


var _portable = Symbol('_portable');

var Gzip =
/*#__PURE__*/
function (_Zlib3) {
  _inherits(Gzip, _Zlib3);

  function Gzip(opts) {
    var _this6;

    _classCallCheck(this, Gzip);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Gzip).call(this, opts, 'Gzip'));
    _this6[_portable] = opts && !!opts.portable;
    return _this6;
  }

  _createClass(Gzip, [{
    key: _superWrite,
    value: function value(data) {
      if (!this[_portable]) return _get(_getPrototypeOf(Gzip.prototype), _superWrite, this).call(this, data); // we'll always get the header emitted in one first chunk
      // overwrite the OS indicator byte with 0xFF

      this[_portable] = false;
      data[9] = 255;
      return _get(_getPrototypeOf(Gzip.prototype), _superWrite, this).call(this, data);
    }
  }]);

  return Gzip;
}(Zlib);

var Gunzip =
/*#__PURE__*/
function (_Zlib4) {
  _inherits(Gunzip, _Zlib4);

  function Gunzip(opts) {
    _classCallCheck(this, Gunzip);

    return _possibleConstructorReturn(this, _getPrototypeOf(Gunzip).call(this, opts, 'Gunzip'));
  }

  return Gunzip;
}(Zlib); // raw - no header


var DeflateRaw =
/*#__PURE__*/
function (_Zlib5) {
  _inherits(DeflateRaw, _Zlib5);

  function DeflateRaw(opts) {
    _classCallCheck(this, DeflateRaw);

    return _possibleConstructorReturn(this, _getPrototypeOf(DeflateRaw).call(this, opts, 'DeflateRaw'));
  }

  return DeflateRaw;
}(Zlib);

var InflateRaw =
/*#__PURE__*/
function (_Zlib6) {
  _inherits(InflateRaw, _Zlib6);

  function InflateRaw(opts) {
    _classCallCheck(this, InflateRaw);

    return _possibleConstructorReturn(this, _getPrototypeOf(InflateRaw).call(this, opts, 'InflateRaw'));
  }

  return InflateRaw;
}(Zlib); // auto-detect header.


var Unzip =
/*#__PURE__*/
function (_Zlib7) {
  _inherits(Unzip, _Zlib7);

  function Unzip(opts) {
    _classCallCheck(this, Unzip);

    return _possibleConstructorReturn(this, _getPrototypeOf(Unzip).call(this, opts, 'Unzip'));
  }

  return Unzip;
}(Zlib);

var Brotli =
/*#__PURE__*/
function (_ZlibBase2) {
  _inherits(Brotli, _ZlibBase2);

  function Brotli(opts, mode) {
    var _this7;

    _classCallCheck(this, Brotli);

    opts = opts || {};
    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(Brotli).call(this, opts, mode));
    _this7[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
    return _this7;
  }

  return Brotli;
}(ZlibBase);

var BrotliCompress =
/*#__PURE__*/
function (_Brotli) {
  _inherits(BrotliCompress, _Brotli);

  function BrotliCompress(opts) {
    _classCallCheck(this, BrotliCompress);

    return _possibleConstructorReturn(this, _getPrototypeOf(BrotliCompress).call(this, opts, 'BrotliCompress'));
  }

  return BrotliCompress;
}(Brotli);

var BrotliDecompress =
/*#__PURE__*/
function (_Brotli2) {
  _inherits(BrotliDecompress, _Brotli2);

  function BrotliDecompress(opts) {
    _classCallCheck(this, BrotliDecompress);

    return _possibleConstructorReturn(this, _getPrototypeOf(BrotliDecompress).call(this, opts, 'BrotliDecompress'));
  }

  return BrotliDecompress;
}(Brotli);

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;
/* istanbul ignore else */

if (typeof realZlib.BrotliCompress === 'function') {
  exports.BrotliCompress = BrotliCompress;
  exports.BrotliDecompress = BrotliDecompress;
} else {
  exports.BrotliCompress = exports.BrotliDecompress =
  /*#__PURE__*/
  function () {
    function _class() {
      _classCallCheck(this, _class);

      throw new Error('Brotli is not supported in this version of Node.js');
    }

    return _class;
  }();
}