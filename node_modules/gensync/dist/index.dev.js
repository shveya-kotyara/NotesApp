"use strict"; // These use the global symbol registry so that multiple copies of this
// library can work together in case they are not deduped.

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var GENSYNC_START = Symbol["for"]("gensync:v1:start");
var GENSYNC_SUSPEND = Symbol["for"]("gensync:v1:suspend");
var GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START";
var GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND";
var GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
var GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY";
var GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
module.exports = Object.assign(function gensync(optsOrFn) {
  var genFn = optsOrFn;

  if (typeof optsOrFn !== "function") {
    genFn = newGenerator(optsOrFn);
  } else {
    genFn = wrapGenerator(optsOrFn);
  }

  return Object.assign(genFn, makeFunctionAPI(genFn));
}, {
  all: buildOperation({
    name: "all",
    arity: 1,
    sync: function sync(args) {
      var items = Array.from(args[0]);
      return items.map(function (item) {
        return evaluateSync(item);
      });
    },
    async: function async(args, resolve, reject) {
      var items = Array.from(args[0]);

      if (items.length === 0) {
        Promise.resolve().then(function () {
          return resolve([]);
        });
        return;
      }

      var count = 0;
      var results = items.map(function () {
        return undefined;
      });
      items.forEach(function (item, i) {
        evaluateAsync(item, function (val) {
          results[i] = val;
          count += 1;
          if (count === results.length) resolve(results);
        }, reject);
      });
    }
  }),
  race: buildOperation({
    name: "race",
    arity: 1,
    sync: function sync(args) {
      var items = Array.from(args[0]);

      if (items.length === 0) {
        throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
      }

      return evaluateSync(items[0]);
    },
    async: function async(args, resolve, reject) {
      var items = Array.from(args[0]);

      if (items.length === 0) {
        throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
      }

      for (var _i = 0, _items = items; _i < _items.length; _i++) {
        var item = _items[_i];
        evaluateAsync(item, resolve, reject);
      }
    }
  })
});
/**
 * Given a generator function, return the standard API object that executes
 * the generator and calls the callbacks.
 */

function makeFunctionAPI(genFn) {
  var fns = {
    sync: function sync() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return evaluateSync(genFn.apply(this, args));
    },
    async: function async() {
      var _this = this;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return new Promise(function (resolve, reject) {
        evaluateAsync(genFn.apply(_this, args), resolve, reject);
      });
    },
    errback: function errback() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var cb = args.pop();

      if (typeof cb !== "function") {
        throw makeError("Asynchronous function called without callback", GENSYNC_ERRBACK_NO_CALLBACK);
      }

      var gen;

      try {
        gen = genFn.apply(this, args);
      } catch (err) {
        cb(err);
        return;
      }

      evaluateAsync(gen, function (val) {
        return cb(undefined, val);
      }, function (err) {
        return cb(err);
      });
    }
  };
  return fns;
}

function assertTypeof(type, name, value, allowUndefined) {
  if (_typeof(value) === type || allowUndefined && typeof value === "undefined") {
    return;
  }

  var msg;

  if (allowUndefined) {
    msg = "Expected opts.".concat(name, " to be either a ").concat(type, ", or undefined.");
  } else {
    msg = "Expected opts.".concat(name, " to be a ").concat(type, ".");
  }

  throw makeError(msg, GENSYNC_OPTIONS_ERROR);
}

function makeError(msg, code) {
  return Object.assign(new Error(msg), {
    code: code
  });
}
/**
 * Given an options object, return a new generator that dispatches the
 * correct handler based on sync or async execution.
 */


function newGenerator(_ref) {
  var name = _ref.name,
      arity = _ref.arity,
      _sync = _ref.sync,
      _async = _ref.async,
      errback = _ref.errback;
  assertTypeof("string", "name", name, true
  /* allowUndefined */
  );
  assertTypeof("number", "arity", arity, true
  /* allowUndefined */
  );
  assertTypeof("function", "sync", _sync);
  assertTypeof("function", "async", _async, true
  /* allowUndefined */
  );
  assertTypeof("function", "errback", errback, true
  /* allowUndefined */
  );

  if (_async && errback) {
    throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);
  }

  if (typeof name !== "string") {
    var fnName;

    if (errback && errback.name && errback.name !== "errback") {
      fnName = errback.name;
    }

    if (_async && _async.name && _async.name !== "async") {
      fnName = _async.name.replace(/Async$/, "");
    }

    if (_sync && _sync.name && _sync.name !== "sync") {
      fnName = _sync.name.replace(/Sync$/, "");
    }

    if (typeof fnName === "string") {
      name = fnName;
    }
  }

  if (typeof arity !== "number") {
    arity = _sync.length;
  }

  return buildOperation({
    name: name,
    arity: arity,
    sync: function sync(args) {
      return _sync.apply(this, args);
    },
    async: function async(args, resolve, reject) {
      if (_async) {
        _async.apply(this, args).then(resolve, reject);
      } else if (errback) {
        errback.call.apply(errback, [this].concat(_toConsumableArray(args), [function (err, value) {
          if (err == null) resolve(value);else reject(err);
        }]));
      } else {
        resolve(_sync.apply(this, args));
      }
    }
  });
}

function wrapGenerator(genFn) {
  return setFunctionMetadata(genFn.name, genFn.length, function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return genFn.apply(this, args);
  });
}

function buildOperation(_ref2) {
  var name = _ref2.name,
      arity = _ref2.arity,
      sync = _ref2.sync,
      async = _ref2.async;
  return setFunctionMetadata(name, arity,
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee() {
    var resume,
        _len5,
        args,
        _key5,
        res,
        result,
        _args = arguments;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return GENSYNC_START;

          case 2:
            resume = _context.sent;

            for (_len5 = _args.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = _args[_key5];
            }

            if (resume) {
              _context.next = 7;
              break;
            }

            // Break the tail call to avoid a bug in V8 v6.X with --harmony enabled.
            res = sync.call(this, args);
            return _context.abrupt("return", res);

          case 7:
            try {
              async.call(this, args, function (value) {
                if (result) return;
                result = {
                  value: value
                };
                resume();
              }, function (err) {
                if (result) return;
                result = {
                  err: err
                };
                resume();
              });
            } catch (err) {
              result = {
                err: err
              };
              resume();
            } // Suspend until the callbacks run. Will resume synchronously if the
            // callback was already called.


            _context.next = 10;
            return GENSYNC_SUSPEND;

          case 10:
            if (!result.hasOwnProperty("err")) {
              _context.next = 12;
              break;
            }

            throw result.err;

          case 12:
            return _context.abrupt("return", result.value);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
}

function evaluateSync(gen) {
  var value;

  while (!(_gen$next = gen.next(), value = _gen$next.value, _gen$next).done) {
    var _gen$next;

    assertStart(value, gen);
  }

  return value;
}

function evaluateAsync(gen, resolve, reject) {
  (function step() {
    try {
      var value;

      var _loop = function _loop() {
        assertStart(value, gen); // If this throws, it is considered to have broken the contract
        // established for async handlers. If these handlers are called
        // synchronously, it is also considered bad behavior.

        var sync = true;
        var didSyncResume = false;
        var out = gen.next(function () {
          if (sync) {
            didSyncResume = true;
          } else {
            step();
          }
        });
        sync = false;
        assertSuspend(out, gen);

        if (!didSyncResume) {
          // Callback wasn't called synchronously, so break out of the loop
          // and let it call 'step' later.
          return {
            v: void 0
          };
        }
      };

      while (!(_gen$next2 = gen.next(), value = _gen$next2.value, _gen$next2).done) {
        var _gen$next2;

        var _ret = _loop();

        if (_typeof(_ret) === "object") return _ret.v;
      }

      return resolve(value);
    } catch (err) {
      return reject(err);
    }
  })();
}

function assertStart(value, gen) {
  if (value === GENSYNC_START) return;
  throwError(gen, makeError("Got unexpected yielded value in gensync generator: ".concat(JSON.stringify(value), ". Did you perhaps mean to use 'yield*' instead of 'yield'?"), GENSYNC_EXPECTED_START));
}

function assertSuspend(_ref3, gen) {
  var value = _ref3.value,
      done = _ref3.done;
  if (!done && value === GENSYNC_SUSPEND) return;
  throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : "Expected GENSYNC_SUSPEND, got ".concat(JSON.stringify(value), ". If you get this, it is probably a gensync bug."), GENSYNC_EXPECTED_SUSPEND));
}

function throwError(gen, err) {
  // Call `.throw` so that users can step in a debugger to easily see which
  // 'yield' passed an unexpected value. If the `.throw` call didn't throw
  // back to the generator, we explicitly do it to stop the error
  // from being swallowed by user code try/catches.
  if (gen["throw"]) gen["throw"](err);
  throw err;
}

function isIterable(value) {
  return !!value && (_typeof(value) === "object" || typeof value === "function") && !value[Symbol.iterator];
}

function setFunctionMetadata(name, arity, fn) {
  if (typeof name === "string") {
    // This should always work on the supported Node versions, but for the
    // sake of users that are compiling to older versions, we check for
    // configurability so we don't throw.
    var nameDesc = Object.getOwnPropertyDescriptor(fn, "name");

    if (!nameDesc || nameDesc.configurable) {
      Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, {
        configurable: true,
        value: name
      }));
    }
  }

  if (typeof arity === "number") {
    var lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");

    if (!lengthDesc || lengthDesc.configurable) {
      Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, {
        configurable: true,
        value: arity
      }));
    }
  }

  return fn;
}