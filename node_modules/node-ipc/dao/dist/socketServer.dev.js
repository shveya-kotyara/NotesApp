'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var net = require('net'),
    tls = require('tls'),
    fs = require('fs'),
    dgram = require('dgram'),
    EventParser = require('../entities/EventParser.js'),
    Message = require('js-message'),
    Events = require('event-pubsub');

var eventParser = new EventParser();

var Server =
/*#__PURE__*/
function (_Events) {
  _inherits(Server, _Events);

  function Server(path, config, log, port) {
    var _this;

    _classCallCheck(this, Server);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));
    Object.assign(_assertThisInitialized(_this), {
      config: config,
      path: path,
      port: port,
      udp4: false,
      udp6: false,
      log: log,
      server: false,
      sockets: [],
      emit: emit,
      broadcast: broadcast
    });
    eventParser = new EventParser(_this.config);

    _this.on('close', serverClosed.bind(_assertThisInitialized(_this)));

    return _this;
  }

  _createClass(Server, [{
    key: "onStart",
    value: function onStart(socket) {
      this.trigger('start', socket);
    }
  }, {
    key: "stop",
    value: function stop() {
      this.server.close();
    }
  }, {
    key: "start",
    value: function start() {
      if (!this.path) {
        this.log('Socket Server Path not specified, refusing to start');
        return;
      }

      if (this.config.unlink) {
        fs.unlink(this.path, startServer.bind(this));
      } else {
        startServer.bind(this)();
      }
    }
  }]);

  return Server;
}(Events);

function emit(socket, type, data) {
  this.log('dispatching event to socket', ' : ', type, data);
  var message = new Message();
  message.type = type;
  message.data = data;

  if (this.config.rawBuffer) {
    this.log(this.config.encoding);
    message = Buffer.from(type, this.config.encoding);
  } else {
    message = eventParser.format(message);
  }

  if (this.udp4 || this.udp6) {
    if (!socket.address || !socket.port) {
      this.log('Attempting to emit to a single UDP socket without supplying socket address or port. Redispatching event as broadcast to all connected sockets');
      this.broadcast(type, data);
      return;
    }

    this.server.write(message, socket);
    return;
  }

  socket.write(message);
}

function broadcast(type, data) {
  this.log('broadcasting event to all known sockets listening to ', this.path, ' : ', this.port ? this.port : '', type, data);
  var message = new Message();
  message.type = type;
  message.data = data;

  if (this.config.rawBuffer) {
    message = Buffer.from(type, this.config.encoding);
  } else {
    message = eventParser.format(message);
  }

  if (this.udp4 || this.udp6) {
    for (var i = 1, count = this.sockets.length; i < count; i++) {
      this.server.write(message, this.sockets[i]);
    }
  } else {
    for (var _i = 0, _count = this.sockets.length; _i < _count; _i++) {
      this.sockets[_i].write(message);
    }
  }
}

function serverClosed() {
  for (var i = 0, count = this.sockets.length; i < count; i++) {
    var socket = this.sockets[i];
    var destroyedSocketId = false;

    if (socket) {
      if (socket.readable) {
        continue;
      }
    }

    if (socket.id) {
      destroyedSocketId = socket.id;
    }

    this.log('socket disconnected', destroyedSocketId.toString());

    if (socket && socket.destroy) {
      socket.destroy();
    }

    this.sockets.splice(i, 1);
    this.publish('socket.disconnected', socket, destroyedSocketId);
    return;
  }
}

function gotData(socket, data, UDPSocket) {
  var sock = this.udp4 || this.udp6 ? UDPSocket : socket;

  if (this.config.rawBuffer) {
    data = Buffer.from(data, this.config.encoding);
    this.publish('data', data, sock);
    return;
  }

  if (!sock.ipcBuffer) {
    sock.ipcBuffer = '';
  }

  data = sock.ipcBuffer += data;

  if (data.slice(-1) != eventParser.delimiter || data.indexOf(eventParser.delimiter) == -1) {
    this.log('Messages are large, You may want to consider smaller messages.');
    return;
  }

  sock.ipcBuffer = '';
  data = eventParser.parse(data);

  while (data.length > 0) {
    var message = new Message();
    message.load(data.shift()); // Only set the sock id if it is specified.

    if (message.data && message.data.id) {
      sock.id = message.data.id;
    }

    this.log('received event of : ', message.type, message.data);
    this.publish(message.type, message.data, sock);
  }
}

function socketClosed(socket) {
  this.publish('close', socket);
}

function serverCreated(socket) {
  this.sockets.push(socket);

  if (socket.setEncoding) {
    socket.setEncoding(this.config.encoding);
  }

  this.log('## socket connection to server detected ##');
  socket.on('close', socketClosed.bind(this));
  socket.on('error', function (err) {
    this.log('server socket error', err);
    this.publish('error', err);
  }.bind(this));
  socket.on('data', gotData.bind(this, socket));
  socket.on('message', function (msg, rinfo) {
    if (!rinfo) {
      return;
    }

    this.log('Received UDP message from ', rinfo.address, rinfo.port);
    var data;

    if (this.config.rawSocket) {
      data = Buffer.from(msg, this.config.encoding);
    } else {
      data = msg.toString();
    }

    socket.emit('data', data, rinfo);
  }.bind(this));
  this.publish('connect', socket);

  if (this.config.rawBuffer) {
    return;
  }
}

function startServer() {
  this.log('starting server on ', this.path, this.port ? ":".concat(this.port) : '');

  if (!this.udp4 && !this.udp6) {
    this.log('starting TLS server', this.config.tls);

    if (!this.config.tls) {
      this.server = net.createServer(serverCreated.bind(this));
    } else {
      startTLSServer.bind(this)();
    }
  } else {
    this.server = dgram.createSocket(this.udp4 ? 'udp4' : 'udp6');
    this.server.write = UDPWrite.bind(this);
    this.server.on('listening', function UDPServerStarted() {
      serverCreated.bind(this)(this.server);
    }.bind(this));
  }

  this.server.on('error', function (err) {
    this.log('server error', err);
    this.publish('error', err);
  }.bind(this));
  this.server.maxConnections = this.config.maxConnections;

  if (!this.port) {
    this.log('starting server as', 'Unix || Windows Socket');

    if (process.platform === 'win32') {
      this.path = this.path.replace(/^\//, '');
      this.path = this.path.replace(/\//g, '-');
      this.path = "\\\\.\\pipe\\".concat(this.path);
    }

    this.server.listen(this.path, this.onStart.bind(this));
    return;
  }

  if (!this.udp4 && !this.udp6) {
    this.log('starting server as', this.config.tls ? 'TLS' : 'TCP');
    this.server.listen(this.port, this.path, this.onStart.bind(this));
    return;
  }

  this.log('starting server as', this.udp4 ? 'udp4' : 'udp6');
  this.server.bind(this.port, this.path);
  this.onStart({
    address: this.path,
    port: this.port
  });
}

function startTLSServer() {
  this.log('starting TLS server', this.config.tls);

  if (this.config.tls["private"]) {
    this.config.tls.key = fs.readFileSync(this.config.tls["private"]);
  } else {
    this.config.tls.key = fs.readFileSync("".concat(__dirname, "/../local-node-ipc-certs/private/server.key"));
  }

  if (this.config.tls["public"]) {
    this.config.tls.cert = fs.readFileSync(this.config.tls["public"]);
  } else {
    this.config.tls.cert = fs.readFileSync("".concat(__dirname, "/../local-node-ipc-certs/server.pub"));
  }

  if (this.config.tls.dhparam) {
    this.config.tls.dhparam = fs.readFileSync(this.config.tls.dhparam);
  }

  if (this.config.tls.trustedConnections) {
    if (typeof this.config.tls.trustedConnections === 'string') {
      this.config.tls.trustedConnections = [this.config.tls.trustedConnections];
    }

    this.config.tls.ca = [];

    for (var i = 0; i < this.config.tls.trustedConnections.length; i++) {
      this.config.tls.ca.push(fs.readFileSync(this.config.tls.trustedConnections[i]));
    }
  }

  this.server = tls.createServer(this.config.tls, serverCreated.bind(this));
}

function UDPWrite(message, socket) {
  var data = Buffer.from(message, this.config.encoding);
  this.server.send(data, 0, data.length, socket.port, socket.address, function (err, bytes) {
    if (err) {
      this.log('error writing data to socket', err);
      this.publish('error', function (err) {
        this.publish('error', err);
      });
    }
  });
}

module.exports = Server;