'use strict';

var fs = require('fs');

var path = require('path');

var pify = require('pify');

var semver = require('semver');

var defaults = {
  mode: 511 & ~process.umask(),
  fs: fs
};
var useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0'); // https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088

var checkPath = function checkPath(pth) {
  if (process.platform === 'win32') {
    var pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

    if (pathHasInvalidWinCharacters) {
      var error = new Error("Path contains invalid characters: ".concat(pth));
      error.code = 'EINVAL';
      throw error;
    }
  }
};

var permissionError = function permissionError(pth) {
  // This replicates the exception of `fs.mkdir` with native the
  // `recusive` option when run on an invalid drive under Windows.
  var error = new Error("operation not permitted, mkdir '".concat(pth, "'"));
  error.code = 'EPERM';
  error.errno = -4048;
  error.path = pth;
  error.syscall = 'mkdir';
  return error;
};

var makeDir = function makeDir(input, options) {
  return Promise.resolve().then(function () {
    checkPath(input);
    options = Object.assign({}, defaults, options); // TODO: Use util.promisify when targeting Node.js 8

    var mkdir = pify(options.fs.mkdir);
    var stat = pify(options.fs.stat);

    if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
      var pth = path.resolve(input);
      return mkdir(pth, {
        mode: options.mode,
        recursive: true
      }).then(function () {
        return pth;
      });
    }

    var make = function make(pth) {
      return mkdir(pth, options.mode).then(function () {
        return pth;
      })["catch"](function (error) {
        if (error.code === 'EPERM') {
          throw error;
        }

        if (error.code === 'ENOENT') {
          if (path.dirname(pth) === pth) {
            throw permissionError(pth);
          }

          if (error.message.includes('null bytes')) {
            throw error;
          }

          return make(path.dirname(pth)).then(function () {
            return make(pth);
          });
        }

        return stat(pth).then(function (stats) {
          return stats.isDirectory() ? pth : Promise.reject();
        })["catch"](function () {
          throw error;
        });
      });
    };

    return make(path.resolve(input));
  });
};

module.exports = makeDir;
module.exports["default"] = makeDir;

module.exports.sync = function (input, options) {
  checkPath(input);
  options = Object.assign({}, defaults, options);

  if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
    var pth = path.resolve(input);
    fs.mkdirSync(pth, {
      mode: options.mode,
      recursive: true
    });
    return pth;
  }

  var make = function make(pth) {
    try {
      options.fs.mkdirSync(pth, options.mode);
    } catch (error) {
      if (error.code === 'EPERM') {
        throw error;
      }

      if (error.code === 'ENOENT') {
        if (path.dirname(pth) === pth) {
          throw permissionError(pth);
        }

        if (error.message.includes('null bytes')) {
          throw error;
        }

        make(path.dirname(pth));
        return make(pth);
      }

      try {
        if (!options.fs.statSync(pth).isDirectory()) {
          throw new Error('The path is not a directory');
        }
      } catch (_) {
        throw error;
      }
    }

    return pth;
  };

  return make(path.resolve(input));
};