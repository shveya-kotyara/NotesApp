'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _stylehacks = require('stylehacks');

var _insertCloned = require('../insertCloned');

var _insertCloned2 = _interopRequireDefault(_insertCloned);

var _parseTrbl = require('../parseTrbl');

var _parseTrbl2 = _interopRequireDefault(_parseTrbl);

var _hasAllProps = require('../hasAllProps');

var _hasAllProps2 = _interopRequireDefault(_hasAllProps);

var _getDecls = require('../getDecls');

var _getDecls2 = _interopRequireDefault(_getDecls);

var _getRules = require('../getRules');

var _getRules2 = _interopRequireDefault(_getRules);

var _getValue = require('../getValue');

var _getValue2 = _interopRequireDefault(_getValue);

var _mergeRules = require('../mergeRules');

var _mergeRules2 = _interopRequireDefault(_mergeRules);

var _minifyTrbl = require('../minifyTrbl');

var _minifyTrbl2 = _interopRequireDefault(_minifyTrbl);

var _minifyWsc = require('../minifyWsc');

var _minifyWsc2 = _interopRequireDefault(_minifyWsc);

var _canMerge = require('../canMerge');

var _canMerge2 = _interopRequireDefault(_canMerge);

var _remove = require('../remove');

var _remove2 = _interopRequireDefault(_remove);

var _trbl = require('../trbl');

var _trbl2 = _interopRequireDefault(_trbl);

var _isCustomProp = require('../isCustomProp');

var _isCustomProp2 = _interopRequireDefault(_isCustomProp);

var _canExplode = require('../canExplode');

var _canExplode2 = _interopRequireDefault(_canExplode);

var _getLastNode = require('../getLastNode');

var _getLastNode2 = _interopRequireDefault(_getLastNode);

var _parseWsc = require('../parseWsc');

var _parseWsc2 = _interopRequireDefault(_parseWsc);

var _validateWsc = require('../validateWsc');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var wsc = ['width', 'style', 'color'];
var defaults = ['medium', 'none', 'currentcolor'];

function borderProperty() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }

  return "border-".concat(parts.join('-'));
}

function mapBorderProperty(value) {
  return borderProperty(value);
}

var directions = _trbl2["default"].map(mapBorderProperty);

var properties = wsc.map(mapBorderProperty);
var directionalProperties = directions.reduce(function (prev, curr) {
  return prev.concat(wsc.map(function (prop) {
    return "".concat(curr, "-").concat(prop);
  }));
}, []);
var precedence = [['border'], directions.concat(properties), directionalProperties];
var allProperties = precedence.reduce(function (a, b) {
  return a.concat(b);
});

function getLevel(prop) {
  for (var i = 0; i < precedence.length; i++) {
    if (!!~precedence[i].indexOf(prop.toLowerCase())) {
      return i;
    }
  }
}

var isValueCustomProp = function isValueCustomProp(value) {
  return value && !!~value.search(/var\s*\(\s*--/i);
};

function canMergeValues(values) {
  return !values.some(isValueCustomProp) || values.every(isValueCustomProp);
}

function getColorValue(decl) {
  if (decl.prop.substr(-5) === 'color') {
    return decl.value;
  }

  return (0, _parseWsc2["default"])(decl.value)[2] || defaults[2];
}

function diffingProps(values, nextValues) {
  return wsc.reduce(function (prev, curr, i) {
    if (values[i] === nextValues[i]) {
      return prev;
    }

    return [].concat(_toConsumableArray(prev), [curr]);
  }, []);
}

function mergeRedundant(_ref) {
  var values = _ref.values,
      nextValues = _ref.nextValues,
      decl = _ref.decl,
      nextDecl = _ref.nextDecl,
      index = _ref.index;

  if (!(0, _canMerge2["default"])([decl, nextDecl])) {
    return;
  }

  if ((0, _stylehacks.detect)(decl) || (0, _stylehacks.detect)(nextDecl)) {
    return;
  }

  var diff = diffingProps(values, nextValues);

  if (diff.length > 1) {
    return;
  }

  var prop = diff.pop();
  var position = wsc.indexOf(prop);
  var prop1 = "".concat(nextDecl.prop, "-").concat(prop);
  var prop2 = "border-".concat(prop);
  var props = (0, _parseTrbl2["default"])(values[position]);
  props[index] = nextValues[position];
  var borderValue2 = values.filter(function (e, i) {
    return i !== position;
  }).join(' ');
  var propValue2 = (0, _minifyTrbl2["default"])(props);
  var origLength = ((0, _minifyWsc2["default"])(decl.value) + nextDecl.prop + nextDecl.value).length;
  var newLength1 = decl.value.length + prop1.length + (0, _minifyWsc2["default"])(nextValues[position]).length;
  var newLength2 = borderValue2.length + prop2.length + propValue2.length;

  if (newLength1 < newLength2 && newLength1 < origLength) {
    nextDecl.prop = prop1;
    nextDecl.value = nextValues[position];
  }

  if (newLength2 < newLength1 && newLength2 < origLength) {
    decl.value = borderValue2;
    nextDecl.prop = prop2;
    nextDecl.value = propValue2;
  }
}

function isCloseEnough(mapped) {
  return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];
}

function getDistinctShorthands(mapped) {
  return mapped.reduce(function (a, b) {
    a = Array.isArray(a) ? a : [a];

    if (!~a.indexOf(b)) {
      a.push(b);
    }

    return a;
  });
}

function explode(rule) {
  rule.walkDecls(/^border/i, function (decl) {
    if (!(0, _canExplode2["default"])(decl, false)) {
      return;
    }

    if ((0, _stylehacks.detect)(decl)) {
      return;
    }

    var prop = decl.prop.toLowerCase(); // border -> border-trbl

    if (prop === 'border') {
      if ((0, _validateWsc.isValidWsc)((0, _parseWsc2["default"])(decl.value))) {
        directions.forEach(function (direction) {
          (0, _insertCloned2["default"])(decl.parent, decl, {
            prop: direction
          });
        });
        return decl.remove();
      }
    } // border-trbl -> border-trbl-wsc


    if (directions.some(function (direction) {
      return prop === direction;
    })) {
      var values = (0, _parseWsc2["default"])(decl.value);

      if ((0, _validateWsc.isValidWsc)(values)) {
        wsc.forEach(function (d, i) {
          (0, _insertCloned2["default"])(decl.parent, decl, {
            prop: "".concat(prop, "-").concat(d),
            value: values[i] || defaults[i]
          });
        });
        return decl.remove();
      }
    } // border-wsc -> border-trbl-wsc


    wsc.some(function (style) {
      if (prop !== borderProperty(style)) {
        return false;
      }

      (0, _parseTrbl2["default"])(decl.value).forEach(function (value, i) {
        (0, _insertCloned2["default"])(decl.parent, decl, {
          prop: borderProperty(_trbl2["default"][i], style),
          value: value
        });
      });
      return decl.remove();
    });
  });
}

function merge(rule) {
  // border-trbl-wsc -> border-trbl
  _trbl2["default"].forEach(function (direction) {
    var prop = borderProperty(direction);
    (0, _mergeRules2["default"])(rule, wsc.map(function (style) {
      return borderProperty(direction, style);
    }), function (rules, lastNode) {
      if ((0, _canMerge2["default"])(rules, false) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned2["default"])(lastNode.parent, lastNode, {
          prop: prop,
          value: rules.map(_getValue2["default"]).join(' ')
        });
        rules.forEach(_remove2["default"]);
        return true;
      }
    });
  }); // border-trbl-wsc -> border-wsc


  wsc.forEach(function (style) {
    var prop = borderProperty(style);
    (0, _mergeRules2["default"])(rule, _trbl2["default"].map(function (direction) {
      return borderProperty(direction, style);
    }), function (rules, lastNode) {
      if ((0, _canMerge2["default"])(rules) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned2["default"])(lastNode.parent, lastNode, {
          prop: prop,
          value: (0, _minifyTrbl2["default"])(rules.map(_getValue2["default"]).join(' '))
        });
        rules.forEach(_remove2["default"]);
        return true;
      }
    });
  }); // border-trbl -> border-wsc

  (0, _mergeRules2["default"])(rule, directions, function (rules, lastNode) {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    var values = rules.map(function (_ref2) {
      var value = _ref2.value;
      return value;
    });

    if (!canMergeValues(values)) {
      return;
    }

    var parsed = values.map(function (value) {
      return (0, _parseWsc2["default"])(value);
    });

    if (!parsed.every(_validateWsc.isValidWsc)) {
      return;
    }

    wsc.forEach(function (d, i) {
      var value = parsed.map(function (v) {
        return v[i] || defaults[i];
      });

      if (canMergeValues(value)) {
        (0, _insertCloned2["default"])(lastNode.parent, lastNode, {
          prop: borderProperty(d),
          value: (0, _minifyTrbl2["default"])(value)
        });
      } else {
        (0, _insertCloned2["default"])(lastNode.parent, lastNode);
      }
    });
    rules.forEach(_remove2["default"]);
    return true;
  }); // border-wsc -> border
  // border-wsc -> border + border-color
  // border-wsc -> border + border-dir

  (0, _mergeRules2["default"])(rule, properties, function (rules, lastNode) {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    var values = rules.map(function (node) {
      return (0, _parseTrbl2["default"])(node.value);
    });
    var mapped = [0, 1, 2, 3].map(function (i) {
      return [values[0][i], values[1][i], values[2][i]].join(' ');
    });

    if (!canMergeValues(mapped)) {
      return;
    }

    var _rules = _slicedToArray(rules, 3),
        width = _rules[0],
        style = _rules[1],
        color = _rules[2];

    var reduced = getDistinctShorthands(mapped);

    if (isCloseEnough(mapped) && (0, _canMerge2["default"])(rules, false)) {
      var first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);
      var border = (0, _insertCloned2["default"])(lastNode.parent, lastNode, {
        prop: 'border',
        value: first ? reduced[0] : reduced[1]
      });

      if (reduced[1]) {
        var value = first ? reduced[1] : reduced[0];
        var prop = borderProperty(_trbl2["default"][mapped.indexOf(value)]);
        rule.insertAfter(border, Object.assign(lastNode.clone(), {
          prop: prop,
          value: value
        }));
      }

      rules.forEach(_remove2["default"]);
      return true;
    } else if (reduced.length === 1) {
      rule.insertBefore(color, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: [width, style].map(_getValue2["default"]).join(' ')
      }));
      rules.filter(function (node) {
        return node.prop.toLowerCase() !== properties[2];
      }).forEach(_remove2["default"]);
      return true;
    }
  }); // border-wsc -> border + border-trbl

  (0, _mergeRules2["default"])(rule, properties, function (rules, lastNode) {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    var values = rules.map(function (node) {
      return (0, _parseTrbl2["default"])(node.value);
    });
    var mapped = [0, 1, 2, 3].map(function (i) {
      return [values[0][i], values[1][i], values[2][i]].join(' ');
    });
    var reduced = getDistinctShorthands(mapped);
    var none = 'medium none currentcolor';

    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {
      var filtered = mapped.filter(function (p) {
        return p !== none;
      });
      var mostCommon = reduced.sort(function (a, b) {
        return mapped.filter(function (v) {
          return v === b;
        }).length - mapped.filter(function (v) {
          return v === a;
        }).length;
      })[0];
      var borderValue = reduced.length === 2 ? filtered[0] : mostCommon;
      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: borderValue
      }));
      directions.forEach(function (dir, i) {
        if (mapped[i] !== borderValue) {
          rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
            prop: dir,
            value: mapped[i]
          }));
        }
      });
      rules.forEach(_remove2["default"]);
      return true;
    }
  }); // border-trbl -> border
  // border-trbl -> border + border-trbl

  (0, _mergeRules2["default"])(rule, directions, function (rules, lastNode) {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    var values = rules.map(function (node) {
      var wscValue = (0, _parseWsc2["default"])(node.value);

      if (!(0, _validateWsc.isValidWsc)(wscValue)) {
        return node.value;
      }

      return wscValue.map(function (value, i) {
        return value || defaults[i];
      }).join(' ');
    });
    var reduced = getDistinctShorthands(values);

    if (isCloseEnough(values)) {
      var first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);
      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: (0, _minifyWsc2["default"])(first ? values[0] : values[1])
      }));

      if (reduced[1]) {
        var value = first ? reduced[1] : reduced[0];
        var prop = directions[values.indexOf(value)];
        rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
          prop: prop,
          value: (0, _minifyWsc2["default"])(value)
        }));
      }

      rules.forEach(_remove2["default"]);
      return true;
    }
  }); // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)

  directions.forEach(function (direction) {
    wsc.forEach(function (style, i) {
      var prop = "".concat(direction, "-").concat(style);
      (0, _mergeRules2["default"])(rule, [direction, prop], function (rules, lastNode) {
        if (lastNode.prop !== direction) {
          return;
        }

        var values = (0, _parseWsc2["default"])(lastNode.value);

        if (!(0, _validateWsc.isValidWsc)(values)) {
          return;
        }

        var wscProp = rules.filter(function (r) {
          return r !== lastNode;
        })[0];

        if (!isValueCustomProp(values[i]) || (0, _isCustomProp2["default"])(wscProp)) {
          return;
        }

        var wscValue = values[i];
        values[i] = wscProp.value;

        if ((0, _canMerge2["default"])(rules, false) && !rules.some(_stylehacks.detect)) {
          (0, _insertCloned2["default"])(lastNode.parent, lastNode, {
            prop: prop,
            value: wscValue
          });
          lastNode.value = (0, _minifyWsc2["default"])(values);
          wscProp.remove();
          return true;
        }
      });
    });
  }); // border-wsc + border (custom prop) -> border + border-wsc (custom prop)

  wsc.forEach(function (style, i) {
    var prop = borderProperty(style);
    (0, _mergeRules2["default"])(rule, ['border', prop], function (rules, lastNode) {
      if (lastNode.prop !== 'border') {
        return;
      }

      var values = (0, _parseWsc2["default"])(lastNode.value);

      if (!(0, _validateWsc.isValidWsc)(values)) {
        return;
      }

      var wscProp = rules.filter(function (r) {
        return r !== lastNode;
      })[0];

      if (!isValueCustomProp(values[i]) || (0, _isCustomProp2["default"])(wscProp)) {
        return;
      }

      var wscValue = values[i];
      values[i] = wscProp.value;

      if ((0, _canMerge2["default"])(rules, false) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned2["default"])(lastNode.parent, lastNode, {
          prop: prop,
          value: wscValue
        });
        lastNode.value = (0, _minifyWsc2["default"])(values);
        wscProp.remove();
        return true;
      }
    });
  }); // optimize border-trbl

  var decls = (0, _getDecls2["default"])(rule, directions);

  var _loop = function _loop() {
    var lastNode = decls[decls.length - 1];
    wsc.forEach(function (d, i) {
      var names = directions.filter(function (name) {
        return name !== lastNode.prop;
      }).map(function (name) {
        return "".concat(name, "-").concat(d);
      });
      var nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));
      var border = (0, _getLastNode2["default"])(nodes, 'border');

      if (border) {
        nodes = nodes.slice(nodes.indexOf(border));
      }

      var props = nodes.filter(function (node) {
        return node.prop && ~names.indexOf(node.prop) && node.important === lastNode.important;
      });
      var rules = (0, _getRules2["default"])(props, names);

      if ((0, _hasAllProps2["default"]).apply(void 0, [rules].concat(_toConsumableArray(names))) && !rules.some(_stylehacks.detect)) {
        var values = rules.map(function (node) {
          return node ? node.value : null;
        });
        var filteredValues = values.filter(Boolean);

        var lastNodeValue = _postcss.list.space(lastNode.value)[i];

        values[directions.indexOf(lastNode.prop)] = lastNodeValue;
        var value = (0, _minifyTrbl2["default"])(values.join(' '));

        if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {
          value = filteredValues[0];
        }

        var refNode = props[props.length - 1];

        if (value === lastNodeValue) {
          refNode = lastNode;

          var valueArray = _postcss.list.space(lastNode.value);

          valueArray.splice(i, 1);
          lastNode.value = valueArray.join(' ');
        }

        (0, _insertCloned2["default"])(refNode.parent, refNode, {
          prop: borderProperty(d),
          value: value
        });
        decls = decls.filter(function (node) {
          return !~rules.indexOf(node);
        });
        rules.forEach(_remove2["default"]);
      }
    });
    decls = decls.filter(function (node) {
      return node !== lastNode;
    });
  };

  while (decls.length) {
    _loop();
  }

  rule.walkDecls('border', function (decl) {
    var nextDecl = decl.next();

    if (!nextDecl || nextDecl.type !== 'decl') {
      return;
    }

    var index = directions.indexOf(nextDecl.prop);

    if (!~index) {
      return;
    }

    var values = (0, _parseWsc2["default"])(decl.value);
    var nextValues = (0, _parseWsc2["default"])(nextDecl.value);

    if (!(0, _validateWsc.isValidWsc)(values) || !(0, _validateWsc.isValidWsc)(nextValues)) {
      return;
    }

    var config = {
      values: values,
      nextValues: nextValues,
      decl: decl,
      nextDecl: nextDecl,
      index: index
    };
    return mergeRedundant(config);
  });
  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, function (decl) {
    var values = (0, _parseWsc2["default"])(decl.value);

    if (!(0, _validateWsc.isValidWsc)(values)) {
      return;
    }

    var position = directions.indexOf(decl.prop);

    var dirs = _toConsumableArray(directions);

    dirs.splice(position, 1);
    wsc.forEach(function (d, i) {
      var props = dirs.map(function (dir) {
        return "".concat(dir, "-").concat(d);
      });
      (0, _mergeRules2["default"])(rule, [decl.prop].concat(_toConsumableArray(props)), function (rules) {
        if (!rules.includes(decl)) {
          return;
        }

        var longhands = rules.filter(function (p) {
          return p !== decl;
        });

        if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {
          longhands.forEach(_remove2["default"]);
          (0, _insertCloned2["default"])(decl.parent, decl, {
            prop: borderProperty(d),
            value: values[i]
          });
          values[i] = null;
        }
      });
      var newValue = values.join(' ');

      if (newValue) {
        decl.value = newValue;
      } else {
        decl.remove();
      }
    });
  }); // clean-up values

  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, function (decl) {
    decl.value = (0, _minifyWsc2["default"])(decl.value);
  }); // border-spacing-hv -> border-spacing

  rule.walkDecls(/^border-spacing$/i, function (decl) {
    var value = _postcss.list.space(decl.value); // merge vertical and horizontal dups


    if (value.length > 1 && value[0] === value[1]) {
      decl.value = value.slice(1).join(' ');
    }
  }); // clean-up rules

  decls = (0, _getDecls2["default"])(rule, allProperties);

  var _loop2 = function _loop2() {
    var lastNode = decls[decls.length - 1];
    var lastPart = lastNode.prop.split('-').pop(); // remove properties of lower precedence

    var lesser = decls.filter(function (node) {
      return !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && !(0, _isCustomProp2["default"])(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (!!~node.prop.toLowerCase().indexOf(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart));
    });
    lesser.forEach(_remove2["default"]);
    decls = decls.filter(function (node) {
      return !~lesser.indexOf(node);
    }); // get duplicate properties

    var duplicates = decls.filter(function (node) {
      return !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp2["default"])(node) && (0, _isCustomProp2["default"])(lastNode));
    });

    if (duplicates.length) {
      if (/hsla\(|rgba\(/i.test(getColorValue(lastNode))) {
        var preserve = duplicates.filter(function (node) {
          return !/hsla\(|rgba\(/i.test(getColorValue(node));
        }).pop();
        duplicates = duplicates.filter(function (node) {
          return node !== preserve;
        });
      }

      duplicates.forEach(_remove2["default"]);
    }

    decls = decls.filter(function (node) {
      return node !== lastNode && !~duplicates.indexOf(node);
    });
  };

  while (decls.length) {
    _loop2();
  }
}

exports["default"] = {
  explode: explode,
  merge: merge
};
module.exports = exports['default'];