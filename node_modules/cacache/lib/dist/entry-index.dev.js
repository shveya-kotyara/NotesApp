'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _templateObject() {
  var data = _taggedTemplateLiteral(["No cache entry for `", "` found in `", "`"], ["No cache entry for \\`", "\\` found in \\`", "\\`"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var BB = require('bluebird');

var contentPath = require('./content/path');

var crypto = require('crypto');

var figgyPudding = require('figgy-pudding');

var fixOwner = require('./util/fix-owner');

var fs = require('graceful-fs');

var hashToSegments = require('./util/hash-to-segments');

var ms = require('mississippi');

var path = require('path');

var ssri = require('ssri');

var Y = require('./util/y.js');

var indexV = require('../package.json')['cache-version'].index;

var appendFileAsync = BB.promisify(fs.appendFile);
var readFileAsync = BB.promisify(fs.readFile);
var readdirAsync = BB.promisify(fs.readdir);
var concat = ms.concat;
var from = ms.from;

module.exports.NotFoundError =
/*#__PURE__*/
function (_Error) {
  _inherits(NotFoundError, _Error);

  function NotFoundError(cache, key) {
    var _this;

    _classCallCheck(this, NotFoundError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NotFoundError).call(this, Y(_templateObject(), key, cache)));
    _this.code = 'ENOENT';
    _this.cache = cache;
    _this.key = key;
    return _this;
  }

  return NotFoundError;
}(_wrapNativeSuper(Error));

var IndexOpts = figgyPudding({
  metadata: {},
  size: {}
});
module.exports.insert = insert;

function insert(cache, key, integrity, opts) {
  opts = IndexOpts(opts);
  var bucket = bucketPath(cache, key);
  var entry = {
    key: key,
    integrity: integrity && ssri.stringify(integrity),
    time: Date.now(),
    size: opts.size,
    metadata: opts.metadata
  };
  return fixOwner.mkdirfix(cache, path.dirname(bucket)).then(function () {
    var stringified = JSON.stringify(entry); // NOTE - Cleverness ahoy!
    //
    // This works because it's tremendously unlikely for an entry to corrupt
    // another while still preserving the string length of the JSON in
    // question. So, we just slap the length in there and verify it on read.
    //
    // Thanks to @isaacs for the whiteboarding session that ended up with this.

    return appendFileAsync(bucket, "\n".concat(hashEntry(stringified), "\t").concat(stringified));
  }).then(function () {
    return fixOwner.chownr(cache, bucket);
  })["catch"]({
    code: 'ENOENT'
  }, function () {// There's a class of race conditions that happen when things get deleted
    // during fixOwner, or between the two mkdirfix/chownr calls.
    //
    // It's perfectly fine to just not bother in those cases and lie
    // that the index entry was written. Because it's a cache.
  }).then(function () {
    return formatEntry(cache, entry);
  });
}

module.exports.insert.sync = insertSync;

function insertSync(cache, key, integrity, opts) {
  opts = IndexOpts(opts);
  var bucket = bucketPath(cache, key);
  var entry = {
    key: key,
    integrity: integrity && ssri.stringify(integrity),
    time: Date.now(),
    size: opts.size,
    metadata: opts.metadata
  };
  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));
  var stringified = JSON.stringify(entry);
  fs.appendFileSync(bucket, "\n".concat(hashEntry(stringified), "\t").concat(stringified));

  try {
    fixOwner.chownr.sync(cache, bucket);
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }

  return formatEntry(cache, entry);
}

module.exports.find = find;

function find(cache, key) {
  var bucket = bucketPath(cache, key);
  return bucketEntries(bucket).then(function (entries) {
    return entries.reduce(function (latest, next) {
      if (next && next.key === key) {
        return formatEntry(cache, next);
      } else {
        return latest;
      }
    }, null);
  })["catch"](function (err) {
    if (err.code === 'ENOENT') {
      return null;
    } else {
      throw err;
    }
  });
}

module.exports.find.sync = findSync;

function findSync(cache, key) {
  var bucket = bucketPath(cache, key);

  try {
    return bucketEntriesSync(bucket).reduce(function (latest, next) {
      if (next && next.key === key) {
        return formatEntry(cache, next);
      } else {
        return latest;
      }
    }, null);
  } catch (err) {
    if (err.code === 'ENOENT') {
      return null;
    } else {
      throw err;
    }
  }
}

module.exports["delete"] = del;

function del(cache, key, opts) {
  return insert(cache, key, null, opts);
}

module.exports["delete"].sync = delSync;

function delSync(cache, key, opts) {
  return insertSync(cache, key, null, opts);
}

module.exports.lsStream = lsStream;

function lsStream(cache) {
  var indexDir = bucketDir(cache);
  var stream = from.obj(); // "/cachename/*"

  readdirOrEmpty(indexDir).map(function (bucket) {
    var bucketPath = path.join(indexDir, bucket); // "/cachename/<bucket 0xFF>/*"

    return readdirOrEmpty(bucketPath).map(function (subbucket) {
      var subbucketPath = path.join(bucketPath, subbucket); // "/cachename/<bucket 0xFF>/<bucket 0xFF>/*"

      return readdirOrEmpty(subbucketPath).map(function (entry) {
        var getKeyToEntry = bucketEntries(path.join(subbucketPath, entry)).reduce(function (acc, entry) {
          acc.set(entry.key, entry);
          return acc;
        }, new Map());
        return getKeyToEntry.then(function (reduced) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = reduced.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _entry = _step.value;
              var formatted = formatEntry(cache, _entry);
              formatted && stream.push(formatted);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        })["catch"]({
          code: 'ENOENT'
        }, nop);
      });
    });
  }).then(function () {
    stream.push(null);
  }, function (err) {
    stream.emit('error', err);
  });
  return stream;
}

module.exports.ls = ls;

function ls(cache) {
  return BB.fromNode(function (cb) {
    lsStream(cache).on('error', cb).pipe(concat(function (entries) {
      cb(null, entries.reduce(function (acc, xs) {
        acc[xs.key] = xs;
        return acc;
      }, {}));
    }));
  });
}

function bucketEntries(bucket, filter) {
  return readFileAsync(bucket, 'utf8').then(function (data) {
    return _bucketEntries(data, filter);
  });
}

function bucketEntriesSync(bucket, filter) {
  var data = fs.readFileSync(bucket, 'utf8');
  return _bucketEntries(data, filter);
}

function _bucketEntries(data, filter) {
  var entries = [];
  data.split('\n').forEach(function (entry) {
    if (!entry) {
      return;
    }

    var pieces = entry.split('\t');

    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {
      // Hash is no good! Corruption or malice? Doesn't matter!
      // EJECT EJECT
      return;
    }

    var obj;

    try {
      obj = JSON.parse(pieces[1]);
    } catch (e) {
      // Entry is corrupted!
      return;
    }

    if (obj) {
      entries.push(obj);
    }
  });
  return entries;
}

module.exports._bucketDir = bucketDir;

function bucketDir(cache) {
  return path.join(cache, "index-v".concat(indexV));
}

module.exports._bucketPath = bucketPath;

function bucketPath(cache, key) {
  var hashed = hashKey(key);
  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));
}

module.exports._hashKey = hashKey;

function hashKey(key) {
  return hash(key, 'sha256');
}

module.exports._hashEntry = hashEntry;

function hashEntry(str) {
  return hash(str, 'sha1');
}

function hash(str, digest) {
  return crypto.createHash(digest).update(str).digest('hex');
}

function formatEntry(cache, entry) {
  // Treat null digests as deletions. They'll shadow any previous entries.
  if (!entry.integrity) {
    return null;
  }

  return {
    key: entry.key,
    integrity: entry.integrity,
    path: contentPath(cache, entry.integrity),
    size: entry.size,
    time: entry.time,
    metadata: entry.metadata
  };
}

function readdirOrEmpty(dir) {
  return readdirAsync(dir)["catch"]({
    code: 'ENOENT'
  }, function () {
    return [];
  })["catch"]({
    code: 'ENOTDIR'
  }, function () {
    return [];
  });
}

function nop() {}