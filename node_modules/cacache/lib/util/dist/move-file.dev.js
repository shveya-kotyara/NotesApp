'use strict';

var fs = require('graceful-fs');

var BB = require('bluebird');

var chmod = BB.promisify(fs.chmod);
var unlink = BB.promisify(fs.unlink);
var move;
var pinflight;
module.exports = moveFile;

function moveFile(src, dest) {
  // This isn't quite an fs.rename -- the assumption is that
  // if `dest` already exists, and we get certain errors while
  // trying to move it, we should just not bother.
  //
  // In the case of cache corruption, users will receive an
  // EINTEGRITY error elsewhere, and can remove the offending
  // content their own way.
  //
  // Note that, as the name suggests, this strictly only supports file moves.
  return BB.fromNode(function (cb) {
    fs.link(src, dest, function (err) {
      if (err) {
        if (err.code === 'EEXIST' || err.code === 'EBUSY') {// file already exists, so whatever
        } else if (err.code === 'EPERM' && process.platform === 'win32') {// file handle stayed open even past graceful-fs limits
        } else {
          return cb(err);
        }
      }

      return cb();
    });
  }).then(function () {
    // content should never change for any reason, so make it read-only
    return BB.join(unlink(src), process.platform !== 'win32' && chmod(dest, '0444'));
  })["catch"](function () {
    if (!pinflight) {
      pinflight = require('promise-inflight');
    }

    return pinflight('cacache-move-file:' + dest, function () {
      return BB.promisify(fs.stat)(dest)["catch"](function (err) {
        if (err.code !== 'ENOENT') {
          // Something else is wrong here. Bail bail bail
          throw err;
        } // file doesn't already exist! let's try a rename -> copy fallback


        if (!move) {
          move = require('move-concurrently');
        }

        return move(src, dest, {
          BB: BB,
          fs: fs
        });
      });
    });
  });
}