"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Minipass = require('minipass');

var EE = require('events');

var isStream = function isStream(s) {
  return s && s instanceof EE && (typeof s.pipe === 'function' || // readable
  typeof s.write === 'function' && typeof s.end === 'function' // writable
  );
};

var _head = Symbol('_head');

var _tail = Symbol('_tail');

var _linkStreams = Symbol('_linkStreams');

var _setHead = Symbol('_setHead');

var _setTail = Symbol('_setTail');

var _onError = Symbol('_onError');

var _onData = Symbol('_onData');

var _onEnd = Symbol('_onEnd');

var _onDrain = Symbol('_onDrain');

var _streams = Symbol('_streams');

var Pipeline =
/*#__PURE__*/
function (_Minipass) {
  _inherits(Pipeline, _Minipass);

  function Pipeline(opts) {
    var _this2;

    var _this;

    _classCallCheck(this, Pipeline);

    for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      streams[_key - 1] = arguments[_key];
    }

    if (isStream(opts)) {
      streams.unshift(opts);
      opts = {};
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pipeline).call(this, opts));
    _this[_streams] = [];
    if (streams.length) (_this2 = _this).push.apply(_this2, streams);
    return _this;
  }

  _createClass(Pipeline, [{
    key: _linkStreams,
    value: function value(streams) {
      // reduce takes (left,right), and we return right to make it the
      // new left value.
      return streams.reduce(function (src, dest) {
        src.on('error', function (er) {
          return dest.emit('error', er);
        });
        src.pipe(dest);
        return dest;
      });
    }
  }, {
    key: "push",
    value: function push() {
      var _this$_streams;

      for (var _len2 = arguments.length, streams = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        streams[_key2] = arguments[_key2];
      }

      (_this$_streams = this[_streams]).push.apply(_this$_streams, streams);

      if (this[_tail]) streams.unshift(this[_tail]);

      var linkRet = this[_linkStreams](streams);

      this[_setTail](linkRet);

      if (!this[_head]) this[_setHead](streams[0]);
    }
  }, {
    key: "unshift",
    value: function unshift() {
      var _this$_streams2;

      for (var _len3 = arguments.length, streams = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        streams[_key3] = arguments[_key3];
      }

      (_this$_streams2 = this[_streams]).unshift.apply(_this$_streams2, streams);

      if (this[_head]) streams.push(this[_head]);

      var linkRet = this[_linkStreams](streams);

      this[_setHead](streams[0]);

      if (!this[_tail]) this[_setTail](linkRet);
    }
  }, {
    key: "destroy",
    value: function destroy(er) {
      // set fire to the whole thing.
      this[_streams].forEach(function (s) {
        return typeof s.destroy === 'function' && s.destroy();
      });

      return _get(_getPrototypeOf(Pipeline.prototype), "destroy", this).call(this, er);
    } // readable interface -> tail

  }, {
    key: _setTail,
    value: function value(stream) {
      var _this3 = this;

      this[_tail] = stream;
      stream.on('error', function (er) {
        return _this3[_onError](stream, er);
      });
      stream.on('data', function (chunk) {
        return _this3[_onData](stream, chunk);
      });
      stream.on('end', function () {
        return _this3[_onEnd](stream);
      });
      stream.on('finish', function () {
        return _this3[_onEnd](stream);
      });
    } // errors proxied down the pipeline
    // they're considered part of the "read" interface

  }, {
    key: _onError,
    value: function value(stream, er) {
      if (stream === this[_tail]) this.emit('error', er);
    }
  }, {
    key: _onData,
    value: function value(stream, chunk) {
      if (stream === this[_tail]) _get(_getPrototypeOf(Pipeline.prototype), "write", this).call(this, chunk);
    }
  }, {
    key: _onEnd,
    value: function value(stream) {
      if (stream === this[_tail]) _get(_getPrototypeOf(Pipeline.prototype), "end", this).call(this);
    }
  }, {
    key: "pause",
    value: function pause() {
      _get(_getPrototypeOf(Pipeline.prototype), "pause", this).call(this);

      return this[_tail] && this[_tail].pause && this[_tail].pause();
    } // NB: Minipass calls its internal private [RESUME] method during
    // pipe drains, to avoid hazards where stream.resume() is overridden.
    // Thus, we need to listen to the resume *event*, not override the
    // resume() method, and proxy *that* to the tail.

  }, {
    key: "emit",
    value: function emit(ev) {
      var _get2;

      if (ev === 'resume' && this[_tail] && this[_tail].resume) this[_tail].resume();

      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      return (_get2 = _get(_getPrototypeOf(Pipeline.prototype), "emit", this)).call.apply(_get2, [this, ev].concat(args));
    } // writable interface -> head

  }, {
    key: _setHead,
    value: function value(stream) {
      var _this4 = this;

      this[_head] = stream;
      stream.on('drain', function () {
        return _this4[_onDrain](stream);
      });
    }
  }, {
    key: _onDrain,
    value: function value(stream) {
      if (stream === this[_head]) this.emit('drain');
    }
  }, {
    key: "write",
    value: function write(chunk, enc, cb) {
      return this[_head].write(chunk, enc, cb) && (this.flowing || this.buffer.length === 0);
    }
  }, {
    key: "end",
    value: function end(chunk, enc, cb) {
      this[_head].end(chunk, enc, cb);

      return this;
    }
  }]);

  return Pipeline;
}(Minipass);

module.exports = Pipeline;