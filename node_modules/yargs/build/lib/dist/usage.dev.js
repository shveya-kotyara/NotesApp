"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usage = void 0; // this file handles outputting usage instructions,
// failures, etc. keeps logging in one place.

var common_types_1 = require("./common-types");

var obj_filter_1 = require("./obj-filter");

var path = require("path");

var yerror_1 = require("./yerror");

var decamelize = require("decamelize");

var setBlocking = require("set-blocking");

var stringWidth = require("string-width");

function usage(yargs, y18n) {
  var __ = y18n.__;
  var self = {}; // methods for ouputting/building failure message.

  var fails = [];

  self.failFn = function failFn(f) {
    fails.push(f);
  };

  var failMessage = null;
  var showHelpOnFail = true;

  self.showHelpOnFail = function showHelpOnFailFn() {
    var arg1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var arg2 = arguments.length > 1 ? arguments[1] : undefined;

    function parseFunctionArgs() {
      return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];
    }

    var _parseFunctionArgs = parseFunctionArgs(),
        _parseFunctionArgs2 = _slicedToArray(_parseFunctionArgs, 2),
        enabled = _parseFunctionArgs2[0],
        message = _parseFunctionArgs2[1];

    failMessage = message;
    showHelpOnFail = enabled;
    return self;
  };

  var failureOutput = false;

  self.fail = function fail(msg, err) {
    var logger = yargs._getLoggerInstance();

    if (fails.length) {
      for (var i = fails.length - 1; i >= 0; --i) {
        fails[i](msg, err, self);
      }
    } else {
      if (yargs.getExitProcess()) setBlocking(true); // don't output failure message more than once

      if (!failureOutput) {
        failureOutput = true;

        if (showHelpOnFail) {
          yargs.showHelp('error');
          logger.error();
        }

        if (msg || err) logger.error(msg || err);

        if (failMessage) {
          if (msg || err) logger.error('');
          logger.error(failMessage);
        }
      }

      err = err || new yerror_1.YError(msg);

      if (yargs.getExitProcess()) {
        return yargs.exit(1);
      } else if (yargs._hasParseCallback()) {
        return yargs.exit(1, err);
      } else {
        throw err;
      }
    }
  }; // methods for ouputting/building help (usage) message.


  var usages = [];
  var usageDisabled = false;

  self.usage = function (msg, description) {
    if (msg === null) {
      usageDisabled = true;
      usages = [];
      return self;
    }

    usageDisabled = false;
    usages.push([msg, description || '']);
    return self;
  };

  self.getUsage = function () {
    return usages;
  };

  self.getUsageDisabled = function () {
    return usageDisabled;
  };

  self.getPositionalGroupName = function () {
    return __('Positionals:');
  };

  var examples = [];

  self.example = function (cmd, description) {
    examples.push([cmd, description || '']);
  };

  var commands = [];

  self.command = function command(cmd, description, isDefault, aliases) {
    var deprecated = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    // the last default wins, so cancel out any previously set default
    if (isDefault) {
      commands = commands.map(function (cmdArray) {
        cmdArray[2] = false;
        return cmdArray;
      });
    }

    commands.push([cmd, description || '', isDefault, aliases, deprecated]);
  };

  self.getCommands = function () {
    return commands;
  };

  var descriptions = {};

  self.describe = function describe(keyOrKeys, desc) {
    if (Array.isArray(keyOrKeys)) {
      keyOrKeys.forEach(function (k) {
        self.describe(k, desc);
      });
    } else if (_typeof(keyOrKeys) === 'object') {
      Object.keys(keyOrKeys).forEach(function (k) {
        self.describe(k, keyOrKeys[k]);
      });
    } else {
      descriptions[keyOrKeys] = desc;
    }
  };

  self.getDescriptions = function () {
    return descriptions;
  };

  var epilogs = [];

  self.epilog = function (msg) {
    epilogs.push(msg);
  };

  var wrapSet = false;
  var wrap;

  self.wrap = function (cols) {
    wrapSet = true;
    wrap = cols;
  };

  function getWrap() {
    if (!wrapSet) {
      wrap = windowWidth();
      wrapSet = true;
    }

    return wrap;
  }

  var deferY18nLookupPrefix = '__yargsString__:';

  self.deferY18nLookup = function (str) {
    return deferY18nLookupPrefix + str;
  };

  self.help = function help() {
    if (cachedHelpMessage) return cachedHelpMessage;
    normalizeAliases(); // handle old demanded API

    var base$0 = yargs.customScriptName ? yargs.$0 : path.basename(yargs.$0);
    var demandedOptions = yargs.getDemandedOptions();
    var demandedCommands = yargs.getDemandedCommands();
    var deprecatedOptions = yargs.getDeprecatedOptions();
    var groups = yargs.getGroups();
    var options = yargs.getOptions();
    var keys = [];
    keys = keys.concat(Object.keys(descriptions));
    keys = keys.concat(Object.keys(demandedOptions));
    keys = keys.concat(Object.keys(demandedCommands));
    keys = keys.concat(Object.keys(options["default"]));
    keys = keys.filter(filterHiddenOptions);
    keys = Object.keys(keys.reduce(function (acc, key) {
      if (key !== '_') acc[key] = true;
      return acc;
    }, {}));
    var theWrap = getWrap();

    var ui = require('cliui')({
      width: theWrap,
      wrap: !!theWrap
    }); // the usage string.


    if (!usageDisabled) {
      if (usages.length) {
        // user-defined usage.
        usages.forEach(function (usage) {
          ui.div("".concat(usage[0].replace(/\$0/g, base$0)));

          if (usage[1]) {
            ui.div({
              text: "".concat(usage[1]),
              padding: [1, 0, 0, 0]
            });
          }
        });
        ui.div();
      } else if (commands.length) {
        var u = null; // demonstrate how commands are used.

        if (demandedCommands._) {
          u = "".concat(base$0, " <").concat(__('command'), ">\n");
        } else {
          u = "".concat(base$0, " [").concat(__('command'), "]\n");
        }

        ui.div("".concat(u));
      }
    } // your application's commands, i.e., non-option
    // arguments populated in '_'.


    if (commands.length) {
      ui.div(__('Commands:'));
      var context = yargs.getContext();
      var parentCommands = context.commands.length ? "".concat(context.commands.join(' '), " ") : '';

      if (yargs.getParserConfiguration()['sort-commands'] === true) {
        commands = commands.sort(function (a, b) {
          return a[0].localeCompare(b[0]);
        });
      }

      commands.forEach(function (command) {
        var commandString = "".concat(base$0, " ").concat(parentCommands).concat(command[0].replace(/^\$0 ?/, '')); // drop $0 from default commands.

        ui.span({
          text: commandString,
          padding: [0, 2, 0, 2],
          width: maxWidth(commands, theWrap, "".concat(base$0).concat(parentCommands)) + 4
        }, {
          text: command[1]
        });
        var hints = [];
        if (command[2]) hints.push("[".concat(__('default'), "]"));

        if (command[3] && command[3].length) {
          hints.push("[".concat(__('aliases:'), " ").concat(command[3].join(', '), "]"));
        }

        if (command[4]) {
          if (typeof command[4] === 'string') {
            hints.push("[".concat(__('deprecated: %s', command[4]), "]"));
          } else {
            hints.push("[".concat(__('deprecated'), "]"));
          }
        }

        if (hints.length) {
          ui.div({
            text: hints.join(' '),
            padding: [0, 0, 0, 2],
            align: 'right'
          });
        } else {
          ui.div();
        }
      });
      ui.div();
    } // perform some cleanup on the keys array, making it
    // only include top-level keys not their aliases.


    var aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
    keys = keys.filter(function (key) {
      return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {
        return (options.alias[alias] || []).indexOf(key) === -1;
      });
    }); // populate 'Options:' group with any keys that have not
    // explicitly had a group set.

    var defaultGroup = __('Options:');

    if (!groups[defaultGroup]) groups[defaultGroup] = [];
    addUngroupedKeys(keys, options.alias, groups, defaultGroup); // display 'Options:' table along with any custom tables:

    Object.keys(groups).forEach(function (groupName) {
      if (!groups[groupName].length) return; // if we've grouped the key 'f', but 'f' aliases 'foobar',
      // normalizedKeys should contain only 'foobar'.

      var normalizedKeys = groups[groupName].filter(filterHiddenOptions).map(function (key) {
        if (~aliasKeys.indexOf(key)) return key;

        for (var i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {
          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey;
        }

        return key;
      });
      if (normalizedKeys.length < 1) return;
      ui.div(groupName); // actually generate the switches string --foo, -f, --bar.

      var switches = normalizedKeys.reduce(function (acc, key) {
        acc[key] = [key].concat(options.alias[key] || []).map(function (sw) {
          // for the special positional group don't
          // add '--' or '-' prefix.
          if (groupName === self.getPositionalGroupName()) return sw;else {
            return ( // matches yargs-parser logic in which single-digits
            // aliases declared with a boolean type are now valid
            /^[0-9]$/.test(sw) ? ~options["boolean"].indexOf(key) ? '-' : '--' : sw.length > 1 ? '--' : '-') + sw;
          }
        }).join(', ');
        return acc;
      }, {});
      normalizedKeys.forEach(function (key) {
        var kswitch = switches[key];
        var desc = descriptions[key] || '';
        var type = null;
        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));
        if (~options["boolean"].indexOf(key)) type = "[".concat(__('boolean'), "]");
        if (~options.count.indexOf(key)) type = "[".concat(__('count'), "]");
        if (~options.string.indexOf(key)) type = "[".concat(__('string'), "]");
        if (~options.normalize.indexOf(key)) type = "[".concat(__('string'), "]");
        if (~options.array.indexOf(key)) type = "[".concat(__('array'), "]");
        if (~options.number.indexOf(key)) type = "[".concat(__('number'), "]");

        var deprecatedExtra = function deprecatedExtra(deprecated) {
          return typeof deprecated === 'string' ? "[".concat(__('deprecated: %s', deprecated), "]") : "[".concat(__('deprecated'), "]");
        };

        var extra = [key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null, type, key in demandedOptions ? "[".concat(__('required'), "]") : null, options.choices && options.choices[key] ? "[".concat(__('choices:'), " ").concat(self.stringifiedValues(options.choices[key]), "]") : null, defaultString(options["default"][key], options.defaultDescription[key])].filter(Boolean).join(' ');
        ui.span({
          text: kswitch,
          padding: [0, 2, 0, 2],
          width: maxWidth(switches, theWrap) + 4
        }, desc);
        if (extra) ui.div({
          text: extra,
          padding: [0, 0, 0, 2],
          align: 'right'
        });else ui.div();
      });
      ui.div();
    }); // describe some common use-cases for your application.

    if (examples.length) {
      ui.div(__('Examples:'));
      examples.forEach(function (example) {
        example[0] = example[0].replace(/\$0/g, base$0);
      });
      examples.forEach(function (example) {
        if (example[1] === '') {
          ui.div({
            text: example[0],
            padding: [0, 2, 0, 2]
          });
        } else {
          ui.div({
            text: example[0],
            padding: [0, 2, 0, 2],
            width: maxWidth(examples, theWrap) + 4
          }, {
            text: example[1]
          });
        }
      });
      ui.div();
    } // the usage string.


    if (epilogs.length > 0) {
      var e = epilogs.map(function (epilog) {
        return epilog.replace(/\$0/g, base$0);
      }).join('\n');
      ui.div("".concat(e, "\n"));
    } // Remove the trailing white spaces


    return ui.toString().replace(/\s*$/, '');
  }; // return the maximum width of a string
  // in the left-hand column of a table.


  function maxWidth(table, theWrap, modifier) {
    var width = 0; // table might be of the form [leftColumn],
    // or {key: leftColumn}

    if (!Array.isArray(table)) {
      table = Object.values(table).map(function (v) {
        return [v];
      });
    }

    table.forEach(function (v) {
      width = Math.max(stringWidth(modifier ? "".concat(modifier, " ").concat(v[0]) : v[0]), width);
    }); // if we've enabled 'wrap' we should limit
    // the max-width of the left-column.

    if (theWrap) width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
    return width;
  } // make sure any options set for aliases,
  // are copied to the keys being aliased.


  function normalizeAliases() {
    // handle old demanded API
    var demandedOptions = yargs.getDemandedOptions();
    var options = yargs.getOptions();
    (Object.keys(options.alias) || []).forEach(function (key) {
      options.alias[key].forEach(function (alias) {
        // copy descriptions.
        if (descriptions[alias]) self.describe(key, descriptions[alias]); // copy demanded.

        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]); // type messages.

        if (~options["boolean"].indexOf(alias)) yargs["boolean"](key);
        if (~options.count.indexOf(alias)) yargs.count(key);
        if (~options.string.indexOf(alias)) yargs.string(key);
        if (~options.normalize.indexOf(alias)) yargs.normalize(key);
        if (~options.array.indexOf(alias)) yargs.array(key);
        if (~options.number.indexOf(alias)) yargs.number(key);
      });
    });
  } // if yargs is executing an async handler, we take a snapshot of the
  // help message to display on failure:


  var cachedHelpMessage;

  self.cacheHelpMessage = function () {
    cachedHelpMessage = this.help();
  }; // however this snapshot must be cleared afterwards
  // not to be be used by next calls to parse


  self.clearCachedHelpMessage = function () {
    cachedHelpMessage = undefined;
  }; // given a set of keys, place any keys that are
  // ungrouped under the 'Options:' grouping.


  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
    var groupedKeys = [];
    var toCheck = null;
    Object.keys(groups).forEach(function (group) {
      groupedKeys = groupedKeys.concat(groups[group]);
    });
    keys.forEach(function (key) {
      toCheck = [key].concat(aliases[key]);

      if (!toCheck.some(function (k) {
        return groupedKeys.indexOf(k) !== -1;
      })) {
        groups[defaultGroup].push(key);
      }
    });
    return groupedKeys;
  }

  function filterHiddenOptions(key) {
    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
  }

  self.showHelp = function (level) {
    var logger = yargs._getLoggerInstance();

    if (!level) level = 'error';
    var emit = typeof level === 'function' ? level : logger[level];
    emit(self.help());
  };

  self.functionDescription = function (fn) {
    var description = fn.name ? decamelize(fn.name, '-') : __('generated-value');
    return ['(', description, ')'].join('');
  };

  self.stringifiedValues = function stringifiedValues(values, separator) {
    var string = '';
    var sep = separator || ', ';
    var array = [].concat(values);
    if (!values || !array.length) return string;
    array.forEach(function (value) {
      if (string.length) string += sep;
      string += JSON.stringify(value);
    });
    return string;
  }; // format the default-value-string displayed in
  // the right-hand column.


  function defaultString(value, defaultDescription) {
    var string = "[".concat(__('default:'), " ");
    if (value === undefined && !defaultDescription) return null;

    if (defaultDescription) {
      string += defaultDescription;
    } else {
      switch (_typeof(value)) {
        case 'string':
          string += "\"".concat(value, "\"");
          break;

        case 'object':
          string += JSON.stringify(value);
          break;

        default:
          string += value;
      }
    }

    return "".concat(string, "]");
  } // guess the width of the console window, max-width 80.


  function windowWidth() {
    var maxWidth = 80; // CI is not a TTY

    /* c8 ignore next 2 */

    if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.stdout && process.stdout.columns) {
      return Math.min(maxWidth, process.stdout.columns);
    } else {
      return maxWidth;
    }
  } // logic for displaying application version.


  var version = null;

  self.version = function (ver) {
    version = ver;
  };

  self.showVersion = function () {
    var logger = yargs._getLoggerInstance();

    logger.log(version);
  };

  self.reset = function reset(localLookup) {
    // do not reset wrap here
    // do not reset fails here
    failMessage = null;
    failureOutput = false;
    usages = [];
    usageDisabled = false;
    epilogs = [];
    examples = [];
    commands = [];
    descriptions = obj_filter_1.objFilter(descriptions, function (k) {
      return !localLookup[k];
    });
    return self;
  };

  var frozens = [];

  self.freeze = function freeze() {
    frozens.push({
      failMessage: failMessage,
      failureOutput: failureOutput,
      usages: usages,
      usageDisabled: usageDisabled,
      epilogs: epilogs,
      examples: examples,
      commands: commands,
      descriptions: descriptions
    });
  };

  self.unfreeze = function unfreeze() {
    var frozen = frozens.pop();
    common_types_1.assertNotStrictEqual(frozen, undefined);
    failMessage = frozen.failMessage;
    failureOutput = frozen.failureOutput;
    usages = frozen.usages;
    usageDisabled = frozen.usageDisabled;
    epilogs = frozen.epilogs;
    examples = frozen.examples;
    commands = frozen.commands;
    descriptions = frozen.descriptions;
  };

  return self;
}

exports.usage = usage;