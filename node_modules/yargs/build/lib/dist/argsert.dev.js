"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.argsert = void 0;

var yerror_1 = require("./yerror");

var parse_command_1 = require("./parse-command");

var positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];

function argsert(arg1, arg2, arg3) {
  function parseArgs() {
    return _typeof(arg1) === 'object' ? [{
      demanded: [],
      optional: []
    }, arg1, arg2] : [parse_command_1.parseCommand("cmd ".concat(arg1)), arg2, arg3];
  } // TODO: should this eventually raise an exception.


  try {
    // preface the argument description with "cmd", so
    // that we can run it through yargs' command parser.
    var position = 0;

    var _parseArgs = parseArgs(),
        _parseArgs2 = _slicedToArray(_parseArgs, 3),
        parsed = _parseArgs2[0],
        callerArguments = _parseArgs2[1],
        length = _parseArgs2[2];

    var args = [].slice.call(callerArguments);

    while (args.length && args[args.length - 1] === undefined) {
      args.pop();
    }

    length = length || args.length;

    if (length < parsed.demanded.length) {
      throw new yerror_1.YError("Not enough arguments provided. Expected ".concat(parsed.demanded.length, " but received ").concat(args.length, "."));
    }

    var totalCommands = parsed.demanded.length + parsed.optional.length;

    if (length > totalCommands) {
      throw new yerror_1.YError("Too many arguments provided. Expected max ".concat(totalCommands, " but received ").concat(length, "."));
    }

    parsed.demanded.forEach(function (demanded) {
      var arg = args.shift();
      var observedType = guessType(arg);
      var matchingTypes = demanded.cmd.filter(function (type) {
        return type === observedType || type === '*';
      });
      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position);
      position += 1;
    });
    parsed.optional.forEach(function (optional) {
      if (args.length === 0) return;
      var arg = args.shift();
      var observedType = guessType(arg);
      var matchingTypes = optional.cmd.filter(function (type) {
        return type === observedType || type === '*';
      });
      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position);
      position += 1;
    });
  } catch (err) {
    console.warn(err.stack);
  }
}

exports.argsert = argsert;

function guessType(arg) {
  if (Array.isArray(arg)) {
    return 'array';
  } else if (arg === null) {
    return 'null';
  }

  return _typeof(arg);
}

function argumentTypeError(observedType, allowedTypes, position) {
  throw new yerror_1.YError("Invalid ".concat(positionName[position] || 'manyith', " argument. Expected ").concat(allowedTypes.join(' or '), " but received ").concat(observedType, "."));
}