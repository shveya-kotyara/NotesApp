"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validation = void 0;

var argsert_1 = require("./argsert");

var common_types_1 = require("./common-types");

var levenshtein_1 = require("./levenshtein");

var obj_filter_1 = require("./obj-filter");

var specialKeys = ['$0', '--', '_']; // validation-type-stuff, missing params,
// bad implications, custom checks.

function validation(yargs, usage, y18n) {
  var __ = y18n.__;
  var __n = y18n.__n;
  var self = {}; // validate appropriate # of non-option
  // arguments were provided, i.e., '_'.

  self.nonOptionCount = function nonOptionCount(argv) {
    var demandedCommands = yargs.getDemandedCommands(); // don't count currently executing commands

    var _s = argv._.length - yargs.getContext().commands.length;

    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== undefined) {
          usage.fail( // replace $0 with observed, $1 with expected.
          demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
        } else {
          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s, demandedCommands._.min));
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== undefined) {
          usage.fail( // replace $0 with observed, $1 with expected.
          demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
        } else {
          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s, demandedCommands._.max));
        }
      }
    }
  }; // validate the appropriate # of <required>
  // positional arguments were provided:


  self.positionalCount = function positionalCount(required, observed) {
    if (observed < required) {
      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed, required));
    }
  }; // make sure all the required arguments are present.


  self.requiredArguments = function requiredArguments(argv) {
    var demandedOptions = yargs.getDemandedOptions();
    var missing = null;

    for (var _i = 0, _Object$keys = Object.keys(demandedOptions); _i < _Object$keys.length; _i++) {
      var _key = _Object$keys[_i];

      if (!Object.prototype.hasOwnProperty.call(argv, _key) || typeof argv[_key] === 'undefined') {
        missing = missing || {};
        missing[_key] = demandedOptions[_key];
      }
    }

    if (missing) {
      var customMsgs = [];

      for (var _i2 = 0, _Object$keys2 = Object.keys(missing); _i2 < _Object$keys2.length; _i2++) {
        var key = _Object$keys2[_i2];
        var msg = missing[key];

        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg);
        }
      }

      var customMsg = customMsgs.length ? "\n".concat(customMsgs.join('\n')) : '';
      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
    }
  }; // check for unknown arguments (strict-mode).


  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {
    var commandKeys = yargs.getCommandInstance().getCommands();
    var unknown = [];
    var currentContext = yargs.getContext();
    Object.keys(argv).forEach(function (key) {
      if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
        unknown.push(key);
      }
    });

    if (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand) {
      argv._.slice(currentContext.commands.length).forEach(function (key) {
        if (commandKeys.indexOf(key) === -1) {
          unknown.push(key);
        }
      });
    }

    if (unknown.length > 0) {
      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));
    }
  };

  self.unknownCommands = function unknownCommands(argv) {
    var commandKeys = yargs.getCommandInstance().getCommands();
    var unknown = [];
    var currentContext = yargs.getContext();

    if (currentContext.commands.length > 0 || commandKeys.length > 0) {
      argv._.slice(currentContext.commands.length).forEach(function (key) {
        if (commandKeys.indexOf(key) === -1) {
          unknown.push(key);
        }
      });
    }

    if (unknown.length > 0) {
      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
      return true;
    } else {
      return false;
    }
  }; // check for a key that is not an alias, or for which every alias is new,
  // implying that it was invented by the parser, e.g., during camelization


  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
      return false;
    }

    var newAliases = yargs.parsed.newAliases;

    for (var _i3 = 0, _arr = [key].concat(_toConsumableArray(aliases[key])); _i3 < _arr.length; _i3++) {
      var a = _arr[_i3];

      if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {
        return true;
      }
    }

    return false;
  }; // validate arguments limited to enumerated choices


  self.limitedChoices = function limitedChoices(argv) {
    var options = yargs.getOptions();
    var invalid = {};
    if (!Object.keys(options.choices).length) return;
    Object.keys(argv).forEach(function (key) {
      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
        [].concat(argv[key]).forEach(function (value) {
          // TODO case-insensitive configurability
          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {
            invalid[key] = (invalid[key] || []).concat(value);
          }
        });
      }
    });
    var invalidKeys = Object.keys(invalid);
    if (!invalidKeys.length) return;

    var msg = __('Invalid values:');

    invalidKeys.forEach(function (key) {
      msg += "\n  ".concat(__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key])));
    });
    usage.fail(msg);
  }; // custom checks, added using the `check` option on yargs.


  var checks = [];

  self.check = function check(f, global) {
    checks.push({
      func: f,
      global: global
    });
  };

  self.customChecks = function customChecks(argv, aliases) {
    for (var i = 0, f; (f = checks[i]) !== undefined; i++) {
      var func = f.func;
      var result = null;

      try {
        result = func(argv, aliases);
      } catch (err) {
        usage.fail(err.message ? err.message : err, err);
        continue;
      }

      if (!result) {
        usage.fail(__('Argument check failed: %s', func.toString()));
      } else if (typeof result === 'string' || result instanceof Error) {
        usage.fail(result.toString(), result);
      }
    }
  }; // check implications, argument foo implies => argument bar.


  var implied = {};

  self.implies = function implies(key, value) {
    argsert_1.argsert('<string|object> [array|number|string]', [key, value], arguments.length);

    if (_typeof(key) === 'object') {
      Object.keys(key).forEach(function (k) {
        self.implies(k, key[k]);
      });
    } else {
      yargs.global(key);

      if (!implied[key]) {
        implied[key] = [];
      }

      if (Array.isArray(value)) {
        value.forEach(function (i) {
          return self.implies(key, i);
        });
      } else {
        common_types_1.assertNotStrictEqual(value, undefined);
        implied[key].push(value);
      }
    }
  };

  self.getImplied = function getImplied() {
    return implied;
  };

  function keyExists(argv, val) {
    // convert string '1' to number 1
    var num = Number(val);
    val = isNaN(num) ? val : num;

    if (typeof val === 'number') {
      // check length of argv._
      val = argv._.length >= val;
    } else if (val.match(/^--no-.+/)) {
      // check if key/value doesn't exist
      val = val.match(/^--no-(.+)/)[1];
      val = !argv[val];
    } else {
      // check if key/value exists
      val = argv[val];
    }

    return val;
  }

  self.implications = function implications(argv) {
    var implyFail = [];
    Object.keys(implied).forEach(function (key) {
      var origKey = key;
      (implied[key] || []).forEach(function (value) {
        var key = origKey;
        var origValue = value;
        key = keyExists(argv, key);
        value = keyExists(argv, value);

        if (key && !value) {
          implyFail.push(" ".concat(origKey, " -> ").concat(origValue));
        }
      });
    });

    if (implyFail.length) {
      var msg = "".concat(__('Implications failed:'), "\n");
      implyFail.forEach(function (value) {
        msg += value;
      });
      usage.fail(msg);
    }
  };

  var conflicting = {};

  self.conflicts = function conflicts(key, value) {
    argsert_1.argsert('<string|object> [array|string]', [key, value], arguments.length);

    if (_typeof(key) === 'object') {
      Object.keys(key).forEach(function (k) {
        self.conflicts(k, key[k]);
      });
    } else {
      yargs.global(key);

      if (!conflicting[key]) {
        conflicting[key] = [];
      }

      if (Array.isArray(value)) {
        value.forEach(function (i) {
          return self.conflicts(key, i);
        });
      } else {
        conflicting[key].push(value);
      }
    }
  };

  self.getConflicting = function () {
    return conflicting;
  };

  self.conflicting = function conflictingFn(argv) {
    Object.keys(argv).forEach(function (key) {
      if (conflicting[key]) {
        conflicting[key].forEach(function (value) {
          // we default keys to 'undefined' that have been configured, we should not
          // apply conflicting check unless they are a value other than 'undefined'.
          if (value && argv[key] !== undefined && argv[value] !== undefined) {
            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
          }
        });
      }
    });
  };

  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
    var threshold = 3; // if it takes more than three edits, let's move on.

    potentialCommands = potentialCommands.sort(function (a, b) {
      return b.length - a.length;
    });
    var recommended = null;
    var bestDistance = Infinity;

    for (var i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
      var d = levenshtein_1.levenshtein(cmd, candidate);

      if (d <= threshold && d < bestDistance) {
        bestDistance = d;
        recommended = candidate;
      }
    }

    if (recommended) usage.fail(__('Did you mean %s?', recommended));
  };

  self.reset = function reset(localLookup) {
    implied = obj_filter_1.objFilter(implied, function (k) {
      return !localLookup[k];
    });
    conflicting = obj_filter_1.objFilter(conflicting, function (k) {
      return !localLookup[k];
    });
    checks = checks.filter(function (c) {
      return c.global;
    });
    return self;
  };

  var frozens = [];

  self.freeze = function freeze() {
    frozens.push({
      implied: implied,
      checks: checks,
      conflicting: conflicting
    });
  };

  self.unfreeze = function unfreeze() {
    var frozen = frozens.pop();
    common_types_1.assertNotStrictEqual(frozen, undefined);
    implied = frozen.implied;
    checks = frozen.checks;
    conflicting = frozen.conflicting;
  };

  return self;
}

exports.validation = validation;