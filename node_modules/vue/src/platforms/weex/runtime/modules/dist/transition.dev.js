"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _debug = require("core/util/debug");

var _util = require("shared/util");

var _lifecycle = require("core/instance/lifecycle");

var _transitionUtil = require("web/runtime/transition-util");

var _default = {
  create: enter,
  activate: enter,
  remove: leave
};
exports["default"] = _default;

function enter(_, vnode) {
  var el = vnode.elm; // call leave callback now

  if (el._leaveCb) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = (0, _transitionUtil.resolveTransition)(vnode.data.transition);

  if (!data) {
    return;
  }
  /* istanbul ignore if */


  if (el._enterCb) {
    return;
  }

  var enterClass = data.enterClass,
      enterToClass = data.enterToClass,
      enterActiveClass = data.enterActiveClass,
      appearClass = data.appearClass,
      appearToClass = data.appearToClass,
      appearActiveClass = data.appearActiveClass,
      beforeEnter = data.beforeEnter,
      enter = data.enter,
      afterEnter = data.afterEnter,
      enterCancelled = data.enterCancelled,
      beforeAppear = data.beforeAppear,
      appear = data.appear,
      afterAppear = data.afterAppear,
      appearCancelled = data.appearCancelled;
  var context = _lifecycle.activeInstance;
  var transitionNode = _lifecycle.activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear ? appearClass : enterClass;
  var toClass = isAppear ? appearToClass : enterToClass;
  var activeClass = isAppear ? appearActiveClass : enterActiveClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var userWantsControl = enterHook && // enterHook may be a bound method which exposes
  // the length of original fn as _length
  (enterHook._length || enterHook.length) > 1;
  var stylesheet = vnode.context.$options.style || {};
  var startState = stylesheet[startClass];
  var transitionProperties = stylesheet['@TRANSITION'] && stylesheet['@TRANSITION'][activeClass] || {};
  var endState = getEnterTargetState(el, stylesheet, startClass, toClass, activeClass);
  var needAnimation = Object.keys(endState).length > 0;
  var cb = el._enterCb = (0, _util.once)(function () {
    if (cb.cancelled) {
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  }); // We need to wait until the native element has been inserted, but currently
  // there's no API to do that. So we have to wait "one frame" - not entirely
  // sure if this is guaranteed to be enough (e.g. on slow devices?)

  setTimeout(function () {
    var parent = el.parentNode;
    var pendingNode = parent && parent._pending && parent._pending[vnode.key];

    if (pendingNode && pendingNode.context === vnode.context && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
      pendingNode.elm._leaveCb();
    }

    enterHook && enterHook(el, cb);

    if (needAnimation) {
      var animation = vnode.context.$requireWeexModule('animation');
      animation.transition(el.ref, {
        styles: endState,
        duration: transitionProperties.duration || 0,
        delay: transitionProperties.delay || 0,
        timingFunction: transitionProperties.timingFunction || 'linear'
      }, userWantsControl ? _util.noop : cb);
    } else if (!userWantsControl) {
      cb();
    }
  }, 16); // start enter transition

  beforeEnterHook && beforeEnterHook(el);

  if (startState) {
    if (typeof el.setStyles === 'function') {
      el.setStyles(startState);
    } else {
      for (var key in startState) {
        el.setStyle(key, startState[key]);
      }
    }
  }

  if (!needAnimation && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (el._enterCb) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = (0, _transitionUtil.resolveTransition)(vnode.data.transition);

  if (!data) {
    return rm();
  }

  if (el._leaveCb) {
    return;
  }

  var leaveClass = data.leaveClass,
      leaveToClass = data.leaveToClass,
      leaveActiveClass = data.leaveActiveClass,
      beforeLeave = data.beforeLeave,
      leave = data.leave,
      afterLeave = data.afterLeave,
      leaveCancelled = data.leaveCancelled,
      delayLeave = data.delayLeave;
  var userWantsControl = leave && // leave hook may be a bound method which exposes
  // the length of original fn as _length
  (leave._length || leave.length) > 1;
  var stylesheet = vnode.context.$options.style || {};
  var startState = stylesheet[leaveClass];
  var endState = stylesheet[leaveToClass] || stylesheet[leaveActiveClass];
  var transitionProperties = stylesheet['@TRANSITION'] && stylesheet['@TRANSITION'][leaveActiveClass] || {};
  var cb = el._leaveCb = (0, _util.once)(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (cb.cancelled) {
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    var animation = vnode.context.$requireWeexModule('animation'); // the delayed leave may have already been cancelled

    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (startState) {
      animation.transition(el.ref, {
        styles: startState
      }, next);
    } else {
      next();
    }

    function next() {
      animation.transition(el.ref, {
        styles: endState,
        duration: transitionProperties.duration || 0,
        delay: transitionProperties.delay || 0,
        timingFunction: transitionProperties.timingFunction || 'linear'
      }, userWantsControl ? _util.noop : cb);
    }

    leave && leave(el, cb);

    if (!endState && !userWantsControl) {
      cb();
    }
  }
} // determine the target animation style for an entering transition.


function getEnterTargetState(el, stylesheet, startClass, endClass, activeClass) {
  var targetState = {};
  var startState = stylesheet[startClass];
  var endState = stylesheet[endClass];
  var activeState = stylesheet[activeClass]; // 1. fallback to element's default styling

  if (startState) {
    for (var key in startState) {
      targetState[key] = el.style[key];

      if (process.env.NODE_ENV !== 'production' && targetState[key] == null && (!activeState || activeState[key] == null) && (!endState || endState[key] == null)) {
        (0, _debug.warn)("transition property \"".concat(key, "\" is declared in enter starting class (.").concat(startClass, "), ") + "but not declared anywhere in enter ending class (.".concat(endClass, "), ") + "enter active cass (.".concat(activeClass, ") or the element's default styling. ") + "Note in Weex, CSS properties need explicit values to be transitionable.");
      }
    }
  } // 2. if state is mixed in active state, extract them while excluding
  //    transition properties


  if (activeState) {
    for (var _key in activeState) {
      if (_key.indexOf('transition') !== 0) {
        targetState[_key] = activeState[_key];
      }
    }
  } // 3. explicit endState has highest priority


  if (endState) {
    (0, _util.extend)(targetState, endState);
  }

  return targetState;
}