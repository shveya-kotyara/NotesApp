"use strict";
/**
 * @typedef {[number, boolean]} RangeValue
 */

/**
 * @callback RangeValueCallback
 * @param {RangeValue} rangeValue
 * @returns {boolean}
 */

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Range =
/*#__PURE__*/
function () {
  _createClass(Range, null, [{
    key: "getOperator",

    /**
     * @param {"left" | "right"} side
     * @param {boolean} exclusive
     * @returns {">" | ">=" | "<" | "<="}
     */
    value: function getOperator(side, exclusive) {
      if (side === 'left') {
        return exclusive ? '>' : '>=';
      }

      return exclusive ? '<' : '<=';
    }
    /**
     * @param {number} value
     * @param {boolean} logic is not logic applied
     * @param {boolean} exclusive is range exclusive
     * @returns {string}
     */

  }, {
    key: "formatRight",
    value: function formatRight(value, logic, exclusive) {
      if (logic === false) {
        return Range.formatLeft(value, !logic, !exclusive);
      }

      return "should be ".concat(Range.getOperator('right', exclusive), " ").concat(value);
    }
    /**
     * @param {number} value
     * @param {boolean} logic is not logic applied
     * @param {boolean} exclusive is range exclusive
     * @returns {string}
     */

  }, {
    key: "formatLeft",
    value: function formatLeft(value, logic, exclusive) {
      if (logic === false) {
        return Range.formatRight(value, !logic, !exclusive);
      }

      return "should be ".concat(Range.getOperator('left', exclusive), " ").concat(value);
    }
    /**
     * @param {number} start left side value
     * @param {number} end right side value
     * @param {boolean} startExclusive is range exclusive from left side
     * @param {boolean} endExclusive is range exclusive from right side
     * @param {boolean} logic is not logic applied
     * @returns {string}
     */

  }, {
    key: "formatRange",
    value: function formatRange(start, end, startExclusive, endExclusive, logic) {
      var result = 'should be';
      result += " ".concat(Range.getOperator(logic ? 'left' : 'right', logic ? startExclusive : !startExclusive), " ").concat(start, " ");
      result += logic ? 'and' : 'or';
      result += " ".concat(Range.getOperator(logic ? 'right' : 'left', logic ? endExclusive : !endExclusive), " ").concat(end);
      return result;
    }
    /**
     * @param {Array<RangeValue>} values
     * @param {boolean} logic is not logic applied
     * @return {RangeValue} computed value and it's exclusive flag
     */

  }, {
    key: "getRangeValue",
    value: function getRangeValue(values, logic) {
      var minMax = logic ? Infinity : -Infinity;
      var j = -1;
      var predicate = logic ?
      /** @type {RangeValueCallback} */
      function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            value = _ref2[0];

        return value <= minMax;
      } :
      /** @type {RangeValueCallback} */
      function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 1),
            value = _ref4[0];

        return value >= minMax;
      };

      for (var i = 0; i < values.length; i++) {
        if (predicate(values[i])) {
          var _values$i = _slicedToArray(values[i], 1);

          minMax = _values$i[0];
          j = i;
        }
      }

      if (j > -1) {
        return values[j];
      }

      return [Infinity, true];
    }
  }]);

  function Range() {
    _classCallCheck(this, Range);

    /** @type {Array<RangeValue>} */
    this._left = [];
    /** @type {Array<RangeValue>} */

    this._right = [];
  }
  /**
   * @param {number} value
   * @param {boolean=} exclusive
   */


  _createClass(Range, [{
    key: "left",
    value: function left(value) {
      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this._left.push([value, exclusive]);
    }
    /**
     * @param {number} value
     * @param {boolean=} exclusive
     */

  }, {
    key: "right",
    value: function right(value) {
      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this._right.push([value, exclusive]);
    }
    /**
     * @param {boolean} logic is not logic applied
     * @return {string} "smart" range string representation
     */

  }, {
    key: "format",
    value: function format() {
      var logic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var _Range$getRangeValue = Range.getRangeValue(this._left, logic),
          _Range$getRangeValue2 = _slicedToArray(_Range$getRangeValue, 2),
          start = _Range$getRangeValue2[0],
          leftExclusive = _Range$getRangeValue2[1];

      var _Range$getRangeValue3 = Range.getRangeValue(this._right, !logic),
          _Range$getRangeValue4 = _slicedToArray(_Range$getRangeValue3, 2),
          end = _Range$getRangeValue4[0],
          rightExclusive = _Range$getRangeValue4[1];

      if (!Number.isFinite(start) && !Number.isFinite(end)) {
        return '';
      }

      var realStart = leftExclusive ? start + 1 : start;
      var realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6

      if (realStart === realEnd) {
        return "should be ".concat(logic ? '' : '!', "= ").concat(realStart);
      } // e.g. 4 < x < ∞


      if (Number.isFinite(start) && !Number.isFinite(end)) {
        return Range.formatLeft(start, logic, leftExclusive);
      } // e.g. ∞ < x < 4


      if (!Number.isFinite(start) && Number.isFinite(end)) {
        return Range.formatRight(end, logic, rightExclusive);
      }

      return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);
    }
  }]);

  return Range;
}();

module.exports = Range;