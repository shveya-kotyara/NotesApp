"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _require = require('./util/hints'),
    stringHints = _require.stringHints,
    numberHints = _require.numberHints;
/** @typedef {import("json-schema").JSONSchema6} JSONSchema6 */

/** @typedef {import("json-schema").JSONSchema7} JSONSchema7 */

/** @typedef {import("./validate").Schema} Schema */

/** @typedef {import("./validate").ValidationErrorConfiguration} ValidationErrorConfiguration */

/** @typedef {import("./validate").PostFormatter} PostFormatter */

/** @typedef {import("./validate").SchemaUtilErrorObject} SchemaUtilErrorObject */

/** @enum {number} */


var SPECIFICITY = {
  type: 1,
  not: 1,
  oneOf: 1,
  anyOf: 1,
  "if": 1,
  "enum": 1,
  "const": 1,
  "instanceof": 1,
  required: 2,
  pattern: 2,
  patternRequired: 2,
  format: 2,
  formatMinimum: 2,
  formatMaximum: 2,
  minimum: 2,
  exclusiveMinimum: 2,
  maximum: 2,
  exclusiveMaximum: 2,
  multipleOf: 2,
  uniqueItems: 2,
  contains: 2,
  minLength: 2,
  maxLength: 2,
  minItems: 2,
  maxItems: 2,
  minProperties: 2,
  maxProperties: 2,
  dependencies: 2,
  propertyNames: 2,
  additionalItems: 2,
  additionalProperties: 2,
  absolutePath: 2
};
/**
 *
 * @param {Array<SchemaUtilErrorObject>} array
 * @param {(item: SchemaUtilErrorObject) => number} fn
 * @returns {Array<SchemaUtilErrorObject>}
 */

function filterMax(array, fn) {
  var evaluatedMax = array.reduce(function (max, item) {
    return Math.max(max, fn(item));
  }, 0);
  return array.filter(function (item) {
    return fn(item) === evaluatedMax;
  });
}
/**
 *
 * @param {Array<SchemaUtilErrorObject>} children
 * @returns {Array<SchemaUtilErrorObject>}
 */


function filterChildren(children) {
  var newChildren = children;
  newChildren = filterMax(newChildren,
  /**
   *
   * @param {SchemaUtilErrorObject} error
   * @returns {number}
   */
  function (error) {
    return error.dataPath ? error.dataPath.length : 0;
  });
  newChildren = filterMax(newChildren,
  /**
   * @param {SchemaUtilErrorObject} error
   * @returns {number}
   */
  function (error) {
    return SPECIFICITY[
    /** @type {keyof typeof SPECIFICITY} */
    error.keyword] || 2;
  });
  return newChildren;
}
/**
 * Find all children errors
 * @param {Array<SchemaUtilErrorObject>} children
 * @param {Array<string>} schemaPaths
 * @return {number} returns index of first child
 */


function findAllChildren(children, schemaPaths) {
  var i = children.length - 1;

  var predicate =
  /**
   * @param {string} schemaPath
   * @returns {boolean}
   */
  function predicate(schemaPath) {
    return children[i].schemaPath.indexOf(schemaPath) !== 0;
  };

  while (i > -1 && !schemaPaths.every(predicate)) {
    if (children[i].keyword === 'anyOf' || children[i].keyword === 'oneOf') {
      var refs = extractRefs(children[i]);
      var childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));
      i = childrenStart - 1;
    } else {
      i -= 1;
    }
  }

  return i + 1;
}
/**
 * Extracts all refs from schema
 * @param {SchemaUtilErrorObject} error
 * @return {Array<string>}
 */


function extractRefs(error) {
  var schema = error.schema;

  if (!Array.isArray(schema)) {
    return [];
  }

  return schema.map(function (_ref) {
    var $ref = _ref.$ref;
    return $ref;
  }).filter(function (s) {
    return s;
  });
}
/**
 * Groups children by their first level parent (assuming that error is root)
 * @param {Array<SchemaUtilErrorObject>} children
 * @return {Array<SchemaUtilErrorObject>}
 */


function groupChildrenByFirstChild(children) {
  var result = [];
  var i = children.length - 1;

  while (i > 0) {
    var child = children[i];

    if (child.keyword === 'anyOf' || child.keyword === 'oneOf') {
      var refs = extractRefs(child);
      var childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));

      if (childrenStart !== i) {
        result.push(Object.assign({}, child, {
          children: children.slice(childrenStart, i)
        }));
        i = childrenStart;
      } else {
        result.push(child);
      }
    } else {
      result.push(child);
    }

    i -= 1;
  }

  if (i === 0) {
    result.push(children[i]);
  }

  return result.reverse();
}
/**
 * @param {string} str
 * @param {string} prefix
 * @returns {string}
 */


function indent(str, prefix) {
  return str.replace(/\n(?!$)/g, "\n".concat(prefix));
}
/**
 * @param {Schema} schema
 * @returns {schema is (Schema & {not: Schema})}
 */


function hasNotInSchema(schema) {
  return !!schema.not;
}
/**
 * @param {Schema} schema
 * @return {Schema}
 */


function findFirstTypedSchema(schema) {
  if (hasNotInSchema(schema)) {
    return findFirstTypedSchema(schema.not);
  }

  return schema;
}
/**
 * @param {Schema} schema
 * @return {boolean}
 */


function canApplyNot(schema) {
  var typedSchema = findFirstTypedSchema(schema);
  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);
}
/**
 * @param {any} maybeObj
 * @returns {boolean}
 */


function isObject(maybeObj) {
  return _typeof(maybeObj) === 'object' && maybeObj !== null;
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */


function likeNumber(schema) {
  return schema.type === 'number' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */


function likeInteger(schema) {
  return schema.type === 'integer' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */


function likeString(schema) {
  return schema.type === 'string' || typeof schema.minLength !== 'undefined' || typeof schema.maxLength !== 'undefined' || typeof schema.pattern !== 'undefined' || typeof schema.format !== 'undefined' || typeof schema.formatMinimum !== 'undefined' || typeof schema.formatMaximum !== 'undefined';
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */


function likeBoolean(schema) {
  return schema.type === 'boolean';
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */


function likeArray(schema) {
  return schema.type === 'array' || typeof schema.minItems === 'number' || typeof schema.maxItems === 'number' || typeof schema.uniqueItems !== 'undefined' || typeof schema.items !== 'undefined' || typeof schema.additionalItems !== 'undefined' || typeof schema.contains !== 'undefined';
}
/**
 * @param {Schema & {patternRequired?: Array<string>}} schema
 * @returns {boolean}
 */


function likeObject(schema) {
  return schema.type === 'object' || typeof schema.minProperties !== 'undefined' || typeof schema.maxProperties !== 'undefined' || typeof schema.required !== 'undefined' || typeof schema.properties !== 'undefined' || typeof schema.patternProperties !== 'undefined' || typeof schema.additionalProperties !== 'undefined' || typeof schema.dependencies !== 'undefined' || typeof schema.propertyNames !== 'undefined' || typeof schema.patternRequired !== 'undefined';
}
/**
 * @param {Schema} schema
 * @returns {boolean}
 */


function likeNull(schema) {
  return schema.type === 'null';
}
/**
 * @param {string} type
 * @returns {string}
 */


function getArticle(type) {
  if (/^[aeiou]/i.test(type)) {
    return 'an';
  }

  return 'a';
}
/**
 * @param {Schema=} schema
 * @returns {string}
 */


function getSchemaNonTypes(schema) {
  if (!schema) {
    return '';
  }

  if (!schema.type) {
    if (likeNumber(schema) || likeInteger(schema)) {
      return ' | should be any non-number';
    }

    if (likeString(schema)) {
      return ' | should be any non-string';
    }

    if (likeArray(schema)) {
      return ' | should be any non-array';
    }

    if (likeObject(schema)) {
      return ' | should be any non-object';
    }
  }

  return '';
}
/**
 * @param {Array<string>} hints
 * @returns {string}
 */


function formatHints(hints) {
  return hints.length > 0 ? "(".concat(hints.join(', '), ")") : '';
}
/**
 * @param {Schema} schema
 * @param {boolean} logic
 * @returns {string[]}
 */


function getHints(schema, logic) {
  if (likeNumber(schema) || likeInteger(schema)) {
    return numberHints(schema, logic);
  } else if (likeString(schema)) {
    return stringHints(schema, logic);
  }

  return [];
}

var ValidationError =
/*#__PURE__*/
function (_Error) {
  _inherits(ValidationError, _Error);

  /**
   * @param {Array<SchemaUtilErrorObject>} errors
   * @param {Schema} schema
   * @param {ValidationErrorConfiguration} configuration
   */
  function ValidationError(errors, schema) {
    var _this;

    var configuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ValidationError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ValidationError).call(this));
    /** @type {string} */

    _this.name = 'ValidationError';
    /** @type {Array<SchemaUtilErrorObject>} */

    _this.errors = errors;
    /** @type {Schema} */

    _this.schema = schema;
    var headerNameFromSchema;
    var baseDataPathFromSchema;

    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {
      var splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);

      if (splittedTitleFromSchema) {
        if (!configuration.name) {
          var _splittedTitleFromSch = _slicedToArray(splittedTitleFromSchema, 2);

          headerNameFromSchema = _splittedTitleFromSch[1];
        }

        if (!configuration.baseDataPath) {
          var _splittedTitleFromSch2 = _slicedToArray(splittedTitleFromSchema, 3);

          baseDataPathFromSchema = _splittedTitleFromSch2[2];
        }
      }
    }
    /** @type {string} */


    _this.headerName = configuration.name || headerNameFromSchema || 'Object';
    /** @type {string} */

    _this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || 'configuration';
    /** @type {PostFormatter | null} */

    _this.postFormatter = configuration.postFormatter || null;
    var header = "Invalid ".concat(_this.baseDataPath, " object. ").concat(_this.headerName, " has been initialized using ").concat(getArticle(_this.baseDataPath), " ").concat(_this.baseDataPath, " object that does not match the API schema.\n");
    /** @type {string} */

    _this.message = "".concat(header).concat(_this.formatValidationErrors(errors));
    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    return _this;
  }
  /**
   * @param {string} path
   * @returns {Schema}
   */


  _createClass(ValidationError, [{
    key: "getSchemaPart",
    value: function getSchemaPart(path) {
      var newPath = path.split('/');
      var schemaPart = this.schema;

      for (var i = 1; i < newPath.length; i++) {
        var inner = schemaPart[
        /** @type {keyof Schema} */
        newPath[i]];

        if (!inner) {
          break;
        }

        schemaPart = inner;
      }

      return schemaPart;
    }
    /**
     * @param {Schema} schema
     * @param {boolean} logic
     * @param {Array<Object>} prevSchemas
     * @returns {string}
     */

  }, {
    key: "formatSchema",
    value: function formatSchema(schema) {
      var _this2 = this;

      var logic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var prevSchemas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var newLogic = logic;

      var formatInnerSchema =
      /**
       *
       * @param {Object} innerSchema
       * @param {boolean=} addSelf
       * @returns {string}
       */
      function formatInnerSchema(innerSchema, addSelf) {
        if (!addSelf) {
          return _this2.formatSchema(innerSchema, newLogic, prevSchemas);
        }

        if (prevSchemas.includes(innerSchema)) {
          return '(recursive)';
        }

        return _this2.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));
      };

      if (hasNotInSchema(schema) && !likeObject(schema)) {
        if (canApplyNot(schema.not)) {
          newLogic = !logic;
          return formatInnerSchema(schema.not);
        }

        var needApplyLogicHere = !schema.not.not;
        var prefix = logic ? '' : 'non ';
        newLogic = !logic;
        return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);
      }

      if (
      /** @type {Schema & {instanceof: string | Array<string>}} */
      schema["instanceof"]) {
        var value =
        /** @type {Schema & {instanceof: string | Array<string>}} */
        schema["instanceof"];
        var values = !Array.isArray(value) ? [value] : value;
        return values.map(
        /**
         * @param {string} item
         * @returns {string}
         */
        function (item) {
          return item === 'Function' ? 'function' : item;
        }).join(' | ');
      }

      if (schema["enum"]) {
        return (
          /** @type {Array<any>} */
          schema["enum"].map(function (item) {
            return JSON.stringify(item);
          }).join(' | ')
        );
      }

      if (typeof schema["const"] !== 'undefined') {
        return JSON.stringify(schema["const"]);
      }

      if (schema.oneOf) {
        return (
          /** @type {Array<Schema>} */
          schema.oneOf.map(function (item) {
            return formatInnerSchema(item, true);
          }).join(' | ')
        );
      }

      if (schema.anyOf) {
        return (
          /** @type {Array<Schema>} */
          schema.anyOf.map(function (item) {
            return formatInnerSchema(item, true);
          }).join(' | ')
        );
      }

      if (schema.allOf) {
        return (
          /** @type {Array<Schema>} */
          schema.allOf.map(function (item) {
            return formatInnerSchema(item, true);
          }).join(' & ')
        );
      }

      if (
      /** @type {JSONSchema7} */
      schema["if"]) {
        var ifValue =
        /** @type {JSONSchema7} */
        schema["if"],
            thenValue = schema.then,
            elseValue = schema["else"];
        return "".concat(ifValue ? "if ".concat(formatInnerSchema(ifValue)) : '').concat(thenValue ? " then ".concat(formatInnerSchema(thenValue)) : '').concat(elseValue ? " else ".concat(formatInnerSchema(elseValue)) : '');
      }

      if (schema.$ref) {
        return formatInnerSchema(this.getSchemaPart(schema.$ref), true);
      }

      if (likeNumber(schema) || likeInteger(schema)) {
        var _getHints = getHints(schema, logic),
            _getHints2 = _toArray(_getHints),
            type = _getHints2[0],
            hints = _getHints2.slice(1);

        var str = "".concat(type).concat(hints.length > 0 ? " ".concat(formatHints(hints)) : '');
        return logic ? str : hints.length > 0 ? "non-".concat(type, " | ").concat(str) : "non-".concat(type);
      }

      if (likeString(schema)) {
        var _getHints3 = getHints(schema, logic),
            _getHints4 = _toArray(_getHints3),
            _type = _getHints4[0],
            _hints = _getHints4.slice(1);

        var _str = "".concat(_type).concat(_hints.length > 0 ? " ".concat(formatHints(_hints)) : '');

        return logic ? _str : _str === 'string' ? 'non-string' : "non-string | ".concat(_str);
      }

      if (likeBoolean(schema)) {
        return "".concat(logic ? '' : 'non-', "boolean");
      }

      if (likeArray(schema)) {
        // not logic already applied in formatValidationError
        newLogic = true;
        var _hints2 = [];

        if (typeof schema.minItems === 'number') {
          _hints2.push("should not have fewer than ".concat(schema.minItems, " item").concat(schema.minItems > 1 ? 's' : ''));
        }

        if (typeof schema.maxItems === 'number') {
          _hints2.push("should not have more than ".concat(schema.maxItems, " item").concat(schema.maxItems > 1 ? 's' : ''));
        }

        if (schema.uniqueItems) {
          _hints2.push('should not have duplicate items');
        }

        var hasAdditionalItems = typeof schema.additionalItems === 'undefined' || Boolean(schema.additionalItems);
        var items = '';

        if (schema.items) {
          if (Array.isArray(schema.items) && schema.items.length > 0) {
            items = "".concat(
            /** @type {Array<Schema>} */
            schema.items.map(function (item) {
              return formatInnerSchema(item);
            }).join(', '));

            if (hasAdditionalItems) {
              if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {
                _hints2.push("additional items should be ".concat(formatInnerSchema(schema.additionalItems)));
              }
            }
          } else if (schema.items && Object.keys(schema.items).length > 0) {
            // "additionalItems" is ignored
            items = "".concat(formatInnerSchema(schema.items));
          } else {
            // Fallback for empty `items` value
            items = 'any';
          }
        } else {
          // "additionalItems" is ignored
          items = 'any';
        }

        if (schema.contains && Object.keys(schema.contains).length > 0) {
          _hints2.push("should contains at least one ".concat(this.formatSchema(schema.contains), " item"));
        }

        return "[".concat(items).concat(hasAdditionalItems ? ', ...' : '', "]").concat(_hints2.length > 0 ? " (".concat(_hints2.join(', '), ")") : '');
      }

      if (likeObject(schema)) {
        // not logic already applied in formatValidationError
        newLogic = true;
        var _hints3 = [];

        if (typeof schema.minProperties === 'number') {
          _hints3.push("should not have fewer than ".concat(schema.minProperties, " ").concat(schema.minProperties > 1 ? 'properties' : 'property'));
        }

        if (typeof schema.maxProperties === 'number') {
          _hints3.push("should not have more than ".concat(schema.maxProperties, " ").concat(schema.minProperties && schema.minProperties > 1 ? 'properties' : 'property'));
        }

        if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {
          var patternProperties = Object.keys(schema.patternProperties);

          _hints3.push("additional property names should match pattern".concat(patternProperties.length > 1 ? 's' : '', " ").concat(patternProperties.map(function (pattern) {
            return JSON.stringify(pattern);
          }).join(' | ')));
        }

        var properties = schema.properties ? Object.keys(schema.properties) : [];
        var required = schema.required ? schema.required : [];

        var allProperties = _toConsumableArray(new Set(
        /** @type {Array<string>} */
        [].concat(required).concat(properties)));

        var objectStructure = allProperties.map(function (property) {
          var isRequired = required.includes(property); // Some properties need quotes, maybe we should add check
          // Maybe we should output type of property (`foo: string`), but it is looks very unreadable

          return "".concat(property).concat(isRequired ? '' : '?');
        }).concat(typeof schema.additionalProperties === 'undefined' || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? ["<key>: ".concat(formatInnerSchema(schema.additionalProperties))] : ['…'] : []).join(', ');
        var dependencies =
        /** @type {Schema & {patternRequired?: Array<string>;}} */
        schema.dependencies,
            propertyNames = schema.propertyNames,
            patternRequired = schema.patternRequired;

        if (dependencies) {
          Object.keys(dependencies).forEach(function (dependencyName) {
            var dependency = dependencies[dependencyName];

            if (Array.isArray(dependency)) {
              _hints3.push("should have ".concat(dependency.length > 1 ? 'properties' : 'property', " ").concat(dependency.map(function (dep) {
                return "'".concat(dep, "'");
              }).join(', '), " when property '").concat(dependencyName, "' is present"));
            } else {
              _hints3.push("should be valid according to the schema ".concat(formatInnerSchema(dependency), " when property '").concat(dependencyName, "' is present"));
            }
          });
        }

        if (propertyNames && Object.keys(propertyNames).length > 0) {
          _hints3.push("each property name should match format ".concat(JSON.stringify(schema.propertyNames.format)));
        }

        if (patternRequired && patternRequired.length > 0) {
          _hints3.push("should have property matching pattern ".concat(patternRequired.map(
          /**
           * @param {string} item
           * @returns {string}
           */
          function (item) {
            return JSON.stringify(item);
          })));
        }

        return "object {".concat(objectStructure ? " ".concat(objectStructure, " ") : '', "}").concat(_hints3.length > 0 ? " (".concat(_hints3.join(', '), ")") : '');
      }

      if (likeNull(schema)) {
        return "".concat(logic ? '' : 'non-', "null");
      }

      if (Array.isArray(schema.type)) {
        // not logic already applied in formatValidationError
        return "".concat(schema.type.join(' | '));
      } // Fallback for unknown keywords
      // not logic already applied in formatValidationError

      /* istanbul ignore next */


      return JSON.stringify(schema, null, 2);
    }
    /**
     * @param {Schema=} schemaPart
     * @param {(boolean | Array<string>)=} additionalPath
     * @param {boolean=} needDot
     * @param {boolean=} logic
     * @returns {string}
     */

  }, {
    key: "getSchemaPartText",
    value: function getSchemaPartText(schemaPart, additionalPath) {
      var needDot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var logic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (!schemaPart) {
        return '';
      }

      if (Array.isArray(additionalPath)) {
        for (var i = 0; i < additionalPath.length; i++) {
          /** @type {Schema | undefined} */
          var inner = schemaPart[
          /** @type {keyof Schema} */
          additionalPath[i]];

          if (inner) {
            // eslint-disable-next-line no-param-reassign
            schemaPart = inner;
          } else {
            break;
          }
        }
      }

      while (schemaPart.$ref) {
        // eslint-disable-next-line no-param-reassign
        schemaPart = this.getSchemaPart(schemaPart.$ref);
      }

      var schemaText = "".concat(this.formatSchema(schemaPart, logic)).concat(needDot ? '.' : '');

      if (schemaPart.description) {
        schemaText += "\n-> ".concat(schemaPart.description);
      }

      return schemaText;
    }
    /**
     * @param {Schema=} schemaPart
     * @returns {string}
     */

  }, {
    key: "getSchemaPartDescription",
    value: function getSchemaPartDescription(schemaPart) {
      if (!schemaPart) {
        return '';
      }

      while (schemaPart.$ref) {
        // eslint-disable-next-line no-param-reassign
        schemaPart = this.getSchemaPart(schemaPart.$ref);
      }

      if (schemaPart.description) {
        return "\n-> ".concat(schemaPart.description);
      }

      return '';
    }
    /**
     * @param {SchemaUtilErrorObject} error
     * @returns {string}
     */

  }, {
    key: "formatValidationError",
    value: function formatValidationError(error) {
      var _this3 = this;

      var keyword = error.keyword,
          errorDataPath = error.dataPath;
      var dataPath = "".concat(this.baseDataPath).concat(errorDataPath);

      switch (keyword) {
        case 'type':
          {
            var parentSchema = error.parentSchema,
                params = error.params; // eslint-disable-next-line default-case

            switch (
            /** @type {import("ajv").TypeParams} */
            params.type) {
              case 'number':
                return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

              case 'integer':
                return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

              case 'string':
                return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

              case 'boolean':
                return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

              case 'array':
                return "".concat(dataPath, " should be an array:\n").concat(this.getSchemaPartText(parentSchema));

              case 'object':
                return "".concat(dataPath, " should be an object:\n").concat(this.getSchemaPartText(parentSchema));

              case 'null':
                return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

              default:
                return "".concat(dataPath, " should be:\n").concat(this.getSchemaPartText(parentSchema));
            }
          }

        case 'instanceof':
          {
            var _parentSchema = error.parentSchema;
            return "".concat(dataPath, " should be an instance of ").concat(this.getSchemaPartText(_parentSchema, false, true));
          }

        case 'pattern':
          {
            var _params = error.params,
                _parentSchema2 = error.parentSchema;
            var pattern =
            /** @type {import("ajv").PatternParams} */
            _params.pattern;
            return "".concat(dataPath, " should match pattern ").concat(JSON.stringify(pattern)).concat(getSchemaNonTypes(_parentSchema2), ".").concat(this.getSchemaPartDescription(_parentSchema2));
          }

        case 'format':
          {
            var _params2 = error.params,
                _parentSchema3 = error.parentSchema;
            var format =
            /** @type {import("ajv").FormatParams} */
            _params2.format;
            return "".concat(dataPath, " should match format ").concat(JSON.stringify(format)).concat(getSchemaNonTypes(_parentSchema3), ".").concat(this.getSchemaPartDescription(_parentSchema3));
          }

        case 'formatMinimum':
        case 'formatMaximum':
          {
            var _params3 = error.params,
                _parentSchema4 = error.parentSchema;
            var comparison =
            /** @type {import("ajv").ComparisonParams} */
            _params3.comparison,
                limit = _params3.limit;
            return "".concat(dataPath, " should be ").concat(comparison, " ").concat(JSON.stringify(limit)).concat(getSchemaNonTypes(_parentSchema4), ".").concat(this.getSchemaPartDescription(_parentSchema4));
          }

        case 'minimum':
        case 'maximum':
        case 'exclusiveMinimum':
        case 'exclusiveMaximum':
          {
            var _parentSchema5 = error.parentSchema,
                _params4 = error.params;
            var _comparison =
            /** @type {import("ajv").ComparisonParams} */
            _params4.comparison,
                _limit = _params4.limit;

            var _getHints5 = getHints(
            /** @type {Schema} */
            _parentSchema5, true),
                _getHints6 = _toArray(_getHints5),
                hints = _getHints6.slice(1);

            if (hints.length === 0) {
              hints.push("should be ".concat(_comparison, " ").concat(_limit));
            }

            return "".concat(dataPath, " ").concat(hints.join(' ')).concat(getSchemaNonTypes(_parentSchema5), ".").concat(this.getSchemaPartDescription(_parentSchema5));
          }

        case 'multipleOf':
          {
            var _params5 = error.params,
                _parentSchema6 = error.parentSchema;
            var multipleOf =
            /** @type {import("ajv").MultipleOfParams} */
            _params5.multipleOf;
            return "".concat(dataPath, " should be multiple of ").concat(multipleOf).concat(getSchemaNonTypes(_parentSchema6), ".").concat(this.getSchemaPartDescription(_parentSchema6));
          }

        case 'patternRequired':
          {
            var _params6 = error.params,
                _parentSchema7 = error.parentSchema;
            var missingPattern =
            /** @type {import("ajv").PatternRequiredParams} */
            _params6.missingPattern;
            return "".concat(dataPath, " should have property matching pattern ").concat(JSON.stringify(missingPattern)).concat(getSchemaNonTypes(_parentSchema7), ".").concat(this.getSchemaPartDescription(_parentSchema7));
          }

        case 'minLength':
          {
            var _params7 = error.params,
                _parentSchema8 = error.parentSchema;
            var _limit2 =
            /** @type {import("ajv").LimitParams} */
            _params7.limit;

            if (_limit2 === 1) {
              return "".concat(dataPath, " should be an non-empty string").concat(getSchemaNonTypes(_parentSchema8), ".").concat(this.getSchemaPartDescription(_parentSchema8));
            }

            var length = _limit2 - 1;
            return "".concat(dataPath, " should be longer than ").concat(length, " character").concat(length > 1 ? 's' : '').concat(getSchemaNonTypes(_parentSchema8), ".").concat(this.getSchemaPartDescription(_parentSchema8));
          }

        case 'minItems':
          {
            var _params8 = error.params,
                _parentSchema9 = error.parentSchema;
            var _limit3 =
            /** @type {import("ajv").LimitParams} */
            _params8.limit;

            if (_limit3 === 1) {
              return "".concat(dataPath, " should be an non-empty array").concat(getSchemaNonTypes(_parentSchema9), ".").concat(this.getSchemaPartDescription(_parentSchema9));
            }

            return "".concat(dataPath, " should not have fewer than ").concat(_limit3, " items").concat(getSchemaNonTypes(_parentSchema9), ".").concat(this.getSchemaPartDescription(_parentSchema9));
          }

        case 'minProperties':
          {
            var _params9 = error.params,
                _parentSchema10 = error.parentSchema;
            var _limit4 =
            /** @type {import("ajv").LimitParams} */
            _params9.limit;

            if (_limit4 === 1) {
              return "".concat(dataPath, " should be an non-empty object").concat(getSchemaNonTypes(_parentSchema10), ".").concat(this.getSchemaPartDescription(_parentSchema10));
            }

            return "".concat(dataPath, " should not have fewer than ").concat(_limit4, " properties").concat(getSchemaNonTypes(_parentSchema10), ".").concat(this.getSchemaPartDescription(_parentSchema10));
          }

        case 'maxLength':
          {
            var _params10 = error.params,
                _parentSchema11 = error.parentSchema;
            var _limit5 =
            /** @type {import("ajv").LimitParams} */
            _params10.limit;
            var max = _limit5 + 1;
            return "".concat(dataPath, " should be shorter than ").concat(max, " character").concat(max > 1 ? 's' : '').concat(getSchemaNonTypes(_parentSchema11), ".").concat(this.getSchemaPartDescription(_parentSchema11));
          }

        case 'maxItems':
          {
            var _params11 = error.params,
                _parentSchema12 = error.parentSchema;
            var _limit6 =
            /** @type {import("ajv").LimitParams} */
            _params11.limit;
            return "".concat(dataPath, " should not have more than ").concat(_limit6, " items").concat(getSchemaNonTypes(_parentSchema12), ".").concat(this.getSchemaPartDescription(_parentSchema12));
          }

        case 'maxProperties':
          {
            var _params12 = error.params,
                _parentSchema13 = error.parentSchema;
            var _limit7 =
            /** @type {import("ajv").LimitParams} */
            _params12.limit;
            return "".concat(dataPath, " should not have more than ").concat(_limit7, " properties").concat(getSchemaNonTypes(_parentSchema13), ".").concat(this.getSchemaPartDescription(_parentSchema13));
          }

        case 'uniqueItems':
          {
            var _params13 = error.params,
                _parentSchema14 = error.parentSchema;
            var i =
            /** @type {import("ajv").UniqueItemsParams} */
            _params13.i;
            return "".concat(dataPath, " should not contain the item '").concat(error.data[i], "' twice").concat(getSchemaNonTypes(_parentSchema14), ".").concat(this.getSchemaPartDescription(_parentSchema14));
          }

        case 'additionalItems':
          {
            var _params14 = error.params,
                _parentSchema15 = error.parentSchema;
            var _limit8 =
            /** @type {import("ajv").LimitParams} */
            _params14.limit;
            return "".concat(dataPath, " should not have more than ").concat(_limit8, " items").concat(getSchemaNonTypes(_parentSchema15), ". These items are valid:\n").concat(this.getSchemaPartText(_parentSchema15));
          }

        case 'contains':
          {
            var _parentSchema16 = error.parentSchema;
            return "".concat(dataPath, " should contains at least one ").concat(this.getSchemaPartText(_parentSchema16, ['contains']), " item").concat(getSchemaNonTypes(_parentSchema16), ".");
          }

        case 'required':
          {
            var _parentSchema17 = error.parentSchema,
                _params15 = error.params;

            var missingProperty =
            /** @type {import("ajv").DependenciesParams} */
            _params15.missingProperty.replace(/^\./, '');

            var hasProperty = _parentSchema17 && Boolean(
            /** @type {Schema} */
            _parentSchema17.properties &&
            /** @type {Schema} */
            _parentSchema17.properties[missingProperty]);

            return "".concat(dataPath, " misses the property '").concat(missingProperty, "'").concat(getSchemaNonTypes(_parentSchema17), ".").concat(hasProperty ? " Should be:\n".concat(this.getSchemaPartText(_parentSchema17, ['properties', missingProperty])) : this.getSchemaPartDescription(_parentSchema17));
          }

        case 'additionalProperties':
          {
            var _params16 = error.params,
                _parentSchema18 = error.parentSchema;
            var additionalProperty =
            /** @type {import("ajv").AdditionalPropertiesParams} */
            _params16.additionalProperty;
            return "".concat(dataPath, " has an unknown property '").concat(additionalProperty, "'").concat(getSchemaNonTypes(_parentSchema18), ". These properties are valid:\n").concat(this.getSchemaPartText(_parentSchema18));
          }

        case 'dependencies':
          {
            var _params17 = error.params,
                _parentSchema19 = error.parentSchema;
            var property =
            /** @type {import("ajv").DependenciesParams} */
            _params17.property,
                deps = _params17.deps;
            var dependencies = deps.split(',').map(
            /**
             * @param {string} dep
             * @returns {string}
             */
            function (dep) {
              return "'".concat(dep.trim(), "'");
            }).join(', ');
            return "".concat(dataPath, " should have properties ").concat(dependencies, " when property '").concat(property, "' is present").concat(getSchemaNonTypes(_parentSchema19), ".").concat(this.getSchemaPartDescription(_parentSchema19));
          }

        case 'propertyNames':
          {
            var _params18 = error.params,
                _parentSchema20 = error.parentSchema,
                schema = error.schema;
            var propertyName =
            /** @type {import("ajv").PropertyNamesParams} */
            _params18.propertyName;
            return "".concat(dataPath, " property name '").concat(propertyName, "' is invalid").concat(getSchemaNonTypes(_parentSchema20), ". Property names should be match format ").concat(JSON.stringify(schema.format), ".").concat(this.getSchemaPartDescription(_parentSchema20));
          }

        case 'enum':
          {
            var _parentSchema21 = error.parentSchema;

            if (_parentSchema21 &&
            /** @type {Schema} */
            _parentSchema21["enum"] &&
            /** @type {Schema} */
            _parentSchema21["enum"].length === 1) {
              return "".concat(dataPath, " should be ").concat(this.getSchemaPartText(_parentSchema21, false, true));
            }

            return "".concat(dataPath, " should be one of these:\n").concat(this.getSchemaPartText(_parentSchema21));
          }

        case 'const':
          {
            var _parentSchema22 = error.parentSchema;
            return "".concat(dataPath, " should be equal to constant ").concat(this.getSchemaPartText(_parentSchema22, false, true));
          }

        case 'not':
          {
            var postfix = likeObject(
            /** @type {Schema} */
            error.parentSchema) ? "\n".concat(this.getSchemaPartText(error.parentSchema)) : '';
            var schemaOutput = this.getSchemaPartText(error.schema, false, false, false);

            if (canApplyNot(error.schema)) {
              return "".concat(dataPath, " should be any ").concat(schemaOutput).concat(postfix, ".");
            }

            var _schema = error.schema,
                _parentSchema23 = error.parentSchema;
            return "".concat(dataPath, " should not be ").concat(this.getSchemaPartText(_schema, false, true)).concat(_parentSchema23 && likeObject(_parentSchema23) ? "\n".concat(this.getSchemaPartText(_parentSchema23)) : '');
          }

        case 'oneOf':
        case 'anyOf':
          {
            var _parentSchema24 = error.parentSchema,
                children = error.children;

            if (children && children.length > 0) {
              if (error.schema.length === 1) {
                var lastChild = children[children.length - 1];
                var remainingChildren = children.slice(0, children.length - 1);
                return this.formatValidationError(Object.assign({}, lastChild, {
                  children: remainingChildren,
                  parentSchema: Object.assign({}, _parentSchema24, lastChild.parentSchema)
                }));
              }

              var filteredChildren = filterChildren(children);

              if (filteredChildren.length === 1) {
                return this.formatValidationError(filteredChildren[0]);
              }

              filteredChildren = groupChildrenByFirstChild(filteredChildren);
              return "".concat(dataPath, " should be one of these:\n").concat(this.getSchemaPartText(_parentSchema24), "\nDetails:\n").concat(filteredChildren.map(
              /**
               * @param {SchemaUtilErrorObject} nestedError
               * @returns {string}
               */
              function (nestedError) {
                return " * ".concat(indent(_this3.formatValidationError(nestedError), '   '));
              }).join('\n'));
            }

            return "".concat(dataPath, " should be one of these:\n").concat(this.getSchemaPartText(_parentSchema24));
          }

        case 'if':
          {
            var _params19 = error.params,
                _parentSchema25 = error.parentSchema;
            var failingKeyword =
            /** @type {import("ajv").IfParams} */
            _params19.failingKeyword;
            return "".concat(dataPath, " should match \"").concat(failingKeyword, "\" schema:\n").concat(this.getSchemaPartText(_parentSchema25, [failingKeyword]));
          }

        case 'absolutePath':
          {
            var message = error.message,
                _parentSchema26 = error.parentSchema;
            return "".concat(dataPath, ": ").concat(message).concat(this.getSchemaPartDescription(_parentSchema26));
          }

        /* istanbul ignore next */

        default:
          {
            var _message = error.message,
                _parentSchema27 = error.parentSchema;
            var ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords
            // Fallback for unknown keywords

            return "".concat(dataPath, " ").concat(_message, " (").concat(ErrorInJSON, ").\n").concat(this.getSchemaPartText(_parentSchema27, false));
          }
      }
    }
    /**
     * @param {Array<SchemaUtilErrorObject>} errors
     * @returns {string}
     */

  }, {
    key: "formatValidationErrors",
    value: function formatValidationErrors(errors) {
      var _this4 = this;

      return errors.map(function (error) {
        var formattedError = _this4.formatValidationError(error);

        if (_this4.postFormatter) {
          formattedError = _this4.postFormatter(formattedError, error);
        }

        return " - ".concat(indent(formattedError, '   '));
      }).join('\n');
    }
  }]);

  return ValidationError;
}(_wrapNativeSuper(Error));

var _default = ValidationError;
exports["default"] = _default;