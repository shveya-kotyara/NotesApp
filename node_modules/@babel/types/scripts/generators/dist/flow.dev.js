"use strict";

var t = require("../../");

var stringifyValidator = require("../utils/stringifyValidator");

var toFunctionName = require("../utils/toFunctionName");

var NODE_PREFIX = "BabelNode";
var code = "// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/flow.js for script used.\n\ndeclare class ".concat(NODE_PREFIX, "Comment {\n  value: string;\n  start: number;\n  end: number;\n  loc: ").concat(NODE_PREFIX, "SourceLocation;\n}\n\ndeclare class ").concat(NODE_PREFIX, "CommentBlock extends ").concat(NODE_PREFIX, "Comment {\n  type: \"CommentBlock\";\n}\n\ndeclare class ").concat(NODE_PREFIX, "CommentLine extends ").concat(NODE_PREFIX, "Comment {\n  type: \"CommentLine\";\n}\n\ndeclare class ").concat(NODE_PREFIX, "SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ndeclare class ").concat(NODE_PREFIX, " {\n  leadingComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  innerComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  trailingComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  start: ?number;\n  end: ?number;\n  loc: ?").concat(NODE_PREFIX, "SourceLocation;\n  extra?: { [string]: mixed };\n}\n\n"); //

var lines = [];

var _loop = function _loop(type) {
  var fields = t.NODE_FIELDS[type];
  var struct = ['type: "' + type + '";'];
  var args = [];
  var builderNames = t.BUILDER_KEYS[type];
  Object.keys(t.NODE_FIELDS[type]).sort(function (fieldA, fieldB) {
    var indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
    var indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  }).forEach(function (fieldName) {
    var field = fields[fieldName];
    var suffix = "";
    if (field.optional || field["default"] != null) suffix += "?";
    var typeAnnotation = "any";
    var validate = field.validate;

    if (validate) {
      typeAnnotation = stringifyValidator(validate, NODE_PREFIX);
    }

    if (typeAnnotation) {
      suffix += ": " + typeAnnotation;
    }

    if (builderNames.includes(fieldName)) {
      args.push(t.toBindingIdentifierName(fieldName) + suffix);
    }

    if (t.isValidIdentifier(fieldName)) {
      struct.push(fieldName + suffix + ";");
    }
  });
  code += "declare class ".concat(NODE_PREFIX).concat(type, " extends ").concat(NODE_PREFIX, " {\n  ").concat(struct.join("\n  ").trim(), "\n}\n\n"); // Flow chokes on super() and import() :/

  if (type !== "Super" && type !== "Import") {
    lines.push("declare function ".concat(toFunctionName(type), "(").concat(args.join(", "), "): ").concat(NODE_PREFIX).concat(type, ";"));
  } else {
    var functionName = toFunctionName(type);
    lines.push("declare function _".concat(functionName, "(").concat(args.join(", "), "): ").concat(NODE_PREFIX).concat(type, ";"), "declare export { _".concat(functionName, " as ").concat(functionName, " }"));
  }
};

for (var type in t.NODE_FIELDS) {
  _loop(type);
}

for (var i = 0; i < t.TYPES.length; i++) {
  var decl = "declare function is".concat(t.TYPES[i], "(node: ?Object, opts?: ?Object): boolean");

  if (t.NODE_FIELDS[t.TYPES[i]]) {
    decl += " %checks (node instanceof ".concat(NODE_PREFIX).concat(t.TYPES[i], ")");
  }

  lines.push(decl);
}

lines.push( // builders/
// eslint-disable-next-line max-len
"declare function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): ".concat(NODE_PREFIX, "TypeAnnotation"), // eslint-disable-next-line max-len
"declare function createUnionTypeAnnotation(types: Array<".concat(NODE_PREFIX, "FlowType>): ").concat(NODE_PREFIX, "UnionTypeAnnotation"), // eslint-disable-next-line max-len
"declare function createFlowUnionType(types: Array<".concat(NODE_PREFIX, "FlowType>): ").concat(NODE_PREFIX, "UnionTypeAnnotation"), // this smells like "internal API"
// eslint-disable-next-line max-len
"declare function buildChildren(node: { children: Array<".concat(NODE_PREFIX, "JSXText | ").concat(NODE_PREFIX, "JSXExpressionContainer | ").concat(NODE_PREFIX, "JSXSpreadChild | ").concat(NODE_PREFIX, "JSXElement | ").concat(NODE_PREFIX, "JSXFragment | ").concat(NODE_PREFIX, "JSXEmptyExpression> }): Array<").concat(NODE_PREFIX, "JSXText | ").concat(NODE_PREFIX, "JSXExpressionContainer | ").concat(NODE_PREFIX, "JSXSpreadChild | ").concat(NODE_PREFIX, "JSXElement | ").concat(NODE_PREFIX, "JSXFragment>"), // clone/
"declare function clone<T>(n: T): T;", "declare function cloneDeep<T>(n: T): T;", "declare function cloneDeepWithoutLoc<T>(n: T): T;", "declare function cloneNode<T>(n: T, deep?: boolean, withoutLoc?: boolean): T;", "declare function cloneWithoutLoc<T>(n: T): T;", // comments/
"declare type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'", // eslint-disable-next-line max-len
"declare function addComment<T: Node>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T", // eslint-disable-next-line max-len
"declare function addComments<T: Node>(node: T, type: CommentTypeShorthand, comments: Array<Comment>): T", "declare function inheritInnerComments(node: Node, parent: Node): void", "declare function inheritLeadingComments(node: Node, parent: Node): void", "declare function inheritsComments<T: Node>(node: T, parent: Node): void", "declare function inheritTrailingComments(node: Node, parent: Node): void", "declare function removeComments<T: Node>(node: T): T", // converters/
"declare function ensureBlock(node: ".concat(NODE_PREFIX, ", key: string): ").concat(NODE_PREFIX, "BlockStatement"), "declare function toBindingIdentifierName(name?: ?string): string", // eslint-disable-next-line max-len
"declare function toBlock(node: ".concat(NODE_PREFIX, "Statement | ").concat(NODE_PREFIX, "Expression, parent?: ").concat(NODE_PREFIX, "Function | null): ").concat(NODE_PREFIX, "BlockStatement"), // eslint-disable-next-line max-len
"declare function toComputedKey(node: ".concat(NODE_PREFIX, "Method | ").concat(NODE_PREFIX, "Property, key?: ").concat(NODE_PREFIX, "Expression | ").concat(NODE_PREFIX, "Identifier): ").concat(NODE_PREFIX, "Expression"), // eslint-disable-next-line max-len
"declare function toExpression(node: ".concat(NODE_PREFIX, "ExpressionStatement | ").concat(NODE_PREFIX, "Expression | ").concat(NODE_PREFIX, "Class | ").concat(NODE_PREFIX, "Function): ").concat(NODE_PREFIX, "Expression"), "declare function toIdentifier(name?: ?string): string", // eslint-disable-next-line max-len
"declare function toKeyAlias(node: ".concat(NODE_PREFIX, "Method | ").concat(NODE_PREFIX, "Property, key?: ").concat(NODE_PREFIX, "): string"), // toSequenceExpression relies on types that aren't declared in flow
// eslint-disable-next-line max-len
"declare function toStatement(node: ".concat(NODE_PREFIX, "Statement | ").concat(NODE_PREFIX, "Class | ").concat(NODE_PREFIX, "Function | ").concat(NODE_PREFIX, "AssignmentExpression, ignore?: boolean): ").concat(NODE_PREFIX, "Statement | void"), "declare function valueToNode(value: any): ".concat(NODE_PREFIX, "Expression"), // modifications/
// eslint-disable-next-line max-len
"declare function removeTypeDuplicates(types: Array<".concat(NODE_PREFIX, "FlowType>): Array<").concat(NODE_PREFIX, "FlowType>"), // eslint-disable-next-line max-len
"declare function appendToMemberExpression(member: ".concat(NODE_PREFIX, "MemberExpression, append: ").concat(NODE_PREFIX, ", computed?: boolean): ").concat(NODE_PREFIX, "MemberExpression"), // eslint-disable-next-line max-len
"declare function inherits<T: Node>(child: T, parent: ".concat(NODE_PREFIX, " | null | void): T"), // eslint-disable-next-line max-len
"declare function prependToMemberExpression(member: ".concat(NODE_PREFIX, "MemberExpression, prepend: ").concat(NODE_PREFIX, "Expression): ").concat(NODE_PREFIX, "MemberExpression"), "declare function removeProperties<T>(n: T, opts: ?{}): void;", "declare function removePropertiesDeep<T>(n: T, opts: ?{}): T;", // retrievers/
// eslint-disable-next-line max-len
"declare function getBindingIdentifiers(node: ".concat(NODE_PREFIX, ", duplicates: boolean, outerOnly?: boolean): { [key: string]: ").concat(NODE_PREFIX, "Identifier | Array<").concat(NODE_PREFIX, "Identifier> }"), // eslint-disable-next-line max-len
"declare function getOuterBindingIdentifiers(node: Node, duplicates: boolean): { [key: string]: ".concat(NODE_PREFIX, "Identifier | Array<").concat(NODE_PREFIX, "Identifier> }"), // traverse/
"declare type TraversalAncestors = Array<{\n    node: BabelNode,\n    key: string,\n    index?: number,\n  }>;\n  declare type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;\n  declare type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };".replace(/(^|\n) {2}/g, "$1"), // eslint-disable-next-line
"declare function traverse<T>(n: BabelNode, TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;", "declare function traverseFast<T>(n: Node, h: TraversalHandler<T>, state?: T): void;", // utils/
// cleanJSXElementLiteralChild is not exported
// inherit is not exported
"declare function shallowEqual(actual: Object, expected: Object): boolean", // validators/
// eslint-disable-next-line max-len
"declare function buildMatchMemberExpression(match: string, allowPartial?: boolean): (?BabelNode) => boolean", "declare function is(type: string, n: BabelNode, opts: Object): boolean;", "declare function isBinding(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean", "declare function isBlockScoped(node: BabelNode): boolean", "declare function isImmutable(node: BabelNode): boolean", "declare function isLet(node: BabelNode): boolean", "declare function isNode(node: ?Object): boolean", "declare function isNodesEquivalent(a: any, b: any): boolean", "declare function isPlaceholderType(placeholderType: string, targetType: string): boolean", "declare function isReferenced(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean", "declare function isScope(node: BabelNode, parent: BabelNode): boolean", "declare function isSpecifierDefault(specifier: BabelNodeModuleSpecifier): boolean", "declare function isType(nodetype: ?string, targetType: string): boolean", "declare function isValidES3Identifier(name: string): boolean", "declare function isValidES3Identifier(name: string): boolean", "declare function isValidIdentifier(name: string): boolean", "declare function isVar(node: BabelNode): boolean", // eslint-disable-next-line max-len
"declare function matchesPattern(node: ?BabelNode, match: string | Array<string>, allowPartial?: boolean): boolean", "declare function validate(n: BabelNode, key: string, value: mixed): void;");

for (var _type in t.FLIPPED_ALIAS_KEYS) {
  var types = t.FLIPPED_ALIAS_KEYS[_type];
  code += "type ".concat(NODE_PREFIX).concat(_type, " = ").concat(types.map(function (type) {
    return "".concat(NODE_PREFIX).concat(type);
  }).join(" | "), ";\n");
}

code += "\ndeclare module \"@babel/types\" {\n  ".concat(lines.join("\n").replace(/\n/g, "\n  ").trim(), "\n}\n"); //

process.stdout.write(code);