"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExpressionErrors = exports["default"] = void 0;

var _types = require("../tokenizer/types");

var _tokenizer = _interopRequireDefault(require("../tokenizer"));

var _state = _interopRequireDefault(require("../tokenizer/state"));

var _whitespace = require("../util/whitespace");

var _identifier = require("../util/identifier");

var _error = require("./error");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var UtilParser =
/*#__PURE__*/
function (_tokenizer$default) {
  _inherits(UtilParser, _tokenizer$default);

  function UtilParser() {
    _classCallCheck(this, UtilParser);

    return _possibleConstructorReturn(this, _getPrototypeOf(UtilParser).apply(this, arguments));
  }

  _createClass(UtilParser, [{
    key: "addExtra",
    value: function addExtra(node, key, val) {
      if (!node) return;
      var extra = node.extra = node.extra || {};
      extra[key] = val;
    }
  }, {
    key: "isRelational",
    value: function isRelational(op) {
      return this.match(_types.types.relational) && this.state.value === op;
    }
  }, {
    key: "expectRelational",
    value: function expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, _types.types.relational);
      }
    }
  }, {
    key: "isContextual",
    value: function isContextual(name) {
      return this.match(_types.types.name) && this.state.value === name && !this.state.containsEsc;
    }
  }, {
    key: "isUnparsedContextual",
    value: function isUnparsedContextual(nameStart, name) {
      var nameEnd = nameStart + name.length;
      return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !(0, _identifier.isIdentifierChar)(this.input.charCodeAt(nameEnd)));
    }
  }, {
    key: "isLookaheadContextual",
    value: function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
  }, {
    key: "eatContextual",
    value: function eatContextual(name) {
      return this.isContextual(name) && this.eat(_types.types.name);
    }
  }, {
    key: "expectContextual",
    value: function expectContextual(name, message) {
      if (!this.eatContextual(name)) this.unexpected(null, message);
    }
  }, {
    key: "canInsertSemicolon",
    value: function canInsertSemicolon() {
      return this.match(_types.types.eof) || this.match(_types.types.braceR) || this.hasPrecedingLineBreak();
    }
  }, {
    key: "hasPrecedingLineBreak",
    value: function hasPrecedingLineBreak() {
      return _whitespace.lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
  }, {
    key: "isLineTerminator",
    value: function isLineTerminator() {
      return this.eat(_types.types.semi) || this.canInsertSemicolon();
    }
  }, {
    key: "semicolon",
    value: function semicolon() {
      if (!this.isLineTerminator()) this.unexpected(null, _types.types.semi);
    }
  }, {
    key: "expect",
    value: function expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }
  }, {
    key: "assertNoSpace",
    value: function assertNoSpace() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Unexpected space.";

      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, message);
      }
    }
  }, {
    key: "unexpected",
    value: function unexpected(pos) {
      var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token";

      if (typeof messageOrType !== "string") {
        messageOrType = "Unexpected token, expected \"".concat(messageOrType.label, "\"");
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    }
  }, {
    key: "expectPlugin",
    value: function expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: [name]
        }, "This experimental syntax requires enabling the parser plugin: '".concat(name, "'"));
      }

      return true;
    }
  }, {
    key: "expectOnePlugin",
    value: function expectOnePlugin(names, pos) {
      var _this = this;

      if (!names.some(function (n) {
        return _this.hasPlugin(n);
      })) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: names
        }, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(names.join(", "), "'"));
      }
    }
  }, {
    key: "tryParse",
    value: function tryParse(fn) {
      var oldState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.clone();
      var abortSignal = {
        node: null
      };

      try {
        var node = fn(function () {
          var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          return {
            node: node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }

        return {
          node: node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }

        throw error;
      }
    }
  }, {
    key: "checkExpressionErrors",
    value: function checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      var shorthandAssign = refExpressionErrors.shorthandAssign,
          doubleProto = refExpressionErrors.doubleProto;
      if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;

      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }

      if (doubleProto >= 0) {
        this.raise(doubleProto, _error.Errors.DuplicateProto);
      }
    }
  }, {
    key: "isLiteralPropertyName",
    value: function isLiteralPropertyName() {
      return this.match(_types.types.name) || !!this.state.type.keyword || this.match(_types.types.string) || this.match(_types.types.num) || this.match(_types.types.bigint) || this.match(_types.types.decimal);
    }
  }]);

  return UtilParser;
}(_tokenizer["default"]);

exports["default"] = UtilParser;

var ExpressionErrors = function ExpressionErrors() {
  _classCallCheck(this, ExpressionErrors);

  this.shorthandAssign = -1;
  this.doubleProto = -1;
};

exports.ExpressionErrors = ExpressionErrors;