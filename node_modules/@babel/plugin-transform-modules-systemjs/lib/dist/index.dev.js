"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExportSpecifierName = getExportSpecifierName;
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperHoistVariables = _interopRequireDefault(require("@babel/helper-hoist-variables"));

var _core = require("@babel/core");

var _utils = require("babel-plugin-dynamic-import-node/utils");

var _helperModuleTransforms = require("@babel/helper-module-transforms");

var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var buildTemplate = (0, _core.template)("\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n");
var buildExportAll = (0, _core.template)("\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n");
var MISSING_PLUGIN_WARNING = "WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n";

function getExportSpecifierName(node, stringSpecifiers) {
  if (node.type === "Identifier") {
    return node.name;
  } else if (node.type === "StringLiteral") {
    var stringValue = node.value;

    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
      stringSpecifiers.add(stringValue);
    }

    return stringValue;
  } else {
    throw new Error("Expected export specifier to be either Identifier or StringLiteral, got ".concat(node.type));
  }
}

function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
  var statements = [];

  if (exportNames.length === 1) {
    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));
  } else if (!exportStarTarget) {
    var objectProperties = [];

    for (var i = 0; i < exportNames.length; i++) {
      var exportName = exportNames[i];
      var exportValue = exportValues[i];
      objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));
    }

    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));
  } else {
    var exportObj = path.scope.generateUid("exportObj");
    statements.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));
    statements.push(buildExportAll({
      KEY: path.scope.generateUidIdentifier("key"),
      EXPORT_OBJ: _core.types.identifier(exportObj),
      TARGET: exportStarTarget
    }));

    for (var _i = 0; _i < exportNames.length; _i++) {
      var _exportName = exportNames[_i];
      var _exportValue = exportValues[_i];
      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(_exportName)), _exportValue)));
    }

    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));
  }

  return statements;
}

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var _options$systemGlobal = options.systemGlobal,
      systemGlobal = _options$systemGlobal === void 0 ? "System" : _options$systemGlobal,
      _options$allowTopLeve = options.allowTopLevelThis,
      allowTopLevelThis = _options$allowTopLeve === void 0 ? false : _options$allowTopLeve;
  var IGNORE_REASSIGNMENT_SYMBOL = Symbol();
  var reassignmentVisitor = {
    "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path) {
      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
      var arg = path.get(path.isAssignmentExpression() ? "left" : "argument");

      if (arg.isObjectPattern() || arg.isArrayPattern()) {
        var exprs = [path.node];

        for (var _i2 = 0, _Object$keys = Object.keys(arg.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
          var _name = _Object$keys[_i2];

          if (this.scope.getBinding(_name) !== path.scope.getBinding(_name)) {
            return;
          }

          var _exportedNames = this.exports[_name];
          if (!_exportedNames) return;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _exportedNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var exportedName = _step.value;
              exprs.push(this.buildCall(exportedName, _core.types.identifier(_name)).expression);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        path.replaceWith(_core.types.sequenceExpression(exprs));
        return;
      }

      if (!arg.isIdentifier()) return;
      var name = arg.node.name;
      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
      var exportedNames = this.exports[name];
      if (!exportedNames) return;
      var node = path.node;
      var isPostUpdateExpression = path.isUpdateExpression({
        prefix: false
      });

      if (isPostUpdateExpression) {
        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = exportedNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _exportedName = _step2.value;
          node = this.buildCall(_exportedName, node).expression;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (isPostUpdateExpression) {
        node = _core.types.sequenceExpression([node, path.node]);
      }

      path.replaceWith(node);
    }
  };
  return {
    name: "transform-modules-systemjs",
    pre: function pre() {
      this.file.set("@babel/plugin-transform-modules-*", "systemjs");
    },
    visitor: {
      CallExpression: function CallExpression(path, state) {
        if (_core.types.isImport(path.node.callee)) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
            console.warn(MISSING_PLUGIN_WARNING);
          }

          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [(0, _utils.getImportSource)(_core.types, path.node)]));
        }
      },
      MetaProperty: function MetaProperty(path, state) {
        if (path.node.meta.name === "import" && path.node.property.name === "meta") {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
        }
      },
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
        }
      },
      Program: {
        enter: function enter(path, state) {
          state.contextIdent = path.scope.generateUid("context");
          state.stringSpecifiers = new Set();

          if (!allowTopLevelThis) {
            (0, _helperModuleTransforms.rewriteThis)(path);
          }
        },
        exit: function exit(path, state) {
          var scope = path.scope;
          var exportIdent = scope.generateUid("export");
          var contextIdent = state.contextIdent,
              stringSpecifiers = state.stringSpecifiers;
          var exportMap = Object.create(null);
          var modules = [];
          var beforeBody = [];
          var setters = [];
          var sources = [];
          var variableIds = [];
          var removedPaths = [];

          function addExportName(key, val) {
            exportMap[key] = exportMap[key] || [];
            exportMap[key].push(val);
          }

          function pushModule(source, key, specifiers) {
            var module;
            modules.forEach(function (m) {
              if (m.key === source) {
                module = m;
              }
            });

            if (!module) {
              modules.push(module = {
                key: source,
                imports: [],
                exports: []
              });
            }

            module[key] = module[key].concat(specifiers);
          }

          function buildExportCall(name, val) {
            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));
          }

          var exportNames = [];
          var exportValues = [];
          var body = path.get("body");
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = body[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _path = _step3.value;

              if (_path.isFunctionDeclaration()) {
                beforeBody.push(_path.node);
                removedPaths.push(_path);
              } else if (_path.isClassDeclaration()) {
                variableIds.push(_core.types.cloneNode(_path.node.id));

                _path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(_path.node.id), _core.types.toExpression(_path.node))));
              } else if (_path.isImportDeclaration()) {
                var source = _path.node.source.value;
                pushModule(source, "imports", _path.node.specifiers);

                for (var _i4 = 0, _Object$keys2 = Object.keys(_path.getBindingIdentifiers()); _i4 < _Object$keys2.length; _i4++) {
                  var name = _Object$keys2[_i4];
                  scope.removeBinding(name);
                  variableIds.push(_core.types.identifier(name));
                }

                _path.remove();
              } else if (_path.isExportAllDeclaration()) {
                pushModule(_path.node.source.value, "exports", _path.node);

                _path.remove();
              } else if (_path.isExportDefaultDeclaration()) {
                var declar = _path.get("declaration");

                var id = declar.node.id;

                if (declar.isClassDeclaration()) {
                  if (id) {
                    exportNames.push("default");
                    exportValues.push(scope.buildUndefinedNode());
                    variableIds.push(_core.types.cloneNode(id));
                    addExportName(id.name, "default");

                    _path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar.node))));
                  } else {
                    exportNames.push("default");
                    exportValues.push(_core.types.toExpression(declar.node));
                    removedPaths.push(_path);
                  }
                } else if (declar.isFunctionDeclaration()) {
                  if (id) {
                    beforeBody.push(declar.node);
                    exportNames.push("default");
                    exportValues.push(_core.types.cloneNode(id));
                    addExportName(id.name, "default");
                  } else {
                    exportNames.push("default");
                    exportValues.push(_core.types.toExpression(declar.node));
                  }

                  removedPaths.push(_path);
                } else {
                  _path.replaceWith(buildExportCall("default", declar.node));
                }
              } else if (_path.isExportNamedDeclaration()) {
                var _declar = _path.get("declaration");

                if (_declar.node) {
                  _path.replaceWith(_declar);

                  if (_path.isFunction()) {
                    var node = _declar.node;
                    var _name2 = node.id.name;
                    addExportName(_name2, _name2);
                    beforeBody.push(node);
                    exportNames.push(_name2);
                    exportValues.push(_core.types.cloneNode(node.id));
                    removedPaths.push(_path);
                  } else if (_path.isClass()) {
                    var _name3 = _declar.node.id.name;
                    exportNames.push(_name3);
                    exportValues.push(scope.buildUndefinedNode());
                    variableIds.push(_core.types.cloneNode(_declar.node.id));

                    _path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(_declar.node.id), _core.types.toExpression(_declar.node))));

                    addExportName(_name3, _name3);
                  } else {
                    for (var _i5 = 0, _Object$keys3 = Object.keys(_declar.getBindingIdentifiers()); _i5 < _Object$keys3.length; _i5++) {
                      var _name4 = _Object$keys3[_i5];
                      addExportName(_name4, _name4);
                    }
                  }
                } else {
                  var specifiers = _path.node.specifiers;

                  if (specifiers == null ? void 0 : specifiers.length) {
                    if (_path.node.source) {
                      pushModule(_path.node.source.value, "exports", specifiers);

                      _path.remove();
                    } else {
                      var nodes = [];
                      var _iteratorNormalCompletion7 = true;
                      var _didIteratorError7 = false;
                      var _iteratorError7 = undefined;

                      try {
                        for (var _iterator7 = specifiers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                          var specifier = _step7.value;
                          var local = specifier.local,
                              exported = specifier.exported;
                          var binding = scope.getBinding(local.name);
                          var exportedName = getExportSpecifierName(exported, stringSpecifiers);

                          if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {
                            exportNames.push(exportedName);
                            exportValues.push(_core.types.cloneNode(local));
                          } else if (!binding) {
                            nodes.push(buildExportCall(exportedName, local));
                          }

                          addExportName(local.name, exportedName);
                        }
                      } catch (err) {
                        _didIteratorError7 = true;
                        _iteratorError7 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                            _iterator7["return"]();
                          }
                        } finally {
                          if (_didIteratorError7) {
                            throw _iteratorError7;
                          }
                        }
                      }

                      _path.replaceWithMultiple(nodes);
                    }
                  } else {
                    _path.remove();
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          modules.forEach(function (specifiers) {
            var setterBody = [];
            var target = scope.generateUid(specifiers.key);
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = specifiers.imports[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var specifier = _step4.value;

                if (_core.types.isImportNamespaceSpecifier(specifier)) {
                  setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.identifier(target))));
                } else if (_core.types.isImportDefaultSpecifier(specifier)) {
                  specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier("default"));
                }

                if (_core.types.isImportSpecifier(specifier)) {
                  var _specifier = specifier,
                      imported = _specifier.imported;
                  setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, imported.type === "StringLiteral"))));
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            if (specifiers.exports.length) {
              var _exportNames = [];
              var _exportValues = [];
              var hasExportStar = false;
              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = specifiers.exports[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var node = _step5.value;

                  if (_core.types.isExportAllDeclaration(node)) {
                    hasExportStar = true;
                  } else if (_core.types.isExportSpecifier(node)) {
                    var exportedName = getExportSpecifierName(node.exported, stringSpecifiers);

                    _exportNames.push(exportedName);

                    _exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));
                  } else {}
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                    _iterator5["return"]();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }

              setterBody = setterBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), _exportNames, _exportValues, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));
            }

            sources.push(_core.types.stringLiteral(specifiers.key));
            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));
          });
          var moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
          (0, _helperHoistVariables["default"])(path, function (id, name, hasInit) {
            variableIds.push(id);

            if (!hasInit && name in exportMap) {
              var _iteratorNormalCompletion6 = true;
              var _didIteratorError6 = false;
              var _iteratorError6 = undefined;

              try {
                for (var _iterator6 = exportMap[name][Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  var exported = _step6.value;
                  exportNames.push(exported);
                  exportValues.push(scope.buildUndefinedNode());
                }
              } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                    _iterator6["return"]();
                  }
                } finally {
                  if (_didIteratorError6) {
                    throw _iteratorError6;
                  }
                }
              }
            }
          }, null);

          if (variableIds.length) {
            beforeBody.unshift(_core.types.variableDeclaration("var", variableIds.map(function (id) {
              return _core.types.variableDeclarator(id);
            })));
          }

          if (exportNames.length) {
            beforeBody = beforeBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));
          }

          path.traverse(reassignmentVisitor, {
            exports: exportMap,
            buildCall: buildExportCall,
            scope: scope
          });

          for (var _i3 = 0, _removedPaths = removedPaths; _i3 < _removedPaths.length; _i3++) {
            var _path2 = _removedPaths[_i3];

            _path2.remove();
          }

          var hasTLA = false;
          path.traverse({
            AwaitExpression: function AwaitExpression(path) {
              hasTLA = true;
              path.stop();
            },
            Function: function Function(path) {
              path.skip();
            },
            noScope: true
          });
          path.node.body = [buildTemplate({
            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier("register")),
            BEFORE_BODY: beforeBody,
            MODULE_NAME: moduleName,
            SETTERS: _core.types.arrayExpression(setters),
            EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), false, hasTLA),
            SOURCES: _core.types.arrayExpression(sources),
            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),
            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)
          })];
        }
      }
    }
  };
});

exports["default"] = _default;