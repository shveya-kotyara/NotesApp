"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.explode = explode;
exports.verify = verify;
exports.merge = merge;

var virtualTypes = _interopRequireWildcard(require("./path/lib/virtual-types"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function explode(visitor) {
  if (visitor._exploded) return visitor;
  visitor._exploded = true;

  for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {
    var nodeType = _Object$keys[_i];
    if (shouldIgnoreKey(nodeType)) continue;
    var parts = nodeType.split("|");
    if (parts.length === 1) continue;
    var fns = visitor[nodeType];
    delete visitor[nodeType];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;
        visitor[part] = fns;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  verify(visitor);
  delete visitor.__esModule;
  ensureEntranceObjects(visitor);
  ensureCallbackArrays(visitor);

  for (var _i2 = 0, _Object$keys2 = Object.keys(visitor); _i2 < _Object$keys2.length; _i2++) {
    var _nodeType = _Object$keys2[_i2];
    if (shouldIgnoreKey(_nodeType)) continue;
    var wrapper = virtualTypes[_nodeType];
    if (!wrapper) continue;
    var _fns = visitor[_nodeType];

    for (var _i5 = 0, _Object$keys5 = Object.keys(_fns); _i5 < _Object$keys5.length; _i5++) {
      var _type = _Object$keys5[_i5];
      _fns[_type] = wrapCheck(wrapper, _fns[_type]);
    }

    delete visitor[_nodeType];

    if (wrapper.types) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = wrapper.types[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var type = _step2.value;

          if (visitor[type]) {
            mergePair(visitor[type], _fns);
          } else {
            visitor[type] = _fns;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    } else {
      mergePair(visitor, _fns);
    }
  }

  for (var _i3 = 0, _Object$keys3 = Object.keys(visitor); _i3 < _Object$keys3.length; _i3++) {
    var _nodeType2 = _Object$keys3[_i3];
    if (shouldIgnoreKey(_nodeType2)) continue;
    var _fns2 = visitor[_nodeType2];
    var aliases = t.FLIPPED_ALIAS_KEYS[_nodeType2];
    var deprecratedKey = t.DEPRECATED_KEYS[_nodeType2];

    if (deprecratedKey) {
      console.trace("Visitor defined for ".concat(_nodeType2, " but it has been renamed to ").concat(deprecratedKey));
      aliases = [deprecratedKey];
    }

    if (!aliases) continue;
    delete visitor[_nodeType2];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = aliases[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var alias = _step3.value;
        var existing = visitor[alias];

        if (existing) {
          mergePair(existing, _fns2);
        } else {
          visitor[alias] = Object.assign({}, _fns2);
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  for (var _i4 = 0, _Object$keys4 = Object.keys(visitor); _i4 < _Object$keys4.length; _i4++) {
    var _nodeType3 = _Object$keys4[_i4];
    if (shouldIgnoreKey(_nodeType3)) continue;
    ensureCallbackArrays(visitor[_nodeType3]);
  }

  return visitor;
}

function verify(visitor) {
  if (visitor._verified) return;

  if (typeof visitor === "function") {
    throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
  }

  for (var _i6 = 0, _Object$keys6 = Object.keys(visitor); _i6 < _Object$keys6.length; _i6++) {
    var nodeType = _Object$keys6[_i6];

    if (nodeType === "enter" || nodeType === "exit") {
      validateVisitorMethods(nodeType, visitor[nodeType]);
    }

    if (shouldIgnoreKey(nodeType)) continue;

    if (t.TYPES.indexOf(nodeType) < 0) {
      throw new Error("You gave us a visitor for the node type ".concat(nodeType, " but it's not a valid type"));
    }

    var visitors = visitor[nodeType];

    if (_typeof(visitors) === "object") {
      for (var _i7 = 0, _Object$keys7 = Object.keys(visitors); _i7 < _Object$keys7.length; _i7++) {
        var visitorKey = _Object$keys7[_i7];

        if (visitorKey === "enter" || visitorKey === "exit") {
          validateVisitorMethods("".concat(nodeType, ".").concat(visitorKey), visitors[visitorKey]);
        } else {
          throw new Error("You passed `traverse()` a visitor object with the property " + "".concat(nodeType, " that has the invalid property ").concat(visitorKey));
        }
      }
    }
  }

  visitor._verified = true;
}

function validateVisitorMethods(path, val) {
  var fns = [].concat(val);
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = fns[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var fn = _step4.value;

      if (typeof fn !== "function") {
        throw new TypeError("Non-function found defined in ".concat(path, " with type ").concat(_typeof(fn)));
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }
}

function merge(visitors) {
  var states = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var wrapper = arguments.length > 2 ? arguments[2] : undefined;
  var rootVisitor = {};

  for (var i = 0; i < visitors.length; i++) {
    var visitor = visitors[i];
    var state = states[i];
    explode(visitor);

    for (var _i8 = 0, _Object$keys8 = Object.keys(visitor); _i8 < _Object$keys8.length; _i8++) {
      var type = _Object$keys8[_i8];
      var visitorType = visitor[type];

      if (state || wrapper) {
        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
      }

      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
      mergePair(nodeVisitor, visitorType);
    }
  }

  return rootVisitor;
}

function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
  var newVisitor = {};

  var _loop = function _loop() {
    var key = _Object$keys9[_i9];
    var fns = oldVisitor[key];
    if (!Array.isArray(fns)) return "continue";
    fns = fns.map(function (fn) {
      var newFn = fn;

      if (state) {
        newFn = function newFn(path) {
          return fn.call(state, path, state);
        };
      }

      if (wrapper) {
        newFn = wrapper(state.key, key, newFn);
      }

      if (newFn !== fn) {
        newFn.toString = function () {
          return fn.toString();
        };
      }

      return newFn;
    });
    newVisitor[key] = fns;
  };

  for (var _i9 = 0, _Object$keys9 = Object.keys(oldVisitor); _i9 < _Object$keys9.length; _i9++) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }

  return newVisitor;
}

function ensureEntranceObjects(obj) {
  for (var _i10 = 0, _Object$keys10 = Object.keys(obj); _i10 < _Object$keys10.length; _i10++) {
    var key = _Object$keys10[_i10];
    if (shouldIgnoreKey(key)) continue;
    var fns = obj[key];

    if (typeof fns === "function") {
      obj[key] = {
        enter: fns
      };
    }
  }
}

function ensureCallbackArrays(obj) {
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
}

function wrapCheck(wrapper, fn) {
  var newFn = function newFn(path) {
    if (wrapper.checkPath(path)) {
      return fn.apply(this, arguments);
    }
  };

  newFn.toString = function () {
    return fn.toString();
  };

  return newFn;
}

function shouldIgnoreKey(key) {
  if (key[0] === "_") return true;
  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

  if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") {
    return true;
  }

  return false;
}

function mergePair(dest, src) {
  for (var _i11 = 0, _Object$keys11 = Object.keys(src); _i11 < _Object$keys11.length; _i11++) {
    var key = _Object$keys11[_i11];
    dest[key] = [].concat(dest[key] || [], src[key]);
  }
}