"use strict";

var _environmentVisitor;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skipAllButComputedKey = skipAllButComputedKey;
exports["default"] = exports.environmentVisitor = void 0;

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var _helperMemberExpressionToFunctions = _interopRequireDefault(require("@babel/helper-member-expression-to-functions"));

var _helperOptimiseCallExpression = _interopRequireDefault(require("@babel/helper-optimise-call-expression"));

var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
  objectRef = t.cloneNode(objectRef);
  var targetRef = isStatic || isPrivateMethod ? objectRef : t.memberExpression(objectRef, t.identifier("prototype"));
  return t.callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
}

function skipAllButComputedKey(path) {
  if (!path.node.computed) {
    path.skip();
    return;
  }

  var keys = t.VISITOR_KEYS[path.type];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      if (key !== "key") path.skipKey(key);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

var environmentVisitor = (_environmentVisitor = {}, _defineProperty(_environmentVisitor, "".concat(t.StaticBlock ? "StaticBlock|" : "", "ClassPrivateProperty|TypeAnnotation"), function ClassPrivatePropertyTypeAnnotation(path) {
  path.skip();
}), _defineProperty(_environmentVisitor, "Function", function Function(path) {
  if (path.isMethod()) return;
  if (path.isArrowFunctionExpression()) return;
  path.skip();
}), _defineProperty(_environmentVisitor, "Method|ClassProperty", function MethodClassProperty(path) {
  skipAllButComputedKey(path);
}), _environmentVisitor);
exports.environmentVisitor = environmentVisitor;

var visitor = _traverse["default"].visitors.merge([environmentVisitor, {
  Super: function Super(path, state) {
    var node = path.node,
        parentPath = path.parentPath;
    if (!parentPath.isMemberExpression({
      object: node
    })) return;
    state.handle(parentPath);
  }
}]);

var specHandlers = {
  memoise: function memoise(superMember, count) {
    var scope = superMember.scope,
        node = superMember.node;
    var computed = node.computed,
        property = node.property;

    if (!computed) {
      return;
    }

    var memo = scope.maybeGenerateMemoised(property);

    if (!memo) {
      return;
    }

    this.memoiser.set(property, memo, count);
  },
  prop: function prop(superMember) {
    var _superMember$node = superMember.node,
        computed = _superMember$node.computed,
        property = _superMember$node.property;

    if (this.memoiser.has(property)) {
      return t.cloneNode(this.memoiser.get(property));
    }

    if (computed) {
      return t.cloneNode(property);
    }

    return t.stringLiteral(property.name);
  },
  get: function get(superMember) {
    return this._get(superMember, this._getThisRefs());
  },
  _get: function _get(superMember, thisRefs) {
    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return t.callExpression(this.file.addHelper("get"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs["this"]]);
  },
  _getThisRefs: function _getThisRefs() {
    if (!this.isDerivedConstructor) {
      return {
        "this": t.thisExpression()
      };
    }

    var thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
    return {
      memo: t.assignmentExpression("=", thisRef, t.thisExpression()),
      "this": t.cloneNode(thisRef)
    };
  },
  set: function set(superMember, value) {
    var thisRefs = this._getThisRefs();

    var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return t.callExpression(this.file.addHelper("set"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs["this"], t.booleanLiteral(superMember.isInStrictMode())]);
  },
  destructureSet: function destructureSet(superMember) {
    throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  },
  call: function call(superMember, args) {
    var thisRefs = this._getThisRefs();

    return (0, _helperOptimiseCallExpression["default"])(this._get(superMember, thisRefs), t.cloneNode(thisRefs["this"]), args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    var thisRefs = this._getThisRefs();

    return (0, _helperOptimiseCallExpression["default"])(this._get(superMember, thisRefs), t.cloneNode(thisRefs["this"]), args, true);
  }
};
var looseHandlers = Object.assign({}, specHandlers, {
  prop: function prop(superMember) {
    var property = superMember.node.property;

    if (this.memoiser.has(property)) {
      return t.cloneNode(this.memoiser.get(property));
    }

    return t.cloneNode(property);
  },
  get: function get(superMember) {
    var isStatic = this.isStatic,
        superRef = this.superRef;
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    var object;

    if (isStatic) {
      object = superRef ? t.cloneNode(superRef) : t.memberExpression(t.identifier("Function"), t.identifier("prototype"));
    } else {
      object = superRef ? t.memberExpression(t.cloneNode(superRef), t.identifier("prototype")) : t.memberExpression(t.identifier("Object"), t.identifier("prototype"));
    }

    return t.memberExpression(object, prop, computed);
  },
  set: function set(superMember, value) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return t.assignmentExpression("=", t.memberExpression(t.thisExpression(), prop, computed), value);
  },
  destructureSet: function destructureSet(superMember) {
    var computed = superMember.node.computed;
    var prop = this.prop(superMember);
    return t.memberExpression(t.thisExpression(), prop, computed);
  },
  call: function call(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this.get(superMember), t.thisExpression(), args, false);
  },
  optionalCall: function optionalCall(superMember, args) {
    return (0, _helperOptimiseCallExpression["default"])(this.get(superMember), t.thisExpression(), args, true);
  }
});

var ReplaceSupers =
/*#__PURE__*/
function () {
  function ReplaceSupers(opts) {
    _classCallCheck(this, ReplaceSupers);

    var path = opts.methodPath;
    this.methodPath = path;
    this.isDerivedConstructor = path.isClassMethod({
      kind: "constructor"
    }) && !!opts.superRef;
    this.isStatic = path.isObjectMethod() || path.node["static"];
    this.isPrivateMethod = path.isPrivate() && path.isMethod();
    this.file = opts.file;
    this.superRef = opts.superRef;
    this.isLoose = opts.isLoose;
    this.opts = opts;
  }

  _createClass(ReplaceSupers, [{
    key: "getObjectRef",
    value: function getObjectRef() {
      return t.cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    }
  }, {
    key: "replace",
    value: function replace() {
      var handler = this.isLoose ? looseHandlers : specHandlers;
      (0, _helperMemberExpressionToFunctions["default"])(this.methodPath, visitor, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        superRef: this.superRef
      }, handler));
    }
  }]);

  return ReplaceSupers;
}();

exports["default"] = ReplaceSupers;