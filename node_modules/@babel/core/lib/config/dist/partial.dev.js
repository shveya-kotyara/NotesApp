"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(resolveRootMode),
    _marked2 =
/*#__PURE__*/
regeneratorRuntime.mark(loadPrivatePartialConfig);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = loadPrivatePartialConfig;
exports.loadPartialConfig = void 0;

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _gensync() {
  var data = _interopRequireDefault(require("gensync"));

  _gensync = function _gensync() {
    return data;
  };

  return data;
}

var _plugin = _interopRequireDefault(require("./plugin"));

var _util = require("./util");

var _item = require("./item");

var _configChain = require("./config-chain");

var _environment = require("./helpers/environment");

var _options = require("./validation/options");

var _files = require("./files");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function resolveRootMode(rootDir, rootMode) {
  var upwardRootDir, _upwardRootDir;

  return regeneratorRuntime.wrap(function resolveRootMode$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.t0 = rootMode;
          _context.next = _context.t0 === "root" ? 3 : _context.t0 === "upward-optional" ? 4 : _context.t0 === "upward" ? 7 : 12;
          break;

        case 3:
          return _context.abrupt("return", rootDir);

        case 4:
          return _context.delegateYield((0, _files.findConfigUpwards)(rootDir), "t1", 5);

        case 5:
          upwardRootDir = _context.t1;
          return _context.abrupt("return", upwardRootDir === null ? rootDir : upwardRootDir);

        case 7:
          return _context.delegateYield((0, _files.findConfigUpwards)(rootDir), "t2", 8);

        case 8:
          _upwardRootDir = _context.t2;

          if (!(_upwardRootDir !== null)) {
            _context.next = 11;
            break;
          }

          return _context.abrupt("return", _upwardRootDir);

        case 11:
          throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + "be found when searching upward from \"".concat(rootDir, "\".\n") + "One of the following config files must be in the directory tree: " + "\"".concat(_files.ROOT_CONFIG_FILENAMES.join(", "), "\".")), {
            code: "BABEL_ROOT_NOT_FOUND",
            dirname: rootDir
          });

        case 12:
          throw new Error("Assertion failure - unknown rootMode value.");

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

function loadPrivatePartialConfig(inputOpts) {
  var args, _args$envName, envName, _args$cwd, cwd, _args$root, rootDir, _args$rootMode, rootMode, caller, _args$cloneInputAst, cloneInputAst, absoluteCwd, absoluteRootDir, filename, showConfigPath, context, configChain, options;

  return regeneratorRuntime.wrap(function loadPrivatePartialConfig$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(inputOpts != null && (_typeof(inputOpts) !== "object" || Array.isArray(inputOpts)))) {
            _context2.next = 2;
            break;
          }

          throw new Error("Babel options must be an object, null, or undefined");

        case 2:
          args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {};
          _args$envName = args.envName, envName = _args$envName === void 0 ? (0, _environment.getEnv)() : _args$envName, _args$cwd = args.cwd, cwd = _args$cwd === void 0 ? "." : _args$cwd, _args$root = args.root, rootDir = _args$root === void 0 ? "." : _args$root, _args$rootMode = args.rootMode, rootMode = _args$rootMode === void 0 ? "root" : _args$rootMode, caller = args.caller, _args$cloneInputAst = args.cloneInputAst, cloneInputAst = _args$cloneInputAst === void 0 ? true : _args$cloneInputAst;
          absoluteCwd = _path()["default"].resolve(cwd);
          return _context2.delegateYield(resolveRootMode(_path()["default"].resolve(absoluteCwd, rootDir), rootMode), "t0", 6);

        case 6:
          absoluteRootDir = _context2.t0;
          filename = typeof args.filename === "string" ? _path()["default"].resolve(cwd, args.filename) : undefined;
          return _context2.delegateYield((0, _files.resolveShowConfigPath)(absoluteCwd), "t1", 9);

        case 9:
          showConfigPath = _context2.t1;
          context = {
            filename: filename,
            cwd: absoluteCwd,
            root: absoluteRootDir,
            envName: envName,
            caller: caller,
            showConfig: showConfigPath === filename
          };
          return _context2.delegateYield((0, _configChain.buildRootChain)(args, context), "t2", 12);

        case 12:
          configChain = _context2.t2;

          if (configChain) {
            _context2.next = 15;
            break;
          }

          return _context2.abrupt("return", null);

        case 15:
          options = {};
          configChain.options.forEach(function (opts) {
            (0, _util.mergeOptions)(options, opts);
          });
          options.cloneInputAst = cloneInputAst;
          options.babelrc = false;
          options.configFile = false;
          options.passPerPreset = false;
          options.envName = context.envName;
          options.cwd = context.cwd;
          options.root = context.root;
          options.filename = typeof context.filename === "string" ? context.filename : undefined;
          options.plugins = configChain.plugins.map(function (descriptor) {
            return (0, _item.createItemFromDescriptor)(descriptor);
          });
          options.presets = configChain.presets.map(function (descriptor) {
            return (0, _item.createItemFromDescriptor)(descriptor);
          });
          return _context2.abrupt("return", {
            options: options,
            context: context,
            fileHandling: configChain.fileHandling,
            ignore: configChain.ignore,
            babelrc: configChain.babelrc,
            config: configChain.config,
            files: configChain.files
          });

        case 28:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}

var loadPartialConfig = (0, _gensync()["default"])(
/*#__PURE__*/
regeneratorRuntime.mark(function _callee(opts) {
  var showIgnoredFiles, _opts, result, options, babelrc, ignore, config, fileHandling, files;

  return regeneratorRuntime.wrap(function _callee$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          showIgnoredFiles = false;

          if (_typeof(opts) === "object" && opts !== null && !Array.isArray(opts)) {
            _opts = opts;
            showIgnoredFiles = _opts.showIgnoredFiles;
            opts = _objectWithoutPropertiesLoose(_opts, ["showIgnoredFiles"]);
            _opts;
          }

          return _context3.delegateYield(loadPrivatePartialConfig(opts), "t0", 3);

        case 3:
          result = _context3.t0;

          if (result) {
            _context3.next = 6;
            break;
          }

          return _context3.abrupt("return", null);

        case 6:
          options = result.options, babelrc = result.babelrc, ignore = result.ignore, config = result.config, fileHandling = result.fileHandling, files = result.files;

          if (!(fileHandling === "ignored" && !showIgnoredFiles)) {
            _context3.next = 9;
            break;
          }

          return _context3.abrupt("return", null);

        case 9:
          (options.plugins || []).forEach(function (item) {
            if (item.value instanceof _plugin["default"]) {
              throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
            }
          });
          return _context3.abrupt("return", new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined, fileHandling, files));

        case 11:
        case "end":
          return _context3.stop();
      }
    }
  }, _callee);
}));
exports.loadPartialConfig = loadPartialConfig;

var PartialConfig =
/*#__PURE__*/
function () {
  function PartialConfig(options, babelrc, ignore, config, fileHandling, files) {
    _classCallCheck(this, PartialConfig);

    this.options = void 0;
    this.babelrc = void 0;
    this.babelignore = void 0;
    this.config = void 0;
    this.fileHandling = void 0;
    this.files = void 0;
    this.options = options;
    this.babelignore = ignore;
    this.babelrc = babelrc;
    this.config = config;
    this.fileHandling = fileHandling;
    this.files = files;
    Object.freeze(this);
  }

  _createClass(PartialConfig, [{
    key: "hasFilesystemConfig",
    value: function hasFilesystemConfig() {
      return this.babelrc !== undefined || this.config !== undefined;
    }
  }]);

  return PartialConfig;
}();

Object.freeze(PartialConfig.prototype);