"use strict";

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(findConfigUpwards),
    _marked2 =
/*#__PURE__*/
regeneratorRuntime.mark(findRelativeConfig),
    _marked3 =
/*#__PURE__*/
regeneratorRuntime.mark(loadOneConfig),
    _marked4 =
/*#__PURE__*/
regeneratorRuntime.mark(loadConfig),
    _marked5 =
/*#__PURE__*/
regeneratorRuntime.mark(resolveShowConfigPath);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findConfigUpwards = findConfigUpwards;
exports.findRelativeConfig = findRelativeConfig;
exports.findRootConfig = findRootConfig;
exports.loadConfig = loadConfig;
exports.resolveShowConfigPath = resolveShowConfigPath;
exports.ROOT_CONFIG_FILENAMES = void 0;

function _debug() {
  var data = _interopRequireDefault(require("debug"));

  _debug = function _debug() {
    return data;
  };

  return data;
}

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _json() {
  var data = _interopRequireDefault(require("json5"));

  _json = function _json() {
    return data;
  };

  return data;
}

function _gensync() {
  var data = _interopRequireDefault(require("gensync"));

  _gensync = function _gensync() {
    return data;
  };

  return data;
}

var _caching = require("../caching");

var _configApi = _interopRequireDefault(require("../helpers/config-api"));

var _utils = require("./utils");

var _moduleTypes = _interopRequireDefault(require("./module-types"));

var _patternToRegex = _interopRequireDefault(require("../pattern-to-regex"));

var fs = _interopRequireWildcard(require("../../gensync-utils/fs"));

var _resolve = _interopRequireDefault(require("../../gensync-utils/resolve"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var debug = (0, _debug()["default"])("babel:config:loading:files:configuration");
var ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json"];
exports.ROOT_CONFIG_FILENAMES = ROOT_CONFIG_FILENAMES;
var RELATIVE_CONFIG_FILENAMES = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json"];
var BABELIGNORE_FILENAME = ".babelignore";

function findConfigUpwards(rootDir) {
  var dirname, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, filename, nextDir;

  return regeneratorRuntime.wrap(function findConfigUpwards$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          dirname = rootDir;

        case 1:
          if (!true) {
            _context.next = 35;
            break;
          }

          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 5;
          _iterator = ROOT_CONFIG_FILENAMES[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 15;
            break;
          }

          filename = _step.value;
          return _context.delegateYield(fs.exists(_path()["default"].join(dirname, filename)), "t0", 10);

        case 10:
          if (!_context.t0) {
            _context.next = 12;
            break;
          }

          return _context.abrupt("return", dirname);

        case 12:
          _iteratorNormalCompletion = true;
          _context.next = 7;
          break;

        case 15:
          _context.next = 21;
          break;

        case 17:
          _context.prev = 17;
          _context.t1 = _context["catch"](5);
          _didIteratorError = true;
          _iteratorError = _context.t1;

        case 21:
          _context.prev = 21;
          _context.prev = 22;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 24:
          _context.prev = 24;

          if (!_didIteratorError) {
            _context.next = 27;
            break;
          }

          throw _iteratorError;

        case 27:
          return _context.finish(24);

        case 28:
          return _context.finish(21);

        case 29:
          nextDir = _path()["default"].dirname(dirname);

          if (!(dirname === nextDir)) {
            _context.next = 32;
            break;
          }

          return _context.abrupt("break", 35);

        case 32:
          dirname = nextDir;
          _context.next = 1;
          break;

        case 35:
          return _context.abrupt("return", null);

        case 36:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[5, 17, 21, 29], [22,, 24, 28]]);
}

function findRelativeConfig(packageData, envName, caller) {
  var config, ignore, dirname, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, loc, _packageData$pkg, ignoreLoc;

  return regeneratorRuntime.wrap(function findRelativeConfig$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          config = null;
          ignore = null;
          dirname = _path()["default"].dirname(packageData.filepath);
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context2.prev = 6;
          _iterator2 = packageData.directories[Symbol.iterator]();

        case 8:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context2.next = 21;
            break;
          }

          loc = _step2.value;

          if (config) {
            _context2.next = 13;
            break;
          }

          return _context2.delegateYield(loadOneConfig(RELATIVE_CONFIG_FILENAMES, loc, envName, caller, ((_packageData$pkg = packageData.pkg) == null ? void 0 : _packageData$pkg.dirname) === loc ? packageToBabelConfig(packageData.pkg) : null), "t0", 12);

        case 12:
          config = _context2.t0;

        case 13:
          if (ignore) {
            _context2.next = 18;
            break;
          }

          ignoreLoc = _path()["default"].join(loc, BABELIGNORE_FILENAME);
          return _context2.delegateYield(readIgnoreConfig(ignoreLoc), "t1", 16);

        case 16:
          ignore = _context2.t1;

          if (ignore) {
            debug("Found ignore %o from %o.", ignore.filepath, dirname);
          }

        case 18:
          _iteratorNormalCompletion2 = true;
          _context2.next = 8;
          break;

        case 21:
          _context2.next = 27;
          break;

        case 23:
          _context2.prev = 23;
          _context2.t2 = _context2["catch"](6);
          _didIteratorError2 = true;
          _iteratorError2 = _context2.t2;

        case 27:
          _context2.prev = 27;
          _context2.prev = 28;

          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }

        case 30:
          _context2.prev = 30;

          if (!_didIteratorError2) {
            _context2.next = 33;
            break;
          }

          throw _iteratorError2;

        case 33:
          return _context2.finish(30);

        case 34:
          return _context2.finish(27);

        case 35:
          return _context2.abrupt("return", {
            config: config,
            ignore: ignore
          });

        case 36:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[6, 23, 27, 35], [28,, 30, 34]]);
}

function findRootConfig(dirname, envName, caller) {
  return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname, envName, caller);
}

function loadOneConfig(names, dirname, envName, caller) {
  var previousConfig,
      configs,
      config,
      _args3 = arguments;
  return regeneratorRuntime.wrap(function loadOneConfig$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          previousConfig = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : null;
          return _context3.delegateYield(_gensync()["default"].all(names.map(function (filename) {
            return readConfig(_path()["default"].join(dirname, filename), envName, caller);
          })), "t0", 2);

        case 2:
          configs = _context3.t0;
          config = configs.reduce(function (previousConfig, config) {
            if (config && previousConfig) {
              throw new Error("Multiple configuration files found. Please remove one:\n" + " - ".concat(_path()["default"].basename(previousConfig.filepath), "\n") + " - ".concat(config.filepath, "\n") + "from ".concat(dirname));
            }

            return config || previousConfig;
          }, previousConfig);

          if (config) {
            debug("Found configuration %o from %o.", config.filepath, dirname);
          }

          return _context3.abrupt("return", config);

        case 6:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}

function loadConfig(name, dirname, envName, caller) {
  var filepath, conf;
  return regeneratorRuntime.wrap(function loadConfig$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          return _context4.delegateYield((0, _resolve["default"])(name, {
            basedir: dirname
          }), "t0", 1);

        case 1:
          filepath = _context4.t0;
          return _context4.delegateYield(readConfig(filepath, envName, caller), "t1", 3);

        case 3:
          conf = _context4.t1;

          if (conf) {
            _context4.next = 6;
            break;
          }

          throw new Error("Config file ".concat(filepath, " contains no configuration data"));

        case 6:
          debug("Loaded config %o from %o.", name, dirname);
          return _context4.abrupt("return", conf);

        case 8:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4);
}

function readConfig(filepath, envName, caller) {
  var ext = _path()["default"].extname(filepath);

  return ext === ".js" || ext === ".cjs" || ext === ".mjs" ? readConfigJS(filepath, {
    envName: envName,
    caller: caller
  }) : readConfigJSON5(filepath);
}

var LOADING_CONFIGS = new Set();
var readConfigJS = (0, _caching.makeStrongCache)(
/*#__PURE__*/
regeneratorRuntime.mark(function readConfigJS(filepath, cache) {
  var options, assertCache;
  return regeneratorRuntime.wrap(function readConfigJS$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          if (fs.exists.sync(filepath)) {
            _context5.next = 3;
            break;
          }

          cache.forever();
          return _context5.abrupt("return", null);

        case 3:
          if (!LOADING_CONFIGS.has(filepath)) {
            _context5.next = 7;
            break;
          }

          cache.never();
          debug("Auto-ignoring usage of config %o.", filepath);
          return _context5.abrupt("return", {
            filepath: filepath,
            dirname: _path()["default"].dirname(filepath),
            options: {}
          });

        case 7:
          _context5.prev = 7;
          LOADING_CONFIGS.add(filepath);
          return _context5.delegateYield((0, _moduleTypes["default"])(filepath, "You appear to be using a native ECMAScript module configuration " + "file, which is only supported when running Babel asynchronously."), "t0", 10);

        case 10:
          options = _context5.t0;
          _context5.next = 17;
          break;

        case 13:
          _context5.prev = 13;
          _context5.t1 = _context5["catch"](7);
          _context5.t1.message = "".concat(filepath, ": Error while loading config - ").concat(_context5.t1.message);
          throw _context5.t1;

        case 17:
          _context5.prev = 17;
          LOADING_CONFIGS["delete"](filepath);
          return _context5.finish(17);

        case 20:
          assertCache = false;

          if (!(typeof options === "function")) {
            _context5.next = 25;
            break;
          }

          return _context5.delegateYield([], "t2", 23);

        case 23:
          options = options((0, _configApi["default"])(cache));
          assertCache = true;

        case 25:
          if (!(!options || _typeof(options) !== "object" || Array.isArray(options))) {
            _context5.next = 27;
            break;
          }

          throw new Error("".concat(filepath, ": Configuration should be an exported JavaScript object."));

        case 27:
          if (!(typeof options.then === "function")) {
            _context5.next = 29;
            break;
          }

          throw new Error("You appear to be using an async configuration, " + "which your current version of Babel does not support. " + "We may add support for this in the future, " + "but if you're on the most recent version of @babel/core and still " + "seeing this error, then you'll need to synchronously return your config.");

        case 29:
          if (assertCache && !cache.configured()) throwConfigError();
          return _context5.abrupt("return", {
            filepath: filepath,
            dirname: _path()["default"].dirname(filepath),
            options: options
          });

        case 31:
        case "end":
          return _context5.stop();
      }
    }
  }, readConfigJS, null, [[7, 13, 17, 20]]);
}));
var packageToBabelConfig = (0, _caching.makeWeakCacheSync)(function (file) {
  var babel = file.options["babel"];
  if (typeof babel === "undefined") return null;

  if (_typeof(babel) !== "object" || Array.isArray(babel) || babel === null) {
    throw new Error("".concat(file.filepath, ": .babel property must be an object"));
  }

  return {
    filepath: file.filepath,
    dirname: file.dirname,
    options: babel
  };
});
var readConfigJSON5 = (0, _utils.makeStaticFileCache)(function (filepath, content) {
  var options;

  try {
    options = _json()["default"].parse(content);
  } catch (err) {
    err.message = "".concat(filepath, ": Error while parsing config - ").concat(err.message);
    throw err;
  }

  if (!options) throw new Error("".concat(filepath, ": No config detected"));

  if (_typeof(options) !== "object") {
    throw new Error("".concat(filepath, ": Config returned typeof ").concat(_typeof(options)));
  }

  if (Array.isArray(options)) {
    throw new Error("".concat(filepath, ": Expected config object but found array"));
  }

  return {
    filepath: filepath,
    dirname: _path()["default"].dirname(filepath),
    options: options
  };
});
var readIgnoreConfig = (0, _utils.makeStaticFileCache)(function (filepath, content) {
  var ignoreDir = _path()["default"].dirname(filepath);

  var ignorePatterns = content.split("\n").map(function (line) {
    return line.replace(/#(.*?)$/, "").trim();
  }).filter(function (line) {
    return !!line;
  });
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = ignorePatterns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var pattern = _step3.value;

      if (pattern[0] === "!") {
        throw new Error("Negation of file paths is not supported.");
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return {
    filepath: filepath,
    dirname: _path()["default"].dirname(filepath),
    ignore: ignorePatterns.map(function (pattern) {
      return (0, _patternToRegex["default"])(pattern, ignoreDir);
    })
  };
});

function resolveShowConfigPath(dirname) {
  var targetPath, absolutePath, stats;
  return regeneratorRuntime.wrap(function resolveShowConfigPath$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          targetPath = process.env.BABEL_SHOW_CONFIG_FOR;

          if (!(targetPath != null)) {
            _context6.next = 8;
            break;
          }

          absolutePath = _path()["default"].resolve(dirname, targetPath);
          return _context6.delegateYield(fs.stat(absolutePath), "t0", 4);

        case 4:
          stats = _context6.t0;

          if (stats.isFile()) {
            _context6.next = 7;
            break;
          }

          throw new Error("".concat(absolutePath, ": BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported."));

        case 7:
          return _context6.abrupt("return", absolutePath);

        case 8:
          return _context6.abrupt("return", null);

        case 9:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked5);
}

function throwConfigError() {
  throw new Error("Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don't call this function again.\n  api.cache(true);\n\n  // Don't cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === \"production\");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === \"production\");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};");
}