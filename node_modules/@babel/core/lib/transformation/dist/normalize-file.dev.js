"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(normalizeFile);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = normalizeFile;

function _fs() {
  var data = _interopRequireDefault(require("fs"));

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _debug() {
  var data = _interopRequireDefault(require("debug"));

  _debug = function _debug() {
    return data;
  };

  return data;
}

function _cloneDeep() {
  var data = _interopRequireDefault(require("lodash/cloneDeep"));

  _cloneDeep = function _cloneDeep() {
    return data;
  };

  return data;
}

function t() {
  var data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}

function _convertSourceMap() {
  var data = _interopRequireDefault(require("convert-source-map"));

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

var _file = _interopRequireDefault(require("./file/file"));

var _parser = _interopRequireDefault(require("../parser"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var debug = (0, _debug()["default"])("babel:transform:file");
var LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;

function normalizeFile(pluginPasses, options, code, ast) {
  var cloneInputAst, inputMap, lastComment, _lastComment, match, inputMapContent;

  return regeneratorRuntime.wrap(function normalizeFile$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          code = "".concat(code || "");

          if (!ast) {
            _context.next = 12;
            break;
          }

          if (!(ast.type === "Program")) {
            _context.next = 6;
            break;
          }

          ast = t().file(ast, [], []);
          _context.next = 8;
          break;

        case 6:
          if (!(ast.type !== "File")) {
            _context.next = 8;
            break;
          }

          throw new Error("AST root must be a Program or File node");

        case 8:
          cloneInputAst = options.cloneInputAst;

          if (cloneInputAst) {
            ast = (0, _cloneDeep()["default"])(ast);
          }

          _context.next = 14;
          break;

        case 12:
          return _context.delegateYield((0, _parser["default"])(pluginPasses, options, code), "t0", 13);

        case 13:
          ast = _context.t0;

        case 14:
          inputMap = null;

          if (options.inputSourceMap !== false) {
            if (_typeof(options.inputSourceMap) === "object") {
              inputMap = _convertSourceMap()["default"].fromObject(options.inputSourceMap);
            }

            if (!inputMap) {
              lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);

              if (lastComment) {
                try {
                  inputMap = _convertSourceMap()["default"].fromComment(lastComment);
                } catch (err) {
                  debug("discarding unknown inline input sourcemap", err);
                }
              }
            }

            if (!inputMap) {
              _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);

              if (typeof options.filename === "string" && _lastComment) {
                try {
                  match = EXTERNAL_SOURCEMAP_REGEX.exec(_lastComment);
                  inputMapContent = _fs()["default"].readFileSync(_path()["default"].resolve(_path()["default"].dirname(options.filename), match[1]));

                  if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {
                    debug("skip merging input map > 1 MB");
                  } else {
                    inputMap = _convertSourceMap()["default"].fromJSON(inputMapContent);
                  }
                } catch (err) {
                  debug("discarding unknown file input sourcemap", err);
                }
              } else if (_lastComment) {
                debug("discarding un-loadable file input sourcemap");
              }
            }
          }

          return _context.abrupt("return", new _file["default"](options, {
            code: code,
            ast: ast,
            inputMap: inputMap
          }));

        case 17:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

function extractCommentsFromList(regex, comments, lastComment) {
  if (comments) {
    comments = comments.filter(function (_ref) {
      var value = _ref.value;

      if (regex.test(value)) {
        lastComment = value;
        return false;
      }

      return true;
    });
  }

  return [comments, lastComment];
}

function extractComments(regex, ast) {
  var lastComment = null;
  t().traverseFast(ast, function (node) {
    var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);

    var _extractCommentsFromL2 = _slicedToArray(_extractCommentsFromL, 2);

    node.leadingComments = _extractCommentsFromL2[0];
    lastComment = _extractCommentsFromL2[1];

    var _extractCommentsFromL3 = extractCommentsFromList(regex, node.innerComments, lastComment);

    var _extractCommentsFromL4 = _slicedToArray(_extractCommentsFromL3, 2);

    node.innerComments = _extractCommentsFromL4[0];
    lastComment = _extractCommentsFromL4[1];

    var _extractCommentsFromL5 = extractCommentsFromList(regex, node.trailingComments, lastComment);

    var _extractCommentsFromL6 = _slicedToArray(_extractCommentsFromL5, 2);

    node.trailingComments = _extractCommentsFromL6[0];
    lastComment = _extractCommentsFromL6[1];
  });
  return lastComment;
}