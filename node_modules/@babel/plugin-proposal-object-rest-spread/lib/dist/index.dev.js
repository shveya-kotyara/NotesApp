"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _pluginSyntaxObjectRestSpread = _interopRequireDefault(require("@babel/plugin-syntax-object-rest-spread"));

var _core = require("@babel/core");

var _pluginTransformParameters = require("@babel/plugin-transform-parameters");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var ZERO_REFS = function () {
  var node = _core.types.identifier("a");

  var property = _core.types.objectProperty(_core.types.identifier("key"), node);

  var pattern = _core.types.objectPattern([property]);

  return _core.types.isReferenced(node, property, pattern) ? 1 : 0;
}();

var _default = (0, _helperPluginUtils.declare)(function (api, opts) {
  api.assertVersion(7);
  var _opts$useBuiltIns = opts.useBuiltIns,
      useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
      _opts$loose = opts.loose,
      loose = _opts$loose === void 0 ? false : _opts$loose;

  if (typeof loose !== "boolean") {
    throw new Error(".loose must be a boolean, or undefined");
  }

  function getExtendsHelper(file) {
    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")) : file.addHelper("extends");
  }

  function hasRestElement(path) {
    var foundRestElement = false;
    visitRestElements(path, function (restElement) {
      foundRestElement = true;
      restElement.stop();
    });
    return foundRestElement;
  }

  function hasObjectPatternRestElement(path) {
    var foundRestElement = false;
    visitRestElements(path, function (restElement) {
      if (restElement.parentPath.isObjectPattern()) {
        foundRestElement = true;
        restElement.stop();
      }
    });
    return foundRestElement;
  }

  function visitRestElements(path, visitor) {
    path.traverse({
      Expression: function Expression(path) {
        var parentType = path.parent.type;

        if (parentType === "AssignmentPattern" && path.key === "right" || parentType === "ObjectProperty" && path.parent.computed && path.key === "key") {
          path.skip();
        }
      },
      RestElement: visitor
    });
  }

  function hasSpread(node) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;

        if (_core.types.isSpreadElement(prop)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return false;
  }

  function extractNormalizedKeys(path) {
    var props = path.node.properties;
    var keys = [];
    var allLiteral = true;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = props[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var prop = _step2.value;

        if (_core.types.isIdentifier(prop.key) && !prop.computed) {
          keys.push(_core.types.stringLiteral(prop.key.name));
        } else if (_core.types.isTemplateLiteral(prop.key)) {
          keys.push(_core.types.cloneNode(prop.key));
        } else if (_core.types.isLiteral(prop.key)) {
          keys.push(_core.types.stringLiteral(String(prop.key.value)));
        } else {
          keys.push(_core.types.cloneNode(prop.key));
          allLiteral = false;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return {
      keys: keys,
      allLiteral: allLiteral
    };
  }

  function replaceImpureComputedKeys(properties, scope) {
    var impureComputedPropertyDeclarators = [];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var propPath = _step3.value;
        var key = propPath.get("key");

        if (propPath.node.computed && !key.isPure()) {
          var name = scope.generateUidBasedOnNode(key.node);

          var declarator = _core.types.variableDeclarator(_core.types.identifier(name), key.node);

          impureComputedPropertyDeclarators.push(declarator);
          key.replaceWith(_core.types.identifier(name));
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return impureComputedPropertyDeclarators;
  }

  function removeUnusedExcludedKeys(path) {
    var bindings = path.getOuterBindingIdentifierPaths();
    Object.keys(bindings).forEach(function (bindingName) {
      var bindingParentPath = bindings[bindingName].parentPath;

      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
        return;
      }

      bindingParentPath.remove();
    });
  }

  function createObjectSpread(path, file, objRef) {
    var props = path.get("properties");
    var last = props[props.length - 1];

    _core.types.assertRestElement(last.node);

    var restElement = _core.types.cloneNode(last.node);

    last.remove();
    var impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);

    var _extractNormalizedKey = extractNormalizedKeys(path),
        keys = _extractNormalizedKey.keys,
        allLiteral = _extractNormalizedKey.allLiteral;

    if (keys.length === 0) {
      return [impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(getExtendsHelper(file), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)])];
    }

    var keyExpression;

    if (!allLiteral) {
      keyExpression = _core.types.callExpression(_core.types.memberExpression(_core.types.arrayExpression(keys), _core.types.identifier("map")), [file.addHelper("toPropertyKey")]);
    } else {
      keyExpression = _core.types.arrayExpression(keys);
    }

    return [impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(file.addHelper("objectWithoutProperties".concat(loose ? "Loose" : "")), [_core.types.cloneNode(objRef), keyExpression])];
  }

  function replaceRestElement(parentPath, paramPath, container) {
    if (paramPath.isAssignmentPattern()) {
      replaceRestElement(parentPath, paramPath.get("left"), container);
      return;
    }

    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
      var elements = paramPath.get("elements");

      for (var i = 0; i < elements.length; i++) {
        replaceRestElement(parentPath, elements[i], container);
      }
    }

    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
      var uid = parentPath.scope.generateUidIdentifier("ref");

      var declar = _core.types.variableDeclaration("let", [_core.types.variableDeclarator(paramPath.node, uid)]);

      if (container) {
        container.push(declar);
      } else {
        parentPath.ensureBlock();
        parentPath.get("body").unshiftContainer("body", declar);
      }

      paramPath.replaceWith(_core.types.cloneNode(uid));
    }
  }

  return {
    name: "proposal-object-rest-spread",
    inherits: _pluginSyntaxObjectRestSpread["default"],
    visitor: {
      Function: function Function(path) {
        var params = path.get("params");
        var paramsWithRestElement = new Set();
        var idsInRestParams = new Set();

        for (var _i = 0; _i < params.length; ++_i) {
          var param = params[_i];

          if (hasRestElement(param)) {
            paramsWithRestElement.add(_i);

            for (var _i2 = 0, _Object$keys = Object.keys(param.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
              var name = _Object$keys[_i2];
              idsInRestParams.add(name);
            }
          }
        }

        var idInRest = false;

        var IdentifierHandler = function IdentifierHandler(path, functionScope) {
          var name = path.node.name;

          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
            idInRest = true;
            path.stop();
          }
        };

        var i;

        for (i = 0; i < params.length && !idInRest; ++i) {
          var _param = params[i];

          if (!paramsWithRestElement.has(i)) {
            if (_param.isReferencedIdentifier() || _param.isBindingIdentifier()) {
              IdentifierHandler(path, path.scope);
            } else {
              _param.traverse({
                "Scope|TypeAnnotation|TSTypeAnnotation": function ScopeTypeAnnotationTSTypeAnnotation(path) {
                  return path.skip();
                },
                "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
              }, path.scope);
            }
          }
        }

        if (!idInRest) {
          for (var _i3 = 0; _i3 < params.length; ++_i3) {
            var _param2 = params[_i3];

            if (paramsWithRestElement.has(_i3)) {
              replaceRestElement(_param2.parentPath, _param2);
            }
          }
        } else {
          var shouldTransformParam = function shouldTransformParam(idx) {
            return idx >= i - 1 || paramsWithRestElement.has(idx);
          };

          (0, _pluginTransformParameters.convertFunctionParams)(path, loose, shouldTransformParam, replaceRestElement);
        }
      },
      VariableDeclarator: function VariableDeclarator(path, file) {
        if (!path.get("id").isObjectPattern()) {
          return;
        }

        var insertionPath = path;
        var originalPath = path;
        visitRestElements(path.get("id"), function (path) {
          if (!path.parentPath.isObjectPattern()) {
            return;
          }

          if (originalPath.node.id.properties.length > 1 && !_core.types.isIdentifier(originalPath.node.init)) {
            var initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
            originalPath.insertBefore(_core.types.variableDeclarator(initRef, originalPath.node.init));
            originalPath.replaceWith(_core.types.variableDeclarator(originalPath.node.id, _core.types.cloneNode(initRef)));
            return;
          }

          var ref = originalPath.node.init;
          var refPropertyPath = [];
          var kind;
          path.findParent(function (path) {
            if (path.isObjectProperty()) {
              refPropertyPath.unshift(path);
            } else if (path.isVariableDeclarator()) {
              kind = path.parentPath.node.kind;
              return true;
            }
          });
          var impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
          refPropertyPath.forEach(function (prop) {
            var node = prop.node;
            ref = _core.types.memberExpression(ref, _core.types.cloneNode(node.key), node.computed || _core.types.isLiteral(node.key));
          });
          var objectPatternPath = path.findParent(function (path) {
            return path.isObjectPattern();
          });

          var _createObjectSpread = createObjectSpread(objectPatternPath, file, ref),
              _createObjectSpread2 = _slicedToArray(_createObjectSpread, 3),
              impureComputedPropertyDeclarators = _createObjectSpread2[0],
              argument = _createObjectSpread2[1],
              callExpression = _createObjectSpread2[2];

          if (loose) {
            removeUnusedExcludedKeys(objectPatternPath);
          }

          _core.types.assertIdentifier(argument);

          insertionPath.insertBefore(impureComputedPropertyDeclarators);
          insertionPath.insertBefore(impureObjRefComputedDeclarators);
          insertionPath.insertAfter(_core.types.variableDeclarator(argument, callExpression));
          insertionPath = insertionPath.getSibling(insertionPath.key + 1);
          path.scope.registerBinding(kind, insertionPath);

          if (objectPatternPath.node.properties.length === 0) {
            objectPatternPath.findParent(function (path) {
              return path.isObjectProperty() || path.isVariableDeclarator();
            }).remove();
          }
        });
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
        var declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        var hasRest = declaration.get("declarations").some(function (path) {
          return hasObjectPatternRestElement(path.get("id"));
        });
        if (!hasRest) return;
        var specifiers = [];

        for (var _i4 = 0, _Object$keys2 = Object.keys(path.getOuterBindingIdentifiers(path)); _i4 < _Object$keys2.length; _i4++) {
          var name = _Object$keys2[_i4];
          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));
        }

        path.replaceWith(declaration.node);
        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));
      },
      CatchClause: function CatchClause(path) {
        var paramPath = path.get("param");
        replaceRestElement(paramPath.parentPath, paramPath);
      },
      AssignmentExpression: function AssignmentExpression(path, file) {
        var leftPath = path.get("left");

        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
          var nodes = [];
          var refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
          nodes.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(refName), path.node.right)]));

          var _createObjectSpread3 = createObjectSpread(leftPath, file, _core.types.identifier(refName)),
              _createObjectSpread4 = _slicedToArray(_createObjectSpread3, 3),
              impureComputedPropertyDeclarators = _createObjectSpread4[0],
              argument = _createObjectSpread4[1],
              callExpression = _createObjectSpread4[2];

          if (impureComputedPropertyDeclarators.length > 0) {
            nodes.push(_core.types.variableDeclaration("var", impureComputedPropertyDeclarators));
          }

          var nodeWithoutSpread = _core.types.cloneNode(path.node);

          nodeWithoutSpread.right = _core.types.identifier(refName);
          nodes.push(_core.types.expressionStatement(nodeWithoutSpread));
          nodes.push(_core.types.toStatement(_core.types.assignmentExpression("=", argument, callExpression)));
          nodes.push(_core.types.expressionStatement(_core.types.identifier(refName)));
          path.replaceWithMultiple(nodes);
        }
      },
      ForXStatement: function ForXStatement(path) {
        var node = path.node,
            scope = path.scope;
        var leftPath = path.get("left");
        var left = node.left;

        if (!hasObjectPatternRestElement(leftPath)) {
          return;
        }

        if (!_core.types.isVariableDeclaration(left)) {
          var temp = scope.generateUidIdentifier("ref");
          node.left = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(temp)]);
          path.ensureBlock();

          if (node.body.body.length === 0 && path.isCompletionRecord()) {
            node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode()));
          }

          node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression("=", left, _core.types.cloneNode(temp))));
        } else {
          var pattern = left.declarations[0].id;
          var key = scope.generateUidIdentifier("ref");
          node.left = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(key, null)]);
          path.ensureBlock();
          node.body.body.unshift(_core.types.variableDeclaration(node.left.kind, [_core.types.variableDeclarator(pattern, _core.types.cloneNode(key))]));
        }
      },
      ArrayPattern: function ArrayPattern(path) {
        var objectPatterns = [];
        visitRestElements(path, function (path) {
          if (!path.parentPath.isObjectPattern()) {
            return;
          }

          var objectPattern = path.parentPath;
          var uid = path.scope.generateUidIdentifier("ref");
          objectPatterns.push(_core.types.variableDeclarator(objectPattern.node, uid));
          objectPattern.replaceWith(_core.types.cloneNode(uid));
          path.skip();
        });

        if (objectPatterns.length > 0) {
          var statementPath = path.getStatementParent();
          statementPath.insertAfter(_core.types.variableDeclaration(statementPath.node.kind || "var", objectPatterns));
        }
      },
      ObjectExpression: function ObjectExpression(path, file) {
        if (!hasSpread(path.node)) return;
        var helper;

        if (loose) {
          helper = getExtendsHelper(file);
        } else {
          try {
            helper = file.addHelper("objectSpread2");
          } catch (_unused) {
            this.file.declarations["objectSpread2"] = null;
            helper = file.addHelper("objectSpread");
          }
        }

        var exp = null;
        var props = [];

        function make() {
          var hadProps = props.length > 0;

          var obj = _core.types.objectExpression(props);

          props = [];

          if (!exp) {
            exp = _core.types.callExpression(helper, [obj]);
            return;
          }

          if (loose) {
            if (hadProps) {
              exp.arguments.push(obj);
            }

            return;
          }

          exp = _core.types.callExpression(_core.types.cloneNode(helper), [exp].concat(_toConsumableArray(hadProps ? [_core.types.objectExpression([]), obj] : [])));
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = path.node.properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var prop = _step4.value;

            if (_core.types.isSpreadElement(prop)) {
              make();
              exp.arguments.push(prop.argument);
            } else {
              props.push(prop);
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        if (props.length) make();
        path.replaceWith(exp);
      }
    }
  };
});

exports["default"] = _default;