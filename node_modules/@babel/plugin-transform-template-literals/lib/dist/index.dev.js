"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          function ", "() {\n            const data = ", ";\n            ", " = function() { return data };\n            return data;\n          }\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

var _default = (0, _helperPluginUtils.declare)(function (api, options) {
  api.assertVersion(7);
  var loose = options.loose;
  var helperName = "taggedTemplateLiteral";
  if (loose) helperName += "Loose";

  function buildConcatCallExpressions(items) {
    var avail = true;
    return items.reduce(function (left, right) {
      var canBeInserted = _core.types.isLiteral(right);

      if (!canBeInserted && avail) {
        canBeInserted = true;
        avail = false;
      }

      if (canBeInserted && _core.types.isCallExpression(left)) {
        left.arguments.push(right);
        return left;
      }

      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [right]);
    });
  }

  return {
    name: "transform-template-literals",
    visitor: {
      TaggedTemplateExpression: function TaggedTemplateExpression(path) {
        var node = path.node;
        var quasi = node.quasi;
        var strings = [];
        var raws = [];
        var isStringsRawEqual = true;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = quasi.quasis[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var elem = _step.value;
            var _elem$value = elem.value,
                raw = _elem$value.raw,
                cooked = _elem$value.cooked;
            var value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);
            strings.push(value);
            raws.push(_core.types.stringLiteral(raw));

            if (raw !== cooked) {
              isStringsRawEqual = false;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var scope = path.scope.getProgramParent();
        var templateObject = scope.generateUidIdentifier("templateObject");
        var helperId = this.addHelper(helperName);
        var callExpressionInput = [_core.types.arrayExpression(strings)];

        if (!isStringsRawEqual) {
          callExpressionInput.push(_core.types.arrayExpression(raws));
        }

        var lazyLoad = _core.template.ast(_templateObject(), templateObject, _core.types.callExpression(helperId, callExpressionInput), _core.types.cloneNode(templateObject));

        scope.path.unshiftContainer("body", lazyLoad);
        path.replaceWith(_core.types.callExpression(node.tag, [_core.types.callExpression(_core.types.cloneNode(templateObject), [])].concat(_toConsumableArray(quasi.expressions))));
      },
      TemplateLiteral: function TemplateLiteral(path) {
        var nodes = [];
        var expressions = path.get("expressions");
        var index = 0;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = path.node.quasis[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var elem = _step2.value;

            if (elem.value.cooked) {
              nodes.push(_core.types.stringLiteral(elem.value.cooked));
            }

            if (index < expressions.length) {
              var expr = expressions[index++];
              var node = expr.node;

              if (!_core.types.isStringLiteral(node, {
                value: ""
              })) {
                nodes.push(node);
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var considerSecondNode = !loose || !_core.types.isStringLiteral(nodes[1]);

        if (!_core.types.isStringLiteral(nodes[0]) && considerSecondNode) {
          nodes.unshift(_core.types.stringLiteral(""));
        }

        var root = nodes[0];

        if (loose) {
          for (var i = 1; i < nodes.length; i++) {
            root = _core.types.binaryExpression("+", root, nodes[i]);
          }
        } else if (nodes.length > 1) {
          root = buildConcatCallExpressions(nodes);
        }

        path.replaceWith(root);
      }
    }
  };
});

exports["default"] = _default;