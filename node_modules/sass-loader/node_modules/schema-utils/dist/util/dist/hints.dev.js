"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Range = require('./Range');
/** @typedef {import("../validate").Schema} Schema */

/**
 * @param {Schema} schema
 * @param {boolean} logic
 * @return {string[]}
 */


module.exports.stringHints = function stringHints(schema, logic) {
  var hints = [];
  var type = 'string';

  var currentSchema = _objectSpread({}, schema);

  if (!logic) {
    var tmpLength = currentSchema.minLength;
    var tmpFormat = currentSchema.formatMinimum;
    var tmpExclusive = currentSchema.formatExclusiveMaximum;
    currentSchema.minLength = currentSchema.maxLength;
    currentSchema.maxLength = tmpLength;
    currentSchema.formatMinimum = currentSchema.formatMaximum;
    currentSchema.formatMaximum = tmpFormat;
    currentSchema.formatExclusiveMaximum = !currentSchema.formatExclusiveMinimum;
    currentSchema.formatExclusiveMinimum = !tmpExclusive;
  }

  if (typeof currentSchema.minLength === 'number') {
    if (currentSchema.minLength === 1) {
      type = 'non-empty string';
    } else {
      var length = Math.max(currentSchema.minLength - 1, 0);
      hints.push("should be longer than ".concat(length, " character").concat(length > 1 ? 's' : ''));
    }
  }

  if (typeof currentSchema.maxLength === 'number') {
    if (currentSchema.maxLength === 0) {
      type = 'empty string';
    } else {
      var _length = currentSchema.maxLength + 1;

      hints.push("should be shorter than ".concat(_length, " character").concat(_length > 1 ? 's' : ''));
    }
  }

  if (currentSchema.pattern) {
    hints.push("should".concat(logic ? '' : ' not', " match pattern ").concat(JSON.stringify(currentSchema.pattern)));
  }

  if (currentSchema.format) {
    hints.push("should".concat(logic ? '' : ' not', " match format ").concat(JSON.stringify(currentSchema.format)));
  }

  if (currentSchema.formatMinimum) {
    hints.push("should be ".concat(currentSchema.formatExclusiveMinimum ? '>' : '>=', " ").concat(JSON.stringify(currentSchema.formatMinimum)));
  }

  if (currentSchema.formatMaximum) {
    hints.push("should be ".concat(currentSchema.formatExclusiveMaximum ? '<' : '<=', " ").concat(JSON.stringify(currentSchema.formatMaximum)));
  }

  return [type].concat(hints);
};
/**
 * @param {Schema} schema
 * @param {boolean} logic
 * @return {string[]}
 */


module.exports.numberHints = function numberHints(schema, logic) {
  var hints = [schema.type === 'integer' ? 'integer' : 'number'];
  var range = new Range();

  if (typeof schema.minimum === 'number') {
    range.left(schema.minimum);
  }

  if (typeof schema.exclusiveMinimum === 'number') {
    range.left(schema.exclusiveMinimum, true);
  }

  if (typeof schema.maximum === 'number') {
    range.right(schema.maximum);
  }

  if (typeof schema.exclusiveMaximum === 'number') {
    range.right(schema.exclusiveMaximum, true);
  }

  var rangeFormat = range.format(logic);

  if (rangeFormat) {
    hints.push(rangeFormat);
  }

  if (typeof schema.multipleOf === 'number') {
    hints.push("should".concat(logic ? '' : ' not', " be multiple of ").concat(schema.multipleOf));
  }

  return hints;
};