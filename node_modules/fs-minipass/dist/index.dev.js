'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var MiniPass = require('minipass');

var EE = require('events').EventEmitter;

var fs = require('fs');

var writev = fs.writev;
/* istanbul ignore next */

if (!writev) {
  // This entire block can be removed if support for earlier than Node.js
  // 12.9.0 is not needed.
  var binding = process.binding('fs');
  var FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;

  writev = function writev(fd, iovec, pos, cb) {
    var done = function done(er, bw) {
      return cb(er, bw, iovec);
    };

    var req = new FSReqWrap();
    req.oncomplete = done;
    binding.writeBuffers(fd, iovec, pos, req);
  };
}

var _autoClose = Symbol('_autoClose');

var _close = Symbol('_close');

var _ended = Symbol('_ended');

var _fd = Symbol('_fd');

var _finished = Symbol('_finished');

var _flags = Symbol('_flags');

var _flush = Symbol('_flush');

var _handleChunk = Symbol('_handleChunk');

var _makeBuf = Symbol('_makeBuf');

var _mode = Symbol('_mode');

var _needDrain = Symbol('_needDrain');

var _onerror = Symbol('_onerror');

var _onopen = Symbol('_onopen');

var _onread = Symbol('_onread');

var _onwrite = Symbol('_onwrite');

var _open = Symbol('_open');

var _path = Symbol('_path');

var _pos = Symbol('_pos');

var _queue = Symbol('_queue');

var _read = Symbol('_read');

var _readSize = Symbol('_readSize');

var _reading = Symbol('_reading');

var _remain = Symbol('_remain');

var _size = Symbol('_size');

var _write = Symbol('_write');

var _writing = Symbol('_writing');

var _defaultFlag = Symbol('_defaultFlag');

var _errored = Symbol('_errored');

var ReadStream =
/*#__PURE__*/
function (_MiniPass) {
  _inherits(ReadStream, _MiniPass);

  function ReadStream(path, opt) {
    var _this;

    _classCallCheck(this, ReadStream);

    opt = opt || {};
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReadStream).call(this, opt));
    _this.readable = true;
    _this.writable = false;
    if (typeof path !== 'string') throw new TypeError('path must be a string');
    _this[_errored] = false;
    _this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;
    _this[_path] = path;
    _this[_readSize] = opt.readSize || 16 * 1024 * 1024;
    _this[_reading] = false;
    _this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;
    _this[_remain] = _this[_size];
    _this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;
    if (typeof _this[_fd] === 'number') _this[_read]();else _this[_open]();
    return _this;
  }

  _createClass(ReadStream, [{
    key: "write",
    value: function write() {
      throw new TypeError('this is a readable stream');
    }
  }, {
    key: "end",
    value: function end() {
      throw new TypeError('this is a readable stream');
    }
  }, {
    key: _open,
    value: function value() {
      var _this2 = this;

      fs.open(this[_path], 'r', function (er, fd) {
        return _this2[_onopen](er, fd);
      });
    }
  }, {
    key: _onopen,
    value: function value(er, fd) {
      if (er) this[_onerror](er);else {
        this[_fd] = fd;
        this.emit('open', fd);

        this[_read]();
      }
    }
  }, {
    key: _makeBuf,
    value: function value() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
  }, {
    key: _read,
    value: function value() {
      var _this3 = this;

      if (!this[_reading]) {
        this[_reading] = true;

        var buf = this[_makeBuf]();
        /* istanbul ignore if */


        if (buf.length === 0) return process.nextTick(function () {
          return _this3[_onread](null, 0, buf);
        });
        fs.read(this[_fd], buf, 0, buf.length, null, function (er, br, buf) {
          return _this3[_onread](er, br, buf);
        });
      }
    }
  }, {
    key: _onread,
    value: function value(er, br, buf) {
      this[_reading] = false;
      if (er) this[_onerror](er);else if (this[_handleChunk](br, buf)) this[_read]();
    }
  }, {
    key: _close,
    value: function value() {
      var _this4 = this;

      if (this[_autoClose] && typeof this[_fd] === 'number') {
        var fd = this[_fd];
        this[_fd] = null;
        fs.close(fd, function (er) {
          return er ? _this4.emit('error', er) : _this4.emit('close');
        });
      }
    }
  }, {
    key: _onerror,
    value: function value(er) {
      this[_reading] = true;

      this[_close]();

      this.emit('error', er);
    }
  }, {
    key: _handleChunk,
    value: function value(br, buf) {
      var ret = false; // no effect if infinite

      this[_remain] -= br;
      if (br > 0) ret = _get(_getPrototypeOf(ReadStream.prototype), "write", this).call(this, br < buf.length ? buf.slice(0, br) : buf);

      if (br === 0 || this[_remain] <= 0) {
        ret = false;

        this[_close]();

        _get(_getPrototypeOf(ReadStream.prototype), "end", this).call(this);
      }

      return ret;
    }
  }, {
    key: "emit",
    value: function emit(ev, data) {
      switch (ev) {
        case 'prefinish':
        case 'finish':
          break;

        case 'drain':
          if (typeof this[_fd] === 'number') this[_read]();
          break;

        case 'error':
          if (this[_errored]) return;
          this[_errored] = true;
          return _get(_getPrototypeOf(ReadStream.prototype), "emit", this).call(this, ev, data);

        default:
          return _get(_getPrototypeOf(ReadStream.prototype), "emit", this).call(this, ev, data);
      }
    }
  }, {
    key: "fd",
    get: function get() {
      return this[_fd];
    }
  }, {
    key: "path",
    get: function get() {
      return this[_path];
    }
  }]);

  return ReadStream;
}(MiniPass);

var ReadStreamSync =
/*#__PURE__*/
function (_ReadStream) {
  _inherits(ReadStreamSync, _ReadStream);

  function ReadStreamSync() {
    _classCallCheck(this, ReadStreamSync);

    return _possibleConstructorReturn(this, _getPrototypeOf(ReadStreamSync).apply(this, arguments));
  }

  _createClass(ReadStreamSync, [{
    key: _open,
    value: function value() {
      var threw = true;

      try {
        this[_onopen](null, fs.openSync(this[_path], 'r'));

        threw = false;
      } finally {
        if (threw) this[_close]();
      }
    }
  }, {
    key: _read,
    value: function value() {
      var threw = true;

      try {
        if (!this[_reading]) {
          this[_reading] = true;

          do {
            var buf = this[_makeBuf]();
            /* istanbul ignore next */


            var br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf)) break;
          } while (true);

          this[_reading] = false;
        }

        threw = false;
      } finally {
        if (threw) this[_close]();
      }
    }
  }, {
    key: _close,
    value: function value() {
      if (this[_autoClose] && typeof this[_fd] === 'number') {
        var fd = this[_fd];
        this[_fd] = null;
        fs.closeSync(fd);
        this.emit('close');
      }
    }
  }]);

  return ReadStreamSync;
}(ReadStream);

var WriteStream =
/*#__PURE__*/
function (_EE) {
  _inherits(WriteStream, _EE);

  function WriteStream(path, opt) {
    var _this5;

    _classCallCheck(this, WriteStream);

    opt = opt || {};
    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(WriteStream).call(this, opt));
    _this5.readable = false;
    _this5.writable = true;
    _this5[_errored] = false;
    _this5[_writing] = false;
    _this5[_ended] = false;
    _this5[_needDrain] = false;
    _this5[_queue] = [];
    _this5[_path] = path;
    _this5[_fd] = typeof opt.fd === 'number' ? opt.fd : null;
    _this5[_mode] = opt.mode === undefined ? 438 : opt.mode;
    _this5[_pos] = typeof opt.start === 'number' ? opt.start : null;
    _this5[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true; // truncating makes no sense when writing into the middle

    var defaultFlag = _this5[_pos] !== null ? 'r+' : 'w';
    _this5[_defaultFlag] = opt.flags === undefined;
    _this5[_flags] = _this5[_defaultFlag] ? defaultFlag : opt.flags;
    if (_this5[_fd] === null) _this5[_open]();
    return _this5;
  }

  _createClass(WriteStream, [{
    key: "emit",
    value: function emit(ev, data) {
      if (ev === 'error') {
        if (this[_errored]) return;
        this[_errored] = true;
      }

      return _get(_getPrototypeOf(WriteStream.prototype), "emit", this).call(this, ev, data);
    }
  }, {
    key: _onerror,
    value: function value(er) {
      this[_close]();

      this[_writing] = true;
      this.emit('error', er);
    }
  }, {
    key: _open,
    value: function value() {
      var _this6 = this;

      fs.open(this[_path], this[_flags], this[_mode], function (er, fd) {
        return _this6[_onopen](er, fd);
      });
    }
  }, {
    key: _onopen,
    value: function value(er, fd) {
      if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {
        this[_flags] = 'w';

        this[_open]();
      } else if (er) this[_onerror](er);else {
        this[_fd] = fd;
        this.emit('open', fd);

        this[_flush]();
      }
    }
  }, {
    key: "end",
    value: function end(buf, enc) {
      if (buf) this.write(buf, enc);
      this[_ended] = true; // synthetic after-write logic, where drain/finish live

      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);
      return this;
    }
  }, {
    key: "write",
    value: function write(buf, enc) {
      if (typeof buf === 'string') buf = Buffer.from(buf, enc);

      if (this[_ended]) {
        this.emit('error', new Error('write() after end()'));
        return false;
      }

      if (this[_fd] === null || this[_writing] || this[_queue].length) {
        this[_queue].push(buf);

        this[_needDrain] = true;
        return false;
      }

      this[_writing] = true;

      this[_write](buf);

      return true;
    }
  }, {
    key: _write,
    value: function value(buf) {
      var _this7 = this;

      fs.write(this[_fd], buf, 0, buf.length, this[_pos], function (er, bw) {
        return _this7[_onwrite](er, bw);
      });
    }
  }, {
    key: _onwrite,
    value: function value(er, bw) {
      if (er) this[_onerror](er);else {
        if (this[_pos] !== null) this[_pos] += bw;
        if (this[_queue].length) this[_flush]();else {
          this[_writing] = false;

          if (this[_ended] && !this[_finished]) {
            this[_finished] = true;

            this[_close]();

            this.emit('finish');
          } else if (this[_needDrain]) {
            this[_needDrain] = false;
            this.emit('drain');
          }
        }
      }
    }
  }, {
    key: _flush,
    value: function value() {
      var _this8 = this;

      if (this[_queue].length === 0) {
        if (this[_ended]) this[_onwrite](null, 0);
      } else if (this[_queue].length === 1) this[_write](this[_queue].pop());else {
        var iovec = this[_queue];
        this[_queue] = [];
        writev(this[_fd], iovec, this[_pos], function (er, bw) {
          return _this8[_onwrite](er, bw);
        });
      }
    }
  }, {
    key: _close,
    value: function value() {
      var _this9 = this;

      if (this[_autoClose] && typeof this[_fd] === 'number') {
        var fd = this[_fd];
        this[_fd] = null;
        fs.close(fd, function (er) {
          return er ? _this9.emit('error', er) : _this9.emit('close');
        });
      }
    }
  }, {
    key: "fd",
    get: function get() {
      return this[_fd];
    }
  }, {
    key: "path",
    get: function get() {
      return this[_path];
    }
  }]);

  return WriteStream;
}(EE);

var WriteStreamSync =
/*#__PURE__*/
function (_WriteStream) {
  _inherits(WriteStreamSync, _WriteStream);

  function WriteStreamSync() {
    _classCallCheck(this, WriteStreamSync);

    return _possibleConstructorReturn(this, _getPrototypeOf(WriteStreamSync).apply(this, arguments));
  }

  _createClass(WriteStreamSync, [{
    key: _open,
    value: function value() {
      var fd; // only wrap in a try{} block if we know we'll retry, to avoid
      // the rethrow obscuring the error's source frame in most cases.

      if (this[_defaultFlag] && this[_flags] === 'r+') {
        try {
          fd = fs.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er.code === 'ENOENT') {
            this[_flags] = 'w';
            return this[_open]();
          } else throw er;
        }
      } else fd = fs.openSync(this[_path], this[_flags], this[_mode]);

      this[_onopen](null, fd);
    }
  }, {
    key: _close,
    value: function value() {
      if (this[_autoClose] && typeof this[_fd] === 'number') {
        var fd = this[_fd];
        this[_fd] = null;
        fs.closeSync(fd);
        this.emit('close');
      }
    }
  }, {
    key: _write,
    value: function value(buf) {
      // throw the original, but try to close if it fails
      var threw = true;

      try {
        this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));

        threw = false;
      } finally {
        if (threw) try {
          this[_close]();
        } catch (_) {}
      }
    }
  }]);

  return WriteStreamSync;
}(WriteStream);

exports.ReadStream = ReadStream;
exports.ReadStreamSync = ReadStreamSync;
exports.WriteStream = WriteStream;
exports.WriteStreamSync = WriteStreamSync;