'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('util'),
    promisify = _require.promisify;

var path = require('path');

var childProcess = require('child_process');

var fs = require('fs');

var isWsl = require('is-wsl');

var pAccess = promisify(fs.access);
var pExecFile = promisify(childProcess.execFile); // Path to included `xdg-open`

var localXdgOpenPath = path.join(__dirname, 'xdg-open'); // Convert a path from WSL format to Windows format:
// `/mnt/c/Program Files/Example/MyApp.exe` â†’ `C:\Program Files\Example\MyApp.exe`

var wslToWindowsPath = function wslToWindowsPath(path) {
  var _ref, stdout;

  return regeneratorRuntime.async(function wslToWindowsPath$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(pExecFile('wslpath', ['-w', path]));

        case 2:
          _ref = _context.sent;
          stdout = _ref.stdout;
          return _context.abrupt("return", stdout.trim());

        case 5:
        case "end":
          return _context.stop();
      }
    }
  });
};

module.exports = function _callee(target, options) {
  var command, appArguments, cliArguments, childProcessOptions, windowsPath, isBundled, exeLocalXdgOpen, useSystemXdgOpen, subprocess;
  return regeneratorRuntime.async(function _callee$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(typeof target !== 'string')) {
            _context2.next = 2;
            break;
          }

          throw new TypeError('Expected a `target`');

        case 2:
          options = _objectSpread({
            wait: false,
            background: false
          }, options);
          appArguments = [];
          cliArguments = [];
          childProcessOptions = {};

          if (Array.isArray(options.app)) {
            appArguments = options.app.slice(1);
            options.app = options.app[0];
          }

          if (!(process.platform === 'darwin')) {
            _context2.next = 14;
            break;
          }

          command = 'open';

          if (options.wait) {
            cliArguments.push('--wait-apps');
          }

          if (options.background) {
            cliArguments.push('--background');
          }

          if (options.app) {
            cliArguments.push('-a', options.app);
          }

          _context2.next = 47;
          break;

        case 14:
          if (!(process.platform === 'win32' || isWsl)) {
            _context2.next = 29;
            break;
          }

          command = 'cmd' + (isWsl ? '.exe' : '');
          cliArguments.push('/c', 'start', '""', '/b');
          target = target.replace(/&/g, '^&');

          if (options.wait) {
            cliArguments.push('/wait');
          }

          if (!options.app) {
            _context2.next = 26;
            break;
          }

          if (!(isWsl && options.app.startsWith('/mnt/'))) {
            _context2.next = 25;
            break;
          }

          _context2.next = 23;
          return regeneratorRuntime.awrap(wslToWindowsPath(options.app));

        case 23:
          windowsPath = _context2.sent;
          options.app = windowsPath;

        case 25:
          cliArguments.push(options.app);

        case 26:
          if (appArguments.length > 0) {
            cliArguments.push.apply(cliArguments, _toConsumableArray(appArguments));
          }

          _context2.next = 47;
          break;

        case 29:
          if (!options.app) {
            _context2.next = 33;
            break;
          }

          command = options.app;
          _context2.next = 45;
          break;

        case 33:
          // When bundled by Webpack, there's no actual package file path and no local `xdg-open`.
          isBundled = !__dirname || __dirname === '/'; // Check if local `xdg-open` exists and is executable.

          exeLocalXdgOpen = false;
          _context2.prev = 35;
          _context2.next = 38;
          return regeneratorRuntime.awrap(pAccess(localXdgOpenPath, fs.constants.X_OK));

        case 38:
          exeLocalXdgOpen = true;
          _context2.next = 43;
          break;

        case 41:
          _context2.prev = 41;
          _context2.t0 = _context2["catch"](35);

        case 43:
          useSystemXdgOpen = process.versions.electron || process.platform === 'android' || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;

        case 45:
          if (appArguments.length > 0) {
            cliArguments.push.apply(cliArguments, _toConsumableArray(appArguments));
          }

          if (!options.wait) {
            // `xdg-open` will block the process unless stdio is ignored
            // and it's detached from the parent even if it's unref'd.
            childProcessOptions.stdio = 'ignore';
            childProcessOptions.detached = true;
          }

        case 47:
          cliArguments.push(target);

          if (process.platform === 'darwin' && appArguments.length > 0) {
            cliArguments.push.apply(cliArguments, ['--args'].concat(_toConsumableArray(appArguments)));
          }

          subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);

          if (!options.wait) {
            _context2.next = 52;
            break;
          }

          return _context2.abrupt("return", new Promise(function (resolve, reject) {
            subprocess.once('error', reject);
            subprocess.once('close', function (exitCode) {
              if (exitCode > 0) {
                reject(new Error("Exited with code ".concat(exitCode)));
                return;
              }

              resolve(subprocess);
            });
          }));

        case 52:
          subprocess.unref();
          return _context2.abrupt("return", subprocess);

        case 54:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[35, 41]]);
};