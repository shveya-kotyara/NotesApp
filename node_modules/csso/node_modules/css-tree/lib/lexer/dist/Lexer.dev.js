"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var SyntaxReferenceError = require('./error').SyntaxReferenceError;

var SyntaxMatchError = require('./error').SyntaxMatchError;

var names = require('../utils/names');

var generic = require('./generic');

var parse = require('../definition-syntax/parse');

var generate = require('../definition-syntax/generate');

var walk = require('../definition-syntax/walk');

var prepareTokens = require('./prepare-tokens');

var buildMatchGraph = require('./match-graph').buildMatchGraph;

var matchAsTree = require('./match').matchAsTree;

var trace = require('./trace');

var search = require('./search');

var getStructureFromConfig = require('./structure').getStructureFromConfig;

var cssWideKeywords = buildMatchGraph('inherit | initial | unset');
var cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');

function dumpMapSyntax(map, compact, syntaxAsAst) {
  var result = {};

  for (var name in map) {
    if (map[name].syntax) {
      result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, {
        compact: compact
      });
    }
  }

  return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
  var result = {};

  for (var _i = 0, _Object$entries = Object.entries(map); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        name = _Object$entries$_i[0],
        atrule = _Object$entries$_i[1];

    result[name] = {
      prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, {
        compact: compact
      })),
      descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
    };
  }

  return result;
}

function valueHasVar(tokens) {
  for (var i = 0; i < tokens.length; i++) {
    if (tokens[i].value.toLowerCase() === 'var(') {
      return true;
    }
  }

  return false;
}

function buildMatchResult(match, error, iterations) {
  return {
    matched: match,
    iterations: iterations,
    error: error,
    getTrace: trace.getTrace,
    isType: trace.isType,
    isProperty: trace.isProperty,
    isKeyword: trace.isKeyword
  };
}

function matchSyntax(lexer, syntax, value, useCommon) {
  var tokens = prepareTokens(value, lexer.syntax);
  var result;

  if (valueHasVar(tokens)) {
    return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
  }

  if (useCommon) {
    result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
  }

  if (!useCommon || !result.match) {
    result = matchAsTree(tokens, syntax.match, lexer);

    if (!result.match) {
      return buildMatchResult(null, new SyntaxMatchError(result.reason, syntax.syntax, value, result), result.iterations);
    }
  }

  return buildMatchResult(result.match, null, result.iterations);
}

var Lexer = function Lexer(config, syntax, structure) {
  this.valueCommonSyntax = cssWideKeywords;
  this.syntax = syntax;
  this.generic = false;
  this.atrules = {};
  this.properties = {};
  this.types = {};
  this.structure = structure || getStructureFromConfig(config);

  if (config) {
    if (config.types) {
      for (var name in config.types) {
        this.addType_(name, config.types[name]);
      }
    }

    if (config.generic) {
      this.generic = true;

      for (var name in generic) {
        this.addType_(name, generic[name]);
      }
    }

    if (config.atrules) {
      for (var name in config.atrules) {
        this.addAtrule_(name, config.atrules[name]);
      }
    }

    if (config.properties) {
      for (var name in config.properties) {
        this.addProperty_(name, config.properties[name]);
      }
    }
  }
};

Lexer.prototype = {
  structure: {},
  checkStructure: function checkStructure(ast) {
    function collectWarning(node, message) {
      warns.push({
        node: node,
        message: message
      });
    }

    var structure = this.structure;
    var warns = [];
    this.syntax.walk(ast, function (node) {
      if (structure.hasOwnProperty(node.type)) {
        structure[node.type].check(node, collectWarning);
      } else {
        collectWarning(node, 'Unknown node type `' + node.type + '`');
      }
    });
    return warns.length ? warns : false;
  },
  createDescriptor: function createDescriptor(syntax, type, name) {
    var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var ref = {
      type: type,
      name: name
    };
    var descriptor = {
      type: type,
      name: name,
      parent: parent,
      syntax: null,
      match: null
    };

    if (typeof syntax === 'function') {
      descriptor.match = buildMatchGraph(syntax, ref);
    } else {
      if (typeof syntax === 'string') {
        // lazy parsing on first access
        Object.defineProperty(descriptor, 'syntax', {
          get: function get() {
            Object.defineProperty(descriptor, 'syntax', {
              value: parse(syntax)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax;
      } // lazy graph build on first access


      Object.defineProperty(descriptor, 'match', {
        get: function get() {
          Object.defineProperty(descriptor, 'match', {
            value: buildMatchGraph(descriptor.syntax, ref)
          });
          return descriptor.match;
        }
      });
    }

    return descriptor;
  },
  addAtrule_: function addAtrule_(name, syntax) {
    var _this = this;

    if (!syntax) {
      return;
    }

    this.atrules[name] = {
      type: 'Atrule',
      name: name,
      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(function (res, descName) {
        res[descName] = _this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
        return res;
      }, {}) : null
    };
  },
  addProperty_: function addProperty_(name, syntax) {
    if (!syntax) {
      return;
    }

    this.properties[name] = this.createDescriptor(syntax, 'Property', name);
  },
  addType_: function addType_(name, syntax) {
    if (!syntax) {
      return;
    }

    this.types[name] = this.createDescriptor(syntax, 'Type', name);

    if (syntax === generic['-ms-legacy-expression']) {
      this.valueCommonSyntax = cssWideKeywordsWithExpression;
    }
  },
  checkAtruleName: function checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
    }
  },
  checkAtrulePrelude: function checkAtrulePrelude(atruleName, prelude) {
    var error = this.checkAtruleName(atruleName);

    if (error) {
      return error;
    }

    var atrule = this.getAtrule(atruleName);

    if (!atrule.prelude && prelude) {
      return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
    }

    if (atrule.prelude && !prelude) {
      return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
    }
  },
  checkAtruleDescriptorName: function checkAtruleDescriptorName(atruleName, descriptorName) {
    var error = this.checkAtruleName(atruleName);

    if (error) {
      return error;
    }

    var atrule = this.getAtrule(atruleName);
    var descriptor = names.keyword(descriptorName);

    if (!atrule.descriptors) {
      return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
    }

    if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
      return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
    }
  },
  checkPropertyName: function checkPropertyName(propertyName) {
    var property = names.property(propertyName); // don't match syntax for a custom property

    if (property.custom) {
      return new Error('Lexer matching doesn\'t applicable for custom properties');
    }

    if (!this.getProperty(propertyName)) {
      return new SyntaxReferenceError('Unknown property', propertyName);
    }
  },
  matchAtrulePrelude: function matchAtrulePrelude(atruleName, prelude) {
    var error = this.checkAtrulePrelude(atruleName, prelude);

    if (error) {
      return buildMatchResult(null, error);
    }

    if (!prelude) {
      return buildMatchResult(null, null);
    }

    return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, true);
  },
  matchAtruleDescriptor: function matchAtruleDescriptor(atruleName, descriptorName, value) {
    var error = this.checkAtruleDescriptorName(atruleName, descriptorName);

    if (error) {
      return buildMatchResult(null, error);
    }

    var atrule = this.getAtrule(atruleName);
    var descriptor = names.keyword(descriptorName);
    return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, true);
  },
  matchDeclaration: function matchDeclaration(node) {
    if (node.type !== 'Declaration') {
      return buildMatchResult(null, new Error('Not a Declaration node'));
    }

    return this.matchProperty(node.property, node.value);
  },
  matchProperty: function matchProperty(propertyName, value) {
    var error = this.checkPropertyName(propertyName);

    if (error) {
      return buildMatchResult(null, error);
    }

    return matchSyntax(this, this.getProperty(propertyName), value, true);
  },
  matchType: function matchType(typeName, value) {
    var typeSyntax = this.getType(typeName);

    if (!typeSyntax) {
      return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
    }

    return matchSyntax(this, typeSyntax, value, false);
  },
  match: function match(syntax, value) {
    if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
      return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
    }

    if (typeof syntax === 'string' || !syntax.match) {
      syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
    }

    return matchSyntax(this, syntax, value, false);
  },
  findValueFragments: function findValueFragments(propertyName, value, type, name) {
    return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
  },
  findDeclarationValueFragments: function findDeclarationValueFragments(declaration, type, name) {
    return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
  },
  findAllFragments: function findAllFragments(ast, type, name) {
    var result = [];
    this.syntax.walk(ast, {
      visit: 'Declaration',
      enter: function (declaration) {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
      }.bind(this)
    });
    return result;
  },
  getAtrule: function getAtrule(atruleName) {
    var fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var atrule = names.keyword(atruleName);
    var atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
    return atruleEntry || null;
  },
  getAtrulePrelude: function getAtrulePrelude(atruleName) {
    var fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var atrule = this.getAtrule(atruleName, fallbackBasename);
    return atrule && atrule.prelude || null;
  },
  getAtruleDescriptor: function getAtruleDescriptor(atruleName, name) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
  },
  getProperty: function getProperty(propertyName) {
    var fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var property = names.property(propertyName);
    var propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
    return propertyEntry || null;
  },
  getType: function getType(name) {
    return this.types.hasOwnProperty(name) ? this.types[name] : null;
  },
  validate: function validate() {
    function validate(syntax, name, broken, descriptor) {
      if (broken.hasOwnProperty(name)) {
        return broken[name];
      }

      broken[name] = false;

      if (descriptor.syntax !== null) {
        walk(descriptor.syntax, function (node) {
          if (node.type !== 'Type' && node.type !== 'Property') {
            return;
          }

          var map = node.type === 'Type' ? syntax.types : syntax.properties;
          var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

          if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
            broken[name] = true;
          }
        }, this);
      }
    }

    var brokenTypes = {};
    var brokenProperties = {};

    for (var key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }

    for (var key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }

    brokenTypes = Object.keys(brokenTypes).filter(function (name) {
      return brokenTypes[name];
    });
    brokenProperties = Object.keys(brokenProperties).filter(function (name) {
      return brokenProperties[name];
    });

    if (brokenTypes.length || brokenProperties.length) {
      return {
        types: brokenTypes,
        properties: brokenProperties
      };
    }

    return null;
  },
  dump: function dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
    };
  },
  toString: function toString() {
    return JSON.stringify(this.dump());
  }
};
module.exports = Lexer;