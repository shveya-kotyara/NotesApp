"use strict";

var createCustomError = require('../utils/createCustomError');

var generate = require('../definition-syntax/generate');

var defaultLoc = {
  offset: 0,
  line: 1,
  column: 1
};

function locateMismatch(matchResult, node) {
  var tokens = matchResult.tokens;
  var longestMatch = matchResult.longestMatch;
  var mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  var badNode = mismatchNode !== node ? mismatchNode : null;
  var mismatchOffset = 0;
  var mismatchLength = 0;
  var entries = 0;
  var css = '';
  var start;
  var end;

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i].value;

    if (i === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }

    if (badNode !== null && tokens[i].node === badNode) {
      if (i <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }

    css += token;
  }

  if (longestMatch === tokens.length || entries > 1) {
    // last
    start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
    end = buildLoc(start);
  } else {
    start = fromLoc(badNode, 'start') || buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
    end = fromLoc(badNode, 'end') || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
  }

  return {
    css: css,
    mismatchOffset: mismatchOffset,
    mismatchLength: mismatchLength,
    start: start,
    end: end
  };
}

function fromLoc(node, point) {
  var value = node && node.loc && node.loc[point];

  if (value) {
    return 'line' in value ? buildLoc(value) : value;
  }

  return null;
}

function buildLoc(_ref, extra) {
  var offset = _ref.offset,
      line = _ref.line,
      column = _ref.column;
  var loc = {
    offset: offset,
    line: line,
    column: column
  };

  if (extra) {
    var lines = extra.split(/\n|\r\n?|\f/);
    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }

  return loc;
}

var SyntaxReferenceError = function SyntaxReferenceError(type, referenceName) {
  var error = createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));
  error.reference = referenceName;
  return error;
};

var SyntaxMatchError = function SyntaxMatchError(message, syntax, node, matchResult) {
  var error = createCustomError('SyntaxMatchError', message);

  var _locateMismatch = locateMismatch(matchResult, node),
      css = _locateMismatch.css,
      mismatchOffset = _locateMismatch.mismatchOffset,
      mismatchLength = _locateMismatch.mismatchLength,
      start = _locateMismatch.start,
      end = _locateMismatch.end;

  error.rawMessage = message;
  error.syntax = syntax ? generate(syntax) : '<generic>';
  error.css = css;
  error.mismatchOffset = mismatchOffset;
  error.mismatchLength = mismatchLength;
  error.message = message + '\n' + '  syntax: ' + error.syntax + '\n' + '   value: ' + (css || '<empty string>') + '\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';
  Object.assign(error, start);
  error.loc = {
    source: node && node.loc && node.loc.source || '<unknown>',
    start: start,
    end: end
  };
  return error;
};

module.exports = {
  SyntaxReferenceError: SyntaxReferenceError,
  SyntaxMatchError: SyntaxMatchError
};