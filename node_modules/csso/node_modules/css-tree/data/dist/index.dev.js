"use strict";

var mdnAtrules = require('mdn-data/css/at-rules.json');

var mdnProperties = require('mdn-data/css/properties.json');

var mdnSyntaxes = require('mdn-data/css/syntaxes.json');

var patch = require('./patch.json');

var extendSyntax = /^\s*\|\s*/;

function preprocessAtrules(dict) {
  var result = Object.create(null);

  for (var atruleName in dict) {
    var atrule = dict[atruleName];
    var descriptors = null;

    if (atrule.descriptors) {
      descriptors = Object.create(null);

      for (var descriptor in atrule.descriptors) {
        descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
      }
    }

    result[atruleName.substr(1)] = {
      prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
      descriptors: descriptors
    };
  }

  return result;
}

function patchDictionary(dict, patchDict) {
  var result = {}; // copy all syntaxes for an original dict

  for (var key in dict) {
    result[key] = dict[key].syntax || dict[key];
  } // apply a patch


  for (var _key in patchDict) {
    if (_key in dict) {
      if (patchDict[_key].syntax) {
        result[_key] = extendSyntax.test(patchDict[_key].syntax) ? result[_key] + ' ' + patchDict[_key].syntax.trim() : patchDict[_key].syntax;
      } else {
        delete result[_key];
      }
    } else {
      if (patchDict[_key].syntax) {
        result[_key] = patchDict[_key].syntax.replace(extendSyntax, '');
      }
    }
  }

  return result;
}

function unpackSyntaxes(dict) {
  var result = {};

  for (var key in dict) {
    result[key] = dict[key].syntax;
  }

  return result;
}

function patchAtrules(dict, patchDict) {
  var result = {}; // copy all syntaxes for an original dict

  for (var key in dict) {
    var patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;
    result[key] = {
      prelude: key in patchDict && 'prelude' in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,
      descriptors: dict[key].descriptors ? patchDictionary(dict[key].descriptors, patchDescriptors || {}) : patchDescriptors && unpackSyntaxes(patchDescriptors)
    };
  } // apply a patch


  for (var _key2 in patchDict) {
    if (!hasOwnProperty.call(dict, _key2)) {
      result[_key2] = {
        prelude: patchDict[_key2].prelude || null,
        descriptors: patchDict[_key2].descriptors && unpackSyntaxes(patchDict[_key2].descriptors)
      };
    }
  }

  return result;
}

module.exports = {
  types: patchDictionary(mdnSyntaxes, patch.syntaxes),
  atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
  properties: patchDictionary(mdnProperties, patch.properties)
};