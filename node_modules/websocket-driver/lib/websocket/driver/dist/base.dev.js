'use strict';

var Emitter = require('events').EventEmitter,
    util = require('util'),
    streams = require('../streams'),
    Headers = require('./headers'),
    Reader = require('./stream_reader');

var Base = function Base(request, url, options) {
  Emitter.call(this);
  Base.validateOptions(options || {}, ['maxLength', 'masking', 'requireMasking', 'protocols']);
  this._request = request;
  this._reader = new Reader();
  this._options = options || {};
  this._maxLength = this._options.maxLength || this.MAX_LENGTH;
  this._headers = new Headers();
  this.__queue = [];
  this.readyState = 0;
  this.url = url;
  this.io = new streams.IO(this);
  this.messages = new streams.Messages(this);

  this._bindEventListeners();
};

util.inherits(Base, Emitter);

Base.validateOptions = function (options, validKeys) {
  for (var key in options) {
    if (validKeys.indexOf(key) < 0) throw new Error('Unrecognized option: ' + key);
  }
};

var instance = {
  // This is 64MB, small enough for an average VPS to handle without
  // crashing from process out of memory
  MAX_LENGTH: 0x3ffffff,
  STATES: ['connecting', 'open', 'closing', 'closed'],
  _bindEventListeners: function _bindEventListeners() {
    var self = this; // Protocol errors are informational and do not have to be handled

    this.messages.on('error', function () {});
    this.on('message', function (event) {
      var messages = self.messages;
      if (messages.readable) messages.emit('data', event.data);
    });
    this.on('error', function (error) {
      var messages = self.messages;
      if (messages.readable) messages.emit('error', error);
    });
    this.on('close', function () {
      var messages = self.messages;
      if (!messages.readable) return;
      messages.readable = messages.writable = false;
      messages.emit('end');
    });
  },
  getState: function getState() {
    return this.STATES[this.readyState] || null;
  },
  addExtension: function addExtension(extension) {
    return false;
  },
  setHeader: function setHeader(name, value) {
    if (this.readyState > 0) return false;

    this._headers.set(name, value);

    return true;
  },
  start: function start() {
    if (this.readyState !== 0) return false;

    var response = this._handshakeResponse();

    if (!response) return false;

    this._write(response);

    if (this._stage !== -1) this._open();
    return true;
  },
  text: function text(message) {
    return this.frame(message);
  },
  binary: function binary(message) {
    return false;
  },
  ping: function ping() {
    return false;
  },
  pong: function pong() {
    return false;
  },
  close: function close(reason, code) {
    if (this.readyState !== 1) return false;
    this.readyState = 3;
    this.emit('close', new Base.CloseEvent(null, null));
    return true;
  },
  _open: function _open() {
    this.readyState = 1;

    this.__queue.forEach(function (args) {
      this.frame.apply(this, args);
    }, this);

    this.__queue = [];
    this.emit('open', new Base.OpenEvent());
  },
  _queue: function _queue(message) {
    this.__queue.push(message);

    return true;
  },
  _write: function _write(chunk) {
    var io = this.io;
    if (io.readable) io.emit('data', chunk);
  }
};

for (var key in instance) {
  Base.prototype[key] = instance[key];
}

Base.ConnectEvent = function () {};

Base.OpenEvent = function () {};

Base.CloseEvent = function (code, reason) {
  this.code = code;
  this.reason = reason;
};

Base.MessageEvent = function (data) {
  this.data = data;
};

module.exports = Base;