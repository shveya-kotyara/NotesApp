'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Stream = require('stream').Stream,
    url = require('url'),
    util = require('util'),
    Base = require('./base'),
    Headers = require('./headers'),
    HttpParser = require('../http_parser');

var PORTS = {
  'ws:': 80,
  'wss:': 443
};

var Proxy = function Proxy(client, origin, options) {
  this._client = client;
  this._http = new HttpParser('response');
  this._origin = _typeof(client.url) === 'object' ? client.url : url.parse(client.url);
  this._url = _typeof(origin) === 'object' ? origin : url.parse(origin);
  this._options = options || {};
  this._state = 0;
  this.readable = this.writable = true;
  this._paused = false;
  this._headers = new Headers();

  this._headers.set('Host', this._origin.host);

  this._headers.set('Connection', 'keep-alive');

  this._headers.set('Proxy-Connection', 'keep-alive');

  var auth = this._url.auth && new Buffer(this._url.auth, 'utf8').toString('base64');
  if (auth) this._headers.set('Proxy-Authorization', 'Basic ' + auth);
};

util.inherits(Proxy, Stream);
var instance = {
  setHeader: function setHeader(name, value) {
    if (this._state !== 0) return false;

    this._headers.set(name, value);

    return true;
  },
  start: function start() {
    if (this._state !== 0) return false;
    this._state = 1;
    var origin = this._origin,
        port = origin.port || PORTS[origin.protocol],
        start = 'CONNECT ' + origin.hostname + ':' + port + ' HTTP/1.1';
    var headers = [start, this._headers.toString(), ''];
    this.emit('data', new Buffer(headers.join('\r\n'), 'utf8'));
    return true;
  },
  pause: function pause() {
    this._paused = true;
  },
  resume: function resume() {
    this._paused = false;
    this.emit('drain');
  },
  write: function write(chunk) {
    if (!this.writable) return false;

    this._http.parse(chunk);

    if (!this._http.isComplete()) return !this._paused;
    this.statusCode = this._http.statusCode;
    this.headers = this._http.headers;

    if (this.statusCode === 200) {
      this.emit('connect', new Base.ConnectEvent());
    } else {
      var message = "Can't establish a connection to the server at " + this._origin.href;
      this.emit('error', new Error(message));
    }

    this.end();
    return !this._paused;
  },
  end: function end(chunk) {
    if (!this.writable) return;
    if (chunk !== undefined) this.write(chunk);
    this.readable = this.writable = false;
    this.emit('close');
    this.emit('end');
  },
  destroy: function destroy() {
    this.end();
  }
};

for (var key in instance) {
  Proxy.prototype[key] = instance[key];
}

module.exports = Proxy;