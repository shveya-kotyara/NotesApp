'use strict';
/* eslint-disable
  arrow-parens,
  multiline-ternary,
  consistent-return,
  no-param-reassign,
  prefer-destructuring
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var noop = function noop() {};

var levels = Symbol('levels');
var instance = Symbol('instance');

var MethodFactory =
/*#__PURE__*/
function () {
  function MethodFactory(logger) {
    _classCallCheck(this, MethodFactory);

    this[levels] = {
      TRACE: 0,
      DEBUG: 1,
      INFO: 2,
      WARN: 3,
      ERROR: 4,
      SILENT: 5
    };
    this[instance] = logger;
  }

  _createClass(MethodFactory, [{
    key: "distillLevel",
    value: function distillLevel(level) {
      var result = level;

      if (typeof result === 'string' && typeof this.levels[result.toUpperCase()] !== 'undefined') {
        result = this.levels[result.toUpperCase()];
      }

      if (this.levelValid(result)) {
        return result;
      }
    }
  }, {
    key: "levelValid",
    value: function levelValid(level) {
      if (typeof level === 'number' && level >= 0 && level <= this.levels.SILENT) {
        return true;
      }

      return false;
    }
    /**
     * Build the best logging method possible for this env
     * Wherever possible we want to bind, not wrap, to preserve stack traces.
     * Since we're targeting modern browsers, there's no need to wait for the
     * console to become available.
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "make",
    value: function make(method) {
      if (method === 'debug') {
        method = 'log';
      }
      /* eslint-disable no-console */


      if (typeof console[method] !== 'undefined') {
        return this.bindMethod(console, method);
      } else if (typeof console.log !== 'undefined') {
        return this.bindMethod(console, 'log');
      }
      /* eslint-enable no-console */


      return noop;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "bindMethod",
    value: function bindMethod(obj, name) {
      var method = obj[name];

      if (typeof method.bind === 'function') {
        return method.bind(obj);
      }

      try {
        return Function.prototype.bind.call(method, obj);
      } catch (err) {
        // Missing bind shim or IE8 + Modernizr, fallback to wrapping
        return function result() {
          // eslint-disable-next-line prefer-rest-params
          return Function.prototype.apply.apply(method, [obj, arguments]);
        };
      }
    }
  }, {
    key: "replaceMethods",
    value: function replaceMethods(logLevel) {
      var _this = this;

      var level = this.distillLevel(logLevel);

      if (level == null) {
        throw new Error("loglevel: replaceMethods() called with invalid level: ".concat(logLevel));
      }

      if (!this.logger || this.logger.type !== 'LogLevel') {
        throw new TypeError('loglevel: Logger is undefined or invalid. Please specify a valid Logger instance.');
      }

      this.methods.forEach(function (method) {
        _this.logger[method] = _this.levels[method.toUpperCase()] < level ? noop : _this.make(method);
      }); // Define log.log as an alias for log.debug

      this.logger.log = this.logger.debug;
    }
  }, {
    key: "logger",
    set: function set(logger) {
      this[instance] = logger;
    },
    get: function get() {
      return this[instance];
    }
  }, {
    key: "levels",
    get: function get() {
      return this[levels];
    }
  }, {
    key: "methods",
    get: function get() {
      return Object.keys(this.levels).map(function (key) {
        return key.toLowerCase();
      }).filter(function (key) {
        return key !== 'silent';
      });
    }
  }]);

  return MethodFactory;
}();

module.exports = MethodFactory;