'use strict';

var path = require('path');

var childProcess = require('child_process');

var crossSpawn = require('cross-spawn');

var stripEof = require('strip-eof');

var npmRunPath = require('npm-run-path');

var isStream = require('is-stream');

var _getStream = require('get-stream');

var pFinally = require('p-finally');

var onExit = require('signal-exit');

var errname = require('./lib/errname');

var stdio = require('./lib/stdio');

var TEN_MEGABYTES = 1000 * 1000 * 10;

function handleArgs(cmd, args, opts) {
  var parsed;
  opts = Object.assign({
    extendEnv: true,
    env: {}
  }, opts);

  if (opts.extendEnv) {
    opts.env = Object.assign({}, process.env, opts.env);
  }

  if (opts.__winShell === true) {
    delete opts.__winShell;
    parsed = {
      command: cmd,
      args: args,
      options: opts,
      file: cmd,
      original: {
        cmd: cmd,
        args: args
      }
    };
  } else {
    parsed = crossSpawn._parse(cmd, args, opts);
  }

  opts = Object.assign({
    maxBuffer: TEN_MEGABYTES,
    buffer: true,
    stripEof: true,
    preferLocal: true,
    localDir: parsed.options.cwd || process.cwd(),
    encoding: 'utf8',
    reject: true,
    cleanup: true
  }, parsed.options);
  opts.stdio = stdio(opts);

  if (opts.preferLocal) {
    opts.env = npmRunPath.env(Object.assign({}, opts, {
      cwd: opts.localDir
    }));
  }

  if (opts.detached) {
    // #115
    opts.cleanup = false;
  }

  if (process.platform === 'win32' && path.basename(parsed.command) === 'cmd.exe') {
    // #116
    parsed.args.unshift('/q');
  }

  return {
    cmd: parsed.command,
    args: parsed.args,
    opts: opts,
    parsed: parsed
  };
}

function handleInput(spawned, input) {
  if (input === null || input === undefined) {
    return;
  }

  if (isStream(input)) {
    input.pipe(spawned.stdin);
  } else {
    spawned.stdin.end(input);
  }
}

function handleOutput(opts, val) {
  if (val && opts.stripEof) {
    val = stripEof(val);
  }

  return val;
}

function handleShell(fn, cmd, opts) {
  var file = '/bin/sh';
  var args = ['-c', cmd];
  opts = Object.assign({}, opts);

  if (process.platform === 'win32') {
    opts.__winShell = true;
    file = process.env.comspec || 'cmd.exe';
    args = ['/s', '/c', "\"".concat(cmd, "\"")];
    opts.windowsVerbatimArguments = true;
  }

  if (opts.shell) {
    file = opts.shell;
    delete opts.shell;
  }

  return fn(file, args, opts);
}

function getStream(process, stream, _ref) {
  var encoding = _ref.encoding,
      buffer = _ref.buffer,
      maxBuffer = _ref.maxBuffer;

  if (!process[stream]) {
    return null;
  }

  var ret;

  if (!buffer) {
    // TODO: Use `ret = util.promisify(stream.finished)(process[stream]);` when targeting Node.js 10
    ret = new Promise(function (resolve, reject) {
      process[stream].once('end', resolve).once('error', reject);
    });
  } else if (encoding) {
    ret = _getStream(process[stream], {
      encoding: encoding,
      maxBuffer: maxBuffer
    });
  } else {
    ret = _getStream.buffer(process[stream], {
      maxBuffer: maxBuffer
    });
  }

  return ret["catch"](function (err) {
    err.stream = stream;
    err.message = "".concat(stream, " ").concat(err.message);
    throw err;
  });
}

function makeError(result, options) {
  var stdout = result.stdout,
      stderr = result.stderr;
  var err = result.error;
  var code = result.code,
      signal = result.signal;
  var parsed = options.parsed,
      joinedCmd = options.joinedCmd;
  var timedOut = options.timedOut || false;

  if (!err) {
    var output = '';

    if (Array.isArray(parsed.opts.stdio)) {
      if (parsed.opts.stdio[2] !== 'inherit') {
        output += output.length > 0 ? stderr : "\n".concat(stderr);
      }

      if (parsed.opts.stdio[1] !== 'inherit') {
        output += "\n".concat(stdout);
      }
    } else if (parsed.opts.stdio !== 'inherit') {
      output = "\n".concat(stderr).concat(stdout);
    }

    err = new Error("Command failed: ".concat(joinedCmd).concat(output));
    err.code = code < 0 ? errname(code) : code;
  }

  err.stdout = stdout;
  err.stderr = stderr;
  err.failed = true;
  err.signal = signal || null;
  err.cmd = joinedCmd;
  err.timedOut = timedOut;
  return err;
}

function joinCmd(cmd, args) {
  var joinedCmd = cmd;

  if (Array.isArray(args) && args.length > 0) {
    joinedCmd += ' ' + args.join(' ');
  }

  return joinedCmd;
}

module.exports = function (cmd, args, opts) {
  var parsed = handleArgs(cmd, args, opts);
  var _parsed$opts = parsed.opts,
      encoding = _parsed$opts.encoding,
      buffer = _parsed$opts.buffer,
      maxBuffer = _parsed$opts.maxBuffer;
  var joinedCmd = joinCmd(cmd, args);
  var spawned;

  try {
    spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
  } catch (err) {
    return Promise.reject(err);
  }

  var removeExitHandler;

  if (parsed.opts.cleanup) {
    removeExitHandler = onExit(function () {
      spawned.kill();
    });
  }

  var timeoutId = null;
  var timedOut = false;

  var cleanup = function cleanup() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }

    if (removeExitHandler) {
      removeExitHandler();
    }
  };

  if (parsed.opts.timeout > 0) {
    timeoutId = setTimeout(function () {
      timeoutId = null;
      timedOut = true;
      spawned.kill(parsed.opts.killSignal);
    }, parsed.opts.timeout);
  }

  var processDone = new Promise(function (resolve) {
    spawned.on('exit', function (code, signal) {
      cleanup();
      resolve({
        code: code,
        signal: signal
      });
    });
    spawned.on('error', function (err) {
      cleanup();
      resolve({
        error: err
      });
    });

    if (spawned.stdin) {
      spawned.stdin.on('error', function (err) {
        cleanup();
        resolve({
          error: err
        });
      });
    }
  });

  function destroy() {
    if (spawned.stdout) {
      spawned.stdout.destroy();
    }

    if (spawned.stderr) {
      spawned.stderr.destroy();
    }
  }

  var handlePromise = function handlePromise() {
    return pFinally(Promise.all([processDone, getStream(spawned, 'stdout', {
      encoding: encoding,
      buffer: buffer,
      maxBuffer: maxBuffer
    }), getStream(spawned, 'stderr', {
      encoding: encoding,
      buffer: buffer,
      maxBuffer: maxBuffer
    })]).then(function (arr) {
      var result = arr[0];
      result.stdout = arr[1];
      result.stderr = arr[2];

      if (result.error || result.code !== 0 || result.signal !== null) {
        var err = makeError(result, {
          joinedCmd: joinedCmd,
          parsed: parsed,
          timedOut: timedOut
        }); // TODO: missing some timeout logic for killed
        // https://github.com/nodejs/node/blob/master/lib/child_process.js#L203
        // err.killed = spawned.killed || killed;

        err.killed = err.killed || spawned.killed;

        if (!parsed.opts.reject) {
          return err;
        }

        throw err;
      }

      return {
        stdout: handleOutput(parsed.opts, result.stdout),
        stderr: handleOutput(parsed.opts, result.stderr),
        code: 0,
        failed: false,
        killed: false,
        signal: null,
        cmd: joinedCmd,
        timedOut: false
      };
    }), destroy);
  };

  crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);

  handleInput(spawned, parsed.opts.input);

  spawned.then = function (onfulfilled, onrejected) {
    return handlePromise().then(onfulfilled, onrejected);
  };

  spawned["catch"] = function (onrejected) {
    return handlePromise()["catch"](onrejected);
  };

  return spawned;
}; // TODO: set `stderr: 'ignore'` when that option is implemented


module.exports.stdout = function () {
  var _module;

  return (_module = module).exports.apply(_module, arguments).then(function (x) {
    return x.stdout;
  });
}; // TODO: set `stdout: 'ignore'` when that option is implemented


module.exports.stderr = function () {
  var _module2;

  return (_module2 = module).exports.apply(_module2, arguments).then(function (x) {
    return x.stderr;
  });
};

module.exports.shell = function (cmd, opts) {
  return handleShell(module.exports, cmd, opts);
};

module.exports.sync = function (cmd, args, opts) {
  var parsed = handleArgs(cmd, args, opts);
  var joinedCmd = joinCmd(cmd, args);

  if (isStream(parsed.opts.input)) {
    throw new TypeError('The `input` option cannot be a stream in sync mode');
  }

  var result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
  result.code = result.status;

  if (result.error || result.status !== 0 || result.signal !== null) {
    var err = makeError(result, {
      joinedCmd: joinedCmd,
      parsed: parsed
    });

    if (!parsed.opts.reject) {
      return err;
    }

    throw err;
  }

  return {
    stdout: handleOutput(parsed.opts, result.stdout),
    stderr: handleOutput(parsed.opts, result.stderr),
    code: 0,
    failed: false,
    signal: null,
    cmd: joinedCmd,
    timedOut: false
  };
};

module.exports.shellSync = function (cmd, opts) {
  return handleShell(module.exports.sync, cmd, opts);
};