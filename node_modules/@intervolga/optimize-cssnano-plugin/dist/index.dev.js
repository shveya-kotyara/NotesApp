"use strict";

var cssnano = require('cssnano');

var postcss = require('postcss');
/**
 * Optimize cssnano plugin
 *
 * @param {Object} options
 */


function OptimizeCssnanoPlugin(options) {
  this.options = Object.assign({
    sourceMap: false,
    cssnanoOptions: {
      preset: 'default'
    }
  }, options);

  if (this.options.sourceMap) {
    this.options.sourceMap = Object.assign({
      inline: false
    }, this.options.sourceMap || {});
  }
}

OptimizeCssnanoPlugin.prototype.apply = function (compiler) {
  var self = this;
  compiler.hooks.emit.tapAsync('OptimizeCssnanoPlugin', function (compilation, callback) {
    // Search for CSS assets
    var assetsNames = Object.keys(compilation.assets).filter(function (assetName) {
      return /\.css$/i.test(assetName);
    });
    var hasErrors = false;
    var promises = []; // Generate promises for each minification

    assetsNames.forEach(function (assetName) {
      // Original CSS
      var asset = compilation.assets[assetName];
      var originalCss = asset.source(); // Options for particalar cssnano call

      var postCssOptions = {
        from: assetName,
        to: assetName,
        map: false
      };
      var cssnanoOptions = self.options.cssnanoOptions; // Extract or remove previous map

      var mapName = assetName + '.map';

      if (self.options.sourceMap) {
        // Use previous map if exist...
        if (compilation.assets[mapName]) {
          var mapObject = JSON.parse(compilation.assets[mapName].source()); // ... and not empty

          if (mapObject.sources.length > 0 || mapObject.mappings.length > 0) {
            postCssOptions.map = Object.assign({
              prev: compilation.assets[mapName].source()
            }, self.options.sourceMap);
          } else {
            postCssOptions.map = Object.assign({}, self.options.sourceMap);
          }
        }
      } else {
        delete compilation.assets[mapName];
      } // Run minification


      var promise = postcss([cssnano(cssnanoOptions)]).process(originalCss, postCssOptions).then(function (result) {
        if (hasErrors) {
          return;
        } // Extract CSS back to assets


        var processedCss = result.css;
        compilation.assets[assetName] = {
          source: function source() {
            return processedCss;
          },
          size: function size() {
            return processedCss.length;
          }
        }; // Extract map back to assets

        if (result.map) {
          var processedMap = result.map.toString();
          compilation.assets[mapName] = {
            source: function source() {
              return processedMap;
            },
            size: function size() {
              return processedMap.length;
            }
          };
        }
      })["catch"](function (err) {
        hasErrors = true;
        throw new Error('CSS minification error: ' + err.message + '. File: ' + assetName);
      });
      promises.push(promise);
    });
    Promise.all(promises).then(function () {
      callback();
    })["catch"](callback);
  });
};

module.exports = OptimizeCssnanoPlugin;