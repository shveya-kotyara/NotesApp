"use strict";

var path = require("path");

var _require = require("ts-pnp"),
    resolveModuleName = _require.resolveModuleName;

function nothing() {// ¯\_(ツ)_/¯
}

function getModuleLocator(module) {
  var pnp = require("pnpapi");

  var moduleLocation = typeof module === "string" ? module : module.filename;
  if (!moduleLocation) throw new Error("The specified module doesn't seem to exist on the filesystem");
  var moduleLocator = pnp.findPackageLocator(moduleLocation);
  if (!moduleLocator) throw new Error("the specified module doesn't seem to be part of the dependency tree");
  return moduleLocator;
}

function getDependencyLocator(sourceLocator, name) {
  var pnp = require("pnpapi");

  var _pnp$getPackageInform = pnp.getPackageInformation(sourceLocator),
      packageDependencies = _pnp$getPackageInform.packageDependencies;

  var reference = packageDependencies.get(name);
  return {
    name: name,
    reference: reference
  };
}

function getSourceLocation(sourceLocator) {
  if (!sourceLocator) return null;

  var pnp = require("pnpapi");

  var sourceInformation = pnp.getPackageInformation(sourceLocator);
  if (!sourceInformation) throw new Error("Couldn't find the package to use as resolution source");
  if (!sourceInformation.packageLocation) throw new Error("The package to use as resolution source seem to not have been installed - maybe it's a devDependency not installed in prod?");
  return sourceInformation.packageLocation.replace(/\/?$/, "/");
}

function makeResolver(sourceLocator, filter) {
  var sourceLocation = getSourceLocation(sourceLocator);
  return function (resolver) {
    var BACKWARD_PATH = /^\.\.([\\\/]|$)/;
    var resolvedHook = resolver.ensureHook("resolve"); // Prevents the SymlinkPlugin from kicking in. We need the symlinks to be preserved because that's how we deal with peer dependencies ambiguities.

    resolver.getHook("file").intercept({
      register: function register(tapInfo) {
        return tapInfo.name !== "SymlinkPlugin" ? tapInfo : Object.assign({}, tapInfo, {
          fn: function fn(request, resolveContext, callback) {
            callback();
          }
        });
      }
    });
    resolver.getHook("after-module").tapAsync("PnpResolver", function (request, resolveContext, callback) {
      // rethrow pnp errors if we have any for this request
      return callback(resolveContext.pnpErrors && resolveContext.pnpErrors.get(request.context.issuer));
    }); // Register a plugin that will resolve bare imports into the package location on the filesystem before leaving the rest of the resolution to Webpack

    resolver.getHook("before-module").tapAsync("PnpResolver", function (requestContext, resolveContext, callback) {
      var pnp = require("pnpapi");

      var request = requestContext.request;
      var issuer = requestContext.context.issuer; // When using require.context, issuer seems to be false (cf https://github.com/webpack/webpack-dev-server/blob/d0725c98fb752d8c0b1e8c9067e526e22b5f5134/client-src/default/index.js#L94)

      if (!issuer) {
        issuer = "".concat(requestContext.path, "/"); // We only support issuer when they're absolute paths. I'm not sure the opposite can ever happen, but better check here.
      } else if (!path.isAbsolute(issuer)) {
        throw new Error("Cannot successfully resolve this dependency - issuer not supported (".concat(issuer, ")"));
      }

      if (filter) {
        var relative = path.relative(filter, issuer);

        if (path.isAbsolute(relative) || BACKWARD_PATH.test(relative)) {
          return callback(null);
        }
      }

      var resolutionIssuer = sourceLocation || issuer;
      var resolution;

      try {
        resolution = pnp.resolveToUnqualified(request, resolutionIssuer, {
          considerBuiltins: false
        });
      } catch (error) {
        if (resolveContext.missingDependencies) resolveContext.missingDependencies.add(requestContext.path);
        if (resolveContext.log) resolveContext.log(error.message);
        resolveContext.pnpErrors = resolveContext.pnpErrors || new Map();
        resolveContext.pnpErrors.set(issuer, error);
        return callback();
      }

      resolver.doResolve(resolvedHook, Object.assign({}, requestContext, {
        request: resolution
      }), null, resolveContext, callback);
    });
  };
}

module.exports = process.versions.pnp ? {
  apply: makeResolver(null)
} : {
  apply: nothing
};

module.exports.makePlugin = function (locator, filter) {
  return process.versions.pnp ? {
    apply: makeResolver(locator, filter)
  } : {
    apply: nothing
  };
};

module.exports.moduleLoader = function (module) {
  return process.versions.pnp ? {
    apply: makeResolver(getModuleLocator(module))
  } : {
    apply: nothing
  };
};

module.exports.topLevelLoader = process.versions.pnp ? {
  apply: makeResolver({
    name: null,
    reference: null
  })
} : {
  apply: nothing
};

module.exports.bind = function (filter, module, dependency) {
  return process.versions.pnp ? {
    apply: makeResolver(dependency ? getDependencyLocator(getModuleLocator(module), dependency) : getModuleLocator(module), filter)
  } : {
    apply: nothing
  };
};

module.exports.tsLoaderOptions = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return process.versions.pnp ? Object.assign({}, options, {
    resolveModuleName: resolveModuleName,
    resolveTypeReferenceDirective: resolveModuleName
  }) : options;
};

module.exports.forkTsCheckerOptions = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return process.versions.pnp ? Object.assign({}, options, {
    resolveModuleNameModule: require.resolve("./ts"),
    resolveTypeReferenceDirectiveModule: require.resolve("./ts")
  }) : options;
};