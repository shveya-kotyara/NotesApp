'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var postcss = require('postcss');

var ICSSUtils = require('icss-utils');

var matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
var matchValueDefinition = /(?:\s+|^)([\w-]+):?\s+(.+?)\s*$/g;
var matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
var options = {};
var importIndex = 0;

var createImportedName = options && options.createImportedName || function (importName
/*, path*/
) {
  return "i__const_".concat(importName.replace(/\W/g, '_'), "_").concat(importIndex++);
};

module.exports = postcss.plugin('postcss-modules-values', function () {
  return function (css, result) {
    var importAliases = [];
    var definitions = {};

    var addDefinition = function addDefinition(atRule) {
      var matches;

      while (matches = matchValueDefinition.exec(atRule.params)) {
        var _matches = matches,
            _matches2 = _slicedToArray(_matches, 3),

        /*match*/
        key = _matches2[1],
            value = _matches2[2]; // Add to the definitions, knowing that values can refer to each other


        definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);
        atRule.remove();
      }
    };

    var addImport = function addImport(atRule) {
      var matches = matchImports.exec(atRule.params);

      if (matches) {
        var _matches3 = _slicedToArray(matches, 3),

        /*match*/
        aliases = _matches3[1],
            path = _matches3[2]; // We can use constants for path names


        if (definitions[path]) {
          path = definitions[path];
        }

        var imports = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, '$1').split(/\s*,\s*/).map(function (alias) {
          var tokens = matchImport.exec(alias);

          if (tokens) {
            var _tokens = _slicedToArray(tokens, 3),

            /*match*/
            theirName = _tokens[1],
                _tokens$ = _tokens[2],
                myName = _tokens$ === void 0 ? theirName : _tokens$;

            var importedName = createImportedName(myName);
            definitions[myName] = importedName;
            return {
              theirName: theirName,
              importedName: importedName
            };
          } else {
            throw new Error("@import statement \"".concat(alias, "\" is invalid!"));
          }
        });
        importAliases.push({
          path: path,
          imports: imports
        });
        atRule.remove();
      }
    };
    /* Look at all the @value statements and treat them as locals or as imports */


    css.walkAtRules('value', function (atRule) {
      if (matchImports.exec(atRule.params)) {
        addImport(atRule);
      } else {
        if (atRule.params.indexOf('@value') !== -1) {
          result.warn('Invalid value definition: ' + atRule.params);
        }

        addDefinition(atRule);
      }
    });
    /* We want to export anything defined by now, but don't add it to the CSS yet or
    it well get picked up by the replacement stuff */

    var exportDeclarations = Object.keys(definitions).map(function (key) {
      return postcss.decl({
        value: definitions[key],
        prop: key,
        raws: {
          before: '\n  '
        }
      });
    });
    /* If we have no definitions, don't continue */

    if (!Object.keys(definitions).length) {
      return;
    }
    /* Perform replacements */


    ICSSUtils.replaceSymbols(css, definitions);
    /* Add export rules if any */

    if (exportDeclarations.length > 0) {
      var exportRule = postcss.rule({
        selector: ':export',
        raws: {
          after: '\n'
        }
      });
      exportRule.append(exportDeclarations);
      css.prepend(exportRule);
    }
    /* Add import rules */


    importAliases.reverse().forEach(function (_ref) {
      var path = _ref.path,
          imports = _ref.imports;
      var importRule = postcss.rule({
        selector: ":import(".concat(path, ")"),
        raws: {
          after: '\n'
        }
      });
      imports.forEach(function (_ref2) {
        var theirName = _ref2.theirName,
            importedName = _ref2.importedName;
        importRule.append({
          value: theirName,
          prop: importedName,
          raws: {
            before: '\n  '
          }
        });
      });
      css.prepend(importRule);
    });
  };
});