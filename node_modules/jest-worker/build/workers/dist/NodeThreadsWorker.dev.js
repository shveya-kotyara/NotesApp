'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _stream() {
  var data = require('stream');

  _stream = function _stream() {
    return data;
  };

  return data;
}

function _worker_threads() {
  var data = require('worker_threads');

  _worker_threads = function _worker_threads() {
    return data;
  };

  return data;
}

function _mergeStream() {
  var data = _interopRequireDefault(require('merge-stream'));

  _mergeStream = function _mergeStream() {
    return data;
  };

  return data;
}

function _types() {
  var data = require('../types');

  _types = function _types() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var ExperimentalWorker =
/*#__PURE__*/
function () {
  function ExperimentalWorker(options) {
    var _this = this;

    _classCallCheck(this, ExperimentalWorker);

    _defineProperty(this, '_worker', void 0);

    _defineProperty(this, '_options', void 0);

    _defineProperty(this, '_request', void 0);

    _defineProperty(this, '_retries', void 0);

    _defineProperty(this, '_onProcessEnd', void 0);

    _defineProperty(this, '_fakeStream', void 0);

    _defineProperty(this, '_stdout', void 0);

    _defineProperty(this, '_stderr', void 0);

    _defineProperty(this, '_exitPromise', void 0);

    _defineProperty(this, '_resolveExitPromise', void 0);

    _defineProperty(this, '_forceExited', void 0);

    this._options = options;
    this._request = null;
    this._fakeStream = null;
    this._stdout = null;
    this._stderr = null;
    this._exitPromise = new Promise(function (resolve) {
      _this._resolveExitPromise = resolve;
    });
    this._forceExited = false;
    this.initialize();
  }

  _createClass(ExperimentalWorker, [{
    key: "initialize",
    value: function initialize() {
      this._worker = new (_worker_threads().Worker)(path().resolve(__dirname, './threadChild.js'), {
        eval: false,
        stderr: true,
        stdout: true,
        workerData: _objectSpread({
          cwd: process.cwd(),
          env: _objectSpread({}, process.env, {
            JEST_WORKER_ID: String(this._options.workerId + 1) // 0-indexed workerId, 1-indexed JEST_WORKER_ID

          }),
          // Suppress --debug / --inspect flags while preserving others (like --harmony).
          execArgv: process.execArgv.filter(function (v) {
            return !/^--(debug|inspect)/.test(v);
          }),
          silent: true
        }, this._options.forkOptions)
      });

      if (this._worker.stdout) {
        if (!this._stdout) {
          // We need to add a permanent stream to the merged stream to prevent it
          // from ending when the subprocess stream ends
          this._stdout = (0, _mergeStream()["default"])(this._getFakeStream());
        }

        this._stdout.add(this._worker.stdout);
      }

      if (this._worker.stderr) {
        if (!this._stderr) {
          // We need to add a permanent stream to the merged stream to prevent it
          // from ending when the subprocess stream ends
          this._stderr = (0, _mergeStream()["default"])(this._getFakeStream());
        }

        this._stderr.add(this._worker.stderr);
      }

      this._worker.on('message', this._onMessage.bind(this));

      this._worker.on('exit', this._onExit.bind(this));

      this._worker.postMessage([_types().CHILD_MESSAGE_INITIALIZE, false, this._options.workerPath, this._options.setupArgs]);

      this._retries++; // If we exceeded the amount of retries, we will emulate an error reply
      // coming from the child. This avoids code duplication related with cleaning
      // the queue, and scheduling the next call.

      if (this._retries > this._options.maxRetries) {
        var error = new Error('Call retries were exceeded');

        this._onMessage([_types().PARENT_MESSAGE_CLIENT_ERROR, error.name, error.message, error.stack, {
          type: 'WorkerError'
        }]);
      }
    }
  }, {
    key: "_shutdown",
    value: function _shutdown() {
      // End the permanent stream so the merged stream end too
      if (this._fakeStream) {
        this._fakeStream.end();

        this._fakeStream = null;
      }

      this._resolveExitPromise();
    }
  }, {
    key: "_onMessage",
    value: function _onMessage(response) {
      var error;

      switch (response[0]) {
        case _types().PARENT_MESSAGE_OK:
          this._onProcessEnd(null, response[1]);

          break;

        case _types().PARENT_MESSAGE_CLIENT_ERROR:
          error = response[4];

          if (error != null && _typeof(error) === 'object') {
            var extra = error; // @ts-ignore: no index

            var NativeCtor = global[response[1]];
            var Ctor = typeof NativeCtor === 'function' ? NativeCtor : Error;
            error = new Ctor(response[2]);
            error.type = response[1];
            error.stack = response[3];

            for (var key in extra) {
              // @ts-ignore: no index
              error[key] = extra[key];
            }
          }

          this._onProcessEnd(error, null);

          break;

        case _types().PARENT_MESSAGE_SETUP_ERROR:
          error = new Error('Error when calling setup: ' + response[2]); // @ts-ignore: adding custom properties to errors.

          error.type = response[1];
          error.stack = response[3];

          this._onProcessEnd(error, null);

          break;

        default:
          throw new TypeError('Unexpected response from worker: ' + response[0]);
      }
    }
  }, {
    key: "_onExit",
    value: function _onExit(exitCode) {
      if (exitCode !== 0 && !this._forceExited) {
        this.initialize();

        if (this._request) {
          this._worker.postMessage(this._request);
        }
      } else {
        this._shutdown();
      }
    }
  }, {
    key: "waitForExit",
    value: function waitForExit() {
      return this._exitPromise;
    }
  }, {
    key: "forceExit",
    value: function forceExit() {
      this._forceExited = true;

      this._worker.terminate();
    }
  }, {
    key: "send",
    value: function send(request, onProcessStart, onProcessEnd) {
      var _this2 = this;

      onProcessStart(this);

      this._onProcessEnd = function () {
        // Clean the request to avoid sending past requests to workers that fail
        // while waiting for a new request (timers, unhandled rejections...)
        _this2._request = null;
        return onProcessEnd.apply(void 0, arguments);
      };

      this._request = request;
      this._retries = 0;

      this._worker.postMessage(request);
    }
  }, {
    key: "getWorkerId",
    value: function getWorkerId() {
      return this._options.workerId;
    }
  }, {
    key: "getStdout",
    value: function getStdout() {
      return this._stdout;
    }
  }, {
    key: "getStderr",
    value: function getStderr() {
      return this._stderr;
    }
  }, {
    key: "_getFakeStream",
    value: function _getFakeStream() {
      if (!this._fakeStream) {
        this._fakeStream = new (_stream().PassThrough)();
      }

      return this._fakeStream;
    }
  }]);

  return ExperimentalWorker;
}();

exports["default"] = ExperimentalWorker;