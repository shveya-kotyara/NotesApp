'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _child_process() {
  var data = require('child_process');

  _child_process = function _child_process() {
    return data;
  };

  return data;
}

function _stream() {
  var data = require('stream');

  _stream = function _stream() {
    return data;
  };

  return data;
}

function _mergeStream() {
  var data = _interopRequireDefault(require('merge-stream'));

  _mergeStream = function _mergeStream() {
    return data;
  };

  return data;
}

function _supportsColor() {
  var data = require('supports-color');

  _supportsColor = function _supportsColor() {
    return data;
  };

  return data;
}

function _types() {
  var data = require('../types');

  _types = function _types() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var SIGNAL_BASE_EXIT_CODE = 128;
var SIGKILL_EXIT_CODE = SIGNAL_BASE_EXIT_CODE + 9;
var SIGTERM_EXIT_CODE = SIGNAL_BASE_EXIT_CODE + 15; // How long to wait after SIGTERM before sending SIGKILL

var SIGKILL_DELAY = 500;
/**
 * This class wraps the child process and provides a nice interface to
 * communicate with. It takes care of:
 *
 *  - Re-spawning the process if it dies.
 *  - Queues calls while the worker is busy.
 *  - Re-sends the requests if the worker blew up.
 *
 * The reason for queueing them here (since childProcess.send also has an
 * internal queue) is because the worker could be doing asynchronous work, and
 * this would lead to the child process to read its receiving buffer and start a
 * second call. By queueing calls here, we don't send the next call to the
 * children until we receive the result of the previous one.
 *
 * As soon as a request starts to be processed by a worker, its "processed"
 * field is changed to "true", so that other workers which might encounter the
 * same call skip it.
 */

var ChildProcessWorker =
/*#__PURE__*/
function () {
  function ChildProcessWorker(options) {
    var _this = this;

    _classCallCheck(this, ChildProcessWorker);

    _defineProperty(this, '_child', void 0);

    _defineProperty(this, '_options', void 0);

    _defineProperty(this, '_request', void 0);

    _defineProperty(this, '_retries', void 0);

    _defineProperty(this, '_onProcessEnd', void 0);

    _defineProperty(this, '_fakeStream', void 0);

    _defineProperty(this, '_stdout', void 0);

    _defineProperty(this, '_stderr', void 0);

    _defineProperty(this, '_exitPromise', void 0);

    _defineProperty(this, '_resolveExitPromise', void 0);

    this._options = options;
    this._request = null;
    this._fakeStream = null;
    this._stdout = null;
    this._stderr = null;
    this._exitPromise = new Promise(function (resolve) {
      _this._resolveExitPromise = resolve;
    });
    this.initialize();
  }

  _createClass(ChildProcessWorker, [{
    key: "initialize",
    value: function initialize() {
      var forceColor = _supportsColor().stdout ? {
        FORCE_COLOR: '1'
      } : {};
      var child = (0, _child_process().fork)(require.resolve('./processChild'), [], _objectSpread({
        cwd: process.cwd(),
        env: _objectSpread({}, process.env, {
          JEST_WORKER_ID: String(this._options.workerId + 1)
        }, forceColor),
        // Suppress --debug / --inspect flags while preserving others (like --harmony).
        execArgv: process.execArgv.filter(function (v) {
          return !/^--(debug|inspect)/.test(v);
        }),
        silent: true
      }, this._options.forkOptions));

      if (child.stdout) {
        if (!this._stdout) {
          // We need to add a permanent stream to the merged stream to prevent it
          // from ending when the subprocess stream ends
          this._stdout = (0, _mergeStream()["default"])(this._getFakeStream());
        }

        this._stdout.add(child.stdout);
      }

      if (child.stderr) {
        if (!this._stderr) {
          // We need to add a permanent stream to the merged stream to prevent it
          // from ending when the subprocess stream ends
          this._stderr = (0, _mergeStream()["default"])(this._getFakeStream());
        }

        this._stderr.add(child.stderr);
      }

      child.on('message', this._onMessage.bind(this));
      child.on('exit', this._onExit.bind(this));
      child.send([_types().CHILD_MESSAGE_INITIALIZE, false, this._options.workerPath, this._options.setupArgs]);
      this._child = child;
      this._retries++; // If we exceeded the amount of retries, we will emulate an error reply
      // coming from the child. This avoids code duplication related with cleaning
      // the queue, and scheduling the next call.

      if (this._retries > this._options.maxRetries) {
        var error = new Error('Call retries were exceeded');

        this._onMessage([_types().PARENT_MESSAGE_CLIENT_ERROR, error.name, error.message, error.stack, {
          type: 'WorkerError'
        }]);
      }
    }
  }, {
    key: "_shutdown",
    value: function _shutdown() {
      // End the temporary streams so the merged streams end too
      if (this._fakeStream) {
        this._fakeStream.end();

        this._fakeStream = null;
      }

      this._resolveExitPromise();
    }
  }, {
    key: "_onMessage",
    value: function _onMessage(response) {
      var error;

      switch (response[0]) {
        case _types().PARENT_MESSAGE_OK:
          this._onProcessEnd(null, response[1]);

          break;

        case _types().PARENT_MESSAGE_CLIENT_ERROR:
          error = response[4];

          if (error != null && _typeof(error) === 'object') {
            var extra = error; // @ts-ignore: no index

            var NativeCtor = global[response[1]];
            var Ctor = typeof NativeCtor === 'function' ? NativeCtor : Error;
            error = new Ctor(response[2]);
            error.type = response[1];
            error.stack = response[3];

            for (var key in extra) {
              // @ts-ignore: adding custom properties to errors.
              error[key] = extra[key];
            }
          }

          this._onProcessEnd(error, null);

          break;

        case _types().PARENT_MESSAGE_SETUP_ERROR:
          error = new Error('Error when calling setup: ' + response[2]); // @ts-ignore: adding custom properties to errors.

          error.type = response[1];
          error.stack = response[3];

          this._onProcessEnd(error, null);

          break;

        default:
          throw new TypeError('Unexpected response from worker: ' + response[0]);
      }
    }
  }, {
    key: "_onExit",
    value: function _onExit(exitCode) {
      if (exitCode !== 0 && exitCode !== SIGTERM_EXIT_CODE && exitCode !== SIGKILL_EXIT_CODE) {
        this.initialize();

        if (this._request) {
          this._child.send(this._request);
        }
      } else {
        this._shutdown();
      }
    }
  }, {
    key: "send",
    value: function send(request, onProcessStart, onProcessEnd) {
      var _this2 = this;

      onProcessStart(this);

      this._onProcessEnd = function () {
        // Clean the request to avoid sending past requests to workers that fail
        // while waiting for a new request (timers, unhandled rejections...)
        _this2._request = null;
        return onProcessEnd.apply(void 0, arguments);
      };

      this._request = request;
      this._retries = 0;

      this._child.send(request);
    }
  }, {
    key: "waitForExit",
    value: function waitForExit() {
      return this._exitPromise;
    }
  }, {
    key: "forceExit",
    value: function forceExit() {
      var _this3 = this;

      this._child.kill('SIGTERM');

      var sigkillTimeout = setTimeout(function () {
        return _this3._child.kill('SIGKILL');
      }, SIGKILL_DELAY);

      this._exitPromise.then(function () {
        return clearTimeout(sigkillTimeout);
      });
    }
  }, {
    key: "getWorkerId",
    value: function getWorkerId() {
      return this._options.workerId;
    }
  }, {
    key: "getStdout",
    value: function getStdout() {
      return this._stdout;
    }
  }, {
    key: "getStderr",
    value: function getStderr() {
      return this._stderr;
    }
  }, {
    key: "_getFakeStream",
    value: function _getFakeStream() {
      if (!this._fakeStream) {
        this._fakeStream = new (_stream().PassThrough)();
      }

      return this._fakeStream;
    }
  }]);

  return ChildProcessWorker;
}();

exports["default"] = ChildProcessWorker;