'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _os() {
  var data = require('os');

  _os = function _os() {
    return data;
  };

  return data;
}

var _WorkerPool = _interopRequireDefault(require('./WorkerPool'));

var _Farm = _interopRequireDefault(require('./Farm'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function getExposedMethods(workerPath, options) {
  var exposedMethods = options.exposedMethods; // If no methods list is given, try getting it by auto-requiring the module.

  if (!exposedMethods) {
    var module = require(workerPath);

    exposedMethods = Object.keys(module).filter( // @ts-ignore: no index
    function (name) {
      return typeof module[name] === 'function';
    });

    if (typeof module === 'function') {
      exposedMethods = [].concat(_toConsumableArray(exposedMethods), ['default']);
    }
  }

  return exposedMethods;
}
/**
 * The Jest farm (publicly called "Worker") is a class that allows you to queue
 * methods across multiple child processes, in order to parallelize work. This
 * is done by providing an absolute path to a module that will be loaded on each
 * of the child processes, and bridged to the main process.
 *
 * Bridged methods are specified by using the "exposedMethods" property of the
 * "options" object. This is an array of strings, where each of them corresponds
 * to the exported name in the loaded module.
 *
 * You can also control the amount of workers by using the "numWorkers" property
 * of the "options" object, and the settings passed to fork the process through
 * the "forkOptions" property. The amount of workers defaults to the amount of
 * CPUS minus one.
 *
 * Queueing calls can be done in two ways:
 *   - Standard method: calls will be redirected to the first available worker,
 *     so they will get executed as soon as they can.
 *
 *   - Sticky method: if a "computeWorkerKey" method is provided within the
 *     config, the resulting string of this method will be used as a key.
 *     Every time this key is returned, it is guaranteed that your job will be
 *     processed by the same worker. This is specially useful if your workers
 *     are caching results.
 */


var JestWorker =
/*#__PURE__*/
function () {
  function JestWorker(workerPath, options) {
    _classCallCheck(this, JestWorker);

    _defineProperty(this, '_ending', void 0);

    _defineProperty(this, '_farm', void 0);

    _defineProperty(this, '_options', void 0);

    _defineProperty(this, '_workerPool', void 0);

    this._options = _objectSpread({}, options);
    this._ending = false;
    var workerPoolOptions = {
      enableWorkerThreads: this._options.enableWorkerThreads || false,
      forkOptions: this._options.forkOptions || {},
      maxRetries: this._options.maxRetries || 3,
      numWorkers: this._options.numWorkers || Math.max((0, _os().cpus)().length - 1, 1),
      setupArgs: this._options.setupArgs || []
    };

    if (this._options.WorkerPool) {
      // @ts-ignore: constructor target any?
      this._workerPool = new this._options.WorkerPool(workerPath, workerPoolOptions);
    } else {
      this._workerPool = new _WorkerPool["default"](workerPath, workerPoolOptions);
    }

    this._farm = new _Farm["default"](workerPoolOptions.numWorkers, this._workerPool.send.bind(this._workerPool), this._options.computeWorkerKey);

    this._bindExposedWorkerMethods(workerPath, this._options);
  }

  _createClass(JestWorker, [{
    key: "_bindExposedWorkerMethods",
    value: function _bindExposedWorkerMethods(workerPath, options) {
      var _this = this;

      getExposedMethods(workerPath, options).forEach(function (name) {
        if (name.startsWith('_')) {
          return;
        }

        if (_this.constructor.prototype.hasOwnProperty(name)) {
          throw new TypeError('Cannot define a method called ' + name);
        } // @ts-ignore: dynamic extension of the class instance is expected.


        _this[name] = _this._callFunctionWithArgs.bind(_this, name);
      });
    }
  }, {
    key: "_callFunctionWithArgs",
    value: function _callFunctionWithArgs(method) {
      var _this$_farm;

      if (this._ending) {
        throw new Error('Farm is ended, no more calls can be done to it');
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_this$_farm = this._farm).doWork.apply(_this$_farm, [method].concat(args));
    }
  }, {
    key: "getStderr",
    value: function getStderr() {
      return this._workerPool.getStderr();
    }
  }, {
    key: "getStdout",
    value: function getStdout() {
      return this._workerPool.getStdout();
    }
  }, {
    key: "end",
    value: function end() {
      return regeneratorRuntime.async(function end$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this._ending) {
                _context.next = 2;
                break;
              }

              throw new Error('Farm is ended, no more calls can be done to it');

            case 2:
              this._ending = true;
              return _context.abrupt("return", this._workerPool.end());

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }]);

  return JestWorker;
}();

exports["default"] = JestWorker;