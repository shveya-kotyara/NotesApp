'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _mergeStream() {
  var data = _interopRequireDefault(require('merge-stream'));

  _mergeStream = function _mergeStream() {
    return data;
  };

  return data;
}

function _types() {
  var data = require('../types');

  _types = function _types() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // How long to wait for the child process to terminate
// after CHILD_MESSAGE_END before sending force exiting.


var FORCE_EXIT_DELAY = 500;
/* istanbul ignore next */

var emptyMethod = function emptyMethod() {};

var BaseWorkerPool =
/*#__PURE__*/
function () {
  function BaseWorkerPool(workerPath, options) {
    _classCallCheck(this, BaseWorkerPool);

    _defineProperty(this, '_stderr', void 0);

    _defineProperty(this, '_stdout', void 0);

    _defineProperty(this, '_options', void 0);

    _defineProperty(this, '_workers', void 0);

    this._options = options;
    this._workers = new Array(options.numWorkers);

    if (!path().isAbsolute(workerPath)) {
      workerPath = require.resolve(workerPath);
    }

    var stdout = (0, _mergeStream()["default"])();
    var stderr = (0, _mergeStream()["default"])();
    var forkOptions = options.forkOptions,
        maxRetries = options.maxRetries,
        setupArgs = options.setupArgs;

    for (var i = 0; i < options.numWorkers; i++) {
      var workerOptions = {
        forkOptions: forkOptions,
        maxRetries: maxRetries,
        setupArgs: setupArgs,
        workerId: i,
        workerPath: workerPath
      };
      var worker = this.createWorker(workerOptions);
      var workerStdout = worker.getStdout();
      var workerStderr = worker.getStderr();

      if (workerStdout) {
        stdout.add(workerStdout);
      }

      if (workerStderr) {
        stderr.add(workerStderr);
      }

      this._workers[i] = worker;
    }

    this._stdout = stdout;
    this._stderr = stderr;
  }

  _createClass(BaseWorkerPool, [{
    key: "getStderr",
    value: function getStderr() {
      return this._stderr;
    }
  }, {
    key: "getStdout",
    value: function getStdout() {
      return this._stdout;
    }
  }, {
    key: "getWorkers",
    value: function getWorkers() {
      return this._workers;
    }
  }, {
    key: "getWorkerById",
    value: function getWorkerById(workerId) {
      return this._workers[workerId];
    }
  }, {
    key: "createWorker",
    value: function createWorker(_workerOptions) {
      throw Error('Missing method createWorker in WorkerPool');
    }
  }, {
    key: "end",
    value: function end() {
      var workerExitPromises, workerExits;
      return regeneratorRuntime.async(function end$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // We do not cache the request object here. If so, it would only be only
              // processed by one of the workers, and we want them all to close.
              workerExitPromises = this._workers.map(function _callee(worker) {
                var forceExited, forceExitTimeout;
                return regeneratorRuntime.async(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        worker.send([_types().CHILD_MESSAGE_END, false], emptyMethod, emptyMethod); // Schedule a force exit in case worker fails to exit gracefully so
                        // await worker.waitForExit() never takes longer than FORCE_EXIT_DELAY

                        forceExited = false;
                        forceExitTimeout = setTimeout(function () {
                          worker.forceExit();
                          forceExited = true;
                        }, FORCE_EXIT_DELAY);
                        _context.next = 5;
                        return regeneratorRuntime.awrap(worker.waitForExit());

                      case 5:
                        // Worker ideally exited gracefully, don't send force exit then
                        clearTimeout(forceExitTimeout);
                        return _context.abrupt("return", forceExited);

                      case 7:
                      case "end":
                        return _context.stop();
                    }
                  }
                });
              });
              _context2.next = 3;
              return regeneratorRuntime.awrap(Promise.all(workerExitPromises));

            case 3:
              workerExits = _context2.sent;
              return _context2.abrupt("return", workerExits.reduce(function (result, forceExited) {
                return {
                  forceExited: result.forceExited || forceExited
                };
              }, {
                forceExited: false
              }));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }]);

  return BaseWorkerPool;
}();

exports["default"] = BaseWorkerPool;