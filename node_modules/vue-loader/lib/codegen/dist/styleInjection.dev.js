"use strict";

var _require = require('./utils'),
    attrsToQuery = _require.attrsToQuery;

var hotReloadAPIPath = JSON.stringify(require.resolve('vue-hot-reload-api'));
var nonWhitespaceRE = /\S+/;

module.exports = function genStyleInjectionCode(loaderContext, styles, id, resourcePath, stringifyRequest, needsHotReload, needsExplicitInjection) {
  var styleImportsCode = "";
  var styleInjectionCode = "";
  var cssModulesHotReloadCode = "";
  var hasCSSModules = false;
  var cssModuleNames = new Map();

  function genStyleRequest(style, i) {
    var src = style.src || resourcePath;
    var attrsQuery = attrsToQuery(style.attrs, 'css');
    var inheritQuery = "&".concat(loaderContext.resourceQuery.slice(1)); // make sure to only pass id when necessary so that we don't inject
    // duplicate tags when multiple components import the same css file

    var idQuery = style.scoped ? "&id=".concat(id) : "";
    var query = "?vue&type=style&index=".concat(i).concat(idQuery).concat(attrsQuery).concat(inheritQuery);
    return stringifyRequest(src + query);
  }

  function genCSSModulesCode(style, request, i) {
    hasCSSModules = true;
    var moduleName = style.module === true ? '$style' : style.module;

    if (cssModuleNames.has(moduleName)) {
      loaderContext.emitError("CSS module name ".concat(moduleName, " is not unique!"));
    }

    cssModuleNames.set(moduleName, true); // `(vue-)style-loader` exports the name-to-hash map directly
    // `css-loader` exports it in `.locals`

    var locals = "(style".concat(i, ".locals || style").concat(i, ")");
    var name = JSON.stringify(moduleName);

    if (!needsHotReload) {
      styleInjectionCode += "this[".concat(name, "] = ").concat(locals, "\n");
    } else {
      styleInjectionCode += "\n        cssModules[".concat(name, "] = ").concat(locals, "\n        Object.defineProperty(this, ").concat(name, ", {\n          configurable: true,\n          get: function () {\n            return cssModules[").concat(name, "]\n          }\n        })\n      ");
      cssModulesHotReloadCode += "\n        module.hot && module.hot.accept([".concat(request, "], function () {\n          var oldLocals = cssModules[").concat(name, "]\n          if (oldLocals) {\n            var newLocals = require(").concat(request, ")\n            if (JSON.stringify(newLocals) !== JSON.stringify(oldLocals)) {\n              cssModules[").concat(name, "] = newLocals\n              require(").concat(hotReloadAPIPath, ").rerender(\"").concat(id, "\")\n            }\n          }\n        })\n      ");
    }
  } // empty styles: with no `src` specified or only contains whitespaces


  var isNotEmptyStyle = function isNotEmptyStyle(style) {
    return style.src || nonWhitespaceRE.test(style.content);
  }; // explicit injection is needed in SSR (for critical CSS collection)
  // or in Shadow Mode (for injection into shadow root)
  // In these modes, vue-style-loader exports objects with the __inject__
  // method; otherwise we simply import the styles.


  if (!needsExplicitInjection) {
    styles.forEach(function (style, i) {
      // do not generate requests for empty styles
      if (isNotEmptyStyle(style)) {
        var request = genStyleRequest(style, i);
        styleImportsCode += "import style".concat(i, " from ").concat(request, "\n");
        if (style.module) genCSSModulesCode(style, request, i);
      }
    });
  } else {
    styles.forEach(function (style, i) {
      if (isNotEmptyStyle(style)) {
        var request = genStyleRequest(style, i);
        styleInjectionCode += "var style".concat(i, " = require(").concat(request, ")\n") + "if (style".concat(i, ".__inject__) style").concat(i, ".__inject__(context)\n");
        if (style.module) genCSSModulesCode(style, request, i);
      }
    });
  }

  if (!needsExplicitInjection && !hasCSSModules) {
    return styleImportsCode;
  }

  return "\n".concat(styleImportsCode, "\n").concat(hasCSSModules && needsHotReload ? "var cssModules = {}" : "", "\n").concat(needsHotReload ? "var disposed = false" : "", "\n\nfunction injectStyles (context) {\n  ").concat(needsHotReload ? "if (disposed) return" : "", "\n  ").concat(styleInjectionCode, "\n}\n\n").concat(needsHotReload ? "\n  module.hot && module.hot.dispose(function (data) {\n    disposed = true\n  })\n" : "", "\n\n").concat(cssModulesHotReloadCode, "\n  ").trim();
};