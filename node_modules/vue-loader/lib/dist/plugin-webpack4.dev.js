"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var qs = require('querystring');

var RuleSet = require('webpack/lib/RuleSet');

var id = 'vue-loader-plugin';
var NS = 'vue-loader';

var VueLoaderPlugin =
/*#__PURE__*/
function () {
  function VueLoaderPlugin() {
    _classCallCheck(this, VueLoaderPlugin);
  }

  _createClass(VueLoaderPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      // add NS marker so that the loader can detect and report missing plugin
      if (compiler.hooks) {
        // webpack 4
        compiler.hooks.compilation.tap(id, function (compilation) {
          var normalModuleLoader = compilation.hooks.normalModuleLoader;
          normalModuleLoader.tap(id, function (loaderContext) {
            loaderContext[NS] = true;
          });
        });
      } else {
        // webpack < 4
        compiler.plugin('compilation', function (compilation) {
          compilation.plugin('normal-module-loader', function (loaderContext) {
            loaderContext[NS] = true;
          });
        });
      } // use webpack's RuleSet utility to normalize user rules


      var rawRules = compiler.options.module.rules;

      var _ref = new RuleSet(rawRules),
          rules = _ref.rules; // find the rule that applies to vue files


      var vueRuleIndex = rawRules.findIndex(createMatcher("foo.vue"));

      if (vueRuleIndex < 0) {
        vueRuleIndex = rawRules.findIndex(createMatcher("foo.vue.html"));
      }

      var vueRule = rules[vueRuleIndex];

      if (!vueRule) {
        throw new Error("[VueLoaderPlugin Error] No matching rule for .vue files found.\n" + "Make sure there is at least one root-level rule that matches .vue or .vue.html files.");
      }

      if (vueRule.oneOf) {
        throw new Error("[VueLoaderPlugin Error] vue-loader 15 currently does not support vue rules with oneOf.");
      } // get the normlized "use" for vue files


      var vueUse = vueRule.use; // get vue-loader options

      var vueLoaderUseIndex = vueUse.findIndex(function (u) {
        return /^vue-loader|(\/|\\|@)vue-loader/.test(u.loader);
      });

      if (vueLoaderUseIndex < 0) {
        throw new Error("[VueLoaderPlugin Error] No matching use for vue-loader is found.\n" + "Make sure the rule matching .vue files include vue-loader in its use.");
      } // make sure vue-loader options has a known ident so that we can share
      // options by reference in the template-loader by using a ref query like
      // template-loader??vue-loader-options


      var vueLoaderUse = vueUse[vueLoaderUseIndex];
      vueLoaderUse.ident = 'vue-loader-options';
      vueLoaderUse.options = vueLoaderUse.options || {}; // for each user rule (expect the vue rule), create a cloned rule
      // that targets the corresponding language blocks in *.vue files.

      var clonedRules = rules.filter(function (r) {
        return r !== vueRule;
      }).map(cloneRule); // global pitcher (responsible for injecting template compiler loader & CSS
      // post loader)

      var pitcher = {
        loader: require.resolve('./loaders/pitcher'),
        resourceQuery: function resourceQuery(query) {
          var parsed = qs.parse(query.slice(1));
          return parsed.vue != null;
        },
        options: {
          cacheDirectory: vueLoaderUse.options.cacheDirectory,
          cacheIdentifier: vueLoaderUse.options.cacheIdentifier
        }
      }; // replace original rules

      compiler.options.module.rules = [pitcher].concat(_toConsumableArray(clonedRules), _toConsumableArray(rules));
    }
  }]);

  return VueLoaderPlugin;
}();

function createMatcher(fakeFile) {
  return function (rule, i) {
    // #1201 we need to skip the `include` check when locating the vue rule
    var clone = Object.assign({}, rule);
    delete clone.include;
    var normalized = RuleSet.normalizeRule(clone, {}, '');
    return !rule.enforce && normalized.resource && normalized.resource(fakeFile);
  };
}

function cloneRule(rule) {
  var resource = rule.resource,
      _resourceQuery = rule.resourceQuery; // Assuming `test` and `resourceQuery` tests are executed in series and
  // synchronously (which is true based on RuleSet's implementation), we can
  // save the current resource being matched from `test` so that we can access
  // it in `resourceQuery`. This ensures when we use the normalized rule's
  // resource check, include/exclude are matched correctly.

  var currentResource;
  var res = Object.assign({}, rule, {
    resource: {
      test: function test(resource) {
        currentResource = resource;
        return true;
      }
    },
    resourceQuery: function resourceQuery(query) {
      var parsed = qs.parse(query.slice(1));

      if (parsed.vue == null) {
        return false;
      }

      if (resource && parsed.lang == null) {
        return false;
      }

      var fakeResourcePath = "".concat(currentResource, ".").concat(parsed.lang);

      if (resource && !resource(fakeResourcePath)) {
        return false;
      }

      if (_resourceQuery && !_resourceQuery(query)) {
        return false;
      }

      return true;
    }
  });

  if (rule.rules) {
    res.rules = rule.rules.map(cloneRule);
  }

  if (rule.oneOf) {
    res.oneOf = rule.oneOf.map(cloneRule);
  }

  return res;
}

VueLoaderPlugin.NS = NS;
module.exports = VueLoaderPlugin;