"use strict";

var path = require('path');

var hash = require('hash-sum');

var qs = require('querystring');

var plugin = require('./plugin');

var selectBlock = require('./select');

var loaderUtils = require('loader-utils');

var _require = require('./codegen/utils'),
    attrsToQuery = _require.attrsToQuery;

var _require2 = require('@vue/component-compiler-utils'),
    parse = _require2.parse;

var genStylesCode = require('./codegen/styleInjection');

var _require3 = require('./codegen/hotReload'),
    genHotReloadCode = _require3.genHotReloadCode;

var genCustomBlocksCode = require('./codegen/customBlocks');

var componentNormalizerPath = require.resolve('./runtime/componentNormalizer');

var _require4 = require('./plugin'),
    NS = _require4.NS;

var errorEmitted = false;

function loadTemplateCompiler(loaderContext) {
  try {
    return require('vue-template-compiler');
  } catch (e) {
    if (/version mismatch/.test(e.toString())) {
      loaderContext.emitError(e);
    } else {
      loaderContext.emitError(new Error("[vue-loader] vue-template-compiler must be installed as a peer dependency, " + "or a compatible compiler implementation must be passed via options."));
    }
  }
}

module.exports = function (source) {
  var loaderContext = this;

  if (!errorEmitted && !loaderContext['thread-loader'] && !loaderContext[NS]) {
    loaderContext.emitError(new Error("vue-loader was used without the corresponding plugin. " + "Make sure to include VueLoaderPlugin in your webpack config."));
    errorEmitted = true;
  }

  var stringifyRequest = function stringifyRequest(r) {
    return loaderUtils.stringifyRequest(loaderContext, r);
  };

  var target = loaderContext.target,
      request = loaderContext.request,
      minimize = loaderContext.minimize,
      sourceMap = loaderContext.sourceMap,
      rootContext = loaderContext.rootContext,
      resourcePath = loaderContext.resourcePath,
      resourceQuery = loaderContext.resourceQuery;
  var rawQuery = resourceQuery.slice(1);
  var inheritQuery = "&".concat(rawQuery);
  var incomingQuery = qs.parse(rawQuery);
  var options = loaderUtils.getOptions(loaderContext) || {};
  var isServer = target === 'node';
  var isShadow = !!options.shadowMode;
  var isProduction = options.productionMode || minimize || process.env.NODE_ENV === 'production';
  var filename = path.basename(resourcePath);
  var context = rootContext || process.cwd();
  var sourceRoot = path.dirname(path.relative(context, resourcePath));
  var descriptor = parse({
    source: source,
    compiler: options.compiler || loadTemplateCompiler(loaderContext),
    filename: filename,
    sourceRoot: sourceRoot,
    needMap: sourceMap
  }); // if the query has a type field, this is a language block request
  // e.g. foo.vue?type=template&id=xxxxx
  // and we will return early

  if (incomingQuery.type) {
    return selectBlock(descriptor, loaderContext, incomingQuery, !!options.appendExtension);
  } // module id for scoped CSS & hot-reload


  var rawShortFilePath = path.relative(context, resourcePath).replace(/^(\.\.[\/\\])+/, '');
  var shortFilePath = rawShortFilePath.replace(/\\/g, '/') + resourceQuery;
  var id = hash(isProduction ? shortFilePath + '\n' + source.replace(/\r\n/g, '\n') : shortFilePath); // feature information

  var hasScoped = descriptor.styles.some(function (s) {
    return s.scoped;
  });
  var hasFunctional = descriptor.template && descriptor.template.attrs.functional;
  var needsHotReload = !isServer && !isProduction && (descriptor.script || descriptor.template) && options.hotReload !== false; // template

  var templateImport = "var render, staticRenderFns";
  var templateRequest;

  if (descriptor.template) {
    var src = descriptor.template.src || resourcePath;
    var idQuery = "&id=".concat(id);
    var scopedQuery = hasScoped ? "&scoped=true" : "";
    var attrsQuery = attrsToQuery(descriptor.template.attrs);
    var query = "?vue&type=template".concat(idQuery).concat(scopedQuery).concat(attrsQuery).concat(inheritQuery);

    var _request = templateRequest = stringifyRequest(src + query);

    templateImport = "import { render, staticRenderFns } from ".concat(_request);
  } // script


  var scriptImport = "var script = {}";

  if (descriptor.script) {
    var _src = descriptor.script.src || resourcePath;

    var _attrsQuery = attrsToQuery(descriptor.script.attrs, 'js');

    var _query = "?vue&type=script".concat(_attrsQuery).concat(inheritQuery);

    var _request2 = stringifyRequest(_src + _query);

    scriptImport = "import script from ".concat(_request2, "\n") + "export * from ".concat(_request2) // support named exports
    ;
  } // styles


  var stylesCode = "";

  if (descriptor.styles.length) {
    stylesCode = genStylesCode(loaderContext, descriptor.styles, id, resourcePath, stringifyRequest, needsHotReload, isServer || isShadow // needs explicit injection?
    );
  }

  var code = "\n".concat(templateImport, "\n").concat(scriptImport, "\n").concat(stylesCode, "\n\n/* normalize component */\nimport normalizer from ").concat(stringifyRequest("!".concat(componentNormalizerPath)), "\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  ").concat(hasFunctional ? "true" : "false", ",\n  ").concat(/injectStyles/.test(stylesCode) ? "injectStyles" : "null", ",\n  ").concat(hasScoped ? JSON.stringify(id) : "null", ",\n  ").concat(isServer ? JSON.stringify(hash(request)) : "null", "\n  ").concat(isShadow ? ",true" : "", "\n)\n  ").trim() + "\n";

  if (descriptor.customBlocks && descriptor.customBlocks.length) {
    code += genCustomBlocksCode(descriptor.customBlocks, resourcePath, resourceQuery, stringifyRequest);
  }

  if (needsHotReload) {
    code += "\n" + genHotReloadCode(id, hasFunctional, templateRequest);
  } // Expose filename. This is used by the devtools and Vue runtime warnings.


  if (!isProduction) {
    // Expose the file's full path in development, so that it can be opened
    // from the devtools.
    code += "\ncomponent.options.__file = ".concat(JSON.stringify(rawShortFilePath.replace(/\\/g, '/')));
  } else if (options.exposeFilename) {
    // Libraries can opt-in to expose their components' filenames in production builds.
    // For security reasons, only expose the file's basename in production.
    code += "\ncomponent.options.__file = ".concat(JSON.stringify(filename));
  }

  code += "\nexport default component.exports";
  return code;
};

module.exports.VueLoaderPlugin = plugin;