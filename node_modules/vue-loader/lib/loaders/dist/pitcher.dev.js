"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var qs = require('querystring');

var loaderUtils = require('loader-utils');

var hash = require('hash-sum');

var selfPath = require.resolve('../index');

var templateLoaderPath = require.resolve('./templateLoader');

var stylePostLoaderPath = require.resolve('./stylePostLoader');

var isESLintLoader = function isESLintLoader(l) {
  return /(\/|\\|@)eslint-loader/.test(l.path);
};

var isNullLoader = function isNullLoader(l) {
  return /(\/|\\|@)null-loader/.test(l.path);
};

var isCSSLoader = function isCSSLoader(l) {
  return /(\/|\\|@)css-loader/.test(l.path);
};

var isCacheLoader = function isCacheLoader(l) {
  return /(\/|\\|@)cache-loader/.test(l.path);
};

var isPitcher = function isPitcher(l) {
  return l.path !== __filename;
};

var isPreLoader = function isPreLoader(l) {
  return !l.pitchExecuted;
};

var isPostLoader = function isPostLoader(l) {
  return l.pitchExecuted;
};

var dedupeESLintLoader = function dedupeESLintLoader(loaders) {
  var res = [];
  var seen = false;
  loaders.forEach(function (l) {
    if (!isESLintLoader(l)) {
      res.push(l);
    } else if (!seen) {
      seen = true;
      res.push(l);
    }
  });
  return res;
};

var shouldIgnoreCustomBlock = function shouldIgnoreCustomBlock(loaders) {
  var actualLoaders = loaders.filter(function (loader) {
    // vue-loader
    if (loader.path === selfPath) {
      return false;
    } // cache-loader


    if (isCacheLoader(loader)) {
      return false;
    }

    return true;
  });
  return actualLoaders.length === 0;
};

module.exports = function (code) {
  return code;
}; // This pitching loader is responsible for intercepting all vue block requests
// and transform it into appropriate requests.


module.exports.pitch = function (remainingRequest) {
  var _this = this;

  var options = loaderUtils.getOptions(this);
  var cacheDirectory = options.cacheDirectory,
      cacheIdentifier = options.cacheIdentifier;
  var query = qs.parse(this.resourceQuery.slice(1));
  var loaders = this.loaders; // if this is a language block request, eslint-loader may get matched
  // multiple times

  if (query.type) {
    // if this is an inline block, since the whole file itself is being linted,
    // remove eslint-loader to avoid duplicate linting.
    if (/\.vue$/.test(this.resourcePath)) {
      loaders = loaders.filter(function (l) {
        return !isESLintLoader(l);
      });
    } else {
      // This is a src import. Just make sure there's not more than 1 instance
      // of eslint present.
      loaders = dedupeESLintLoader(loaders);
    }
  } // remove self


  loaders = loaders.filter(isPitcher); // do not inject if user uses null-loader to void the type (#1239)

  if (loaders.some(isNullLoader)) {
    return;
  }

  var genRequest = function genRequest(loaders) {
    // Important: dedupe since both the original rule
    // and the cloned rule would match a source import request.
    // also make sure to dedupe based on loader path.
    // assumes you'd probably never want to apply the same loader on the same
    // file twice.
    // Exception: in Vue CLI we do need two instances of postcss-loader
    // for user config and inline minification. So we need to dedupe baesd on
    // path AND query to be safe.
    var seen = new Map();
    var loaderStrings = [];
    loaders.forEach(function (loader) {
      var identifier = typeof loader === 'string' ? loader : loader.path + loader.query;
      var request = typeof loader === 'string' ? loader : loader.request;

      if (!seen.has(identifier)) {
        seen.set(identifier, true); // loader.request contains both the resolved loader path and its options
        // query (e.g. ??ref-0)

        loaderStrings.push(request);
      }
    });
    return loaderUtils.stringifyRequest(_this, '-!' + [].concat(loaderStrings, [_this.resourcePath + _this.resourceQuery]).join('!'));
  }; // Inject style-post-loader before css-loader for scoped CSS and trimming


  if (query.type === "style") {
    var cssLoaderIndex = loaders.findIndex(isCSSLoader);

    if (cssLoaderIndex > -1) {
      var afterLoaders = loaders.slice(0, cssLoaderIndex + 1);
      var beforeLoaders = loaders.slice(cssLoaderIndex + 1);

      var _request = genRequest([].concat(_toConsumableArray(afterLoaders), [stylePostLoaderPath], _toConsumableArray(beforeLoaders))); // console.log(request)


      return query.module ? "export { default } from  ".concat(_request, "; export * from ").concat(_request) : "export * from ".concat(_request);
    }
  } // for templates: inject the template compiler & optional cache


  if (query.type === "template") {
    var path = require('path');

    var cacheLoader = cacheDirectory && cacheIdentifier ? ["".concat(require.resolve('cache-loader'), "?").concat(JSON.stringify({
      // For some reason, webpack fails to generate consistent hash if we
      // use absolute paths here, even though the path is only used in a
      // comment. For now we have to ensure cacheDirectory is a relative path.
      cacheDirectory: (path.isAbsolute(cacheDirectory) ? path.relative(process.cwd(), cacheDirectory) : cacheDirectory).replace(/\\/g, '/'),
      cacheIdentifier: hash(cacheIdentifier) + '-vue-loader-template'
    }))] : [];
    var preLoaders = loaders.filter(isPreLoader);
    var postLoaders = loaders.filter(isPostLoader);

    var _request2 = genRequest([].concat(cacheLoader, _toConsumableArray(postLoaders), [templateLoaderPath + "??vue-loader-options"], _toConsumableArray(preLoaders))); // console.log(request)
    // the template compiler uses esm exports


    return "export * from ".concat(_request2);
  } // if a custom block has no other matching loader other than vue-loader itself
  // or cache-loader, we should ignore it


  if (query.type === "custom" && shouldIgnoreCustomBlock(loaders)) {
    return "";
  } // When the user defines a rule that has only resourceQuery but no test,
  // both that rule and the cloned rule will match, resulting in duplicated
  // loaders. Therefore it is necessary to perform a dedupe here.


  var request = genRequest(loaders);
  return "import mod from ".concat(request, "; export default mod; export * from ").concat(request);
};