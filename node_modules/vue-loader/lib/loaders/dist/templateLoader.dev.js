"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var qs = require('querystring');

var loaderUtils = require('loader-utils');

var _require = require('@vue/component-compiler-utils'),
    compileTemplate = _require.compileTemplate; // Loader that compiles raw template into JavaScript functions.
// This is injected by the global pitcher (../pitch) for template
// selection requests initiated from vue files.


module.exports = function (source) {
  var loaderContext = this;
  var query = qs.parse(this.resourceQuery.slice(1)); // although this is not the main vue-loader, we can get access to the same
  // vue-loader options because we've set an ident in the plugin and used that
  // ident to create the request for this loader in the pitcher.

  var options = loaderUtils.getOptions(loaderContext) || {};
  var id = query.id;
  var isServer = loaderContext.target === 'node';
  var isProduction = options.productionMode || loaderContext.minimize || process.env.NODE_ENV === 'production';
  var isFunctional = query.functional; // allow using custom compiler via options

  var compiler = options.compiler || require('vue-template-compiler');

  var compilerOptions = Object.assign({
    outputSourceRange: true
  }, options.compilerOptions, {
    scopeId: query.scoped ? "data-v-".concat(id) : null,
    comments: query.comments
  }); // for vue-component-compiler

  var finalOptions = {
    source: source,
    filename: this.resourcePath,
    compiler: compiler,
    compilerOptions: compilerOptions,
    // allow customizing behavior of vue-template-es2015-compiler
    transpileOptions: options.transpileOptions,
    transformAssetUrls: options.transformAssetUrls || true,
    isProduction: isProduction,
    isFunctional: isFunctional,
    optimizeSSR: isServer && options.optimizeSSR !== false,
    prettify: options.prettify
  };
  var compiled = compileTemplate(finalOptions); // tips

  if (compiled.tips && compiled.tips.length) {
    compiled.tips.forEach(function (tip) {
      loaderContext.emitWarning(_typeof(tip) === 'object' ? tip.msg : tip);
    });
  } // errors


  if (compiled.errors && compiled.errors.length) {
    // 2.6 compiler outputs errors as objects with range
    if (compiler.generateCodeFrame && finalOptions.compilerOptions.outputSourceRange) {
      // TODO account for line offset in case template isn't placed at top
      // of the file
      loaderContext.emitError("\n\n  Errors compiling template:\n\n" + compiled.errors.map(function (_ref) {
        var msg = _ref.msg,
            start = _ref.start,
            end = _ref.end;
        var frame = compiler.generateCodeFrame(source, start, end);
        return "  ".concat(msg, "\n\n").concat(pad(frame));
      }).join("\n\n") + '\n');
    } else {
      loaderContext.emitError("\n  Error compiling template:\n".concat(pad(compiled.source), "\n") + compiled.errors.map(function (e) {
        return "  - ".concat(e);
      }).join('\n') + '\n');
    }
  }

  var code = compiled.code; // finish with ESM exports

  return code + "\nexport { render, staticRenderFns }";
};

function pad(source) {
  return source.split(/\r?\n/).map(function (line) {
    return "  ".concat(line);
  }).join('\n');
}