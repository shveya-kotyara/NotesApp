"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VueLoaderPlugin = void 0;

try {
  require.resolve('@vue/compiler-sfc');
} catch (e) {
  throw new Error('vue-loader requires @vue/compiler-sfc to be present in the dependency ' + 'tree.');
}

var path = require("path");

var qs = require("querystring");

var loaderUtils = require("loader-utils");

var hash = require("hash-sum");

var compiler_sfc_1 = require("@vue/compiler-sfc");

var select_1 = require("./select");

var hotReload_1 = require("./hotReload");

var cssModules_1 = require("./cssModules");

var formatError_1 = require("./formatError");

var plugin_1 = require("./plugin");

exports.VueLoaderPlugin = plugin_1["default"];
var errorEmitted = false;

function loader(source) {
  var _a;

  var loaderContext = this; // check if plugin is installed

  if (!errorEmitted && !loaderContext['thread-loader'] && !loaderContext[plugin_1["default"].NS]) {
    loaderContext.emitError(new Error("vue-loader was used without the corresponding plugin. " + "Make sure to include VueLoaderPlugin in your webpack config."));
    errorEmitted = true;
  }

  var stringifyRequest = function stringifyRequest(r) {
    return loaderUtils.stringifyRequest(loaderContext, r);
  };

  var mode = loaderContext.mode,
      target = loaderContext.target,
      sourceMap = loaderContext.sourceMap,
      rootContext = loaderContext.rootContext,
      resourcePath = loaderContext.resourcePath,
      resourceQuery = loaderContext.resourceQuery;
  var rawQuery = resourceQuery.slice(1);
  var incomingQuery = qs.parse(rawQuery);
  var options = loaderUtils.getOptions(loaderContext) || {};
  var isServer = target === 'node';
  var isProduction = mode === 'production';

  var _compiler_sfc_1$parse = compiler_sfc_1.parse(source, {
    filename: resourcePath,
    sourceMap: sourceMap
  }),
      descriptor = _compiler_sfc_1$parse.descriptor,
      errors = _compiler_sfc_1$parse.errors;

  if (errors.length) {
    errors.forEach(function (err) {
      formatError_1.formatError(err, source, resourcePath);
      loaderContext.emitError(err);
    });
    return "";
  } // if the query has a type field, this is a language block request
  // e.g. foo.vue?type=template&id=xxxxx
  // and we will return early


  if (incomingQuery.type) {
    return select_1.selectBlock(descriptor, loaderContext, incomingQuery, !!options.appendExtension);
  } // module id for scoped CSS & hot-reload


  var rawShortFilePath = path.relative(rootContext || process.cwd(), resourcePath).replace(/^(\.\.[\/\\])+/, '');
  var shortFilePath = rawShortFilePath.replace(/\\/g, '/') + resourceQuery;
  var id = hash(isProduction ? shortFilePath + '\n' + source.replace(/\r\n/g, '\n') : shortFilePath); // feature information

  var hasScoped = descriptor.styles.some(function (s) {
    return s.scoped;
  });
  var needsHotReload = !isServer && !isProduction && !!(descriptor.script || descriptor.template) && options.hotReload !== false; // script

  var script;
  var scriptImport = "const script = {}";

  if (descriptor.script || descriptor.scriptSetup) {
    try {
      script = descriptor.scriptCompiled = compiler_sfc_1.compileScript(descriptor, {
        babelParserPlugins: options.babelParserPlugins
      });
    } catch (e) {
      loaderContext.emitError(e);
    }

    if (script) {
      var src = script.src || resourcePath;
      var attrsQuery = attrsToQuery(script.attrs, 'js');
      var query = "?vue&type=script".concat(attrsQuery).concat(resourceQuery);
      var scriptRequest = stringifyRequest(src + query);
      scriptImport = "import script from ".concat(scriptRequest, "\n") + // support named exports
      "export * from ".concat(scriptRequest);
    }
  } // template


  var templateImport = "";
  var templateRequest;
  var renderFnName = isServer ? "ssrRender" : "render";

  if (descriptor.template) {
    var _src = descriptor.template.src || resourcePath;

    var idQuery = "&id=".concat(id);
    var scopedQuery = hasScoped ? "&scoped=true" : "";

    var _attrsQuery = attrsToQuery(descriptor.template.attrs);

    var bindingsQuery = script ? "&bindings=".concat(JSON.stringify((_a = script.bindings) !== null && _a !== void 0 ? _a : {})) : "";

    var _query = "?vue&type=template".concat(idQuery).concat(scopedQuery).concat(_attrsQuery).concat(bindingsQuery).concat(resourceQuery);

    templateRequest = stringifyRequest(_src + _query);
    templateImport = "import { ".concat(renderFnName, " } from ").concat(templateRequest);
  } // styles


  var stylesCode = "";
  var hasCSSModules = false;
  var nonWhitespaceRE = /\S+/;

  if (descriptor.styles.length) {
    descriptor.styles.filter(function (style) {
      return style.src || nonWhitespaceRE.test(style.content);
    }).forEach(function (style, i) {
      var src = style.src || resourcePath;
      var attrsQuery = attrsToQuery(style.attrs, 'css'); // make sure to only pass id when necessary so that we don't inject
      // duplicate tags when multiple components import the same css file

      var idQuery = style.scoped ? "&id=".concat(id) : "";
      var query = "?vue&type=style&index=".concat(i).concat(idQuery).concat(attrsQuery).concat(resourceQuery);
      var styleRequest = stringifyRequest(src + query);

      if (style.module) {
        if (!hasCSSModules) {
          stylesCode += "\nconst cssModules = script.__cssModules = {}";
          hasCSSModules = true;
        }

        stylesCode += cssModules_1.genCSSModulesCode(id, i, styleRequest, style.module, needsHotReload);
      } else {
        stylesCode += "\nimport ".concat(styleRequest);
      } // TODO SSR critical CSS collection

    });
  }

  var code = [templateImport, scriptImport, stylesCode, templateImport ? "script.".concat(renderFnName, " = ").concat(renderFnName) : ""].filter(Boolean).join('\n'); // attach scope Id for runtime use

  if (hasScoped) {
    code += "\nscript.__scopeId = \"data-v-".concat(id, "\"");
  }

  if (needsHotReload) {
    code += hotReload_1.genHotReloadCode(id, templateRequest);
  } // Expose filename. This is used by the devtools and Vue runtime warnings.


  if (!isProduction) {
    // Expose the file's full path in development, so that it can be opened
    // from the devtools.
    code += "\nscript.__file = ".concat(JSON.stringify(rawShortFilePath.replace(/\\/g, '/')));
  } else if (options.exposeFilename) {
    // Libraries can opt-in to expose their components' filenames in production builds.
    // For security reasons, only expose the file's basename in production.
    code += "\nscript.__file = ".concat(JSON.stringify(path.basename(resourcePath)));
  } // custom blocks


  if (descriptor.customBlocks && descriptor.customBlocks.length) {
    code += "\n/* custom blocks */\n";
    code += descriptor.customBlocks.map(function (block, i) {
      var src = block.attrs.src || resourcePath;
      var attrsQuery = attrsToQuery(block.attrs);
      var blockTypeQuery = "&blockType=".concat(qs.escape(block.type));
      var issuerQuery = block.attrs.src ? "&issuerPath=".concat(qs.escape(resourcePath)) : '';
      var query = "?vue&type=custom&index=".concat(i).concat(blockTypeQuery).concat(issuerQuery).concat(attrsQuery).concat(resourceQuery);
      return "import block".concat(i, " from ").concat(stringifyRequest(src + query), "\n") + "if (typeof block".concat(i, " === 'function') block").concat(i, "(script)");
    }).join("\n") + "\n";
  } // finalize


  code += "\n\nexport default script";
  return code;
}

exports["default"] = loader; // these are built-in query parameters so should be ignored
// if the user happen to add them as attrs

var ignoreList = ['id', 'index', 'src', 'type'];

function attrsToQuery(attrs, langFallback) {
  var query = "";

  for (var name in attrs) {
    var value = attrs[name];

    if (!ignoreList.includes(name)) {
      query += "&".concat(qs.escape(name), "=").concat(value ? qs.escape(String(value)) : "");
    }
  }

  if (langFallback && !("lang" in attrs)) {
    query += "&lang=".concat(langFallback);
  }

  return query;
}