"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pitch = void 0;

var qs = require("querystring");

var loaderUtils = require("loader-utils");

var selfPath = require.resolve('./index'); // const templateLoaderPath = require.resolve('./templateLoader')


var stylePostLoaderPath = require.resolve('./stylePostLoader');

var isESLintLoader = function isESLintLoader(l) {
  return /(\/|\\|@)eslint-loader/.test(l.path);
};

var isNullLoader = function isNullLoader(l) {
  return /(\/|\\|@)null-loader/.test(l.path);
};

var isCSSLoader = function isCSSLoader(l) {
  return /(\/|\\|@)css-loader/.test(l.path);
};

var isCacheLoader = function isCacheLoader(l) {
  return /(\/|\\|@)cache-loader/.test(l.path);
};

var isNotPitcher = function isNotPitcher(l) {
  return l.path !== __filename;
};

var pitcher = function pitcher(code) {
  return code;
}; // This pitching loader is responsible for intercepting all vue block requests
// and transform it into appropriate requests.


exports.pitch = function () {
  var context = this;
  var rawLoaders = context.loaders.filter(isNotPitcher);
  var loaders = rawLoaders; // do not inject if user uses null-loader to void the type (#1239)

  if (loaders.some(isNullLoader)) {
    return;
  }

  var query = qs.parse(context.resourceQuery.slice(1));
  var isInlineBlock = /\.vue$/.test(context.resourcePath); // eslint-loader may get matched multiple times
  // if this is an inline block, since the whole file itself is being linted,
  // remove eslint-loader to avoid duplicate linting.

  if (isInlineBlock) {
    loaders = loaders.filter(function (l) {
      return !isESLintLoader(l);
    });
  } // Important: dedupe loaders since both the original rule
  // and the cloned rule would match a source import request or a
  // resourceQuery-only rule that intends to target a custom block with no lang


  var seen = new Map();
  loaders = loaders.filter(function (loader) {
    var identifier = typeof loader === 'string' ? loader : // Dedupe based on both path and query if available. This is important
    // in Vue CLI so that postcss-loaders with different options can co-exist
    loader.path + loader.query;

    if (!seen.has(identifier)) {
      seen.set(identifier, true);
      return true;
    }
  }); // Inject style-post-loader before css-loader for scoped CSS and trimming

  if (query.type === "style") {
    var cssLoaderIndex = loaders.findIndex(isCSSLoader);

    if (cssLoaderIndex > -1) {
      var afterLoaders = loaders.slice(0, cssLoaderIndex + 1);
      var beforeLoaders = loaders.slice(cssLoaderIndex + 1);
      return genProxyModule([].concat(_toConsumableArray(afterLoaders), [stylePostLoaderPath], _toConsumableArray(beforeLoaders)), context, !!query.module);
    }
  } // if a custom block has no other matching loader other than vue-loader itself
  // or cache-loader, we should ignore it


  if (query.type === "custom" && shouldIgnoreCustomBlock(loaders)) {
    return "";
  } // Rewrite request. Technically this should only be done when we have deduped
  // loaders. But somehow this is required for block source maps to work.


  return genProxyModule(loaders, context, query.type !== 'template');
};

function genProxyModule(loaders, context) {
  var exportDefault = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var request = genRequest(loaders, context); // return a proxy module which simply re-exports everything from the
  // actual request. Note for template blocks the compiled module has no
  // default export.

  return (exportDefault ? "export { default } from ".concat(request, "; ") : "") + "export * from ".concat(request);
}

function genRequest(loaders, context) {
  var loaderStrings = loaders.map(function (loader) {
    return typeof loader === 'string' ? loader : loader.request;
  });
  var resource = context.resourcePath + context.resourceQuery;
  return loaderUtils.stringifyRequest(context, '-!' + [].concat(_toConsumableArray(loaderStrings), [resource]).join('!'));
}

function shouldIgnoreCustomBlock(loaders) {
  var actualLoaders = loaders.filter(function (loader) {
    // vue-loader
    if (loader.path === selfPath) {
      return false;
    } // cache-loader


    if (isCacheLoader(loader)) {
      return false;
    }

    return true;
  });
  return actualLoaders.length === 0;
}

exports["default"] = pitcher;