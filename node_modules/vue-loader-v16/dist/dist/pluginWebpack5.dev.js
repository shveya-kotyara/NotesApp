"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var qs = require("querystring");

var id = 'vue-loader-plugin';
var NS = 'vue-loader';

var NormalModule = require('webpack/lib/NormalModule');

var BasicEffectRulePlugin = require('webpack/lib/rules/BasicEffectRulePlugin');

var BasicMatcherRulePlugin = require('webpack/lib/rules/BasicMatcherRulePlugin');

var DescriptionDataMatcherRulePlugin = require('webpack/lib/rules/DescriptionDataMatcherRulePlugin');

var UseEffectRulePlugin = require('webpack/lib/rules/UseEffectRulePlugin');

var RuleSetCompiler = require('webpack/lib/rules/RuleSetCompiler');

var ruleSetCompiler = new RuleSetCompiler([new BasicMatcherRulePlugin('test', 'resource'), new BasicMatcherRulePlugin('mimetype'), new BasicMatcherRulePlugin('dependency'), new BasicMatcherRulePlugin('include', 'resource'), new BasicMatcherRulePlugin('exclude', 'resource', true), new BasicMatcherRulePlugin('conditions'), new BasicMatcherRulePlugin('resource'), new BasicMatcherRulePlugin('resourceQuery'), new BasicMatcherRulePlugin('resourceFragment'), new BasicMatcherRulePlugin('realResource'), new BasicMatcherRulePlugin('issuer'), new BasicMatcherRulePlugin('compiler'), new DescriptionDataMatcherRulePlugin(), new BasicEffectRulePlugin('type'), new BasicEffectRulePlugin('sideEffects'), new BasicEffectRulePlugin('parser'), new BasicEffectRulePlugin('resolve'), new BasicEffectRulePlugin('generator'), new UseEffectRulePlugin()]);

var VueLoaderPlugin =
/*#__PURE__*/
function () {
  function VueLoaderPlugin() {
    _classCallCheck(this, VueLoaderPlugin);
  }

  _createClass(VueLoaderPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      // add NS marker so that the loader can detect and report missing plugin
      compiler.hooks.compilation.tap(id, function (compilation) {
        NormalModule.getCompilationHooks(compilation).loader.tap(id, function (loaderContext) {
          loaderContext[NS] = true;
        });
      });
      var rules = compiler.options.module.rules;
      var rawVueRule;
      var vueRules = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var rawRule = _step.value;

          // skip rules with 'enforce'. eg. rule for eslint-loader
          if (rawRule.enforce) {
            continue;
          }

          vueRules = match(rawRule, 'foo.vue');

          if (!vueRules.length) {
            vueRules = match(rawRule, 'foo.vue.html');
          }

          if (vueRules.length > 0) {
            if (rawRule.oneOf) {
              throw new Error("[VueLoaderPlugin Error] vue-loader currently does not support vue rules with oneOf.");
            }

            rawVueRule = rawRule;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (!vueRules.length) {
        throw new Error("[VueLoaderPlugin Error] No matching rule for .vue files found.\n" + "Make sure there is at least one root-level rule that matches .vue or .vue.html files.");
      } // get the normlized "use" for vue files


      var vueUse = vueRules.filter(function (rule) {
        return rule.type === 'use';
      }).map(function (rule) {
        return rule.value;
      }); // get vue-loader options

      var vueLoaderUseIndex = vueUse.findIndex(function (u) {
        return /^vue-loader|(\/|\\|@)vue-loader/.test(u.loader);
      });

      if (vueLoaderUseIndex < 0) {
        throw new Error("[VueLoaderPlugin Error] No matching use for vue-loader is found.\n" + "Make sure the rule matching .vue files include vue-loader in its use.");
      } // make sure vue-loader options has a known ident so that we can share
      // options by reference in the template-loader by using a ref query like
      // template-loader??vue-loader-options


      var vueLoaderUse = vueUse[vueLoaderUseIndex];
      var vueLoaderOptions = vueLoaderUse.options = vueLoaderUse.options || {}; // for each user rule (expect the vue rule), create a cloned rule
      // that targets the corresponding language blocks in *.vue files.

      var refs = new Map();
      var clonedRules = rules.filter(function (r) {
        return r !== rawVueRule;
      }).map(function (rawRule) {
        return cloneRule(rawRule, refs, langBlockRuleCheck, langBlockRuleResource);
      }); // fix conflict with config.loader and config.options when using config.use

      delete rawVueRule.loader;
      delete rawVueRule.options;
      rawVueRule.use = vueUse; // rule for template compiler

      var templateCompilerRule = {
        loader: require.resolve('./templateLoader'),
        resourceQuery: function resourceQuery(query) {
          var parsed = qs.parse(query.slice(1));
          return parsed.vue != null && parsed.type === 'template';
        },
        options: vueLoaderOptions
      }; // for each rule that matches plain .js files, also create a clone and
      // match it against the compiled template code inside *.vue files, so that
      // compiled vue render functions receive the same treatment as user code
      // (mostly babel)

      var jsRulesForRenderFn = rules.filter(function (r) {
        return r !== rawVueRule && match(r, 'test.js').length > 0;
      }).map(function (rawRule) {
        return cloneRule(rawRule, refs, jsRuleCheck, jsRuleResource);
      }); // global pitcher (responsible for injecting template compiler loader & CSS
      // post loader)

      var pitcher = {
        loader: require.resolve('./pitcher'),
        resourceQuery: function resourceQuery(query) {
          var parsed = qs.parse(query.slice(1));
          return parsed.vue != null;
        }
      }; // replace original rules

      compiler.options.module.rules = [pitcher].concat(_toConsumableArray(jsRulesForRenderFn), [templateCompilerRule], _toConsumableArray(clonedRules), _toConsumableArray(rules));
    }
  }]);

  return VueLoaderPlugin;
}();

VueLoaderPlugin.NS = NS;
var matcherCache = new WeakMap();

function match(rule, fakeFile) {
  var ruleSet = matcherCache.get(rule);

  if (!ruleSet) {
    // skip the `include` check when locating the vue rule
    var clonedRawRule = Object.assign({}, rule);
    delete clonedRawRule.include;
    ruleSet = ruleSetCompiler.compile([clonedRawRule]);
    matcherCache.set(rule, ruleSet);
  }

  return ruleSet.exec({
    resource: fakeFile
  });
}

var langBlockRuleCheck = function langBlockRuleCheck(query, rule) {
  return query.type === 'custom' || !rule.conditions.length || query.lang != null;
};

var langBlockRuleResource = function langBlockRuleResource(query, resource) {
  return "".concat(resource, ".").concat(query.lang);
};

var jsRuleCheck = function jsRuleCheck(query) {
  return query.type === 'template';
};

var jsRuleResource = function jsRuleResource(query, resource) {
  return "".concat(resource, ".js");
};

var uid = 0;

function cloneRule(rawRule, refs, ruleCheck, ruleResource) {
  var compiledRule = ruleSetCompiler.compileRule("clonedRuleSet-".concat(++uid), rawRule, refs); // do not process rule with enforce

  if (!rawRule.enforce) {
    var ruleUse = compiledRule.effects.filter(function (effect) {
      return effect.type === 'use';
    }).map(function (effect) {
      return effect.value;
    }); // fix conflict with config.loader and config.options when using config.use

    delete rawRule.loader;
    delete rawRule.options;
    rawRule.use = ruleUse;
  }

  var currentResource;
  var res = Object.assign(Object.assign({}, rawRule), {
    resource: function resource(resources) {
      currentResource = resources;
      return true;
    },
    resourceQuery: function resourceQuery(query) {
      var parsed = qs.parse(query.slice(1));

      if (parsed.vue == null) {
        return false;
      }

      if (!ruleCheck(parsed, compiledRule)) {
        return false;
      }

      var fakeResourcePath = ruleResource(parsed, currentResource);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = compiledRule.conditions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var condition = _step2.value;
          // add support for resourceQuery
          var request = condition.property === 'resourceQuery' ? query : fakeResourcePath;

          if (condition && !condition.fn(request)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return true;
    }
  });
  delete res.test;

  if (rawRule.rules) {
    res.rules = rawRule.rules.map(function (rule) {
      return cloneRule(rule, refs, ruleCheck, ruleResource);
    });
  }

  if (rawRule.oneOf) {
    res.oneOf = rawRule.oneOf.map(function (rule) {
      return cloneRule(rule, refs, ruleCheck, ruleResource);
    });
  }

  return res;
}

exports["default"] = VueLoaderPlugin;