"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var qs = require("querystring");

var RuleSet = require('webpack/lib/RuleSet');

var id = 'vue-loader-plugin';
var NS = 'vue-loader';

var VueLoaderPlugin =
/*#__PURE__*/
function () {
  function VueLoaderPlugin() {
    _classCallCheck(this, VueLoaderPlugin);
  }

  _createClass(VueLoaderPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      // inject NS for plugin installation check in the main loader
      compiler.hooks.compilation.tap(id, function (compilation) {
        compilation.hooks.normalModuleLoader.tap(id, function (loaderContext) {
          loaderContext[NS] = true;
        });
      });
      var rawRules = compiler.options.module.rules; // use webpack's RuleSet utility to normalize user rules

      var rules = new RuleSet(rawRules).rules; // find the rule that applies to vue files

      var vueRuleIndex = rawRules.findIndex(createMatcher("foo.vue"));

      if (vueRuleIndex < 0) {
        vueRuleIndex = rawRules.findIndex(createMatcher("foo.vue.html"));
      }

      var vueRule = rules[vueRuleIndex];

      if (!vueRule) {
        throw new Error("[VueLoaderPlugin Error] No matching rule for .vue files found.\n" + "Make sure there is at least one root-level rule that matches .vue or .vue.html files.");
      }

      if (vueRule.oneOf) {
        throw new Error("[VueLoaderPlugin Error] vue-loader currently does not support vue rules with oneOf.");
      } // get the normlized "use" for vue files


      var vueUse = vueRule.use; // get vue-loader options

      var vueLoaderUseIndex = vueUse.findIndex(function (u) {
        return /^vue-loader|(\/|\\|@)vue-loader/.test(u.loader || '');
      });

      if (vueLoaderUseIndex < 0) {
        throw new Error("[VueLoaderPlugin Error] No matching use for vue-loader is found.\n" + "Make sure the rule matching .vue files include vue-loader in its use.");
      }

      var vueLoaderUse = vueUse[vueLoaderUseIndex];
      var vueLoaderOptions = vueLoaderUse.options = vueLoaderUse.options || {}; // for each user rule (expect the vue rule), create a cloned rule
      // that targets the corresponding language blocks in *.vue files.

      var clonedRules = rules.filter(function (r) {
        return r !== vueRule;
      }).map(cloneRule); // rule for template compiler

      var templateCompilerRule = {
        loader: require.resolve('./templateLoader'),
        resourceQuery: function resourceQuery(query) {
          var parsed = qs.parse(query.slice(1));
          return parsed.vue != null && parsed.type === 'template';
        },
        options: vueLoaderOptions
      }; // for each rule that matches plain .js files, also create a clone and
      // match it against the compiled template code inside *.vue files, so that
      // compiled vue render functions receive the same treatment as user code
      // (mostly babel)

      var matchesJS = createMatcher("test.js");
      var jsRulesForRenderFn = rules.filter(function (r) {
        return r !== vueRule && matchesJS(r);
      }).map(cloneRuleForRenderFn); // pitcher for block requests (for injecting stylePostLoader and deduping
      // loaders matched for src imports)

      var pitcher = {
        loader: require.resolve('./pitcher'),
        resourceQuery: function resourceQuery(query) {
          var parsed = qs.parse(query.slice(1));
          return parsed.vue != null;
        }
      }; // replace original rules

      compiler.options.module.rules = [pitcher].concat(_toConsumableArray(jsRulesForRenderFn), [templateCompilerRule], _toConsumableArray(clonedRules), _toConsumableArray(rules));
    }
  }]);

  return VueLoaderPlugin;
}();

VueLoaderPlugin.NS = NS;

function createMatcher(fakeFile) {
  return function (rule) {
    // #1201 we need to skip the `include` check when locating the vue rule
    var clone = Object.assign({}, rule);
    delete clone.include;
    var normalized = RuleSet.normalizeRule(clone, {}, '');
    return !rule.enforce && normalized.resource && normalized.resource(fakeFile);
  };
}

function cloneRule(rule) {
  var resource = rule.resource;
  var _resourceQuery = rule.resourceQuery; // Assuming `test` and `resourceQuery` tests are executed in series and
  // synchronously (which is true based on RuleSet's implementation), we can
  // save the current resource being matched from `test` so that we can access
  // it in `resourceQuery`. This ensures when we use the normalized rule's
  // resource check, include/exclude are matched correctly.

  var currentResource;
  var res = Object.assign(Object.assign({}, rule), {
    resource: function resource(_resource) {
      currentResource = _resource;
      return true;
    },
    resourceQuery: function resourceQuery(query) {
      var parsed = qs.parse(query.slice(1));

      if (parsed.vue == null) {
        return false;
      }

      if (resource && parsed.lang == null) {
        return false;
      }

      var fakeResourcePath = "".concat(currentResource, ".").concat(parsed.lang);

      if (resource && !resource(fakeResourcePath)) {
        return false;
      }

      if (_resourceQuery && !_resourceQuery(query)) {
        return false;
      }

      return true;
    }
  });

  if (rule.rules) {
    res.rules = rule.rules.map(cloneRule);
  }

  if (rule.oneOf) {
    res.oneOf = rule.oneOf.map(cloneRule);
  }

  return res;
}

function cloneRuleForRenderFn(rule) {
  var resource = rule.resource;
  var _resourceQuery2 = rule.resourceQuery;
  var currentResource;
  var res = Object.assign(Object.assign({}, rule), {
    resource: function resource(_resource2) {
      currentResource = _resource2;
      return true;
    },
    resourceQuery: function resourceQuery(query) {
      var parsed = qs.parse(query.slice(1));

      if (parsed.vue == null || parsed.type !== 'template') {
        return false;
      }

      var fakeResourcePath = "".concat(currentResource, ".js");

      if (resource && !resource(fakeResourcePath)) {
        return false;
      }

      if (_resourceQuery2 && !_resourceQuery2(query)) {
        return false;
      }

      return true;
    }
  });

  if (rule.rules) {
    res.rules = rule.rules.map(cloneRuleForRenderFn);
  }

  if (rule.oneOf) {
    res.oneOf = rule.oneOf.map(cloneRuleForRenderFn);
  }

  return res;
}

exports["default"] = VueLoaderPlugin;