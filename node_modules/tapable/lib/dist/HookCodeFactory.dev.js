/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var HookCodeFactory =
/*#__PURE__*/
function () {
  function HookCodeFactory(config) {
    _classCallCheck(this, HookCodeFactory);

    this.config = config;
    this.options = undefined;
    this._args = undefined;
  }

  _createClass(HookCodeFactory, [{
    key: "create",
    value: function create(options) {
      this.init(options);
      var fn;

      switch (this.options.type) {
        case "sync":
          fn = new Function(this.args(), '"use strict";\n' + this.header() + this.content({
            onError: function onError(err) {
              return "throw ".concat(err, ";\n");
            },
            onResult: function onResult(result) {
              return "return ".concat(result, ";\n");
            },
            resultReturns: true,
            onDone: function onDone() {
              return "";
            },
            rethrowIfPossible: true
          }));
          break;

        case "async":
          fn = new Function(this.args({
            after: "_callback"
          }), '"use strict";\n' + this.header() + this.content({
            onError: function onError(err) {
              return "_callback(".concat(err, ");\n");
            },
            onResult: function onResult(result) {
              return "_callback(null, ".concat(result, ");\n");
            },
            onDone: function onDone() {
              return "_callback();\n";
            }
          }));
          break;

        case "promise":
          var errorHelperUsed = false;
          var content = this.content({
            onError: function onError(err) {
              errorHelperUsed = true;
              return "_error(".concat(err, ");\n");
            },
            onResult: function onResult(result) {
              return "_resolve(".concat(result, ");\n");
            },
            onDone: function onDone() {
              return "_resolve();\n";
            }
          });
          var code = "";
          code += '"use strict";\n';
          code += "return new Promise((_resolve, _reject) => {\n";

          if (errorHelperUsed) {
            code += "var _sync = true;\n";
            code += "function _error(_err) {\n";
            code += "if(_sync)\n";
            code += "_resolve(Promise.resolve().then(() => { throw _err; }));\n";
            code += "else\n";
            code += "_reject(_err);\n";
            code += "};\n";
          }

          code += this.header();
          code += content;

          if (errorHelperUsed) {
            code += "_sync = false;\n";
          }

          code += "});\n";
          fn = new Function(this.args(), code);
          break;
      }

      this.deinit();
      return fn;
    }
  }, {
    key: "setup",
    value: function setup(instance, options) {
      instance._x = options.taps.map(function (t) {
        return t.fn;
      });
    }
    /**
     * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
     */

  }, {
    key: "init",
    value: function init(options) {
      this.options = options;
      this._args = options.args.slice();
    }
  }, {
    key: "deinit",
    value: function deinit() {
      this.options = undefined;
      this._args = undefined;
    }
  }, {
    key: "header",
    value: function header() {
      var code = "";

      if (this.needContext()) {
        code += "var _context = {};\n";
      } else {
        code += "var _context;\n";
      }

      code += "var _x = this._x;\n";

      if (this.options.interceptors.length > 0) {
        code += "var _taps = this.taps;\n";
        code += "var _interceptors = this.interceptors;\n";
      }

      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];

        if (interceptor.call) {
          code += "".concat(this.getInterceptor(i), ".call(").concat(this.args({
            before: interceptor.context ? "_context" : undefined
          }), ");\n");
        }
      }

      return code;
    }
  }, {
    key: "needContext",
    value: function needContext() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.options.taps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tap = _step.value;
          if (tap.context) return true;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    }
  }, {
    key: "callTap",
    value: function callTap(tapIndex, _ref) {
      var onError = _ref.onError,
          onResult = _ref.onResult,
          onDone = _ref.onDone,
          rethrowIfPossible = _ref.rethrowIfPossible;
      var code = "";
      var hasTapCached = false;

      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];

        if (interceptor.tap) {
          if (!hasTapCached) {
            code += "var _tap".concat(tapIndex, " = ").concat(this.getTap(tapIndex), ";\n");
            hasTapCached = true;
          }

          code += "".concat(this.getInterceptor(i), ".tap(").concat(interceptor.context ? "_context, " : "", "_tap").concat(tapIndex, ");\n");
        }
      }

      code += "var _fn".concat(tapIndex, " = ").concat(this.getTapFn(tapIndex), ";\n");
      var tap = this.options.taps[tapIndex];

      switch (tap.type) {
        case "sync":
          if (!rethrowIfPossible) {
            code += "var _hasError".concat(tapIndex, " = false;\n");
            code += "try {\n";
          }

          if (onResult) {
            code += "var _result".concat(tapIndex, " = _fn").concat(tapIndex, "(").concat(this.args({
              before: tap.context ? "_context" : undefined
            }), ");\n");
          } else {
            code += "_fn".concat(tapIndex, "(").concat(this.args({
              before: tap.context ? "_context" : undefined
            }), ");\n");
          }

          if (!rethrowIfPossible) {
            code += "} catch(_err) {\n";
            code += "_hasError".concat(tapIndex, " = true;\n");
            code += onError("_err");
            code += "}\n";
            code += "if(!_hasError".concat(tapIndex, ") {\n");
          }

          if (onResult) {
            code += onResult("_result".concat(tapIndex));
          }

          if (onDone) {
            code += onDone();
          }

          if (!rethrowIfPossible) {
            code += "}\n";
          }

          break;

        case "async":
          var cbCode = "";
          if (onResult) cbCode += "(_err".concat(tapIndex, ", _result").concat(tapIndex, ") => {\n");else cbCode += "_err".concat(tapIndex, " => {\n");
          cbCode += "if(_err".concat(tapIndex, ") {\n");
          cbCode += onError("_err".concat(tapIndex));
          cbCode += "} else {\n";

          if (onResult) {
            cbCode += onResult("_result".concat(tapIndex));
          }

          if (onDone) {
            cbCode += onDone();
          }

          cbCode += "}\n";
          cbCode += "}";
          code += "_fn".concat(tapIndex, "(").concat(this.args({
            before: tap.context ? "_context" : undefined,
            after: cbCode
          }), ");\n");
          break;

        case "promise":
          code += "var _hasResult".concat(tapIndex, " = false;\n");
          code += "var _promise".concat(tapIndex, " = _fn").concat(tapIndex, "(").concat(this.args({
            before: tap.context ? "_context" : undefined
          }), ");\n");
          code += "if (!_promise".concat(tapIndex, " || !_promise").concat(tapIndex, ".then)\n");
          code += "  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise".concat(tapIndex, " + ')');\n");
          code += "_promise".concat(tapIndex, ".then(_result").concat(tapIndex, " => {\n");
          code += "_hasResult".concat(tapIndex, " = true;\n");

          if (onResult) {
            code += onResult("_result".concat(tapIndex));
          }

          if (onDone) {
            code += onDone();
          }

          code += "}, _err".concat(tapIndex, " => {\n");
          code += "if(_hasResult".concat(tapIndex, ") throw _err").concat(tapIndex, ";\n");
          code += onError("_err".concat(tapIndex));
          code += "});\n";
          break;
      }

      return code;
    }
  }, {
    key: "callTapsSeries",
    value: function callTapsSeries(_ref2) {
      var _this = this;

      var _onError = _ref2.onError,
          onResult = _ref2.onResult,
          resultReturns = _ref2.resultReturns,
          onDone = _ref2.onDone,
          doneReturns = _ref2.doneReturns,
          rethrowIfPossible = _ref2.rethrowIfPossible;
      if (this.options.taps.length === 0) return onDone();
      var firstAsync = this.options.taps.findIndex(function (t) {
        return t.type !== "sync";
      });
      var somethingReturns = resultReturns || doneReturns || false;
      var code = "";
      var current = onDone;

      var _loop = function _loop(j) {
        var i = j;
        var unroll = current !== onDone && _this.options.taps[i].type !== "sync";

        if (unroll) {
          code += "function _next".concat(i, "() {\n");
          code += current();
          code += "}\n";

          current = function current() {
            return "".concat(somethingReturns ? "return " : "", "_next").concat(i, "();\n");
          };
        }

        var done = current;

        var doneBreak = function doneBreak(skipDone) {
          if (skipDone) return "";
          return onDone();
        };

        var content = _this.callTap(i, {
          onError: function onError(error) {
            return _onError(i, error, done, doneBreak);
          },
          onResult: onResult && function (result) {
            return onResult(i, result, done, doneBreak);
          },
          onDone: !onResult && done,
          rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
        });

        current = function current() {
          return content;
        };
      };

      for (var j = this.options.taps.length - 1; j >= 0; j--) {
        _loop(j);
      }

      code += current();
      return code;
    }
  }, {
    key: "callTapsLooping",
    value: function callTapsLooping(_ref3) {
      var onError = _ref3.onError,
          onDone = _ref3.onDone,
          rethrowIfPossible = _ref3.rethrowIfPossible;
      if (this.options.taps.length === 0) return onDone();
      var syncOnly = this.options.taps.every(function (t) {
        return t.type === "sync";
      });
      var code = "";

      if (!syncOnly) {
        code += "var _looper = () => {\n";
        code += "var _loopAsync = false;\n";
      }

      code += "var _loop;\n";
      code += "do {\n";
      code += "_loop = false;\n";

      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];

        if (interceptor.loop) {
          code += "".concat(this.getInterceptor(i), ".loop(").concat(this.args({
            before: interceptor.context ? "_context" : undefined
          }), ");\n");
        }
      }

      code += this.callTapsSeries({
        onError: onError,
        onResult: function onResult(i, result, next, doneBreak) {
          var code = "";
          code += "if(".concat(result, " !== undefined) {\n");
          code += "_loop = true;\n";
          if (!syncOnly) code += "if(_loopAsync) _looper();\n";
          code += doneBreak(true);
          code += "} else {\n";
          code += next();
          code += "}\n";
          return code;
        },
        onDone: onDone && function () {
          var code = "";
          code += "if(!_loop) {\n";
          code += onDone();
          code += "}\n";
          return code;
        },
        rethrowIfPossible: rethrowIfPossible && syncOnly
      });
      code += "} while(_loop);\n";

      if (!syncOnly) {
        code += "_loopAsync = true;\n";
        code += "};\n";
        code += "_looper();\n";
      }

      return code;
    }
  }, {
    key: "callTapsParallel",
    value: function callTapsParallel(_ref4) {
      var _this2 = this;

      var _onError2 = _ref4.onError,
          onResult = _ref4.onResult,
          onDone = _ref4.onDone,
          rethrowIfPossible = _ref4.rethrowIfPossible,
          _ref4$onTap = _ref4.onTap,
          onTap = _ref4$onTap === void 0 ? function (i, run) {
        return run();
      } : _ref4$onTap;

      if (this.options.taps.length <= 1) {
        return this.callTapsSeries({
          onError: _onError2,
          onResult: onResult,
          onDone: onDone,
          rethrowIfPossible: rethrowIfPossible
        });
      }

      var code = "";
      code += "do {\n";
      code += "var _counter = ".concat(this.options.taps.length, ";\n");

      if (onDone) {
        code += "var _done = () => {\n";
        code += onDone();
        code += "};\n";
      }

      var _loop2 = function _loop2(i) {
        var done = function done() {
          if (onDone) return "if(--_counter === 0) _done();\n";else return "--_counter;";
        };

        var doneBreak = function doneBreak(skipDone) {
          if (skipDone || !onDone) return "_counter = 0;\n";else return "_counter = 0;\n_done();\n";
        };

        code += "if(_counter <= 0) break;\n";
        code += onTap(i, function () {
          return _this2.callTap(i, {
            onError: function onError(error) {
              var code = "";
              code += "if(_counter > 0) {\n";
              code += _onError2(i, error, done, doneBreak);
              code += "}\n";
              return code;
            },
            onResult: onResult && function (result) {
              var code = "";
              code += "if(_counter > 0) {\n";
              code += onResult(i, result, done, doneBreak);
              code += "}\n";
              return code;
            },
            onDone: !onResult && function () {
              return done();
            },
            rethrowIfPossible: rethrowIfPossible
          });
        }, done, doneBreak);
      };

      for (var i = 0; i < this.options.taps.length; i++) {
        _loop2(i);
      }

      code += "} while(false);\n";
      return code;
    }
  }, {
    key: "args",
    value: function args() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          before = _ref5.before,
          after = _ref5.after;

      var allArgs = this._args;
      if (before) allArgs = [before].concat(allArgs);
      if (after) allArgs = allArgs.concat(after);

      if (allArgs.length === 0) {
        return "";
      } else {
        return allArgs.join(", ");
      }
    }
  }, {
    key: "getTapFn",
    value: function getTapFn(idx) {
      return "_x[".concat(idx, "]");
    }
  }, {
    key: "getTap",
    value: function getTap(idx) {
      return "_taps[".concat(idx, "]");
    }
  }, {
    key: "getInterceptor",
    value: function getInterceptor(idx) {
      return "_interceptors[".concat(idx, "]");
    }
  }]);

  return HookCodeFactory;
}();

module.exports = HookCodeFactory;