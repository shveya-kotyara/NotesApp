'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var chalk = require('chalk');

var cliCursor = require('cli-cursor');

var cliSpinners = require('cli-spinners');

var logSymbols = require('log-symbols');

var stripAnsi = require('strip-ansi');

var wcwidth = require('wcwidth');

var TEXT = Symbol('text');
var PREFIX_TEXT = Symbol('prefixText');

var Ora =
/*#__PURE__*/
function () {
  function Ora(options) {
    _classCallCheck(this, Ora);

    if (typeof options === 'string') {
      options = {
        text: options
      };
    }

    this.options = Object.assign({
      text: '',
      color: 'cyan',
      stream: process.stderr
    }, options);
    this.spinner = this.options.spinner;
    this.color = this.options.color;
    this.hideCursor = this.options.hideCursor !== false;
    this.interval = this.options.interval || this.spinner.interval || 100;
    this.stream = this.options.stream;
    this.id = null;
    this.isEnabled = typeof this.options.isEnabled === 'boolean' ? this.options.isEnabled : this.stream && this.stream.isTTY && !process.env.CI; // Set *after* `this.stream`

    this.text = this.options.text;
    this.prefixText = this.options.prefixText;
    this.linesToClear = 0;
    this.indent = this.options.indent;
  }

  _createClass(Ora, [{
    key: "updateLineCount",
    value: function updateLineCount() {
      var columns = this.stream.columns || 80;
      var fullPrefixText = typeof this[PREFIX_TEXT] === 'string' ? this[PREFIX_TEXT] + '-' : '';
      this.lineCount = stripAnsi(fullPrefixText + '--' + this[TEXT]).split('\n').reduce(function (count, line) {
        return count + Math.max(1, Math.ceil(wcwidth(line) / columns));
      }, 0);
    }
  }, {
    key: "frame",
    value: function frame() {
      var frames = this.spinner.frames;
      var frame = frames[this.frameIndex];

      if (this.color) {
        frame = chalk[this.color](frame);
      }

      this.frameIndex = ++this.frameIndex % frames.length;
      var fullPrefixText = typeof this.prefixText === 'string' ? this.prefixText + ' ' : '';
      var fullText = typeof this.text === 'string' ? ' ' + this.text : '';
      return fullPrefixText + frame + fullText;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (!this.isEnabled || !this.stream.isTTY) {
        return this;
      }

      for (var i = 0; i < this.linesToClear; i++) {
        if (i > 0) {
          this.stream.moveCursor(0, -1);
        }

        this.stream.clearLine();
        this.stream.cursorTo(this.indent);
      }

      this.linesToClear = 0;
      return this;
    }
  }, {
    key: "render",
    value: function render() {
      this.clear();
      this.stream.write(this.frame());
      this.linesToClear = this.lineCount;
      return this;
    }
  }, {
    key: "start",
    value: function start(text) {
      if (text) {
        this.text = text;
      }

      if (!this.isEnabled) {
        this.stream.write("- ".concat(this.text, "\n"));
        return this;
      }

      if (this.isSpinning) {
        return this;
      }

      if (this.hideCursor) {
        cliCursor.hide(this.stream);
      }

      this.render();
      this.id = setInterval(this.render.bind(this), this.interval);
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!this.isEnabled) {
        return this;
      }

      clearInterval(this.id);
      this.id = null;
      this.frameIndex = 0;
      this.clear();

      if (this.hideCursor) {
        cliCursor.show(this.stream);
      }

      return this;
    }
  }, {
    key: "succeed",
    value: function succeed(text) {
      return this.stopAndPersist({
        symbol: logSymbols.success,
        text: text
      });
    }
  }, {
    key: "fail",
    value: function fail(text) {
      return this.stopAndPersist({
        symbol: logSymbols.error,
        text: text
      });
    }
  }, {
    key: "warn",
    value: function warn(text) {
      return this.stopAndPersist({
        symbol: logSymbols.warning,
        text: text
      });
    }
  }, {
    key: "info",
    value: function info(text) {
      return this.stopAndPersist({
        symbol: logSymbols.info,
        text: text
      });
    }
  }, {
    key: "stopAndPersist",
    value: function stopAndPersist() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var prefixText = options.prefixText || this.prefixText;
      var fullPrefixText = typeof prefixText === 'string' ? prefixText + ' ' : '';
      var text = options.text || this.text;
      var fullText = typeof text === 'string' ? ' ' + text : '';
      this.stop();
      this.stream.write("".concat(fullPrefixText).concat(options.symbol || ' ').concat(fullText, "\n"));
      return this;
    }
  }, {
    key: "indent",
    get: function get() {
      return this._indent;
    },
    set: function set() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (!(indent >= 0 && Number.isInteger(indent))) {
        throw new Error('The `indent` option must be an integer from 0 and up');
      }

      this._indent = indent;
    }
  }, {
    key: "spinner",
    get: function get() {
      return this._spinner;
    },
    set: function set(spinner) {
      this.frameIndex = 0;

      if (_typeof(spinner) === 'object') {
        if (spinner.frames === undefined) {
          throw new Error('The given spinner must have a `frames` property');
        }

        this._spinner = spinner;
      } else if (process.platform === 'win32') {
        this._spinner = cliSpinners.line;
      } else if (spinner === undefined) {
        // Set default spinner
        this._spinner = cliSpinners.dots;
      } else if (cliSpinners[spinner]) {
        this._spinner = cliSpinners[spinner];
      } else {
        throw new Error("There is no built-in spinner named '".concat(spinner, "'. See https://github.com/sindresorhus/cli-spinners/blob/master/spinners.json for a full list."));
      }
    }
  }, {
    key: "text",
    get: function get() {
      return this[TEXT];
    },
    set: function set(value) {
      this[TEXT] = value;
      this.updateLineCount();
    }
  }, {
    key: "prefixText",
    get: function get() {
      return this[PREFIX_TEXT];
    },
    set: function set(value) {
      this[PREFIX_TEXT] = value;
      this.updateLineCount();
    }
  }, {
    key: "isSpinning",
    get: function get() {
      return this.id !== null;
    }
  }]);

  return Ora;
}();

var oraFactory = function oraFactory(opts) {
  return new Ora(opts);
};

module.exports = oraFactory; // TODO: Remove this for the next major release

module.exports["default"] = oraFactory;

module.exports.promise = function (action, options) {
  if (typeof action.then !== 'function') {
    throw new TypeError('Parameter `action` must be a Promise');
  }

  var spinner = new Ora(options);
  spinner.start();
  action.then(function () {
    spinner.succeed();
  }, function () {
    spinner.fail();
  });
  return spinner;
};