"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = loader;
exports.pitch = pitch;
exports.raw = void 0;
/* eslint-disable
  import/order
*/

var fs = require('fs');

var os = require('os');

var path = require('path');

var async = require('neo-async');

var crypto = require('crypto');

var mkdirp = require('mkdirp');

var findCacheDir = require('find-cache-dir');

var BJSON = require('buffer-json');

var _require = require('loader-utils'),
    getOptions = _require.getOptions;

var validateOptions = require('schema-utils');

var pkg = require('../package.json');

var env = process.env.NODE_ENV || 'development';

var schema = require('./options.json');

var defaults = {
  cacheContext: '',
  cacheDirectory: findCacheDir({
    name: 'cache-loader'
  }) || os.tmpdir(),
  cacheIdentifier: "cache-loader:".concat(pkg.version, " ").concat(env),
  cacheKey: cacheKey,
  compare: compare,
  precision: 0,
  read: read,
  readOnly: false,
  write: write
};

function pathWithCacheContext(cacheContext, originalPath) {
  if (!cacheContext) {
    return originalPath;
  }

  if (originalPath.includes(cacheContext)) {
    return originalPath.split('!').map(function (subPath) {
      return path.relative(cacheContext, subPath);
    }).join('!');
  }

  return originalPath.split('!').map(function (subPath) {
    return path.resolve(cacheContext, subPath);
  }).join('!');
}

function roundMs(mtime, precision) {
  return Math.floor(mtime / precision) * precision;
} // NOTE: We should only apply `pathWithCacheContext` transformations
// right before writing. Every other internal steps with the paths
// should be accomplish over absolute paths. Otherwise we have the risk
// to break watchpack -> chokidar watch logic  over webpack@4 --watch


function loader() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var options = Object.assign({}, defaults, getOptions(this));
  validateOptions(schema, options, {
    name: 'Cache Loader',
    baseDataPath: 'options'
  });
  var readOnly = options.readOnly,
      writeFn = options.write; // In case we are under a readOnly mode on cache-loader
  // we don't want to write or update any cache file

  if (readOnly) {
    this.callback.apply(this, [null].concat(args));
    return;
  }

  var callback = this.async();
  var data = this.data;
  var dependencies = this.getDependencies().concat(this.loaders.map(function (l) {
    return l.path;
  }));
  var contextDependencies = this.getContextDependencies(); // Should the file get cached?

  var cache = true; // this.fs can be undefined
  // e.g when using the thread-loader
  // fallback to the fs module

  var FS = this.fs || fs;

  var toDepDetails = function toDepDetails(dep, mapCallback) {
    FS.stat(dep, function (err, stats) {
      if (err) {
        mapCallback(err);
        return;
      }

      var mtime = stats.mtime.getTime();

      if (mtime / 1000 >= Math.floor(data.startTime / 1000)) {
        // Don't trust mtime.
        // File was changed while compiling
        // or it could be an inaccurate filesystem.
        cache = false;
      }

      mapCallback(null, {
        path: pathWithCacheContext(options.cacheContext, dep),
        mtime: mtime
      });
    });
  };

  async.parallel([function (cb) {
    return async.mapLimit(dependencies, 20, toDepDetails, cb);
  }, function (cb) {
    return async.mapLimit(contextDependencies, 20, toDepDetails, cb);
  }], function (err, taskResults) {
    if (err) {
      callback.apply(void 0, [null].concat(args));
      return;
    }

    if (!cache) {
      callback.apply(void 0, [null].concat(args));
      return;
    }

    var _taskResults = _slicedToArray(taskResults, 2),
        deps = _taskResults[0],
        contextDeps = _taskResults[1];

    writeFn(data.cacheKey, {
      remainingRequest: pathWithCacheContext(options.cacheContext, data.remainingRequest),
      dependencies: deps,
      contextDependencies: contextDeps,
      result: args
    }, function () {
      // ignore errors here
      callback.apply(void 0, [null].concat(args));
    });
  });
} // NOTE: We should apply `pathWithCacheContext` transformations
// right after reading. Every other internal steps with the paths
// should be accomplish over absolute paths. Otherwise we have the risk
// to break watchpack -> chokidar watch logic  over webpack@4 --watch


function pitch(remainingRequest, prevRequest, dataInput) {
  var _this = this;

  var options = Object.assign({}, defaults, getOptions(this));
  validateOptions(schema, options, {
    name: 'Cache Loader (Pitch)',
    baseDataPath: 'options'
  });
  var cacheContext = options.cacheContext,
      cacheKeyFn = options.cacheKey,
      compareFn = options.compare,
      readFn = options.read,
      readOnly = options.readOnly,
      precision = options.precision;
  var callback = this.async();
  var data = dataInput;
  data.remainingRequest = remainingRequest;
  data.cacheKey = cacheKeyFn(options, data.remainingRequest);
  readFn(data.cacheKey, function (readErr, cacheData) {
    if (readErr) {
      callback();
      return;
    } // We need to patch every path within data on cache with the cacheContext,
    // or it would cause problems when watching


    if (pathWithCacheContext(options.cacheContext, cacheData.remainingRequest) !== data.remainingRequest) {
      // in case of a hash conflict
      callback();
      return;
    }

    var FS = _this.fs || fs;
    async.each(cacheData.dependencies.concat(cacheData.contextDependencies), function (dep, eachCallback) {
      // Applying reverse path transformation, in case they are relatives, when
      // reading from cache
      var contextDep = _objectSpread({}, dep, {
        path: pathWithCacheContext(options.cacheContext, dep.path)
      });

      FS.stat(contextDep.path, function (statErr, stats) {
        if (statErr) {
          eachCallback(statErr);
          return;
        } // When we are under a readOnly config on cache-loader
        // we don't want to emit any other error than a
        // file stat error


        if (readOnly) {
          eachCallback();
          return;
        }

        var compStats = stats;
        var compDep = contextDep;

        if (precision > 1) {
          ['atime', 'mtime', 'ctime', 'birthtime'].forEach(function (key) {
            var msKey = "".concat(key, "Ms");
            var ms = roundMs(stats[msKey], precision);
            compStats[msKey] = ms;
            compStats[key] = new Date(ms);
          });
          compDep.mtime = roundMs(dep.mtime, precision);
        } // If the compare function returns false
        // we not read from cache


        if (compareFn(compStats, compDep) !== true) {
          eachCallback(true);
          return;
        }

        eachCallback();
      });
    }, function (err) {
      if (err) {
        data.startTime = Date.now();
        callback();
        return;
      }

      cacheData.dependencies.forEach(function (dep) {
        return _this.addDependency(pathWithCacheContext(cacheContext, dep.path));
      });
      cacheData.contextDependencies.forEach(function (dep) {
        return _this.addContextDependency(pathWithCacheContext(cacheContext, dep.path));
      });
      callback.apply(void 0, [null].concat(_toConsumableArray(cacheData.result)));
    });
  });
}

function digest(str) {
  return crypto.createHash('md5').update(str).digest('hex');
}

var directories = new Set();

function write(key, data, callback) {
  var dirname = path.dirname(key);
  var content = BJSON.stringify(data);

  if (directories.has(dirname)) {
    // for performance skip creating directory
    fs.writeFile(key, content, 'utf-8', callback);
  } else {
    mkdirp(dirname, function (mkdirErr) {
      if (mkdirErr) {
        callback(mkdirErr);
        return;
      }

      directories.add(dirname);
      fs.writeFile(key, content, 'utf-8', callback);
    });
  }
}

function read(key, callback) {
  fs.readFile(key, 'utf-8', function (err, content) {
    if (err) {
      callback(err);
      return;
    }

    try {
      var data = BJSON.parse(content);
      callback(null, data);
    } catch (e) {
      callback(e);
    }
  });
}

function cacheKey(options, request) {
  var cacheIdentifier = options.cacheIdentifier,
      cacheDirectory = options.cacheDirectory;
  var hash = digest("".concat(cacheIdentifier, "\n").concat(request));
  return path.join(cacheDirectory, "".concat(hash, ".json"));
}

function compare(stats, dep) {
  return stats.mtime.getTime() === dep.mtime;
}

var raw = true;
exports.raw = raw;