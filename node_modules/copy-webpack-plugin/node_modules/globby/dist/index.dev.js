'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var arrayUnion = require('array-union');

var glob = require('glob');

var pify = require('pify');

var dirGlob = require('dir-glob');

var gitignore = require('./gitignore');

var globP = pify(glob);

var DEFAULT_FILTER = function DEFAULT_FILTER() {
  return false;
};

var isNegative = function isNegative(pattern) {
  return pattern[0] === '!';
};

var assertPatternsInput = function assertPatternsInput(patterns) {
  if (!patterns.every(function (x) {
    return typeof x === 'string';
  })) {
    throw new TypeError('Patterns must be a string or an array of strings');
  }
};

var generateGlobTasks = function generateGlobTasks(patterns, taskOpts) {
  patterns = [].concat(patterns);
  assertPatternsInput(patterns);
  var globTasks = [];
  taskOpts = Object.assign({
    cache: Object.create(null),
    statCache: Object.create(null),
    realpathCache: Object.create(null),
    symlinks: Object.create(null),
    ignore: [],
    expandDirectories: true,
    nodir: true
  }, taskOpts);
  patterns.forEach(function (pattern, i) {
    if (isNegative(pattern)) {
      return;
    }

    var ignore = patterns.slice(i).filter(isNegative).map(function (pattern) {
      return pattern.slice(1);
    });
    var opts = Object.assign({}, taskOpts, {
      ignore: taskOpts.ignore.concat(ignore)
    });
    globTasks.push({
      pattern: pattern,
      opts: opts
    });
  });
  return globTasks;
};

var globDirs = function globDirs(task, fn) {
  if (Array.isArray(task.opts.expandDirectories)) {
    return fn(task.pattern, {
      files: task.opts.expandDirectories
    });
  }

  if (_typeof(task.opts.expandDirectories) === 'object') {
    return fn(task.pattern, task.opts.expandDirectories);
  }

  return fn(task.pattern);
};

var getPattern = function getPattern(task, fn) {
  return task.opts.expandDirectories ? globDirs(task, fn) : [task.pattern];
};

module.exports = function (patterns, opts) {
  var globTasks;

  try {
    globTasks = generateGlobTasks(patterns, opts);
  } catch (err) {
    return Promise.reject(err);
  }

  var getTasks = Promise.all(globTasks.map(function (task) {
    return Promise.resolve(getPattern(task, dirGlob)).then(function (globs) {
      return Promise.all(globs.map(function (glob) {
        return {
          pattern: glob,
          opts: task.opts
        };
      }));
    });
  })).then(function (tasks) {
    return arrayUnion.apply(null, tasks);
  });

  var getFilter = function getFilter() {
    return Promise.resolve(opts && opts.gitignore ? gitignore({
      cwd: opts.cwd,
      ignore: opts.ignore
    }) : DEFAULT_FILTER);
  };

  return getFilter().then(function (filter) {
    return getTasks.then(function (tasks) {
      return Promise.all(tasks.map(function (task) {
        return globP(task.pattern, task.opts);
      }));
    }).then(function (paths) {
      return arrayUnion.apply(null, paths);
    }).then(function (paths) {
      return paths.filter(function (p) {
        return !filter(p);
      });
    });
  });
};

module.exports.sync = function (patterns, opts) {
  var globTasks = generateGlobTasks(patterns, opts);

  var getFilter = function getFilter() {
    return opts && opts.gitignore ? gitignore.sync({
      cwd: opts.cwd,
      ignore: opts.ignore
    }) : DEFAULT_FILTER;
  };

  var tasks = globTasks.reduce(function (tasks, task) {
    var newTask = getPattern(task, dirGlob.sync).map(function (glob) {
      return {
        pattern: glob,
        opts: task.opts
      };
    });
    return tasks.concat(newTask);
  }, []);
  var filter = getFilter();
  return tasks.reduce(function (matches, task) {
    return arrayUnion(matches, glob.sync(task.pattern, task.opts));
  }, []).filter(function (p) {
    return !filter(p);
  });
};

module.exports.generateGlobTasks = generateGlobTasks;

module.exports.hasMagic = function (patterns, opts) {
  return [].concat(patterns).some(function (pattern) {
    return glob.hasMagic(pattern, opts);
  });
};

module.exports.gitignore = gitignore;