"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';

var path = require('path');

var COLON = isWindows ? ';' : ':';

var isexe = require('isexe');

var getNotFoundError = function getNotFoundError(cmd) {
  return Object.assign(new Error("not found: ".concat(cmd)), {
    code: 'ENOENT'
  });
};

var getPathInfo = function getPathInfo(cmd, opt) {
  var colon = opt.colon || COLON; // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.

  var pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [''] : [].concat(_toConsumableArray(isWindows ? [process.cwd()] : []), _toConsumableArray((opt.path || process.env.PATH ||
  /* istanbul ignore next: very unusual */
  '').split(colon)));
  var pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';
  var pathExt = isWindows ? pathExtExe.split(colon) : [''];

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
  }

  return {
    pathEnv: pathEnv,
    pathExt: pathExt,
    pathExtExe: pathExtExe
  };
};

var which = function which(cmd, opt, cb) {
  if (typeof opt === 'function') {
    cb = opt;
    opt = {};
  }

  if (!opt) opt = {};

  var _getPathInfo = getPathInfo(cmd, opt),
      pathEnv = _getPathInfo.pathEnv,
      pathExt = _getPathInfo.pathExt,
      pathExtExe = _getPathInfo.pathExtExe;

  var found = [];

  var step = function step(i) {
    return new Promise(function (resolve, reject) {
      if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      var ppRaw = pathEnv[i];
      var pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      var pCmd = path.join(pathPart, cmd);
      var p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
  };

  var subStep = function subStep(p, i, ii) {
    return new Promise(function (resolve, reject) {
      if (ii === pathExt.length) return resolve(step(i + 1));
      var ext = pathExt[ii];
      isexe(p + ext, {
        pathExt: pathExtExe
      }, function (er, is) {
        if (!er && is) {
          if (opt.all) found.push(p + ext);else return resolve(p + ext);
        }

        return resolve(subStep(p, i, ii + 1));
      });
    });
  };

  return cb ? step(0).then(function (res) {
    return cb(null, res);
  }, cb) : step(0);
};

var whichSync = function whichSync(cmd, opt) {
  opt = opt || {};

  var _getPathInfo2 = getPathInfo(cmd, opt),
      pathEnv = _getPathInfo2.pathEnv,
      pathExt = _getPathInfo2.pathExt,
      pathExtExe = _getPathInfo2.pathExtExe;

  var found = [];

  for (var i = 0; i < pathEnv.length; i++) {
    var ppRaw = pathEnv[i];
    var pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    var pCmd = path.join(pathPart, cmd);
    var p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;

    for (var j = 0; j < pathExt.length; j++) {
      var cur = p + pathExt[j];

      try {
        var is = isexe.sync(cur, {
          pathExt: pathExtExe
        });

        if (is) {
          if (opt.all) found.push(cur);else return cur;
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length) return found;
  if (opt.nothrow) return null;
  throw getNotFoundError(cmd);
};

module.exports = which;
which.sync = whichSync;