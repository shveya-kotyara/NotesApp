'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports["default"] = function (nodes, opts) {
  var family = [];
  var last = null;
  var i, max;
  nodes.forEach(function (node, index, arr) {
    if (node.type === 'string' || node.type === 'function') {
      family.push(node);
    } else if (node.type === 'word') {
      if (!last) {
        last = {
          type: 'word',
          value: ''
        };
        family.push(last);
      }

      last.value += node.value;
    } else if (node.type === 'space') {
      if (last && index !== arr.length - 1) {
        last.value += ' ';
      }
    } else {
      last = null;
    }
  });
  family = family.map(function (node) {
    if (node.type === 'string') {
      var isKeyword = regexKeyword.test(node.value);

      if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {
        return (0, _postcssValueParser.stringify)(node);
      }

      var escaped = escapeIdentifierSequence(node.value);

      if (escaped.length < node.value.length + 2) {
        return escaped;
      }
    }

    return (0, _postcssValueParser.stringify)(node);
  });

  if (opts.removeAfterKeyword) {
    for (i = 0, max = family.length; i < max; i += 1) {
      if (~genericFontFamilykeywords.indexOf(family[i].toLowerCase())) {
        family = family.slice(0, i + 1);
        break;
      }
    }
  }

  if (opts.removeDuplicates) {
    family = uniqs(family);
  }

  return [{
    type: 'word',
    value: family.join()
  }];
};

var _postcssValueParser = require('postcss-value-parser');

var _uniqs = require('./uniqs');

var _uniqs2 = _interopRequireDefault(_uniqs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var uniqs = (0, _uniqs2["default"])('monospace');
var globalKeywords = ['inherit', 'initial', 'unset'];
var genericFontFamilykeywords = ['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui'];

function makeArray(value, length) {
  var array = [];

  while (length--) {
    array[length] = value;
  }

  return array;
}

var regexSimpleEscapeCharacters = /[ !"#$%&'()*+,.\/;<=>?@\[\\\]^`{|}~]/;

function escape(string, escapeForString) {
  var counter = 0;
  var character = null;
  var charCode = null;
  var value = null;
  var output = '';

  while (counter < string.length) {
    character = string.charAt(counter++);
    charCode = character.charCodeAt(); // \r is already tokenized away at this point
    // `:` can be escaped as `\:`, but that fails in IE < 8

    if (!escapeForString && /[\t\n\v\f:]/.test(character)) {
      value = '\\' + charCode.toString(16) + ' ';
    } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {
      value = '\\' + character;
    } else {
      value = character;
    }

    output += value;
  }

  if (!escapeForString) {
    if (/^-[-\d]/.test(output)) {
      output = '\\-' + output.slice(1);
    }

    var firstChar = string.charAt(0);

    if (/\d/.test(firstChar)) {
      output = '\\3' + firstChar + ' ' + output.slice(1);
    }
  }

  return output;
}

var regexKeyword = new RegExp(genericFontFamilykeywords.concat(globalKeywords).join('|'), 'i');
var regexInvalidIdentifier = /^(-?\d|--)/;
var regexSpaceAtStart = /^\x20/;
var regexWhitespace = /[\t\n\f\r\x20]/g;
var regexIdentifierCharacter = /^[a-zA-Z\d\xa0-\uffff_-]+$/;
var regexConsecutiveSpaces = /(\\(?:[a-fA-F0-9]{1,6}\x20|\x20))?(\x20{2,})/g;
var regexTrailingEscape = /\\[a-fA-F0-9]{0,6}\x20$/;
var regexTrailingSpace = /\x20$/;

function escapeIdentifierSequence(string) {
  var identifiers = string.split(regexWhitespace);
  var index = 0;
  var result = [];
  var escapeResult;

  while (index < identifiers.length) {
    var subString = identifiers[index++];

    if (subString === '') {
      result.push(subString);
      continue;
    }

    escapeResult = escape(subString, false);

    if (regexIdentifierCharacter.test(subString)) {
      // the font family name part consists of allowed characters exclusively
      if (regexInvalidIdentifier.test(subString)) {
        // the font family name part starts with two hyphens, a digit, or a
        // hyphen followed by a digit
        if (index === 1) {
          // if this is the first item
          result.push(escapeResult);
        } else {
          // if it’s not the first item, we can simply escape the space
          // between the two identifiers to merge them into a single
          // identifier rather than escaping the start characters of the
          // second identifier
          result[index - 2] += '\\';
          result.push(escape(subString, true));
        }
      } else {
        // the font family name part doesn’t start with two hyphens, a digit,
        // or a hyphen followed by a digit
        result.push(escapeResult);
      }
    } else {
      // the font family name part contains invalid identifier characters
      result.push(escapeResult);
    }
  }

  result = result.join(' ').replace(regexConsecutiveSpaces, function ($0, $1, $2) {
    var spaceCount = $2.length;
    var escapesNeeded = Math.floor(spaceCount / 2);
    var array = makeArray('\\ ', escapesNeeded);

    if (spaceCount % 2) {
      array[escapesNeeded - 1] += '\\ ';
    }

    return ($1 || '') + ' ' + array.join(' ');
  }); // Escape trailing spaces unless they’re already part of an escape

  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {
    result = result.replace(regexTrailingSpace, '\\ ');
  }

  if (regexSpaceAtStart.test(result)) {
    result = '\\ ' + result.slice(1);
  }

  return result;
}

;
module.exports = exports['default'];