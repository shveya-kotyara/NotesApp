"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var quote_1 = require("./quote");

var object_1 = require("./object");

var function_1 = require("./function");
/**
 * Stringify primitive values.
 */


var PRIMITIVE_TYPES = {
  string: quote_1.quoteString,
  number: function number(value) {
    return Object.is(value, -0) ? "-0" : String(value);
  },
  "boolean": String,
  symbol: function symbol(value, space, next) {
    var key = Symbol.keyFor(value);
    if (key !== undefined) return "Symbol.for(".concat(next(key), ")"); // ES2018 `Symbol.description`.

    return "Symbol(".concat(next(value.description), ")");
  },
  bigint: function bigint(value, space, next) {
    return "BigInt(".concat(next(String(value)), ")");
  },
  undefined: String,
  object: object_1.objectToString,
  "function": function_1.functionToString
};
/**
 * Stringify a value recursively.
 */

exports.toString = function (value, space, next, key) {
  if (value === null) return "null";
  return PRIMITIVE_TYPES[_typeof(value)](value, space, next, key);
};