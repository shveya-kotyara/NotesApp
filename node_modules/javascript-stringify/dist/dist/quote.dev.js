"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Match all characters that need to be escaped in a string. Modified from
 * source to match single quotes instead of double.
 *
 * Source: https://github.com/douglascrockford/JSON-js/blob/master/json2.js
 */

var ESCAPABLE = /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
/**
 * Map of characters to escape characters.
 */

var META_CHARS = new Map([["\b", "\\b"], ["\t", "\\t"], ["\n", "\\n"], ["\f", "\\f"], ["\r", "\\r"], ["'", "\\'"], ['"', '\\"'], ["\\", "\\\\"]]);
/**
 * Escape any character into its literal JavaScript string.
 *
 * @param  {string} char
 * @return {string}
 */

function escapeChar(_char) {
  return META_CHARS.get(_char) || "\\u".concat("0000".concat(_char.charCodeAt(0).toString(16)).slice(-4));
}
/**
 * Quote a string.
 */


function quoteString(str) {
  return "'".concat(str.replace(ESCAPABLE, escapeChar), "'");
}

exports.quoteString = quoteString;
/**
 * JavaScript reserved keywords.
 */

var RESERVED_WORDS = new Set(("break else new var case finally return void catch for switch while " + "continue function this with default if throw delete in try " + "do instanceof typeof abstract enum int short boolean export " + "interface static byte extends long super char final native synchronized " + "class float package throws const goto private transient debugger " + "implements protected volatile double import public let yield").split(" "));
/**
 * Test for valid JavaScript identifier.
 */

exports.IS_VALID_IDENTIFIER = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
/**
 * Check if a variable name is valid.
 */

function isValidVariableName(name) {
  return typeof name === "string" && !RESERVED_WORDS.has(name) && exports.IS_VALID_IDENTIFIER.test(name);
}

exports.isValidVariableName = isValidVariableName;
/**
 * Quote JavaScript key access.
 */

function quoteKey(key, next) {
  return isValidVariableName(key) ? key : next(key);
}

exports.quoteKey = quoteKey;
/**
 * Serialize the path to a string.
 */

function stringifyPath(path, next) {
  var result = "";
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (isValidVariableName(key)) {
        result += ".".concat(key);
      } else {
        result += "[".concat(next(key), "]");
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

exports.stringifyPath = stringifyPath;