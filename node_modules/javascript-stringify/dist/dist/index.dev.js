"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var stringify_1 = require("./stringify");

var quote_1 = require("./quote");
/**
 * Root path node.
 */


var ROOT_SENTINEL = Symbol("root");
/**
 * Stringify any JavaScript value.
 */

function stringify(value, replacer, indent) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var space = typeof indent === "string" ? indent : " ".repeat(indent || 0);
  var path = [];
  var stack = new Set();
  var tracking = new Map();
  var unpack = new Map();
  var valueCount = 0;
  var _options$maxDepth = options.maxDepth,
      maxDepth = _options$maxDepth === void 0 ? 100 : _options$maxDepth,
      _options$references = options.references,
      references = _options$references === void 0 ? false : _options$references,
      _options$skipUndefine = options.skipUndefinedProperties,
      skipUndefinedProperties = _options$skipUndefine === void 0 ? false : _options$skipUndefine,
      _options$maxValues = options.maxValues,
      maxValues = _options$maxValues === void 0 ? 100000 : _options$maxValues; // Wrap replacer function to support falling back on supported stringify.

  var valueToString = replacerToString(replacer); // Every time you call `next(value)` execute this function.

  var onNext = function onNext(value, key) {
    if (++valueCount > maxValues) return;
    if (skipUndefinedProperties && value === undefined) return;
    if (path.length > maxDepth) return; // An undefined key is treated as an out-of-band "value".

    if (key === undefined) return valueToString(value, space, onNext, key);
    path.push(key);
    var result = builder(value, key === ROOT_SENTINEL ? undefined : key);
    path.pop();
    return result;
  };

  var builder = references ? function (value, key) {
    if (value !== null && (_typeof(value) === "object" || typeof value === "function" || _typeof(value) === "symbol")) {
      // Track nodes to restore later.
      if (tracking.has(value)) {
        unpack.set(path.slice(1), tracking.get(value));
        return; // Avoid serializing referenced nodes on an expression.
      } // Track encountered nodes.


      tracking.set(value, path.slice(1));
    }

    return valueToString(value, space, onNext, key);
  } : function (value, key) {
    // Stop on recursion.
    if (stack.has(value)) return;
    stack.add(value);
    var result = valueToString(value, space, onNext, key);
    stack["delete"](value);
    return result;
  };
  var result = onNext(value, ROOT_SENTINEL); // Attempt to restore circular references.

  if (unpack.size) {
    var sp = space ? " " : "";
    var eol = space ? "\n" : "";
    var wrapper = "var x".concat(sp, "=").concat(sp).concat(result, ";").concat(eol);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = unpack.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 2),
            key = _step$value[0],
            _value = _step$value[1];

        var keyPath = quote_1.stringifyPath(key, onNext);
        var valuePath = quote_1.stringifyPath(_value, onNext);
        wrapper += "x".concat(keyPath).concat(sp, "=").concat(sp, "x").concat(valuePath, ";").concat(eol);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return "(function".concat(sp, "()").concat(sp, "{").concat(eol).concat(wrapper, "return x;").concat(eol, "}())");
  }

  return result;
}

exports.stringify = stringify;
/**
 * Create `toString()` function from replacer.
 */

function replacerToString(replacer) {
  if (!replacer) return stringify_1.toString;
  return function (value, space, next, key) {
    return replacer(value, space, function (value) {
      return stringify_1.toString(value, space, next, key);
    }, key);
  };
}