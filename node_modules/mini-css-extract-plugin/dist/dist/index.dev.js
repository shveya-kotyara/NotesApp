"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackSources = _interopRequireDefault(require("webpack-sources"));

var _CssDependency = _interopRequireDefault(require("./CssDependency"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* eslint-disable class-methods-use-this */


var _webpackSources$defau = _webpackSources["default"],
    ConcatSource = _webpackSources$defau.ConcatSource,
    SourceMapSource = _webpackSources$defau.SourceMapSource,
    OriginalSource = _webpackSources$defau.OriginalSource;
var _webpack$default = _webpack["default"],
    Template = _webpack$default.Template,
    createHash = _webpack$default.util.createHash;
var MODULE_TYPE = 'css/mini-extract';
var pluginName = 'mini-css-extract-plugin';
var REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/i;
var REGEXP_CONTENTHASH = /\[contenthash(?::(\d+))?\]/i;
var REGEXP_NAME = /\[name\]/i;
var REGEXP_PLACEHOLDERS = /\[(name|id|chunkhash)\]/g;
var DEFAULT_FILENAME = '[name].css';

var CssDependencyTemplate =
/*#__PURE__*/
function () {
  function CssDependencyTemplate() {
    _classCallCheck(this, CssDependencyTemplate);
  }

  _createClass(CssDependencyTemplate, [{
    key: "apply",
    value: function apply() {}
  }]);

  return CssDependencyTemplate;
}();

var CssModule =
/*#__PURE__*/
function (_webpack$default$Modu) {
  _inherits(CssModule, _webpack$default$Modu);

  function CssModule(dependency) {
    var _this;

    _classCallCheck(this, CssModule);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CssModule).call(this, MODULE_TYPE, dependency.context));
    _this.id = '';
    _this._identifier = dependency.identifier;
    _this._identifierIndex = dependency.identifierIndex;
    _this.content = dependency.content;
    _this.media = dependency.media;
    _this.sourceMap = dependency.sourceMap;
    return _this;
  } // no source() so webpack doesn't do add stuff to the bundle


  _createClass(CssModule, [{
    key: "size",
    value: function size() {
      return this.content.length;
    }
  }, {
    key: "identifier",
    value: function identifier() {
      return "css ".concat(this._identifier, " ").concat(this._identifierIndex);
    }
  }, {
    key: "readableIdentifier",
    value: function readableIdentifier(requestShortener) {
      return "css ".concat(requestShortener.shorten(this._identifier)).concat(this._identifierIndex ? " (".concat(this._identifierIndex, ")") : '');
    }
  }, {
    key: "nameForCondition",
    value: function nameForCondition() {
      var resource = this._identifier.split('!').pop();

      var idx = resource.indexOf('?');

      if (idx >= 0) {
        return resource.substring(0, idx);
      }

      return resource;
    }
  }, {
    key: "updateCacheModule",
    value: function updateCacheModule(module) {
      this.content = module.content;
      this.media = module.media;
      this.sourceMap = module.sourceMap;
    }
  }, {
    key: "needRebuild",
    value: function needRebuild() {
      return true;
    }
  }, {
    key: "build",
    value: function build(options, compilation, resolver, fileSystem, callback) {
      this.buildInfo = {};
      this.buildMeta = {};
      callback();
    }
  }, {
    key: "updateHash",
    value: function updateHash(hash) {
      _get(_getPrototypeOf(CssModule.prototype), "updateHash", this).call(this, hash);

      hash.update(this.content);
      hash.update(this.media || '');
      hash.update(this.sourceMap ? JSON.stringify(this.sourceMap) : '');
    }
  }]);

  return CssModule;
}(_webpack["default"].Module);

var CssModuleFactory =
/*#__PURE__*/
function () {
  function CssModuleFactory() {
    _classCallCheck(this, CssModuleFactory);
  }

  _createClass(CssModuleFactory, [{
    key: "create",
    value: function create(_ref, callback) {
      var _ref$dependencies = _slicedToArray(_ref.dependencies, 1),
          dependency = _ref$dependencies[0];

      callback(null, new CssModule(dependency));
    }
  }]);

  return CssModuleFactory;
}();

var MiniCssExtractPlugin =
/*#__PURE__*/
function () {
  function MiniCssExtractPlugin() {
    var _this2 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MiniCssExtractPlugin);

    this.options = Object.assign({
      filename: DEFAULT_FILENAME,
      moduleFilename: function moduleFilename() {
        return _this2.options.filename || DEFAULT_FILENAME;
      },
      ignoreOrder: false
    }, options);

    if (!this.options.chunkFilename) {
      var filename = this.options.filename; // Anything changing depending on chunk is fine

      if (filename.match(REGEXP_PLACEHOLDERS)) {
        this.options.chunkFilename = filename;
      } else {
        // Elsewise prefix '[id].' in front of the basename to make it changing
        this.options.chunkFilename = filename.replace(/(^|\/)([^/]*(?:\?|$))/, '$1[id].$2');
      }
    }
  }

  _createClass(MiniCssExtractPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this3 = this;

      compiler.hooks.thisCompilation.tap(pluginName, function (compilation) {
        compilation.dependencyFactories.set(_CssDependency["default"], new CssModuleFactory());
        compilation.dependencyTemplates.set(_CssDependency["default"], new CssDependencyTemplate());
        compilation.mainTemplate.hooks.renderManifest.tap(pluginName, function (result, _ref2) {
          var chunk = _ref2.chunk;
          var renderedModules = Array.from(chunk.modulesIterable).filter(function (module) {
            return module.type === MODULE_TYPE;
          });

          if (renderedModules.length > 0) {
            result.push({
              render: function render() {
                return _this3.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener);
              },
              filenameTemplate: function filenameTemplate(_ref3) {
                var chunkData = _ref3.chunk;
                return _this3.options.moduleFilename(chunkData);
              },
              pathOptions: {
                chunk: chunk,
                contentHashType: MODULE_TYPE
              },
              identifier: "".concat(pluginName, ".").concat(chunk.id),
              hash: chunk.contentHash[MODULE_TYPE]
            });
          }
        });
        compilation.chunkTemplate.hooks.renderManifest.tap(pluginName, function (result, _ref4) {
          var chunk = _ref4.chunk;
          var renderedModules = Array.from(chunk.modulesIterable).filter(function (module) {
            return module.type === MODULE_TYPE;
          });

          if (renderedModules.length > 0) {
            result.push({
              render: function render() {
                return _this3.renderContentAsset(compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener);
              },
              filenameTemplate: _this3.options.chunkFilename,
              pathOptions: {
                chunk: chunk,
                contentHashType: MODULE_TYPE
              },
              identifier: "".concat(pluginName, ".").concat(chunk.id),
              hash: chunk.contentHash[MODULE_TYPE]
            });
          }
        });
        compilation.mainTemplate.hooks.hashForChunk.tap(pluginName, function (hash, chunk) {
          var chunkFilename = _this3.options.chunkFilename;

          if (REGEXP_CHUNKHASH.test(chunkFilename)) {
            hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));
          }

          if (REGEXP_CONTENTHASH.test(chunkFilename)) {
            hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash[MODULE_TYPE] || {}));
          }

          if (REGEXP_NAME.test(chunkFilename)) {
            hash.update(JSON.stringify(chunk.getChunkMaps(true).name));
          }
        });
        compilation.hooks.contentHash.tap(pluginName, function (chunk) {
          var outputOptions = compilation.outputOptions;
          var hashFunction = outputOptions.hashFunction,
              hashDigest = outputOptions.hashDigest,
              hashDigestLength = outputOptions.hashDigestLength;
          var hash = createHash(hashFunction);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = chunk.modulesIterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var m = _step.value;

              if (m.type === MODULE_TYPE) {
                m.updateHash(hash);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var contentHash = chunk.contentHash;
          contentHash[MODULE_TYPE] = hash.digest(hashDigest).substring(0, hashDigestLength);
        });
        var mainTemplate = compilation.mainTemplate;
        mainTemplate.hooks.localVars.tap(pluginName, function (source, chunk) {
          var chunkMap = _this3.getCssChunkObject(chunk);

          if (Object.keys(chunkMap).length > 0) {
            return Template.asString([source, '', '// object to store loaded CSS chunks', 'var installedCssChunks = {', Template.indent(chunk.ids.map(function (id) {
              return "".concat(JSON.stringify(id), ": 0");
            }).join(',\n')), '}']);
          }

          return source;
        });
        mainTemplate.hooks.requireEnsure.tap(pluginName, function (source, chunk, hash) {
          var chunkMap = _this3.getCssChunkObject(chunk);

          if (Object.keys(chunkMap).length > 0) {
            var chunkMaps = chunk.getChunkMaps();
            var crossOriginLoading = mainTemplate.outputOptions.crossOriginLoading;
            var linkHrefPath = mainTemplate.getAssetPath(JSON.stringify(_this3.options.chunkFilename), {
              hash: "\" + ".concat(mainTemplate.renderCurrentHashCode(hash), " + \""),
              hashWithLength: function hashWithLength(length) {
                return "\" + ".concat(mainTemplate.renderCurrentHashCode(hash, length), " + \"");
              },
              chunk: {
                id: '" + chunkId + "',
                hash: "\" + ".concat(JSON.stringify(chunkMaps.hash), "[chunkId] + \""),
                hashWithLength: function hashWithLength(length) {
                  var shortChunkHashMap = Object.create(null);

                  for (var _i2 = 0, _Object$keys = Object.keys(chunkMaps.hash); _i2 < _Object$keys.length; _i2++) {
                    var chunkId = _Object$keys[_i2];

                    if (typeof chunkMaps.hash[chunkId] === 'string') {
                      shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substring(0, length);
                    }
                  }

                  return "\" + ".concat(JSON.stringify(shortChunkHashMap), "[chunkId] + \"");
                },
                contentHash: _defineProperty({}, MODULE_TYPE, "\" + ".concat(JSON.stringify(chunkMaps.contentHash[MODULE_TYPE]), "[chunkId] + \"")),
                contentHashWithLength: _defineProperty({}, MODULE_TYPE, function (length) {
                  var shortContentHashMap = {};
                  var contentHash = chunkMaps.contentHash[MODULE_TYPE];

                  for (var _i3 = 0, _Object$keys2 = Object.keys(contentHash); _i3 < _Object$keys2.length; _i3++) {
                    var chunkId = _Object$keys2[_i3];

                    if (typeof contentHash[chunkId] === 'string') {
                      shortContentHashMap[chunkId] = contentHash[chunkId].substring(0, length);
                    }
                  }

                  return "\" + ".concat(JSON.stringify(shortContentHashMap), "[chunkId] + \"");
                }),
                name: "\" + (".concat(JSON.stringify(chunkMaps.name), "[chunkId]||chunkId) + \"")
              },
              contentHashType: MODULE_TYPE
            });
            return Template.asString([source, '', "// ".concat(pluginName, " CSS loading"), "var cssChunks = ".concat(JSON.stringify(chunkMap), ";"), 'if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);', 'else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {', Template.indent(['promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {', Template.indent(["var href = ".concat(linkHrefPath, ";"), "var fullhref = ".concat(mainTemplate.requireFn, ".p + href;"), 'var existingLinkTags = document.getElementsByTagName("link");', 'for(var i = 0; i < existingLinkTags.length; i++) {', Template.indent(['var tag = existingLinkTags[i];', 'var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");', 'if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return resolve();']), '}', 'var existingStyleTags = document.getElementsByTagName("style");', 'for(var i = 0; i < existingStyleTags.length; i++) {', Template.indent(['var tag = existingStyleTags[i];', 'var dataHref = tag.getAttribute("data-href");', 'if(dataHref === href || dataHref === fullhref) return resolve();']), '}', 'var linkTag = document.createElement("link");', 'linkTag.rel = "stylesheet";', 'linkTag.type = "text/css";', 'linkTag.onload = resolve;', 'linkTag.onerror = function(event) {', Template.indent(['var request = event && event.target && event.target.src || fullhref;', 'var err = new Error("Loading CSS chunk " + chunkId + " failed.\\n(" + request + ")");', 'err.code = "CSS_CHUNK_LOAD_FAILED";', 'err.request = request;', 'delete installedCssChunks[chunkId]', 'linkTag.parentNode.removeChild(linkTag)', 'reject(err);']), '};', 'linkTag.href = fullhref;', crossOriginLoading ? Template.asString(["if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {", Template.indent("linkTag.crossOrigin = ".concat(JSON.stringify(crossOriginLoading), ";")), '}']) : '', 'var head = document.getElementsByTagName("head")[0];', 'head.appendChild(linkTag);']), '}).then(function() {', Template.indent(['installedCssChunks[chunkId] = 0;']), '}));']), '}']);
          }

          return source;
        });
      });
    }
  }, {
    key: "getCssChunkObject",
    value: function getCssChunkObject(mainChunk) {
      var obj = {};
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = mainChunk.getAllAsyncChunks()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var chunk = _step2.value;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = chunk.modulesIterable[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var module = _step3.value;

              if (module.type === MODULE_TYPE) {
                obj[chunk.id] = 1;
                break;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return obj;
    }
  }, {
    key: "renderContentAsset",
    value: function renderContentAsset(compilation, chunk, modules, requestShortener) {
      var _this4 = this;

      var usedModules;

      var _chunk$groupsIterable = _slicedToArray(chunk.groupsIterable, 1),
          chunkGroup = _chunk$groupsIterable[0];

      if (typeof chunkGroup.getModuleIndex2 === 'function') {
        (function () {
          // Store dependencies for modules
          var moduleDependencies = new Map(modules.map(function (m) {
            return [m, new Set()];
          }));
          var moduleDependenciesReasons = new Map(modules.map(function (m) {
            return [m, new Map()];
          })); // Get ordered list of modules per chunk group
          // This loop also gathers dependencies from the ordered lists
          // Lists are in reverse order to allow to use Array.pop()

          var modulesByChunkGroup = Array.from(chunk.groupsIterable, function (cg) {
            var sortedModules = modules.map(function (m) {
              return {
                module: m,
                index: cg.getModuleIndex2(m)
              };
            }) // eslint-disable-next-line no-undefined
            .filter(function (item) {
              return item.index !== undefined;
            }).sort(function (a, b) {
              return b.index - a.index;
            }).map(function (item) {
              return item.module;
            });

            for (var i = 0; i < sortedModules.length; i++) {
              var set = moduleDependencies.get(sortedModules[i]);
              var reasons = moduleDependenciesReasons.get(sortedModules[i]);

              for (var j = i + 1; j < sortedModules.length; j++) {
                var module = sortedModules[j];
                set.add(module);
                var reason = reasons.get(module) || new Set();
                reason.add(cg);
                reasons.set(module, reason);
              }
            }

            return sortedModules;
          }); // set with already included modules in correct order

          usedModules = new Set();

          var unusedModulesFilter = function unusedModulesFilter(m) {
            return !usedModules.has(m);
          };

          while (usedModules.size < modules.length) {
            var success = false;
            var bestMatch = void 0;
            var bestMatchDeps = void 0; // get first module where dependencies are fulfilled

            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = modulesByChunkGroup[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var list = _step4.value;

                // skip and remove already added modules
                while (list.length > 0 && usedModules.has(list[list.length - 1])) {
                  list.pop();
                } // skip empty lists


                if (list.length !== 0) {
                  var module = list[list.length - 1];
                  var deps = moduleDependencies.get(module); // determine dependencies that are not yet included

                  var failedDeps = Array.from(deps).filter(unusedModulesFilter); // store best match for fallback behavior

                  if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {
                    bestMatch = list;
                    bestMatchDeps = failedDeps;
                  }

                  if (failedDeps.length === 0) {
                    // use this module and remove it from list
                    usedModules.add(list.pop());
                    success = true;
                    break;
                  }
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            if (!success) {
              (function () {
                // no module found => there is a conflict
                // use list with fewest failed deps
                // and emit a warning
                var fallbackModule = bestMatch.pop();

                if (!_this4.options.ignoreOrder) {
                  var reasons = moduleDependenciesReasons.get(fallbackModule);
                  compilation.warnings.push(new Error(["chunk ".concat(chunk.name || chunk.id, " [").concat(pluginName, "]"), 'Conflicting order. Following module has been added:', " * ".concat(fallbackModule.readableIdentifier(requestShortener)), 'despite it was not able to fulfill desired ordering with these modules:'].concat(_toConsumableArray(bestMatchDeps.map(function (m) {
                    var goodReasonsMap = moduleDependenciesReasons.get(m);
                    var goodReasons = goodReasonsMap && goodReasonsMap.get(fallbackModule);
                    var failedChunkGroups = Array.from(reasons.get(m), function (cg) {
                      return cg.name;
                    }).join(', ');
                    var goodChunkGroups = goodReasons && Array.from(goodReasons, function (cg) {
                      return cg.name;
                    }).join(', ');
                    return [" * ".concat(m.readableIdentifier(requestShortener)), "   - couldn't fulfill desired order of chunk group(s) ".concat(failedChunkGroups), goodChunkGroups && "   - while fulfilling desired order of chunk group(s) ".concat(goodChunkGroups)].filter(Boolean).join('\n');
                  }))).join('\n')));
                }

                usedModules.add(fallbackModule);
              })();
            }
          }
        })();
      } else {
        // fallback for older webpack versions
        // (to avoid a breaking change)
        // TODO remove this in next major version
        // and increase minimum webpack version to 4.12.0
        modules.sort(function (a, b) {
          return a.index2 - b.index2;
        });
        usedModules = modules;
      }

      var source = new ConcatSource();
      var externalsSource = new ConcatSource();
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = usedModules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var m = _step5.value;

          if (/^@import url/.test(m.content)) {
            // HACK for IE
            // http://stackoverflow.com/a/14676665/1458162
            var content = m.content;

            if (m.media) {
              // insert media into the @import
              // this is rar
              // TODO improve this and parse the CSS to support multiple medias
              content = content.replace(/;|\s*$/, m.media);
            }

            externalsSource.add(content);
            externalsSource.add('\n');
          } else {
            if (m.media) {
              source.add("@media ".concat(m.media, " {\n"));
            }

            if (m.sourceMap) {
              source.add(new SourceMapSource(m.content, m.readableIdentifier(requestShortener), m.sourceMap));
            } else {
              source.add(new OriginalSource(m.content, m.readableIdentifier(requestShortener)));
            }

            source.add('\n');

            if (m.media) {
              source.add('}\n');
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return new ConcatSource(externalsSource, source);
    }
  }]);

  return MiniCssExtractPlugin;
}();

MiniCssExtractPlugin.loader = require.resolve('./loader');
var _default = MiniCssExtractPlugin;
exports["default"] = _default;