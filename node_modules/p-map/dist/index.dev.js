'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var AggregateError = require('aggregate-error');

module.exports = function _callee2(iterable, mapper) {
  var _ref,
      _ref$concurrency,
      concurrency,
      _ref$stopOnError,
      stopOnError,
      _args2 = arguments;

  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _ref = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref$concurrency = _ref.concurrency, concurrency = _ref$concurrency === void 0 ? Infinity : _ref$concurrency, _ref$stopOnError = _ref.stopOnError, stopOnError = _ref$stopOnError === void 0 ? true : _ref$stopOnError;
          return _context2.abrupt("return", new Promise(function (resolve, reject) {
            if (typeof mapper !== 'function') {
              throw new TypeError('Mapper function is required');
            }

            if (!(typeof concurrency === 'number' && concurrency >= 1)) {
              throw new TypeError("Expected `concurrency` to be a number from 1 and up, got `".concat(concurrency, "` (").concat(_typeof(concurrency), ")"));
            }

            var ret = [];
            var errors = [];
            var iterator = iterable[Symbol.iterator]();
            var isRejected = false;
            var isIterableDone = false;
            var resolvingCount = 0;
            var currentIndex = 0;

            var next = function next() {
              if (isRejected) {
                return;
              }

              var nextItem = iterator.next();
              var i = currentIndex;
              currentIndex++;

              if (nextItem.done) {
                isIterableDone = true;

                if (resolvingCount === 0) {
                  if (!stopOnError && errors.length !== 0) {
                    reject(new AggregateError(errors));
                  } else {
                    resolve(ret);
                  }
                }

                return;
              }

              resolvingCount++;

              (function _callee() {
                var element;
                return regeneratorRuntime.async(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        _context.next = 3;
                        return regeneratorRuntime.awrap(nextItem.value);

                      case 3:
                        element = _context.sent;
                        _context.next = 6;
                        return regeneratorRuntime.awrap(mapper(element, i));

                      case 6:
                        ret[i] = _context.sent;
                        resolvingCount--;
                        next();
                        _context.next = 14;
                        break;

                      case 11:
                        _context.prev = 11;
                        _context.t0 = _context["catch"](0);

                        if (stopOnError) {
                          isRejected = true;
                          reject(_context.t0);
                        } else {
                          errors.push(_context.t0);
                          resolvingCount--;
                          next();
                        }

                      case 14:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, null, null, [[0, 11]]);
              })();
            };

            for (var i = 0; i < concurrency; i++) {
              next();

              if (isIterableDone) {
                break;
              }
            }
          }));

        case 2:
        case "end":
          return _context2.stop();
      }
    }
  });
};