"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function resolveModuleName(request, issuer, compilerOptions, moduleResolutionHost, parentResolver) {
  var pnp = require("pnpapi");

  var _request$match = request.match(/^(!(?:.*!)+)?((?!\.{0,2}\/)(?:@[^\/]+\/)?[^\/]+)?(.*)/),
      _request$match2 = _slicedToArray(_request$match, 4),
      _request$match2$ = _request$match2[1],
      prefix = _request$match2$ === void 0 ? "" : _request$match2$,
      _request$match2$2 = _request$match2[2],
      packageName = _request$match2$2 === void 0 ? "" : _request$match2$2,
      rest = _request$match2[3];

  var failedLookupLocations = []; // First we try the resolution on "@types/package-name" starting from the project root

  if (packageName) {
    var typesPackagePath = "@types/".concat(packageName.replace(/\//g, "__")).concat(rest);
    var unqualified;

    try {
      unqualified = pnp.resolveToUnqualified(typesPackagePath, issuer, {
        considerBuiltins: false
      });
    } catch (error) {}

    if (unqualified) {
      // TypeScript checks whether the directory of the candidate is a directory
      // which may cause issues w/ zip loading (since the zip archive is still
      // reported as a file). To workaround this we add a trailing slash, which
      // causes TypeScript to assume the parent is a directory.
      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(unqualified)) unqualified += "/";
      var finalResolution = parentResolver(unqualified, issuer, compilerOptions, moduleResolutionHost);

      if (finalResolution.resolvedModule || finalResolution.resolvedTypeReferenceDirective) {
        return finalResolution;
      } else {
        failedLookupLocations = failedLookupLocations.concat(finalResolution.failedLookupLocations);
      }
    }
  } // Then we try on "package-name", this time starting from the package that makes the request


  if (true) {
    var regularPackagePath = "".concat(packageName || "").concat(rest);

    var _unqualified;

    try {
      _unqualified = pnp.resolveToUnqualified(regularPackagePath, issuer, {
        considerBuiltins: false
      });
    } catch (error) {}

    if (_unqualified) {
      // TypeScript checks whether the directory of the candidate is a directory
      // which may cause issues w/ zip loading (since the zip archive is still
      // reported as a file). To workaround this we add a trailing slash, which
      // causes TypeScript to assume the parent is a directory.
      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(_unqualified)) _unqualified += "/";

      var _finalResolution = parentResolver(_unqualified, issuer, compilerOptions, moduleResolutionHost);

      if (_finalResolution.resolvedModule || _finalResolution.resolvedTypeReferenceDirective) {
        return _finalResolution;
      } else {
        failedLookupLocations = failedLookupLocations.concat(_finalResolution.failedLookupLocations);
      }
    }
  }

  return {
    resolvedModule: undefined,
    resolvedTypeReferenceDirective: undefined,
    failedLookupLocations: failedLookupLocations
  };
}

module.exports.resolveModuleName = process.versions.pnp ? resolveModuleName : function (moduleName, containingFile, compilerOptions, compilerHost, resolveModuleName) {
  return resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost);
};