'use strict';

var assert = require('chai').assert;

var proxyquire = require('proxyquire');

var spooks = require('spooks');

var Promise = require('bluebird');

var modulePath = '../../src/unpipe';
suite('unpipe:', function () {
  test('require does not throw', function () {
    assert.doesNotThrow(function () {
      require(modulePath);
    });
  });
  test('require returns function', function () {
    assert.isFunction(require(modulePath));
  });
  suite('require:', function () {
    var log, results, unpipe;
    setup(function () {
      log = {};
      results = {
        parse: [Promise.resolve()]
      };
      unpipe = proxyquire(modulePath, {
        './parse': spooks.fn({
          name: 'parse',
          log: log,
          results: results.parse
        })
      });
    });
    test('unpipe expects two arguments', function () {
      assert.lengthOf(unpipe, 2);
    });
    test('unpipe does not throw', function () {
      assert.doesNotThrow(function () {
        unpipe(function () {});
      });
    });
    test('unpipe throws if callback is not provided', function () {
      assert["throws"](function () {
        unpipe();
      });
    });
    test('parse was not called', function () {
      assert.strictEqual(log.counts.parse, 0);
    });
    suite('unpipe success:', function () {
      var result, error, options;
      setup(function (done) {
        results.parse[0] = Promise.resolve('foo');
        options = {
          foo: 'bar',
          ndjson: true
        };
        unpipe(function (err, res) {
          error = err;
          result = res;
          done();
        }, options);
      });
      test('parse was called once', function () {
        assert.strictEqual(log.counts.parse, 1);
      });
      test('parse was called correctly', function () {
        assert.isUndefined(log.these.parse[0]);
        assert.lengthOf(log.args.parse[0], 2);
        assert.isObject(log.args.parse[0][0]);
        assert.isTrue(log.args.parse[0][0].readable);
        assert.isTrue(log.args.parse[0][0].writable);
        assert.isFunction(log.args.parse[0][0].pipe);
        assert.isFunction(log.args.parse[0][0].read);
        assert.isFunction(log.args.parse[0][0]._read);
        assert.isFunction(log.args.parse[0][0].write);
        assert.isFunction(log.args.parse[0][0]._write);
        assert.notStrictEqual(log.args.parse[0][1], options);
        assert.deepEqual(log.args.parse[0][1], {
          foo: 'bar',
          ndjson: false
        });
      });
      test('parse result was returned', function () {
        assert.strictEqual(result, 'foo');
      });
      test('did not fail', function () {
        assert.isNull(error);
      });
    });
    suite('unpipe error:', function () {
      var result, error, options;
      setup(function (done) {
        results.parse[0] = Promise.reject('bar');
        options = {};
        unpipe(function (err, res) {
          error = err;
          result = res;
          done();
        }, options);
      });
      test('parse was called once', function () {
        assert.strictEqual(log.counts.parse, 1);
      });
      test('parse result was not returned', function () {
        assert.isUndefined(result);
      });
      test('failed', function () {
        assert.strictEqual(error, 'bar');
      });
    });
  });
});