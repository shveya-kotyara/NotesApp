'use strict';

var check = require('check-types');

var error = require('./error');

var EventEmitter = require('events').EventEmitter;

var events = require('./events');

var promise = require('./promise');

var terminators = {
  obj: '}',
  arr: ']'
};
var escapes = {
  /* eslint-disable quote-props */
  '"': '"',
  '\\': '\\',
  '/': '/',
  'b': '\b',
  'f': '\f',
  'n': '\n',
  'r': '\r',
  't': '\t'
  /* eslint-enable quote-props */

};
module.exports = initialise;
/**
 * Public function `walk`.
 *
 * Returns an event emitter and asynchronously walks a stream of JSON data,
 * emitting events as it encounters tokens. The event emitter is decorated
 * with a `pause` method that can be called to pause processing.
 *
 * @param stream:     Readable instance representing the incoming JSON.
 *
 * @option yieldRate: The number of data items to process per timeslice,
 *                    default is 16384.
 *
 * @option Promise:   The promise constructor to use, defaults to bluebird.
 *
 * @option ndjson:    Set this to true to parse newline-delimited JSON.
 **/

function initialise(stream) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  check.assert.instanceStrict(stream, require('stream').Readable, 'Invalid stream argument');
  var currentPosition = {
    line: 1,
    column: 1
  };
  var emitter = new EventEmitter();
  var handlers = {
    arr: value,
    obj: property
  };
  var json = [];
  var lengths = [];
  var previousPosition = {};
  var Promise = promise(options);
  var scopes = [];
  var yieldRate = options.yieldRate || 16384;
  var shouldHandleNdjson = !!options.ndjson;
  var index = 0;
  var isStreamEnded = false;
  var isWalkBegun = false;
  var isWalkEnded = false;
  var isWalkingString = false;
  var hasEndedLine = true;
  var count = 0;
  var resumeFn;
  var pause;
  var cachedCharacter;
  stream.setEncoding('utf8');
  stream.on('data', readStream);
  stream.on('end', endStream);
  stream.on('error', function (err) {
    emitter.emit(events.error, err);
    endStream();
  });

  emitter.pause = function () {
    var resolve;
    pause = new Promise(function (res) {
      return resolve = res;
    });
    return function () {
      pause = null;
      count = 0;

      if (shouldHandleNdjson && isStreamEnded && isWalkEnded) {
        emit(events.end);
      } else {
        resolve();
      }
    };
  };

  return emitter;

  function readStream(chunk) {
    addChunk(chunk);

    if (isWalkBegun) {
      return resume();
    }

    isWalkBegun = true;
    value();
  }

  function addChunk(chunk) {
    json.push(chunk);
    var chunkLength = chunk.length;
    lengths.push({
      item: chunkLength,
      aggregate: length() + chunkLength
    });
  }

  function length() {
    var chunkCount = lengths.length;

    if (chunkCount === 0) {
      return 0;
    }

    return lengths[chunkCount - 1].aggregate;
  }

  function value() {
    /* eslint-disable no-underscore-dangle */
    if (++count % yieldRate !== 0) {
      return _do();
    }

    return new Promise(function (resolve) {
      setImmediate(function () {
        return _do().then(resolve);
      });
    });

    function _do() {
      return awaitNonWhitespace().then(next).then(handleValue)["catch"](function () {});
    }
    /* eslint-enable no-underscore-dangle */

  }

  function awaitNonWhitespace() {
    return wait();

    function wait() {
      return awaitCharacter().then(step);
    }

    function step() {
      if (isWhitespace(character())) {
        return next().then(wait);
      }
    }
  }

  function awaitCharacter() {
    var resolve, reject;

    if (index < length()) {
      return Promise.resolve();
    }

    if (isStreamEnded) {
      setImmediate(endWalk);
      return Promise.reject();
    }

    resumeFn = after;
    return new Promise(function (res, rej) {
      resolve = res;
      reject = rej;
    });

    function after() {
      if (index < length()) {
        return resolve();
      }

      reject();

      if (isStreamEnded) {
        setImmediate(endWalk);
      }
    }
  }

  function character() {
    if (cachedCharacter) {
      return cachedCharacter;
    }

    if (lengths[0].item > index) {
      return cachedCharacter = json[0][index];
    }

    var len = lengths.length;

    for (var i = 1; i < len; ++i) {
      var _lengths$i = lengths[i],
          aggregate = _lengths$i.aggregate,
          item = _lengths$i.item;

      if (aggregate > index) {
        return cachedCharacter = json[i][index + item - aggregate];
      }
    }
  }

  function isWhitespace(_char) {
    switch (_char) {
      case '\n':
        if (shouldHandleNdjson && scopes.length === 0) {
          return false;
        }

      case ' ':
      case '\t':
      case '\r':
        return true;
    }

    return false;
  }

  function next() {
    return awaitCharacter().then(after);

    function after() {
      var result = character();
      cachedCharacter = null;
      index += 1;
      previousPosition.line = currentPosition.line;
      previousPosition.column = currentPosition.column;

      if (result === '\n') {
        currentPosition.line += 1;
        currentPosition.column = 1;
      } else {
        currentPosition.column += 1;
      }

      if (index > lengths[0].aggregate) {
        json.shift();
        var difference = lengths.shift().item;
        index -= difference;
        lengths.forEach(function (len) {
          return len.aggregate -= difference;
        });
      }

      return result;
    }
  }

  function handleValue(_char2) {
    if (shouldHandleNdjson && scopes.length === 0) {
      if (_char2 === '\n') {
        hasEndedLine = true;
        return emit(events.endLine).then(value);
      }

      if (!hasEndedLine) {
        return fail(_char2, '\n', previousPosition).then(value);
      }

      hasEndedLine = false;
    }

    switch (_char2) {
      case '[':
        return array();

      case '{':
        return object();

      case '"':
        return string();

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
      case '.':
        return number(_char2);

      case 'f':
        return literalFalse();

      case 'n':
        return literalNull();

      case 't':
        return literalTrue();

      default:
        return fail(_char2, 'value', previousPosition).then(value);
    }
  }

  function array() {
    return scope(events.array, value);
  }

  function scope(event, contentHandler) {
    return emit(event).then(function () {
      scopes.push(event);
      return endScope(event);
    }).then(contentHandler);
  }

  function emit() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (pause || Promise.resolve()).then(function () {
      try {
        emitter.emit.apply(emitter, args);
      } catch (err) {
        try {
          emitter.emit(events.error, err);
        } catch (_) {// When calling user code, anything is possible
        }
      }
    });
  }

  function endScope(scp) {
    return awaitNonWhitespace().then(function () {
      if (character() === terminators[scp]) {
        return emit(events.endPrefix + scp).then(function () {
          scopes.pop();
          return next();
        }).then(endValue);
      }
    })["catch"](endWalk);
  }

  function endValue() {
    return awaitNonWhitespace().then(after)["catch"](endWalk);

    function after() {
      if (scopes.length === 0) {
        if (shouldHandleNdjson) {
          return value();
        }

        return fail(character(), 'EOF', currentPosition).then(value);
      }

      return checkScope();
    }

    function checkScope() {
      var scp = scopes[scopes.length - 1];
      var handler = handlers[scp];
      return endScope(scp).then(function () {
        if (scopes.length > 0) {
          return checkCharacter(character(), ',', currentPosition);
        }
      }).then(function (result) {
        if (result) {
          return next();
        }
      }).then(handler);
    }
  }

  function fail(actual, expected, position) {
    return emit(events.dataError, error.create(actual, expected, position.line, position.column));
  }

  function checkCharacter(_char3, expected, position) {
    if (_char3 === expected) {
      return Promise.resolve(true);
    }

    return fail(_char3, expected, position).then(false);
  }

  function object() {
    return scope(events.object, property);
  }

  function property() {
    return awaitNonWhitespace().then(next).then(propertyName);
  }

  function propertyName(_char4) {
    return checkCharacter(_char4, '"', previousPosition).then(function () {
      return walkString(events.property);
    }).then(awaitNonWhitespace).then(next).then(propertyValue);
  }

  function propertyValue(_char5) {
    return checkCharacter(_char5, ':', previousPosition).then(value);
  }

  function walkString(event) {
    var isEscaping = false;
    var str = [];
    isWalkingString = true;
    return next().then(step);

    function step(_char6) {
      if (isEscaping) {
        isEscaping = false;
        return escape(_char6).then(function (escaped) {
          str.push(escaped);
          return next().then(step);
        });
      }

      if (_char6 === '\\') {
        isEscaping = true;
        return next().then(step);
      }

      if (_char6 !== '"') {
        str.push(_char6);
        return next().then(step);
      }

      isWalkingString = false;
      return emit(event, str.join(''));
    }
  }

  function escape(_char7) {
    if (escapes[_char7]) {
      return Promise.resolve(escapes[_char7]);
    }

    if (_char7 === 'u') {
      return escapeHex();
    }

    return fail(_char7, 'escape character', previousPosition).then(function () {
      return "\\".concat(_char7);
    });
  }

  function escapeHex() {
    var hexits = [];
    return next().then(step.bind(null, 0));

    function step(idx, _char8) {
      if (isHexit(_char8)) {
        hexits.push(_char8);
      }

      if (idx < 3) {
        return next().then(step.bind(null, idx + 1));
      }

      hexits = hexits.join('');

      if (hexits.length === 4) {
        return String.fromCharCode(parseInt(hexits, 16));
      }

      return fail(_char8, 'hex digit', previousPosition).then(function () {
        return "\\u".concat(hexits).concat(_char8);
      });
    }
  }

  function string() {
    return walkString(events.string).then(endValue);
  }

  function number(firstCharacter) {
    var digits = [firstCharacter];
    return walkDigits().then(addDigits.bind(null, checkDecimalPlace));

    function addDigits(step, result) {
      digits = digits.concat(result.digits);

      if (result.atEnd) {
        return endNumber();
      }

      return step();
    }

    function checkDecimalPlace() {
      if (character() === '.') {
        return next().then(function (_char9) {
          digits.push(_char9);
          return walkDigits();
        }).then(addDigits.bind(null, checkExponent));
      }

      return checkExponent();
    }

    function checkExponent() {
      if (character() === 'e' || character() === 'E') {
        return next().then(function (_char10) {
          digits.push(_char10);
          return awaitCharacter();
        }).then(checkSign)["catch"](fail.bind(null, 'EOF', 'exponent', currentPosition));
      }

      return endNumber();
    }

    function checkSign() {
      if (character() === '+' || character() === '-') {
        return next().then(function (_char11) {
          digits.push(_char11);
          return readExponent();
        });
      }

      return readExponent();
    }

    function readExponent() {
      return walkDigits().then(addDigits.bind(null, endNumber));
    }

    function endNumber() {
      return emit(events.number, parseFloat(digits.join(''))).then(endValue);
    }
  }

  function walkDigits() {
    var digits = [];
    return wait();

    function wait() {
      return awaitCharacter().then(step)["catch"](atEnd);
    }

    function step() {
      if (isDigit(character())) {
        return next().then(function (_char12) {
          digits.push(_char12);
          return wait();
        });
      }

      return {
        digits: digits,
        atEnd: false
      };
    }

    function atEnd() {
      return {
        digits: digits,
        atEnd: true
      };
    }
  }

  function literalFalse() {
    return literal(['a', 'l', 's', 'e'], false);
  }

  function literal(expectedCharacters, val) {
    var actual, expected, invalid;
    return wait();

    function wait() {
      return awaitCharacter().then(step)["catch"](atEnd);
    }

    function step() {
      if (invalid || expectedCharacters.length === 0) {
        return atEnd();
      }

      return next().then(afterNext);
    }

    function atEnd() {
      return Promise.resolve().then(function () {
        if (invalid) {
          return fail(actual, expected, previousPosition);
        }

        if (expectedCharacters.length > 0) {
          return fail('EOF', expectedCharacters.shift(), currentPosition);
        }

        return done();
      }).then(endValue);
    }

    function afterNext(_char13) {
      actual = _char13;
      expected = expectedCharacters.shift();

      if (actual !== expected) {
        invalid = true;
      }

      return wait();
    }

    function done() {
      return emit(events.literal, val);
    }
  }

  function literalNull() {
    return literal(['u', 'l', 'l'], null);
  }

  function literalTrue() {
    return literal(['r', 'u', 'e'], true);
  }

  function endStream() {
    isStreamEnded = true;

    if (isWalkBegun) {
      return resume();
    }

    endWalk();
  }

  function resume() {
    if (resumeFn) {
      resumeFn();
      resumeFn = null;
    }
  }

  function endWalk() {
    if (isWalkEnded) {
      return Promise.resolve();
    }

    isWalkEnded = true;
    return Promise.resolve().then(function () {
      if (isWalkingString) {
        return fail('EOF', '"', currentPosition);
      }
    }).then(popScopes).then(function () {
      return emit(events.end);
    });
  }

  function popScopes() {
    if (scopes.length === 0) {
      return Promise.resolve();
    }

    return fail('EOF', terminators[scopes.pop()], currentPosition).then(popScopes);
  }
}

function isHexit(character) {
  return isDigit(character) || isInRange(character, 'A', 'F') || isInRange(character, 'a', 'f');
}

function isDigit(character) {
  return isInRange(character, '0', '9');
}

function isInRange(character, lower, upper) {
  var code = character.charCodeAt(0);
  return code >= lower.charCodeAt(0) && code <= upper.charCodeAt(0);
}