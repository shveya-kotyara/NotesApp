'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var stringWidth = require('string-width');

var stripAnsi = require('strip-ansi');

var wrap = require('wrap-ansi');

var align = {
  right: alignRight,
  center: alignCenter
};
var top = 0;
var right = 1;
var bottom = 2;
var left = 3;

var UI =
/*#__PURE__*/
function () {
  function UI(opts) {
    _classCallCheck(this, UI);

    this.width = opts.width;
    this.wrap = opts.wrap;
    this.rows = [];
  }

  _createClass(UI, [{
    key: "span",
    value: function span() {
      var cols = this.div.apply(this, arguments);
      cols.span = true;
    }
  }, {
    key: "resetOutput",
    value: function resetOutput() {
      this.rows = [];
    }
  }, {
    key: "div",
    value: function div() {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args.length === 0) {
        this.div('');
      }

      if (this.wrap && this._shouldApplyLayoutDSL.apply(this, args)) {
        return this._applyLayoutDSL(args[0]);
      }

      var cols = args.map(function (arg) {
        if (typeof arg === 'string') {
          return _this._colFromString(arg);
        }

        return arg;
      });
      this.rows.push(cols);
      return cols;
    }
  }, {
    key: "_shouldApplyLayoutDSL",
    value: function _shouldApplyLayoutDSL() {
      return arguments.length === 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string' && /[\t\n]/.test(arguments.length <= 0 ? undefined : arguments[0]);
    }
  }, {
    key: "_applyLayoutDSL",
    value: function _applyLayoutDSL(str) {
      var _this2 = this;

      var rows = str.split('\n').map(function (row) {
        return row.split('\t');
      });
      var leftColumnWidth = 0; // simple heuristic for layout, make sure the
      // second column lines up along the left-hand.
      // don't allow the first column to take up more
      // than 50% of the screen.

      rows.forEach(function (columns) {
        if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {
          leftColumnWidth = Math.min(Math.floor(_this2.width * 0.5), stringWidth(columns[0]));
        }
      }); // generate a table:
      //  replacing ' ' with padding calculations.
      //  using the algorithmically generated width.

      rows.forEach(function (columns) {
        _this2.div.apply(_this2, _toConsumableArray(columns.map(function (r, i) {
          return {
            text: r.trim(),
            padding: _this2._measurePadding(r),
            width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined
          };
        })));
      });
      return this.rows[this.rows.length - 1];
    }
  }, {
    key: "_colFromString",
    value: function _colFromString(text) {
      return {
        text: text,
        padding: this._measurePadding(text)
      };
    }
  }, {
    key: "_measurePadding",
    value: function _measurePadding(str) {
      // measure padding without ansi escape codes
      var noAnsi = stripAnsi(str);
      return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
  }, {
    key: "toString",
    value: function toString() {
      var _this3 = this;

      var lines = [];
      this.rows.forEach(function (row) {
        _this3.rowToString(row, lines);
      }); // don't display any lines with the
      // hidden flag set.

      return lines.filter(function (line) {
        return !line.hidden;
      }).map(function (line) {
        return line.text;
      }).join('\n');
    }
  }, {
    key: "rowToString",
    value: function rowToString(row, lines) {
      var _this4 = this;

      this._rasterize(row).forEach(function (rrow, r) {
        var str = '';
        rrow.forEach(function (col, c) {
          var width = row[c].width; // the width with padding.

          var wrapWidth = _this4._negatePadding(row[c]); // the width without padding.


          var ts = col; // temporary string used during alignment/padding.

          if (wrapWidth > stringWidth(col)) {
            ts += ' '.repeat(wrapWidth - stringWidth(col));
          } // align the string within its column.


          if (row[c].align && row[c].align !== 'left' && _this4.wrap) {
            ts = align[row[c].align](ts, wrapWidth);

            if (stringWidth(ts) < wrapWidth) {
              ts += ' '.repeat(width - stringWidth(ts) - 1);
            }
          } // apply border and padding to string.


          var padding = row[c].padding || [0, 0, 0, 0];

          if (padding[left]) {
            str += ' '.repeat(padding[left]);
          }

          str += addBorder(row[c], ts, '| ');
          str += ts;
          str += addBorder(row[c], ts, ' |');

          if (padding[right]) {
            str += ' '.repeat(padding[right]);
          } // if prior row is span, try to render the
          // current row on the prior line.


          if (r === 0 && lines.length > 0) {
            str = _this4._renderInline(str, lines[lines.length - 1]);
          }
        }); // remove trailing whitespace.

        lines.push({
          text: str.replace(/ +$/, ''),
          span: row.span
        });
      });

      return lines;
    } // if the full 'source' can render in
    // the target line, do so.

  }, {
    key: "_renderInline",
    value: function _renderInline(source, previousLine) {
      var leadingWhitespace = source.match(/^ */)[0].length;
      var target = previousLine.text;
      var targetTextWidth = stringWidth(target.trimRight());

      if (!previousLine.span) {
        return source;
      } // if we're not applying wrapping logic,
      // just always append to the span.


      if (!this.wrap) {
        previousLine.hidden = true;
        return target + source;
      }

      if (leadingWhitespace < targetTextWidth) {
        return source;
      }

      previousLine.hidden = true;
      return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
  }, {
    key: "_rasterize",
    value: function _rasterize(row) {
      var _this5 = this;

      var rrows = [];

      var widths = this._columnWidths(row);

      var wrapped; // word wrap all columns, and create
      // a data-structure that is easy to rasterize.

      row.forEach(function (col, c) {
        // leave room for left and right padding.
        col.width = widths[c];

        if (_this5.wrap) {
          wrapped = wrap(col.text, _this5._negatePadding(col), {
            hard: true
          }).split('\n');
        } else {
          wrapped = col.text.split('\n');
        }

        if (col.border) {
          wrapped.unshift('.' + '-'.repeat(_this5._negatePadding(col) + 2) + '.');
          wrapped.push("'" + '-'.repeat(_this5._negatePadding(col) + 2) + "'");
        } // add top and bottom padding.


        if (col.padding) {
          var _wrapped, _wrapped2;

          (_wrapped = wrapped).unshift.apply(_wrapped, _toConsumableArray(new Array(col.padding[top] || 0).fill('')));

          (_wrapped2 = wrapped).push.apply(_wrapped2, _toConsumableArray(new Array(col.padding[bottom] || 0).fill('')));
        }

        wrapped.forEach(function (str, r) {
          if (!rrows[r]) {
            rrows.push([]);
          }

          var rrow = rrows[r];

          for (var i = 0; i < c; i++) {
            if (rrow[i] === undefined) {
              rrow.push('');
            }
          }

          rrow.push(str);
        });
      });
      return rrows;
    }
  }, {
    key: "_negatePadding",
    value: function _negatePadding(col) {
      var wrapWidth = col.width;

      if (col.padding) {
        wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
      }

      if (col.border) {
        wrapWidth -= 4;
      }

      return wrapWidth;
    }
  }, {
    key: "_columnWidths",
    value: function _columnWidths(row) {
      if (!this.wrap) {
        return row.map(function (col) {
          return col.width || stringWidth(col.text);
        });
      }

      var unset = row.length;
      var remainingWidth = this.width; // column widths can be set in config.

      var widths = row.map(function (col) {
        if (col.width) {
          unset--;
          remainingWidth -= col.width;
          return col.width;
        }

        return undefined;
      }); // any unset widths should be calculated.

      var unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
      return widths.map(function (w, i) {
        if (w === undefined) {
          return Math.max(unsetWidth, _minWidth(row[i]));
        }

        return w;
      });
    }
  }]);

  return UI;
}();

function addBorder(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return '';
    }

    if (ts.trim().length !== 0) {
      return style;
    }

    return '  ';
  }

  return '';
} // calculates the minimum width of
// a column, based on padding preferences.


function _minWidth(col) {
  var padding = col.padding || [];
  var minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);

  if (col.border) {
    return minWidth + 4;
  }

  return minWidth;
}

function getWindowWidth() {
  /* istanbul ignore next: depends on terminal */
  if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
}

function alignRight(str, width) {
  str = str.trim();
  var strWidth = stringWidth(str);

  if (strWidth < width) {
    return ' '.repeat(width - strWidth) + str;
  }

  return str;
}

function alignCenter(str, width) {
  str = str.trim();
  var strWidth = stringWidth(str);
  /* istanbul ignore next */

  if (strWidth >= width) {
    return str;
  }

  return ' '.repeat(width - strWidth >> 1) + str;
}

module.exports = function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new UI({
    width: opts.width || getWindowWidth() ||
    /* istanbul ignore next */
    80,
    wrap: opts.wrap !== false
  });
};