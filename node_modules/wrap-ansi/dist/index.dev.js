'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var stringWidth = require('string-width');

var stripAnsi = require('strip-ansi');

var ansiStyles = require('ansi-styles');

var ESCAPES = new Set(["\x1B", "\x9B"]);
var END_CODE = 39;

var wrapAnsi = function wrapAnsi(code) {
  return "".concat(ESCAPES.values().next().value, "[").concat(code, "m");
}; // Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes


var wordLengths = function wordLengths(string) {
  return string.split(' ').map(function (character) {
    return stringWidth(character);
  });
}; // Wrap a long word across multiple rows
// Ansi escape codes do not count towards length


var wrapWord = function wrapWord(rows, word, columns) {
  var characters = _toConsumableArray(word);

  var isInsideEscape = false;
  var visible = stringWidth(stripAnsi(rows[rows.length - 1]));
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = characters.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2),
          index = _step$value[0],
          character = _step$value[1];

      var characterLength = stringWidth(character);

      if (visible + characterLength <= columns) {
        rows[rows.length - 1] += character;
      } else {
        rows.push(character);
        visible = 0;
      }

      if (ESCAPES.has(character)) {
        isInsideEscape = true;
      } else if (isInsideEscape && character === 'm') {
        isInsideEscape = false;
        continue;
      }

      if (isInsideEscape) {
        continue;
      }

      visible += characterLength;

      if (visible === columns && index < characters.length - 1) {
        rows.push('');
        visible = 0;
      }
    } // It's possible that the last row we copy over is only
    // ansi escape characters, handle this edge-case

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
    rows[rows.length - 2] += rows.pop();
  }
}; // Trims spaces from a string ignoring invisible sequences


var stringVisibleTrimSpacesRight = function stringVisibleTrimSpacesRight(str) {
  var words = str.split(' ');
  var last = words.length;

  while (last > 0) {
    if (stringWidth(words[last - 1]) > 0) {
      break;
    }

    last--;
  }

  if (last === words.length) {
    return str;
  }

  return words.slice(0, last).join(' ') + words.slice(last).join('');
}; // The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length


var exec = function exec(string, columns) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.trim !== false && string.trim() === '') {
    return '';
  }

  var pre = '';
  var ret = '';
  var escapeCode;
  var lengths = wordLengths(string);
  var rows = [''];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = string.split(' ').entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          index = _step2$value[0],
          word = _step2$value[1];

      if (options.trim !== false) {
        rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
      }

      var rowLength = stringWidth(rows[rows.length - 1]);

      if (index !== 0) {
        if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
          // If we start with a new word but the current row length equals the length of the columns, add a new row
          rows.push('');
          rowLength = 0;
        }

        if (rowLength > 0 || options.trim === false) {
          rows[rows.length - 1] += ' ';
          rowLength++;
        }
      } // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'


      if (options.hard && lengths[index] > columns) {
        var remainingColumns = columns - rowLength;
        var breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
        var breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);

        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push('');
        }

        wrapWord(rows, word, columns);
        continue;
      }

      if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
        if (options.wordWrap === false && rowLength < columns) {
          wrapWord(rows, word, columns);
          continue;
        }

        rows.push('');
      }

      if (rowLength + lengths[index] > columns && options.wordWrap === false) {
        wrapWord(rows, word, columns);
        continue;
      }

      rows[rows.length - 1] += word;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (options.trim !== false) {
    rows = rows.map(stringVisibleTrimSpacesRight);
  }

  pre = rows.join('\n');
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = _toConsumableArray(pre).entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          _index = _step3$value[0],
          character = _step3$value[1];

      ret += character;

      if (ESCAPES.has(character)) {
        var _code = parseFloat(/\d[^m]*/.exec(pre.slice(_index, _index + 4)));

        escapeCode = _code === END_CODE ? null : _code;
      }

      var code = ansiStyles.codes.get(Number(escapeCode));

      if (escapeCode && code) {
        if (pre[_index + 1] === '\n') {
          ret += wrapAnsi(code);
        } else if (character === '\n') {
          ret += wrapAnsi(escapeCode);
        }
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return ret;
}; // For each newline, invoke the method separately


module.exports = function (string, columns, options) {
  return String(string).normalize().replace(/\r\n/g, '\n').split('\n').map(function (line) {
    return exec(line, columns, options);
  }).join('\n');
};