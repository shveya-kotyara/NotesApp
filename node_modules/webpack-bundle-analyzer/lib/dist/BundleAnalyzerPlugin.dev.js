"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var bfj = require('bfj');

var path = require('path');

var mkdir = require('mkdirp');

var _require = require('chalk'),
    bold = _require.bold;

var Logger = require('./Logger');

var viewer = require('./viewer');

var utils = require('./utils');

var BundleAnalyzerPlugin =
/*#__PURE__*/
function () {
  function BundleAnalyzerPlugin() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BundleAnalyzerPlugin);

    this.opts = _objectSpread({
      analyzerMode: 'server',
      analyzerHost: '127.0.0.1',
      reportFilename: null,
      reportTitle: utils.defaultTitle,
      defaultSizes: 'parsed',
      openAnalyzer: true,
      generateStatsFile: false,
      statsFilename: 'stats.json',
      statsOptions: null,
      excludeAssets: null,
      logLevel: 'info',
      // deprecated
      startAnalyzer: true
    }, opts, {
      analyzerPort: 'analyzerPort' in opts ? opts.analyzerPort === 'auto' ? 0 : opts.analyzerPort : 8888
    });
    this.server = null;
    this.logger = new Logger(this.opts.logLevel);
  }

  _createClass(BundleAnalyzerPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this5 = this;

      this.compiler = compiler;

      var done = function done(stats, callback) {
        callback = callback || function () {};

        var actions = [];

        if (_this5.opts.generateStatsFile) {
          actions.push(function () {
            return _this5.generateStatsFile(stats.toJson(_this5.opts.statsOptions));
          });
        } // Handling deprecated `startAnalyzer` flag


        if (_this5.opts.analyzerMode === 'server' && !_this5.opts.startAnalyzer) {
          _this5.opts.analyzerMode = 'disabled';
        }

        if (_this5.opts.analyzerMode === 'server') {
          actions.push(function () {
            return _this5.startAnalyzerServer(stats.toJson());
          });
        } else if (_this5.opts.analyzerMode === 'static') {
          actions.push(function () {
            return _this5.generateStaticReport(stats.toJson());
          });
        } else if (_this5.opts.analyzerMode === 'json') {
          actions.push(function () {
            return _this5.generateJSONReport(stats.toJson());
          });
        }

        if (actions.length) {
          // Making analyzer logs to be after all webpack logs in the console
          setImmediate(
          /*#__PURE__*/
          _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    _context.next = 3;
                    return Promise.all(actions.map(function (action) {
                      return action();
                    }));

                  case 3:
                    callback();
                    _context.next = 9;
                    break;

                  case 6:
                    _context.prev = 6;
                    _context.t0 = _context["catch"](0);
                    callback(_context.t0);

                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[0, 6]]);
          })));
        } else {
          callback();
        }
      };

      if (compiler.hooks) {
        compiler.hooks.done.tapAsync('webpack-bundle-analyzer', done);
      } else {
        compiler.plugin('done', done);
      }
    }
  }, {
    key: "generateStatsFile",
    value: function generateStatsFile(stats) {
      var _this = this;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var statsFilepath;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                statsFilepath = path.resolve(_this.compiler.outputPath, _this.opts.statsFilename);
                mkdir.sync(path.dirname(statsFilepath));
                _context2.prev = 2;
                _context2.next = 5;
                return bfj.write(statsFilepath, stats, {
                  space: 2,
                  promises: 'ignore',
                  buffers: 'ignore',
                  maps: 'ignore',
                  iterables: 'ignore',
                  circular: 'ignore'
                });

              case 5:
                _this.logger.info("".concat(bold('Webpack Bundle Analyzer'), " saved stats file to ").concat(bold(statsFilepath)));

                _context2.next = 11;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);

                _this.logger.error("".concat(bold('Webpack Bundle Analyzer'), " error saving stats file to ").concat(bold(statsFilepath), ": ").concat(_context2.t0));

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 8]]);
      }))();
    }
  }, {
    key: "startAnalyzerServer",
    value: function startAnalyzerServer(stats) {
      var _this2 = this;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!_this2.server) {
                  _context3.next = 7;
                  break;
                }

                _context3.next = 3;
                return _this2.server;

              case 3:
                _context3.t0 = stats;

                _context3.sent.updateChartData(_context3.t0);

                _context3.next = 8;
                break;

              case 7:
                _this2.server = viewer.startServer(stats, {
                  openBrowser: _this2.opts.openAnalyzer,
                  host: _this2.opts.analyzerHost,
                  port: _this2.opts.analyzerPort,
                  reportTitle: _this2.opts.reportTitle,
                  bundleDir: _this2.getBundleDirFromCompiler(),
                  logger: _this2.logger,
                  defaultSizes: _this2.opts.defaultSizes,
                  excludeAssets: _this2.opts.excludeAssets
                });

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    }
  }, {
    key: "generateJSONReport",
    value: function generateJSONReport(stats) {
      var _this3 = this;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return viewer.generateJSONReport(stats, {
                  reportFilename: path.resolve(_this3.compiler.outputPath, _this3.opts.reportFilename || 'report.json'),
                  bundleDir: _this3.getBundleDirFromCompiler(),
                  logger: _this3.logger,
                  excludeAssets: _this3.opts.excludeAssets
                });

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    }
  }, {
    key: "generateStaticReport",
    value: function generateStaticReport(stats) {
      var _this4 = this;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return viewer.generateReport(stats, {
                  openBrowser: _this4.opts.openAnalyzer,
                  reportFilename: path.resolve(_this4.compiler.outputPath, _this4.opts.reportFilename || 'report.html'),
                  reportTitle: _this4.opts.reportTitle,
                  bundleDir: _this4.getBundleDirFromCompiler(),
                  logger: _this4.logger,
                  defaultSizes: _this4.opts.defaultSizes,
                  excludeAssets: _this4.opts.excludeAssets
                });

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }))();
    }
  }, {
    key: "getBundleDirFromCompiler",
    value: function getBundleDirFromCompiler() {
      switch (this.compiler.outputFileSystem.constructor.name) {
        case 'MemoryFileSystem':
          return null;
        // Detect AsyncMFS used by Nuxt 2.5 that replaces webpack's MFS during development
        // Related: #274

        case 'AsyncMFS':
          return null;

        default:
          return this.compiler.outputPath;
      }
    }
  }]);

  return BundleAnalyzerPlugin;
}();

module.exports = BundleAnalyzerPlugin;