"use strict";

var fs = require('fs');

var path = require('path');

var _ = require('lodash');

var gzipSize = require('gzip-size');

var Logger = require('./Logger');

var Folder = require('./tree/Folder')["default"];

var _require = require('./parseUtils'),
    parseBundle = _require.parseBundle;

var _require2 = require('./utils'),
    createAssetsFilter = _require2.createAssetsFilter;

var FILENAME_QUERY_REGEXP = /\?(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*$/;
var FILENAME_EXTENSIONS = /\.(j[s\u017F]|mj[s\u017F])$/i;
module.exports = {
  getViewerData: getViewerData,
  readStatsFromFile: readStatsFromFile
};

function getViewerData(bundleStats, bundleDir, opts) {
  var _ref = opts || {},
      _ref$logger = _ref.logger,
      logger = _ref$logger === void 0 ? new Logger() : _ref$logger,
      _ref$excludeAssets = _ref.excludeAssets,
      excludeAssets = _ref$excludeAssets === void 0 ? null : _ref$excludeAssets;

  var isAssetIncluded = createAssetsFilter(excludeAssets); // Sometimes all the information is located in `children` array (e.g. problem in #10)

  if (_.isEmpty(bundleStats.assets) && !_.isEmpty(bundleStats.children)) {
    var _bundleStats = bundleStats,
        children = _bundleStats.children;
    bundleStats = bundleStats.children[0]; // Sometimes if there are additional child chunks produced add them as child assets,
    // leave the 1st one as that is considered the 'root' asset.

    for (var i = 1; i < children.length; i++) {
      bundleStats.children[i].assets.forEach(function (asset) {
        asset.isChild = true;
        bundleStats.assets.push(asset);
      });
    }
  } else if (!_.isEmpty(bundleStats.children)) {
    // Sometimes if there are additional child chunks produced add them as child assets
    bundleStats.children.forEach(function (child) {
      child.assets.forEach(function (asset) {
        asset.isChild = true;
        bundleStats.assets.push(asset);
      });
    });
  } // Picking only `*.js or *.mjs` assets from bundle that has non-empty `chunks` array


  bundleStats.assets = _.filter(bundleStats.assets, function (asset) {
    // Removing query part from filename (yes, somebody uses it for some reason and Webpack supports it)
    // See #22
    asset.name = asset.name.replace(FILENAME_QUERY_REGEXP, '');
    return FILENAME_EXTENSIONS.test(asset.name) && !_.isEmpty(asset.chunks) && isAssetIncluded(asset.name);
  }); // Trying to parse bundle assets and get real module sizes if `bundleDir` is provided

  var bundlesSources = null;
  var parsedModules = null;

  if (bundleDir) {
    bundlesSources = {};
    parsedModules = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = bundleStats.assets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var statAsset = _step.value;
        var assetFile = path.join(bundleDir, statAsset.name);
        var bundleInfo = void 0;

        try {
          bundleInfo = parseBundle(assetFile);
        } catch (err) {
          var msg = err.code === 'ENOENT' ? 'no such file' : err.message;
          logger.warn("Error parsing bundle asset \"".concat(assetFile, "\": ").concat(msg));
          continue;
        }

        bundlesSources[statAsset.name] = bundleInfo.src;

        _.assign(parsedModules, bundleInfo.modules);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (_.isEmpty(bundlesSources)) {
      bundlesSources = null;
      parsedModules = null;
      logger.warn('\nNo bundles were parsed. Analyzer will show only original module sizes from stats file.\n');
    }
  }

  var assets = _.transform(bundleStats.assets, function (result, statAsset) {
    // If asset is a childAsset, then calculate appropriate bundle modules by looking through stats.children
    var assetBundles = statAsset.isChild ? getChildAssetBundles(bundleStats, statAsset.name) : bundleStats;
    var modules = assetBundles ? getBundleModules(assetBundles) : [];

    var asset = result[statAsset.name] = _.pick(statAsset, 'size');

    if (bundlesSources && _.has(bundlesSources, statAsset.name)) {
      asset.parsedSize = Buffer.byteLength(bundlesSources[statAsset.name]);
      asset.gzipSize = gzipSize.sync(bundlesSources[statAsset.name]);
    } // Picking modules from current bundle script


    asset.modules = _(modules).filter(function (statModule) {
      return assetHasModule(statAsset, statModule);
    }).each(function (statModule) {
      if (parsedModules) {
        statModule.parsedSrc = parsedModules[statModule.id];
      }
    });
    asset.tree = createModulesTree(asset.modules);
  }, {});

  return _.transform(assets, function (result, asset, filename) {
    result.push({
      label: filename,
      isAsset: true,
      // Not using `asset.size` here provided by Webpack because it can be very confusing when `UglifyJsPlugin` is used.
      // In this case all module sizes from stats file will represent unminified module sizes, but `asset.size` will
      // be the size of minified bundle.
      // Using `asset.size` only if current asset doesn't contain any modules (resulting size equals 0)
      statSize: asset.tree.size || asset.size,
      parsedSize: asset.parsedSize,
      gzipSize: asset.gzipSize,
      groups: _.invokeMap(asset.tree.children, 'toChartData')
    });
  }, []);
}

function readStatsFromFile(filename) {
  return JSON.parse(fs.readFileSync(filename, 'utf8'));
}

function getChildAssetBundles(bundleStats, assetName) {
  return _.find(bundleStats.children, function (c) {
    return _(c.assetsByChunkName).values().flatten().includes(assetName);
  });
}

function getBundleModules(bundleStats) {
  return _(bundleStats.chunks).map('modules').concat(bundleStats.modules).compact().flatten().uniqBy('id').value();
}

function assetHasModule(statAsset, statModule) {
  // Checking if this module is the part of asset chunks
  return _.some(statModule.chunks, function (moduleChunk) {
    return _.includes(statAsset.chunks, moduleChunk);
  });
}

function createModulesTree(modules) {
  var root = new Folder('.');

  _.each(modules, function (module) {
    return root.addModule(module);
  });

  root.mergeNestedFolders();
  return root;
}