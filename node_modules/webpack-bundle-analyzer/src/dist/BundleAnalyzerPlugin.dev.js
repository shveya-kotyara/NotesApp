"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var bfj = require('bfj');

var path = require('path');

var mkdir = require('mkdirp');

var _require = require('chalk'),
    bold = _require.bold;

var Logger = require('./Logger');

var viewer = require('./viewer');

var utils = require('./utils');

var BundleAnalyzerPlugin =
/*#__PURE__*/
function () {
  function BundleAnalyzerPlugin() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BundleAnalyzerPlugin);

    this.opts = _objectSpread({
      analyzerMode: 'server',
      analyzerHost: '127.0.0.1',
      reportFilename: null,
      reportTitle: utils.defaultTitle,
      defaultSizes: 'parsed',
      openAnalyzer: true,
      generateStatsFile: false,
      statsFilename: 'stats.json',
      statsOptions: null,
      excludeAssets: null,
      logLevel: 'info',
      // deprecated
      startAnalyzer: true
    }, opts, {
      analyzerPort: 'analyzerPort' in opts ? opts.analyzerPort === 'auto' ? 0 : opts.analyzerPort : 8888
    });
    this.server = null;
    this.logger = new Logger(this.opts.logLevel);
  }

  _createClass(BundleAnalyzerPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      this.compiler = compiler;

      var done = function done(stats, callback) {
        callback = callback || function () {};

        var actions = [];

        if (_this.opts.generateStatsFile) {
          actions.push(function () {
            return _this.generateStatsFile(stats.toJson(_this.opts.statsOptions));
          });
        } // Handling deprecated `startAnalyzer` flag


        if (_this.opts.analyzerMode === 'server' && !_this.opts.startAnalyzer) {
          _this.opts.analyzerMode = 'disabled';
        }

        if (_this.opts.analyzerMode === 'server') {
          actions.push(function () {
            return _this.startAnalyzerServer(stats.toJson());
          });
        } else if (_this.opts.analyzerMode === 'static') {
          actions.push(function () {
            return _this.generateStaticReport(stats.toJson());
          });
        } else if (_this.opts.analyzerMode === 'json') {
          actions.push(function () {
            return _this.generateJSONReport(stats.toJson());
          });
        }

        if (actions.length) {
          // Making analyzer logs to be after all webpack logs in the console
          setImmediate(function _callee() {
            return regeneratorRuntime.async(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    _context.next = 3;
                    return regeneratorRuntime.awrap(Promise.all(actions.map(function (action) {
                      return action();
                    })));

                  case 3:
                    callback();
                    _context.next = 9;
                    break;

                  case 6:
                    _context.prev = 6;
                    _context.t0 = _context["catch"](0);
                    callback(_context.t0);

                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, null, null, [[0, 6]]);
          });
        } else {
          callback();
        }
      };

      if (compiler.hooks) {
        compiler.hooks.done.tapAsync('webpack-bundle-analyzer', done);
      } else {
        compiler.plugin('done', done);
      }
    }
  }, {
    key: "generateStatsFile",
    value: function generateStatsFile(stats) {
      var statsFilepath;
      return regeneratorRuntime.async(function generateStatsFile$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              statsFilepath = path.resolve(this.compiler.outputPath, this.opts.statsFilename);
              mkdir.sync(path.dirname(statsFilepath));
              _context2.prev = 2;
              _context2.next = 5;
              return regeneratorRuntime.awrap(bfj.write(statsFilepath, stats, {
                space: 2,
                promises: 'ignore',
                buffers: 'ignore',
                maps: 'ignore',
                iterables: 'ignore',
                circular: 'ignore'
              }));

            case 5:
              this.logger.info("".concat(bold('Webpack Bundle Analyzer'), " saved stats file to ").concat(bold(statsFilepath)));
              _context2.next = 11;
              break;

            case 8:
              _context2.prev = 8;
              _context2.t0 = _context2["catch"](2);
              this.logger.error("".concat(bold('Webpack Bundle Analyzer'), " error saving stats file to ").concat(bold(statsFilepath), ": ").concat(_context2.t0));

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[2, 8]]);
    }
  }, {
    key: "startAnalyzerServer",
    value: function startAnalyzerServer(stats) {
      return regeneratorRuntime.async(function startAnalyzerServer$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!this.server) {
                _context3.next = 7;
                break;
              }

              _context3.next = 3;
              return regeneratorRuntime.awrap(this.server);

            case 3:
              _context3.t0 = stats;

              _context3.sent.updateChartData(_context3.t0);

              _context3.next = 8;
              break;

            case 7:
              this.server = viewer.startServer(stats, {
                openBrowser: this.opts.openAnalyzer,
                host: this.opts.analyzerHost,
                port: this.opts.analyzerPort,
                reportTitle: this.opts.reportTitle,
                bundleDir: this.getBundleDirFromCompiler(),
                logger: this.logger,
                defaultSizes: this.opts.defaultSizes,
                excludeAssets: this.opts.excludeAssets
              });

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "generateJSONReport",
    value: function generateJSONReport(stats) {
      return regeneratorRuntime.async(function generateJSONReport$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return regeneratorRuntime.awrap(viewer.generateJSONReport(stats, {
                reportFilename: path.resolve(this.compiler.outputPath, this.opts.reportFilename || 'report.json'),
                bundleDir: this.getBundleDirFromCompiler(),
                logger: this.logger,
                excludeAssets: this.opts.excludeAssets
              }));

            case 2:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "generateStaticReport",
    value: function generateStaticReport(stats) {
      return regeneratorRuntime.async(function generateStaticReport$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return regeneratorRuntime.awrap(viewer.generateReport(stats, {
                openBrowser: this.opts.openAnalyzer,
                reportFilename: path.resolve(this.compiler.outputPath, this.opts.reportFilename || 'report.html'),
                reportTitle: this.opts.reportTitle,
                bundleDir: this.getBundleDirFromCompiler(),
                logger: this.logger,
                defaultSizes: this.opts.defaultSizes,
                excludeAssets: this.opts.excludeAssets
              }));

            case 2:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getBundleDirFromCompiler",
    value: function getBundleDirFromCompiler() {
      switch (this.compiler.outputFileSystem.constructor.name) {
        case 'MemoryFileSystem':
          return null;
        // Detect AsyncMFS used by Nuxt 2.5 that replaces webpack's MFS during development
        // Related: #274

        case 'AsyncMFS':
          return null;

        default:
          return this.compiler.outputPath;
      }
    }
  }]);

  return BundleAnalyzerPlugin;
}();

module.exports = BundleAnalyzerPlugin;