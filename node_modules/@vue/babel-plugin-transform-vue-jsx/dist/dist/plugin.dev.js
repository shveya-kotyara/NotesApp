"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(a) {
  return a && "object" == _typeof(a) && "default" in a ? a["default"] : a;
}

var syntaxJsx = _interopDefault(require("@babel/plugin-syntax-jsx")),
    helperModuleImports = require("@babel/helper-module-imports"),
    kebabcase = _interopDefault(require("lodash.kebabcase")),
    htmlTags = _interopDefault(require("html-tags")),
    svgTags = _interopDefault(require("svg-tags"));

var xlinkRE = /^xlink([A-Z])/,
    rootAttributes = ["staticClass", "class", "style", "key", "ref", "refInFor", "slot", "scopedSlots", "model"],
    prefixes = ["props", "domProps", "on", "nativeOn", "hook", "attrs"],
    domPropsValueElements = ["input", "textarea", "option", "select"],
    domPropsElements = [].concat(domPropsValueElements, ["video"]),
    mustUseDomProps = function mustUseDomProps(a, b, c) {
  return "value" === c && domPropsValueElements.includes(a) && "button" !== b || "selected" === c && "option" === a || "checked" === c && "input" === a || "muted" === c && "video" === a;
},
    isDirective = function isDirective(a) {
  return a.startsWith("v-") || a.startsWith("v") && 2 <= a.length && "A" <= a[1] && "Z" >= a[1];
},
    getTag = function getTag(a, b) {
  var c = b.get("name");

  if (a.isJSXIdentifier(c)) {
    var d = c.get("name").node;
    return !b.scope.hasBinding(d) || htmlTags.includes(d) || svgTags.includes(d) ? a.stringLiteral(d) : a.identifier(d);
  }

  if (a.isJSXMemberExpression(c)) return transformJSXMemberExpression(a, c);
  throw new Error("getTag: ".concat(c.type, " is not supported"));
},
    getChildren = function getChildren(a, b) {
  return b.map(function (b) {
    if (b.isJSXText()) return transformJSXText(a, b);
    if (b.isJSXExpressionContainer()) return transformJSXExpressionContainer(a, b);
    if (b.isJSXSpreadChild()) return transformJSXSpreadChild(a, b);
    if (b.isCallExpression()) return b.node;
    throw new Error("getChildren: ".concat(b.type, " is not supported"));
  }).filter(function (b) {
    return null !== b && !a.isJSXEmptyExpression(b);
  });
},
    addAttribute = function addAttribute(a, b, c, d) {
  if (b[c]) {
    var e = !1;
    a.isObjectProperty(d) && ("on" === c || "nativeOn" === c) && b[c].properties.forEach(function (b) {
      a.isObjectProperty(b) && b.key.value === d.key.value && (a.isArrayExpression(b.value) ? b.value.elements.push(d.value) : b.value = a.arrayExpression([b.value, d.value]), e = !0);
    }), e || b[c].properties.push(d);
  } else b[c] = a.objectExpression([d]);
},
    parseMagicDomPropsInfo = function parseMagicDomPropsInfo(a, b, c) {
  var d = a.isStringLiteral(c) && c.value,
      e = domPropsElements.includes(d);
  var f = "";

  if (e) {
    var _c = b.find(function (b) {
      return a.isJSXAttribute(b) && a.isJSXIdentifier(b.get("name")) && a.isStringLiteral(b.get("value")) && "type" === b.get("name.name").node;
    });

    f = _c && _c.get("value.value").node;
  }

  return {
    tagName: d,
    canContainDomProps: e,
    elementType: f
  };
},
    parseAttributeJSXAttribute = function parseAttributeJSXAttribute(a, b, c, d, e) {
  var _h$split, _h$split2, _h$split3, _h$split4;

  var f = b.get("name");
  var g, h, i, j;
  if (h = a.isJSXNamespacedName(f) ? "".concat(f.get("namespace.name").node, ":").concat(f.get("name.name").node) : f.get("name").node, prefixes.includes(h) && a.isJSXExpressionContainer(b.get("value"))) return a.JSXSpreadAttribute(a.objectExpression([a.objectProperty(a.stringLiteral(h), b.get("value").node.expression)]));
  (_h$split = h.split("_"), _h$split2 = _toArray(_h$split), h = _h$split2[0], i = _h$split2.slice(1), _h$split), (_h$split3 = h.split(":"), _h$split4 = _slicedToArray(_h$split3, 2), h = _h$split4[0], j = _h$split4[1], _h$split3), g = prefixes.find(function (a) {
    return h.startsWith(a);
  }) || "attrs", h = h.replace(new RegExp("^".concat(g, "-?")), ""), h = h[0].toLowerCase() + h.substr(1);
  var k = b.get("value");
  var l;
  if (!k.node) l = a.booleanLiteral(!0);else if (a.isStringLiteral(k)) l = k.node;else if (a.isJSXExpressionContainer(k)) mustUseDomProps(d, e, h) && (g = "domProps"), l = k.get("expression").node;else throw new Error("getAttributes (attribute value): ".concat(k.type, " is not supported"));
  l._argument = j, l._modifiers = i, rootAttributes.includes(h) ? c[h] = l : (isDirective(h) ? (h = kebabcase(h.substr(1)), g = "directives") : h = [h].concat(_toConsumableArray(i)).join("_"), h.match(xlinkRE) && (h = h.replace(xlinkRE, function (a, b) {
    return "xlink:" + b.toLowerCase();
  })), addAttribute(a, c, g, a.objectProperty(a.stringLiteral(h), l)));
},
    parseAttributeJSXSpreadAttribute = function parseAttributeJSXSpreadAttribute(a, b, c, d) {
  var e = b.get("argument");
  return a.isObjectExpression(e) && !e.get("properties").find(function (b) {
    return !a.isObjectProperty(b) || !prefixes.includes(b.get("key.name").node);
  }) ? e.get("properties").forEach(function (b) {
    addAttribute(a, c, b.get("key.name").node, a.spreadElement(b.get("value").node));
  }) : (d.push(c), d.push({
    type: "vueSpread",
    argument: e.node
  }), c = {}), c;
},
    getAttributes = function getAttributes(a, b, c, d) {
  var e = [];
  var f = {};

  var _parseMagicDomPropsIn = parseMagicDomPropsInfo(a, b, c),
      g = _parseMagicDomPropsIn.tagName,
      h = _parseMagicDomPropsIn.canContainDomProps,
      i = _parseMagicDomPropsIn.elementType;

  return b.forEach(function (b) {
    if (a.isJSXAttribute(b)) {
      var _c2 = parseAttributeJSXAttribute(a, b, f, g, i);

      if (_c2) {
        d.node.attributes.push(_c2);

        var _b = d.get("attributes"),
            _g = _b[_b.length - 1];

        f = parseAttributeJSXSpreadAttribute(a, _g, f, e), _g.remove();
      }

      return;
    }

    if (a.isJSXSpreadAttribute(b)) return void (f = parseAttributeJSXSpreadAttribute(a, b, f, e));
    throw new Error("getAttributes (attribute): ".concat(b.type, " is not supported"));
  }), 0 < e.length ? (0 < Object.keys(f).length && e.push(f), a.arrayExpression(e.map(function (b) {
    return "vueSpread" === b.type ? b.argument : transformAttributes(a, b);
  }))) : Object.entries(f).length && transformAttributes(a, f);
},
    transformDirectives = function transformDirectives(a, b) {
  return a.arrayExpression(b.properties.map(function (b) {
    return a.objectExpression([a.objectProperty(a.identifier("name"), b.key), a.objectProperty(a.identifier("value"), b.value)].concat(_toConsumableArray(b.value._argument ? [a.objectProperty(a.identifier("arg"), a.stringLiteral(b.value._argument))] : []), _toConsumableArray(b.value._modifiers && 0 < b.value._modifiers.length ? [a.objectProperty(a.identifier("modifiers"), a.objectExpression(b.value._modifiers.map(function (b) {
      return a.objectProperty(a.stringLiteral(b), a.booleanLiteral(!0));
    })))] : [])));
  }));
},
    transformAttributes = function transformAttributes(a, b) {
  return a.objectExpression(Object.entries(b).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        b = _ref2[0],
        c = _ref2[1];

    return "directives" === b ? a.objectProperty(a.stringLiteral(b), transformDirectives(a, c)) : a.objectProperty(a.stringLiteral(b), c);
  }));
},
    transformJSXElement = function transformJSXElement(a, b) {
  if (a.isJSXAttribute(b.container)) throw new Error("getAttributes (attribute value): ".concat(b.type, " is not supported"));
  var c = getTag(a, b.get("openingElement")),
      d = getChildren(a, b.get("children")),
      e = b.get("openingElement"),
      f = getAttributes(a, e.get("attributes"), c, e),
      g = [c];
  if (f) if (a.isArrayExpression(f)) {
    var _c3 = helperModuleImports.addDefault(b, "@vue/babel-helper-vue-jsx-merge-props", {
      nameHint: "_mergeJSXProps"
    });

    g.push(a.callExpression(_c3, [f]));
  } else g.push(f);
  return d.length && g.push(a.arrayExpression(d)), a.callExpression(a.identifier("h"), g);
},
    transformJSXMemberExpression = function transformJSXMemberExpression(a, b) {
  var c = b.get("object"),
      d = b.get("property"),
      e = c.isJSXMemberExpression() ? transformJSXMemberExpression(a, c) : a.identifier(c.get("name").node),
      f = a.identifier(d.get("name").node);
  return a.memberExpression(e, f);
},
    transformJSXText = function transformJSXText(a, b) {
  var c = b.node,
      d = c.value.split(/\r\n|\n|\r/);
  var e = 0;

  for (var _c4 = 0; _c4 < d.length; _c4++) {
    d[_c4].match(/[^ \t]/) && (e = _c4);
  }

  var f = "";

  for (var _c5 = 0; _c5 < d.length; _c5++) {
    var _a = d[_c5],
        _b2 = 0 == _c5,
        g = _c5 == d.length - 1,
        h = _c5 == e;

    var i = _a.replace(/\t/g, " ");

    _b2 || (i = i.replace(/^[ ]+/, "")), g || (i = i.replace(/[ ]+$/, "")), i && (!h && (i += " "), f += i);
  }

  return "" === f ? null : a.stringLiteral(f);
},
    transformJSXExpressionContainer = function transformJSXExpressionContainer(a, b) {
  return b.get("expression").node;
},
    transformJSXSpreadChild = function transformJSXSpreadChild(a, b) {
  return a.spreadElement(b.get("expression").node);
};

var index = function index(a) {
  var b = a.types;
  return {
    name: "babel-plugin-transform-vue-jsx",
    inherits: syntaxJsx,
    visitor: {
      JSXElement: {
        exit: function exit(a) {
          a.replaceWith(transformJSXElement(b, a));
        }
      }
    }
  };
};

module.exports = index;