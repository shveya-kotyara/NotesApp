"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ipc = require('node-ipc');

var DEFAULT_ID = process.env.VUE_CLI_IPC || 'vue-cli';
var DEFAULT_IDLE_TIMEOUT = 3000;
var DEFAULT_OPTIONS = {
  networkId: DEFAULT_ID,
  autoConnect: true,
  disconnectOnIdle: false,
  idleTimeout: DEFAULT_IDLE_TIMEOUT,
  namespaceOnProject: true
};
var PROJECT_ID = process.env.VUE_CLI_PROJECT_ID;

exports.IpcMessenger =
/*#__PURE__*/
function () {
  function IpcMessenger() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, IpcMessenger);

    options = Object.assign({}, DEFAULT_OPTIONS, options);
    ipc.config.id = this.id = options.networkId;
    ipc.config.retry = 1500;
    ipc.config.silent = true;
    this.connected = false;
    this.connecting = false;
    this.disconnecting = false;
    this.queue = null;
    this.options = options;
    this.listeners = [];
    this.disconnectTimeout = 15000;
    this.idleTimer = null; // Prevent forced process exit
    // (or else ipc messages may not be sent before kill)

    process.exit = function (code) {
      process.exitCode = code;
    };

    this._reset();
  }

  _createClass(IpcMessenger, [{
    key: "checkConnection",
    value: function checkConnection() {
      if (!ipc.of[this.id]) {
        this.connected = false;
      }
    }
  }, {
    key: "send",
    value: function send(data) {
      var _this = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'message';
      this.checkConnection();

      if (this.connected) {
        if (this.options.namespaceOnProject && PROJECT_ID) {
          data = {
            _projectId: PROJECT_ID,
            _data: data
          };
        }

        ipc.of[this.id].emit(type, data);
        clearTimeout(this.idleTimer);

        if (this.options.disconnectOnIdle) {
          this.idleTimer = setTimeout(function () {
            _this.disconnect();
          }, this.options.idleTimeout);
        }
      } else {
        this.queue.push(data);

        if (this.options.autoConnect && !this.connecting) {
          this.connect();
        }
      }
    }
  }, {
    key: "connect",
    value: function connect() {
      var _this2 = this;

      this.checkConnection();
      if (this.connected || this.connecting) return;
      this.connecting = true;
      this.disconnecting = false;
      ipc.connectTo(this.id, function () {
        _this2.connected = true;
        _this2.connecting = false;
        _this2.queue && _this2.queue.forEach(function (data) {
          return _this2.send(data);
        });
        _this2.queue = null;

        ipc.of[_this2.id].on('message', _this2._onMessage);
      });
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this3 = this;

      this.checkConnection();
      if (!this.connected || this.disconnecting) return;
      this.disconnecting = true;
      this.connecting = false;
      var ipcTimer = setTimeout(function () {
        _this3._disconnect();
      }, this.disconnectTimeout);
      this.send({
        done: true
      }, 'ack');
      ipc.of[this.id].on('ack', function (data) {
        if (data.ok) {
          clearTimeout(ipcTimer);

          _this3._disconnect();
        }
      });
    }
  }, {
    key: "on",
    value: function on(listener) {
      this.listeners.push(listener);
    }
  }, {
    key: "off",
    value: function off(listener) {
      var index = this.listeners.indexOf(listener);
      if (index !== -1) this.listeners.splice(index, 1);
    }
  }, {
    key: "_reset",
    value: function _reset() {
      this.queue = [];
      this.connected = false;
    }
  }, {
    key: "_disconnect",
    value: function _disconnect() {
      this.connected = false;
      this.disconnecting = false;
      ipc.disconnect(this.id);

      this._reset();
    }
  }, {
    key: "_onMessage",
    value: function _onMessage(data) {
      var _this4 = this;

      this.listeners.forEach(function (fn) {
        if (_this4.options.namespaceOnProject && data._projectId) {
          if (data._projectId === PROJECT_ID) {
            data = data._data;
          } else {
            return;
          }
        }

        fn(data);
      });
    }
  }]);

  return IpcMessenger;
}();