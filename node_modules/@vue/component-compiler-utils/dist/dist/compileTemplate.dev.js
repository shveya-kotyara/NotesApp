"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compileTemplate = void 0;

var assetUrl_1 = __importDefault(require("./templateCompilerModules/assetUrl"));

var srcset_1 = __importDefault(require("./templateCompilerModules/srcset"));

var consolidate = require('consolidate');

var transpile = require('vue-template-es2015-compiler');

function compileTemplate(options) {
  var preprocessLang = options.preprocessLang;
  var preprocessor = preprocessLang && consolidate[preprocessLang];

  if (preprocessor) {
    return actuallyCompile(Object.assign({}, options, {
      source: preprocess(options, preprocessor)
    }));
  } else if (preprocessLang) {
    return {
      ast: {},
      code: "var render = function () {}\n" + "var staticRenderFns = []\n",
      source: options.source,
      tips: ["Component ".concat(options.filename, " uses lang ").concat(preprocessLang, " for template. Please install the language preprocessor.")],
      errors: ["Component ".concat(options.filename, " uses lang ").concat(preprocessLang, " for template, however it is not installed.")]
    };
  } else {
    return actuallyCompile(options);
  }
}

exports.compileTemplate = compileTemplate;

function preprocess(options, preprocessor) {
  var source = options.source,
      filename = options.filename,
      preprocessOptions = options.preprocessOptions;
  var finalPreprocessOptions = Object.assign({
    filename: filename
  }, preprocessOptions); // Consolidate exposes a callback based API, but the callback is in fact
  // called synchronously for most templating engines. In our case, we have to
  // expose a synchronous API so that it is usable in Jest transforms (which
  // have to be sync because they are applied via Node.js require hooks)

  var res, err;
  preprocessor.render(source, finalPreprocessOptions, function (_err, _res) {
    if (_err) err = _err;
    res = _res;
  });
  if (err) throw err;
  return res;
}

function actuallyCompile(options) {
  var source = options.source,
      compiler = options.compiler,
      _options$compilerOpti = options.compilerOptions,
      compilerOptions = _options$compilerOpti === void 0 ? {} : _options$compilerOpti,
      _options$transpileOpt = options.transpileOptions,
      transpileOptions = _options$transpileOpt === void 0 ? {} : _options$transpileOpt,
      transformAssetUrls = options.transformAssetUrls,
      transformAssetUrlsOptions = options.transformAssetUrlsOptions,
      _options$isProduction = options.isProduction,
      isProduction = _options$isProduction === void 0 ? process.env.NODE_ENV === 'production' : _options$isProduction,
      _options$isFunctional = options.isFunctional,
      isFunctional = _options$isFunctional === void 0 ? false : _options$isFunctional,
      _options$optimizeSSR = options.optimizeSSR,
      optimizeSSR = _options$optimizeSSR === void 0 ? false : _options$optimizeSSR,
      _options$prettify = options.prettify,
      prettify = _options$prettify === void 0 ? true : _options$prettify;
  var compile = optimizeSSR && compiler.ssrCompile ? compiler.ssrCompile : compiler.compile;
  var finalCompilerOptions = compilerOptions;

  if (transformAssetUrls) {
    var builtInModules = [transformAssetUrls === true ? assetUrl_1["default"](undefined, transformAssetUrlsOptions) : assetUrl_1["default"](transformAssetUrls, transformAssetUrlsOptions), srcset_1["default"](transformAssetUrlsOptions)];
    finalCompilerOptions = Object.assign({}, compilerOptions, {
      modules: [].concat(builtInModules, _toConsumableArray(compilerOptions.modules || [])),
      filename: options.filename
    });
  }

  var _compile = compile(source, finalCompilerOptions),
      ast = _compile.ast,
      render = _compile.render,
      staticRenderFns = _compile.staticRenderFns,
      tips = _compile.tips,
      errors = _compile.errors;

  if (errors && errors.length) {
    return {
      ast: ast,
      code: "var render = function () {}\n" + "var staticRenderFns = []\n",
      source: source,
      tips: tips,
      errors: errors
    };
  } else {
    var finalTranspileOptions = Object.assign({}, transpileOptions, {
      transforms: Object.assign({}, transpileOptions.transforms, {
        stripWithFunctional: isFunctional
      })
    });

    var toFunction = function toFunction(code) {
      return "function (".concat(isFunctional ? "_h,_vm" : "", ") {").concat(code, "}");
    }; // transpile code with vue-template-es2015-compiler, which is a forked
    // version of Buble that applies ES2015 transforms + stripping `with` usage


    var code = transpile("var __render__ = ".concat(toFunction(render), "\n") + "var __staticRenderFns__ = [".concat(staticRenderFns.map(toFunction), "]"), finalTranspileOptions) + "\n"; // #23 we use __render__ to avoid `render` not being prefixed by the
    // transpiler when stripping with, but revert it back to `render` to
    // maintain backwards compat

    code = code.replace(/\s__(render|staticRenderFns)__\s/g, ' $1 ');

    if (!isProduction) {
      // mark with stripped (this enables Vue to use correct runtime proxy
      // detection)
      code += "render._withStripped = true";

      if (prettify) {
        try {
          code = require('prettier').format(code, {
            semi: false,
            parser: 'babel'
          });
        } catch (e) {
          if (e.code === 'MODULE_NOT_FOUND') {
            tips.push('The `prettify` option is on, but the dependency `prettier` is not found.\n' + 'Please either turn off `prettify` or manually install `prettier`.');
          }

          tips.push("Failed to prettify component ".concat(options.filename, " template source after compilation."));
        }
      }
    }

    return {
      ast: ast,
      code: code,
      source: source,
      tips: tips,
      errors: errors
    };
  }
}