"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.doCompileStyle = exports.compileStyleAsync = exports.compileStyle = void 0;

var postcss = require('postcss');

var trim_1 = __importDefault(require("./stylePlugins/trim"));

var scoped_1 = __importDefault(require("./stylePlugins/scoped"));

var styleProcessors_1 = require("./styleProcessors");

function compileStyle(options) {
  return doCompileStyle(Object.assign(Object.assign({}, options), {
    isAsync: false
  }));
}

exports.compileStyle = compileStyle;

function compileStyleAsync(options) {
  return Promise.resolve(doCompileStyle(Object.assign(Object.assign({}, options), {
    isAsync: true
  })));
}

exports.compileStyleAsync = compileStyleAsync;

function doCompileStyle(options) {
  var filename = options.filename,
      id = options.id,
      _options$scoped = options.scoped,
      scoped = _options$scoped === void 0 ? true : _options$scoped,
      _options$trim = options.trim,
      trim = _options$trim === void 0 ? true : _options$trim,
      preprocessLang = options.preprocessLang,
      postcssOptions = options.postcssOptions,
      postcssPlugins = options.postcssPlugins;
  var preprocessor = preprocessLang && styleProcessors_1.processors[preprocessLang];
  var preProcessedSource = preprocessor && preprocess(options, preprocessor);
  var map = preProcessedSource ? preProcessedSource.map : options.map;
  var source = preProcessedSource ? preProcessedSource.code : options.source;
  var plugins = (postcssPlugins || []).slice();

  if (trim) {
    plugins.push(trim_1["default"]());
  }

  if (scoped) {
    plugins.push(scoped_1["default"](id));
  }

  var postCSSOptions = Object.assign(Object.assign({}, postcssOptions), {
    to: filename,
    from: filename
  });

  if (map) {
    postCSSOptions.map = {
      inline: false,
      annotation: false,
      prev: map
    };
  }

  var result, code, outMap;
  var errors = [];

  if (preProcessedSource && preProcessedSource.errors.length) {
    errors.push.apply(errors, _toConsumableArray(preProcessedSource.errors));
  }

  try {
    result = postcss(plugins).process(source, postCSSOptions); // In async mode, return a promise.

    if (options.isAsync) {
      return result.then(function (result) {
        return {
          code: result.css || '',
          map: result.map && result.map.toJSON(),
          errors: errors,
          rawResult: result
        };
      })["catch"](function (error) {
        return {
          code: '',
          map: undefined,
          errors: [].concat(errors, [error.message]),
          rawResult: undefined
        };
      });
    } // force synchronous transform (we know we only have sync plugins)


    code = result.css;
    outMap = result.map;
  } catch (e) {
    errors.push(e);
  }

  return {
    code: code || "",
    map: outMap && outMap.toJSON(),
    errors: errors,
    rawResult: result
  };
}

exports.doCompileStyle = doCompileStyle;

function preprocess(options, preprocessor) {
  return preprocessor.render(options.source, options.map, Object.assign({
    filename: options.filename
  }, options.preprocessOptions));
}