"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isAsync(chunk) {
  if ('canBeInitial' in chunk) {
    return !chunk.canBeInitial();
  } else {
    return !chunk.isInitial();
  }
}

function getChunkEntryNames(chunk) {
  if ('groupsIterable' in chunk) {
    return Array.from(new Set(getNames(chunk.groupsIterable)));
  } else {
    return chunk.entrypoints.map(function (e) {
      return e.options.name;
    });
  }
}

function getNames(groups) {
  var processed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

  var Entrypoint = require('webpack/lib/Entrypoint');

  var names = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var group = _step.value;

      if (group instanceof Entrypoint) {
        // entrypoint
        if (group.options.name) {
          names.push(group.options.name);
        }
      } else if (!processed.has(group)) {
        processed.add(group);
        names.push.apply(names, _toConsumableArray(getNames(group.parentsIterable, processed)));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return names;
}

function extractChunks(_ref) {
  var compilation = _ref.compilation,
      optionsInclude = _ref.optionsInclude;
  var includeChunks;
  var includeType;
  var includeEntryPoints;

  if (optionsInclude && _typeof(optionsInclude) === 'object') {
    includeType = optionsInclude.type;
    includeChunks = optionsInclude.chunks;
    includeEntryPoints = optionsInclude.entries;
  } else {
    if (Array.isArray(optionsInclude)) {
      includeChunks = optionsInclude;
    } else {
      includeType = optionsInclude;
    }
  }

  var chunks = compilation.chunks;

  if (Array.isArray(includeChunks)) {
    chunks = chunks.filter(function (chunk) {
      return chunk.name && includeChunks.includes(chunk.name);
    });
  }

  if (Array.isArray(includeEntryPoints)) {
    chunks = chunks.filter(function (chunk) {
      var names = getChunkEntryNames(chunk);
      return names.some(function (name) {
        return includeEntryPoints.includes(name);
      });
    });
  } // 'asyncChunks' are chunks intended for lazy/async loading usually generated as
  // part of code-splitting with import() or require.ensure(). By default, asyncChunks
  // get wired up using link rel=preload when using this plugin. This behaviour can be
  // configured to preload all types of chunks or just prefetch chunks as needed.


  if (includeType === undefined || includeType === 'asyncChunks') {
    return chunks.filter(isAsync);
  }

  if (includeType === 'initial') {
    return chunks.filter(function (chunk) {
      return !isAsync(chunk);
    });
  }

  if (includeType === 'allChunks') {
    // Async chunks, vendor chunks, normal chunks.
    return chunks;
  }

  if (includeType === 'allAssets') {
    // Every asset, regardless of which chunk it's in.
    // Wrap it in a single, "psuedo-chunk" return value.
    return [{
      files: Object.keys(compilation.assets)
    }];
  }

  return chunks;
}

module.exports = extractChunks;