"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var defaultOptions = require('./lib/default-options');

var determineAsValue = require('./lib/determine-as-value');

var doesChunkBelongToHTML = require('./lib/does-chunk-belong-to-html');

var extractChunks = require('./lib/extract-chunks');

var PreloadPlugin =
/*#__PURE__*/
function () {
  function PreloadPlugin(options) {
    _classCallCheck(this, PreloadPlugin);

    this.options = Object.assign({}, defaultOptions, options);
  }

  _createClass(PreloadPlugin, [{
    key: "generateLinks",
    value: function generateLinks(compilation, htmlPluginData) {
      var _this = this;

      var options = this.options;
      var extractedChunks = extractChunks({
        compilation: compilation,
        optionsInclude: options.include
      });
      var htmlChunks = options.include === 'allAssets' // Handle all chunks.
      ? extractedChunks // Only handle chunks imported by this HtmlWebpackPlugin.
      : extractedChunks.filter(function (chunk) {
        return doesChunkBelongToHTML({
          chunk: chunk,
          compilation: compilation,
          htmlAssetsChunks: Object.values(htmlPluginData.assets.chunks)
        });
      }); // Flatten the list of files.

      var allFiles = htmlChunks.reduce(function (accumulated, chunk) {
        return accumulated.concat(chunk.files);
      }, []);
      var uniqueFiles = new Set(allFiles);

      var filteredFiles = _toConsumableArray(uniqueFiles).filter(function (file) {
        return !_this.options.fileWhitelist || _this.options.fileWhitelist.some(function (regex) {
          return regex.test(file);
        });
      }).filter(function (file) {
        return !_this.options.fileBlacklist || _this.options.fileBlacklist.every(function (regex) {
          return !regex.test(file);
        });
      }); // Sort to ensure the output is predictable.


      var sortedFilteredFiles = filteredFiles.sort();
      var links = [];
      var publicPath = compilation.outputOptions.publicPath || '';
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = sortedFilteredFiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var file = _step.value;
          var href = "".concat(publicPath).concat(file);
          var attributes = {
            href: href,
            rel: options.rel
          }; // If we're preloading this resource (as opposed to prefetching),
          // then we need to set the 'as' attribute correctly.

          if (options.rel === 'preload') {
            attributes.as = determineAsValue({
              href: href,
              file: file,
              optionsAs: options.as
            }); // On the off chance that we have a cross-origin 'href' attribute,
            // set crossOrigin on the <link> to trigger CORS mode. Non-CORS
            // fonts can't be used.

            if (attributes.as === 'font') {
              attributes.crossorigin = '';
            }
          }

          links.push({
            tagName: 'link',
            attributes: attributes
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.resourceHints = links;
      return htmlPluginData;
    }
  }, {
    key: "apply",
    value: function apply(compiler) {
      var _this2 = this;

      var skip = function skip(data) {
        var htmlFilename = data.plugin.options.filename;
        var exclude = _this2.options.excludeHtmlNames;
        var include = _this2.options.includeHtmlNames;
        return include && !include.includes(htmlFilename) || exclude && exclude.includes(htmlFilename);
      };

      compiler.hooks.compilation.tap(this.constructor.name, function (compilation) {
        compilation.hooks.htmlWebpackPluginBeforeHtmlProcessing.tap(_this2.constructor.name, function (htmlPluginData) {
          if (skip(htmlPluginData)) {
            return;
          }

          _this2.generateLinks(compilation, htmlPluginData);
        });
        compilation.hooks.htmlWebpackPluginAlterAssetTags.tap(_this2.constructor.name, function (htmlPluginData) {
          if (skip(htmlPluginData)) {
            return;
          }

          if (_this2.resourceHints) {
            htmlPluginData.head = [].concat(_toConsumableArray(_this2.resourceHints), _toConsumableArray(htmlPluginData.head));
          }

          return htmlPluginData;
        });
      });
    }
  }]);

  return PreloadPlugin;
}();

module.exports = PreloadPlugin;