"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var path = require('path');

var semver = require('semver');

var defaultPolyfills = [// promise polyfill alone doesn't work in IE,
// needs this as well. see: #1642
'es.array.iterator', // this is required for webpack code splitting, vuex etc.
'es.promise', // this is needed for object rest spread support in templates
// as vue-template-es2015-compiler 1.8+ compiles it to Object.assign() calls.
'es.object.assign', // #2012 es.promise replaces native Promise in FF and causes missing finally
'es.promise.finally'];

var _require = require('@babel/helper-compilation-targets'),
    getTargets = _require["default"],
    isRequired = _require.isRequired;

function getIntersectionTargets(targets, constraintTargets) {
  var intersection = Object.keys(constraintTargets).reduce(function (results, browser) {
    // exclude the browsers that the user does not need
    if (!targets[browser]) {
      return results;
    } // if the user-specified version is higher the minimum version that supports esmodule, than use it


    results[browser] = semver.gt(semver.coerce(constraintTargets[browser]), semver.coerce(targets[browser])) ? constraintTargets[browser] : targets[browser];
    return results;
  }, {});
  return intersection;
}

function getModernTargets(targets) {
  var allModernTargets = getTargets({
    esmodules: true
  }, {
    ignoreBrowserslistConfig: true
  }); // use the intersection of modern mode browsers and user defined targets config

  return getIntersectionTargets(targets, allModernTargets);
}

function getWCTargets(targets) {
  // targeting browsers that at least support ES2015 classes
  // https://github.com/babel/babel/blob/v7.9.6/packages/babel-compat-data/data/plugins.json#L194-L204
  var allWCTargets = getTargets({
    browsers: ['Chrome >= 46', 'Firefox >= 45', 'Safari >= 10', 'Edge >= 13', 'iOS >= 10', 'Electron >= 0.36']
  }, {
    ignoreBrowserslistConfig: true
  }); // use the intersection of browsers supporting Web Components and user defined targets config

  return getIntersectionTargets(targets, allWCTargets);
}

function getPolyfills(targets, includes) {
  // if no targets specified, include all default polyfills
  if (!targets || !Object.keys(targets).length) {
    return includes;
  }

  var compatData = require('core-js-compat').data;

  return includes.filter(function (item) {
    if (!compatData[item]) {
      throw new Error("Cannot find polyfill ".concat(item, ", please refer to 'core-js-compat' for a complete list of available modules"));
    }

    return isRequired(item, targets, {
      compatData: compatData
    });
  });
}

module.exports = function (context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var presets = [];
  var plugins = [];
  var defaultEntryFiles = JSON.parse(process.env.VUE_CLI_ENTRY_FILES || '[]'); // Though in the vue-cli repo, we only use the two environment variables
  // for tests, users may have relied on them for some features,
  // dropping them may break some projects.
  // So in the following blocks we don't directly test the `NODE_ENV`.
  // Rather, we turn it into the two commonly used feature flags.

  if (!process.env.VUE_CLI_TEST && process.env.NODE_ENV === 'test') {
    // Both Jest & Mocha set NODE_ENV to 'test'.
    // And both requires the `node` target.
    process.env.VUE_CLI_BABEL_TARGET_NODE = 'true'; // Jest runs without bundling so it needs this.
    // With the node target, tree shaking is not a necessity,
    // so we set it for maximum compatibility.

    process.env.VUE_CLI_BABEL_TRANSPILE_MODULES = 'true';
  } // JSX


  if (options.jsx !== false) {
    var jsxOptions = {};

    if (_typeof(options.jsx) === 'object') {
      jsxOptions = options.jsx;
    }

    var vueVersion = 2;

    try {
      var Vue = require('vue');

      vueVersion = semver.major(Vue.version);
    } catch (e) {}

    if (vueVersion === 2) {
      presets.push([require('@vue/babel-preset-jsx'), jsxOptions]);
    } else if (vueVersion === 3) {
      plugins.push([require('@vue/babel-plugin-jsx'), jsxOptions]);
    }
  }

  var runtimePath = path.dirname(require.resolve('@babel/runtime/package.json'));

  var runtimeVersion = require('@babel/runtime/package.json').version;

  var userPolyfills = options.polyfills,
      _options$loose = options.loose,
      loose = _options$loose === void 0 ? false : _options$loose,
      _options$debug = options.debug,
      debug = _options$debug === void 0 ? false : _options$debug,
      _options$useBuiltIns = options.useBuiltIns,
      useBuiltIns = _options$useBuiltIns === void 0 ? 'usage' : _options$useBuiltIns,
      _options$modules = options.modules,
      modules = _options$modules === void 0 ? false : _options$modules,
      _options$bugfixes = options.bugfixes,
      bugfixes = _options$bugfixes === void 0 ? true : _options$bugfixes,
      rawTargets = options.targets,
      spec = options.spec,
      ignoreBrowserslistConfig = options.ignoreBrowserslistConfig,
      configPath = options.configPath,
      include = options.include,
      exclude = options.exclude,
      shippedProposals = options.shippedProposals,
      forceAllTransforms = options.forceAllTransforms,
      decoratorsBeforeExport = options.decoratorsBeforeExport,
      decoratorsLegacy = options.decoratorsLegacy,
      _options$entryFiles = options.entryFiles,
      entryFiles = _options$entryFiles === void 0 ? defaultEntryFiles : _options$entryFiles,
      _options$absoluteRunt = options.absoluteRuntime,
      absoluteRuntime = _options$absoluteRunt === void 0 ? runtimePath : _options$absoluteRunt,
      _options$version = options.version,
      version = _options$version === void 0 ? runtimeVersion : _options$version; // resolve targets for preset-env

  var targets = getTargets(rawTargets, {
    ignoreBrowserslistConfig: ignoreBrowserslistConfig,
    configPath: configPath
  });

  if (process.env.VUE_CLI_BABEL_TARGET_NODE) {
    // running tests in Node.js
    targets = {
      node: 'current'
    };
  } else if (process.env.VUE_CLI_BUILD_TARGET === 'wc' || process.env.VUE_CLI_BUILD_TARGET === 'wc-async') {
    // targeting browsers that at least support ES2015 classes
    targets = getWCTargets(targets);
  } else if (process.env.VUE_CLI_MODERN_BUILD) {
    // targeting browsers that at least support <script type="module">
    targets = getModernTargets(targets);
  } // included-by-default polyfills. These are common polyfills that 3rd party
  // dependencies may rely on (e.g. Vuex relies on Promise), but since with
  // useBuiltIns: 'usage' we won't be running Babel on these deps, they need to
  // be force-included.


  var polyfills;
  var buildTarget = process.env.VUE_CLI_BUILD_TARGET || 'app';

  if (buildTarget === 'app' && useBuiltIns === 'usage' && !process.env.VUE_CLI_BABEL_TARGET_NODE) {
    polyfills = getPolyfills(targets, userPolyfills || defaultPolyfills);
    plugins.push([require('./polyfillsPlugin'), {
      polyfills: polyfills,
      entryFiles: entryFiles,
      useAbsolutePath: !!absoluteRuntime
    }]);
  } else {
    polyfills = [];
  }

  var envOptions = {
    bugfixes: bugfixes,
    corejs: useBuiltIns ? require('core-js/package.json').version : false,
    spec: spec,
    loose: loose,
    debug: debug,
    modules: modules,
    targets: targets,
    useBuiltIns: useBuiltIns,
    ignoreBrowserslistConfig: ignoreBrowserslistConfig,
    configPath: configPath,
    include: include,
    exclude: polyfills.concat(exclude || []),
    shippedProposals: shippedProposals,
    forceAllTransforms: forceAllTransforms
  }; // cli-plugin-jest sets this to true because Jest runs without bundling

  if (process.env.VUE_CLI_BABEL_TRANSPILE_MODULES) {
    envOptions.modules = 'commonjs';

    if (process.env.VUE_CLI_BABEL_TARGET_NODE) {
      // necessary for dynamic import to work in tests
      plugins.push(require('babel-plugin-dynamic-import-node'));
    }
  } // pass options along to babel-preset-env


  presets.unshift([require('@babel/preset-env'), envOptions]); // additional <= stage-3 plugins
  // Babel 7 is removing stage presets altogether because people are using
  // too many unstable proposals. Let's be conservative in the defaults here.

  plugins.push(require('@babel/plugin-syntax-dynamic-import'), [require('@babel/plugin-proposal-decorators'), {
    decoratorsBeforeExport: decoratorsBeforeExport,
    legacy: decoratorsLegacy !== false
  }], [require('@babel/plugin-proposal-class-properties'), {
    loose: loose
  }]); // transform runtime, but only for helpers

  plugins.push([require('@babel/plugin-transform-runtime'), {
    regenerator: useBuiltIns !== 'usage',
    // polyfills are injected by preset-env & polyfillsPlugin, so no need to add them again
    corejs: false,
    helpers: useBuiltIns === 'usage',
    useESModules: !process.env.VUE_CLI_BABEL_TRANSPILE_MODULES,
    absoluteRuntime: absoluteRuntime,
    version: version
  }]);
  return {
    sourceType: 'unambiguous',
    overrides: [{
      exclude: [/@babel[\/|\\\\]runtime/, /core-js/],
      presets: presets,
      plugins: plugins
    }, {
      // there are some untranspiled code in @babel/runtime
      // https://github.com/babel/babel/issues/9903
      include: [/@babel[\/|\\\\]runtime/],
      presets: [[require('@babel/preset-env'), envOptions]]
    }]
  };
}; // a special flag to tell @vue/cli-plugin-babel to include @babel/runtime for transpilation
// otherwise the above `include` option won't take effect


process.env.VUE_CLI_TRANSPILE_BABEL_RUNTIME = true;