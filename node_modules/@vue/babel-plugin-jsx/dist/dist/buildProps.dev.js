"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var t = __importStar(require("@babel/types"));

var helper_module_imports_1 = require("@babel/helper-module-imports");

var utils_1 = require("./utils");

var parseDirectives_1 = __importDefault(require("./parseDirectives"));

var transform_vue_jsx_1 = require("./transform-vue-jsx");

var xlinkRE = /^xlink([A-Z])/;
var onRE = /^on[^a-z]/;

var isOn = function isOn(key) {
  return onRE.test(key);
};

var getJSXAttributeValue = function getJSXAttributeValue(path, state) {
  var valuePath = path.get('value');

  if (valuePath.isJSXElement()) {
    return transform_vue_jsx_1.transformJSXElement(valuePath, state);
  }

  if (valuePath.isStringLiteral()) {
    return valuePath.node;
  }

  if (valuePath.isJSXExpressionContainer()) {
    return utils_1.transformJSXExpressionContainer(valuePath);
  }

  return null;
};

var transformJSXSpreadAttribute = function transformJSXSpreadAttribute(nodePath, path, mergeProps, args) {
  var argument = path.get('argument');
  var properties = argument.node.properties;

  if (!properties) {
    if (argument.isIdentifier()) {
      utils_1.walksScope(nodePath, argument.node.name, 2
      /* DYNAMIC */
      );
    }

    args.push(mergeProps ? argument.node : t.spreadElement(argument.node));
  } else {
    args.push(t.objectExpression(properties));
  }
};

var mergeAsArray = function mergeAsArray(existing, incoming) {
  if (t.isArrayExpression(existing.value)) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = t.arrayExpression([existing.value, incoming.value]);
  }
};

var dedupeProperties = function dedupeProperties() {
  var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var mergeProps = arguments.length > 1 ? arguments[1] : undefined;

  if (!mergeProps) {
    return properties;
  }

  var knownProps = new Map();
  var deduped = [];
  properties.forEach(function (prop) {
    var name = prop.key.value;
    var existing = knownProps.get(name);

    if (existing) {
      if (name === 'style' || name === 'class' || name.startsWith('on')) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  });
  return deduped;
};
/**
 *  Check if an attribute value is constant
 * @param node
 * @returns boolean
 */


var isConstant = function isConstant(node) {
  if (t.isIdentifier(node)) {
    return node.name === 'undefined';
  }

  if (t.isArrayExpression(node)) {
    var elements = node.elements;
    return elements.every(function (element) {
      return element && isConstant(element);
    });
  }

  if (t.isObjectExpression(node)) {
    return node.properties.every(function (property) {
      return isConstant(property.value);
    });
  }

  if (t.isLiteral(node)) {
    return true;
  }

  return false;
};

var buildProps = function buildProps(path, state) {
  var tag = utils_1.getTag(path, state);
  var isComponent = utils_1.checkIsComponent(path.get('openingElement'));
  var props = path.get('openingElement').get('attributes');
  var directives = [];
  var dynamicPropNames = new Set();
  var slots = null;
  var patchFlag = 0;

  if (props.length === 0) {
    return {
      tag: tag,
      isComponent: isComponent,
      slots: slots,
      props: t.nullLiteral(),
      directives: directives,
      patchFlag: patchFlag,
      dynamicPropNames: dynamicPropNames
    };
  }

  var properties = []; // patchFlag analysis

  var hasRef = false;
  var hasClassBinding = false;
  var hasStyleBinding = false;
  var hasHydrationEventBinding = false;
  var hasDynamicKeys = false;
  var mergeArgs = [];
  var _state$opts$mergeProp = state.opts.mergeProps,
      mergeProps = _state$opts$mergeProp === void 0 ? true : _state$opts$mergeProp;
  props.forEach(function (prop) {
    var _a;

    if (prop.isJSXAttribute()) {
      var name = utils_1.getJSXAttributeName(prop);
      var attributeValue = getJSXAttributeValue(prop, state);

      if (!isConstant(attributeValue) || name === 'ref') {
        if (!isComponent && isOn(name) // omit the flag for click handlers becaues hydration gives click
        // dedicated fast path.
        && name.toLowerCase() !== 'onclick' // omit v-model handlers
        && name !== 'onUpdate:modelValue') {
          hasHydrationEventBinding = true;
        }

        if (name === 'ref') {
          hasRef = true;
        } else if (name === 'class' && !isComponent) {
          hasClassBinding = true;
        } else if (name === 'style' && !isComponent) {
          hasStyleBinding = true;
        } else if (name !== 'key' && !utils_1.isDirective(name) && name !== 'on') {
          dynamicPropNames.add(name);
        }
      }

      if (state.opts.transformOn && (name === 'on' || name === 'nativeOn')) {
        if (!state.get('transformOn')) {
          state.set('transformOn', helper_module_imports_1.addDefault(path, '@vue/babel-helper-vue-transform-on', {
            nameHint: '_transformOn'
          }));
        }

        mergeArgs.push(t.callExpression(state.get('transformOn'), [attributeValue || t.booleanLiteral(true)]));
        return;
      }

      if (utils_1.isDirective(name)) {
        var _parseDirectives_1$de = parseDirectives_1["default"]({
          tag: tag,
          isComponent: isComponent,
          name: name,
          path: prop,
          state: state,
          value: attributeValue
        }),
            directive = _parseDirectives_1$de.directive,
            modifiers = _parseDirectives_1$de.modifiers,
            value = _parseDirectives_1$de.value,
            arg = _parseDirectives_1$de.arg,
            directiveName = _parseDirectives_1$de.directiveName;

        var argVal = (_a = arg) === null || _a === void 0 ? void 0 : _a.value;
        var propName = argVal || 'modelValue';

        if (directiveName === 'slots') {
          slots = attributeValue;
          return;
        }

        if (directive) {
          directives.push(t.arrayExpression(directive));
        } else if (directiveName === 'model') {
          // must be v-model and is a component
          properties.push(t.objectProperty(arg || t.stringLiteral('modelValue'), // @ts-ignore
          value));
          dynamicPropNames.add(propName);

          if (modifiers.size) {
            properties.push(t.objectProperty(t.stringLiteral("".concat(argVal || 'model', "Modifiers")), t.objectExpression(_toConsumableArray(modifiers).map(function (modifier) {
              return t.objectProperty(t.stringLiteral(modifier), t.booleanLiteral(true));
            }))));
          }
        } else if (directiveName === 'html') {
          properties.push(t.objectProperty(t.stringLiteral('innerHTML'), value));
          dynamicPropNames.add('innerHTML');
        } else if (directiveName === 'text') {
          properties.push(t.objectProperty(t.stringLiteral('textContent'), value));
          dynamicPropNames.add('textContent');
        }

        if (directiveName === 'model' && value) {
          properties.push(t.objectProperty(t.stringLiteral("onUpdate:".concat(propName)), t.arrowFunctionExpression([t.identifier('$event')], // @ts-ignore
          t.assignmentExpression('=', value, t.identifier('$event')))));
          dynamicPropNames.add("onUpdate:".concat(propName));
        }
      } else {
        if (name.match(xlinkRE)) {
          name = name.replace(xlinkRE, function (_, firstCharacter) {
            return "xlink:".concat(firstCharacter.toLowerCase());
          });
        }

        properties.push(t.objectProperty(t.stringLiteral(name), attributeValue || t.booleanLiteral(true)));
      }
    } else {
      if (properties.length && mergeProps) {
        mergeArgs.push(t.objectExpression(dedupeProperties(properties, mergeProps)));
        properties = [];
      } // JSXSpreadAttribute


      hasDynamicKeys = true;
      transformJSXSpreadAttribute(path, prop, mergeProps, mergeProps ? mergeArgs : properties);
    }
  }); // patchFlag analysis

  if (hasDynamicKeys) {
    patchFlag |= 16
    /* FULL_PROPS */
    ;
  } else {
    if (hasClassBinding) {
      patchFlag |= 2
      /* CLASS */
      ;
    }

    if (hasStyleBinding) {
      patchFlag |= 4
      /* STYLE */
      ;
    }

    if (dynamicPropNames.size) {
      patchFlag |= 8
      /* PROPS */
      ;
    }

    if (hasHydrationEventBinding) {
      patchFlag |= 32
      /* HYDRATE_EVENTS */
      ;
    }
  }

  if ((patchFlag === 0 || patchFlag === 32
  /* HYDRATE_EVENTS */
  ) && (hasRef || directives.length > 0)) {
    patchFlag |= 512
    /* NEED_PATCH */
    ;
  }

  var propsExpression = t.nullLiteral();

  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(t.objectExpression(dedupeProperties(properties, mergeProps)));
    }

    if (mergeArgs.length > 1) {
      propsExpression = t.callExpression(utils_1.createIdentifier(state, 'mergeProps'), mergeArgs);
    } else {
      // single no need for a mergeProps call
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    // single no need for spread
    if (properties.length === 1 && t.isSpreadElement(properties[0])) {
      propsExpression = properties[0].argument;
    } else {
      propsExpression = t.objectExpression(dedupeProperties(properties, mergeProps));
    }
  }

  return {
    tag: tag,
    props: propsExpression,
    isComponent: isComponent,
    slots: slots,
    directives: directives,
    patchFlag: patchFlag,
    dynamicPropNames: dynamicPropNames
  };
};

exports["default"] = buildProps;