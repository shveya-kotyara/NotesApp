"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformJSXElement = void 0;

var t = __importStar(require("@babel/types"));

var utils_1 = require("./utils");

var buildProps_1 = __importDefault(require("./buildProps"));
/**
 * Get children from Array of JSX children
 * @param paths Array<JSXText | JSXExpressionContainer  | JSXElement | JSXFragment>
 * @returns Array<Expression | SpreadElement>
 */


var getChildren = function getChildren(paths, state) {
  return paths.map(function (path) {
    if (path.isJSXText()) {
      var transformedText = utils_1.transformJSXText(path);

      if (transformedText) {
        return t.callExpression(utils_1.createIdentifier(state, 'createTextVNode'), [transformedText]);
      }

      return transformedText;
    }

    if (path.isJSXExpressionContainer()) {
      var expression = utils_1.transformJSXExpressionContainer(path);

      if (t.isIdentifier(expression)) {
        var name = expression.name;

        var _ref = path.scope.getBinding(name) || {},
            _ref$referencePaths = _ref.referencePaths,
            referencePaths = _ref$referencePaths === void 0 ? [] : _ref$referencePaths;

        referencePaths.forEach(function (referencePath) {
          utils_1.walksScope(referencePath, name, 2
          /* DYNAMIC */
          );
        });
      }

      return expression;
    }

    if (t.isJSXSpreadChild(path)) {
      return utils_1.transformJSXSpreadChild(path);
    }

    if (path.isCallExpression()) {
      return path.node;
    }

    if (path.isJSXElement()) {
      return transformJSXElement(path, state);
    }

    throw new Error("getChildren: ".concat(path.type, " is not supported"));
  }).filter(function (value) {
    return value !== undefined && value !== null && !t.isJSXEmptyExpression(value);
  });
};

var transformJSXElement = function transformJSXElement(path, state) {
  var children = getChildren(path.get('children'), state);

  var _buildProps_1$default = buildProps_1["default"](path, state),
      tag = _buildProps_1$default.tag,
      props = _buildProps_1$default.props,
      isComponent = _buildProps_1$default.isComponent,
      directives = _buildProps_1$default.directives,
      patchFlag = _buildProps_1$default.patchFlag,
      dynamicPropNames = _buildProps_1$default.dynamicPropNames,
      slots = _buildProps_1$default.slots;

  var _state$opts$optimize = state.opts.optimize,
      optimize = _state$opts$optimize === void 0 ? false : _state$opts$optimize;
  var slotFlag = path.getData('slotFlag') || 1
  /* STABLE */
  ; // @ts-ignore

  var createVNode = t.callExpression(utils_1.createIdentifier(state, 'createVNode'), [tag, props, children.length || slots ? isComponent ? t.objectExpression([!!children.length && t.objectProperty(t.identifier('default'), t.arrowFunctionExpression([], t.arrayExpression(utils_1.buildIIFE(path, children))))].concat(_toConsumableArray(slots ? t.isObjectExpression(slots) ? slots.properties : [t.spreadElement(slots)] : []), [optimize && t.objectProperty(t.identifier('_'), t.numericLiteral(slotFlag))]).filter(Boolean)) : t.arrayExpression(children) : t.nullLiteral(), !!patchFlag && optimize && t.numericLiteral(patchFlag), !!dynamicPropNames.size && optimize && t.arrayExpression(_toConsumableArray(dynamicPropNames.keys()).map(function (name) {
    return t.stringLiteral(name);
  }))].filter(Boolean));

  if (!directives.length) {
    return createVNode;
  }

  return t.callExpression(utils_1.createIdentifier(state, 'withDirectives'), [createVNode, t.arrayExpression(directives)]);
};

exports.transformJSXElement = transformJSXElement;

exports["default"] = function () {
  return {
    JSXElement: {
      exit: function exit(path, state) {
        path.replaceWith(transformJSXElement(path, state));
      }
    }
  };
};