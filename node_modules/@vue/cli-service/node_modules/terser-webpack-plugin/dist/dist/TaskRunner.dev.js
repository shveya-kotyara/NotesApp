"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _os = _interopRequireDefault(require("os"));

var _pLimit = _interopRequireDefault(require("p-limit"));

var _jestWorker = _interopRequireDefault(require("jest-worker"));

var _serializeJavascript = _interopRequireDefault(require("serialize-javascript"));

var _minify = _interopRequireDefault(require("./minify"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var workerPath = require.resolve('./worker');

var TaskRunner =
/*#__PURE__*/
function () {
  function TaskRunner() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TaskRunner);

    this.taskGenerator = options.taskGenerator;
    this.files = options.files;
    this.cache = options.cache;
    this.availableNumberOfCores = TaskRunner.getAvailableNumberOfCores(options.parallel);
  }

  _createClass(TaskRunner, [{
    key: "runTask",
    value: function runTask(task) {
      return regeneratorRuntime.async(function runTask$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.worker) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", this.worker.transform((0, _serializeJavascript["default"])(task)));

            case 2:
              return _context.abrupt("return", (0, _minify["default"])(task));

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      var availableNumberOfCores, cache, files, taskGenerator, concurrency, numWorkers, workerStdout, workerStderr, limit, scheduledTasks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;

      return regeneratorRuntime.async(function run$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              availableNumberOfCores = this.availableNumberOfCores, cache = this.cache, files = this.files, taskGenerator = this.taskGenerator;
              concurrency = Infinity;

              if (availableNumberOfCores > 0) {
                // Do not create unnecessary workers when the number of files is less than the available cores, it saves memory
                numWorkers = Math.min(files.length, availableNumberOfCores);
                concurrency = numWorkers;
                this.worker = new _jestWorker["default"](workerPath, {
                  numWorkers: numWorkers
                }); // https://github.com/facebook/jest/issues/8872#issuecomment-524822081

                workerStdout = this.worker.getStdout();

                if (workerStdout) {
                  workerStdout.on('data', function (chunk) {
                    return process.stdout.write(chunk);
                  });
                }

                workerStderr = this.worker.getStderr();

                if (workerStderr) {
                  workerStderr.on('data', function (chunk) {
                    return process.stderr.write(chunk);
                  });
                }
              }

              limit = (0, _pLimit["default"])(concurrency);
              scheduledTasks = [];
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context3.prev = 8;

              _loop = function _loop() {
                var file = _step.value;

                var enqueue = function enqueue(task) {
                  var taskResult;
                  return regeneratorRuntime.async(function enqueue$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.prev = 0;
                          _context2.next = 3;
                          return regeneratorRuntime.awrap(_this.runTask(task));

                        case 3:
                          taskResult = _context2.sent;
                          _context2.next = 9;
                          break;

                        case 6:
                          _context2.prev = 6;
                          _context2.t0 = _context2["catch"](0);
                          taskResult = {
                            error: _context2.t0
                          };

                        case 9:
                          if (!(cache.isEnabled() && !taskResult.error)) {
                            _context2.next = 13;
                            break;
                          }

                          _context2.next = 12;
                          return regeneratorRuntime.awrap(cache.store(task, taskResult).then(function () {
                            return taskResult;
                          }, function () {
                            return taskResult;
                          }));

                        case 12:
                          taskResult = _context2.sent;

                        case 13:
                          task.callback(taskResult);
                          return _context2.abrupt("return", taskResult);

                        case 15:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, null, null, [[0, 6]]);
                };

                scheduledTasks.push(limit(function () {
                  var task = taskGenerator(file).next().value;

                  if (!task) {
                    // Something went wrong, for example the `cacheKeys` option throw an error
                    return Promise.resolve();
                  }

                  if (cache.isEnabled()) {
                    return cache.get(task).then(function (taskResult) {
                      return task.callback(taskResult);
                    }, function () {
                      return enqueue(task);
                    });
                  }

                  return enqueue(task);
                }));
              };

              for (_iterator = files[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                _loop();
              }

              _context3.next = 17;
              break;

            case 13:
              _context3.prev = 13;
              _context3.t0 = _context3["catch"](8);
              _didIteratorError = true;
              _iteratorError = _context3.t0;

            case 17:
              _context3.prev = 17;
              _context3.prev = 18;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 20:
              _context3.prev = 20;

              if (!_didIteratorError) {
                _context3.next = 23;
                break;
              }

              throw _iteratorError;

            case 23:
              return _context3.finish(20);

            case 24:
              return _context3.finish(17);

            case 25:
              return _context3.abrupt("return", Promise.all(scheduledTasks));

            case 26:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[8, 13, 17, 25], [18,, 20, 24]]);
    }
  }, {
    key: "exit",
    value: function exit() {
      return regeneratorRuntime.async(function exit$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (this.worker) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return", Promise.resolve());

            case 2:
              return _context4.abrupt("return", this.worker.end());

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }], [{
    key: "getAvailableNumberOfCores",
    value: function getAvailableNumberOfCores(parallel) {
      // In some cases cpus() returns undefined
      // https://github.com/nodejs/node/issues/19022
      var cpus = _os["default"].cpus() || {
        length: 1
      };
      return parallel === true ? cpus.length - 1 : Math.min(Number(parallel) || 0, cpus.length - 1);
    }
  }]);

  return TaskRunner;
}();

exports["default"] = TaskRunner;