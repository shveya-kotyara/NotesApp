'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var fs = require('fs');

var path = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var semver = require('semver');

var useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0'); // https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088

var checkPath = function checkPath(pth) {
  if (process.platform === 'win32') {
    var pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

    if (pathHasInvalidWinCharacters) {
      var error = new Error("Path contains invalid characters: ".concat(pth));
      error.code = 'EINVAL';
      throw error;
    }
  }
};

var processOptions = function processOptions(options) {
  // https://github.com/sindresorhus/make-dir/issues/18
  var defaults = {
    mode: 511,
    fs: fs
  };
  return _objectSpread({}, defaults, {}, options);
};

var permissionError = function permissionError(pth) {
  // This replicates the exception of `fs.mkdir` with native the
  // `recusive` option when run on an invalid drive under Windows.
  var error = new Error("operation not permitted, mkdir '".concat(pth, "'"));
  error.code = 'EPERM';
  error.errno = -4048;
  error.path = pth;
  error.syscall = 'mkdir';
  return error;
};

var makeDir = function makeDir(input, options) {
  var mkdir, stat, pth, make;
  return regeneratorRuntime.async(function makeDir$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          checkPath(input);
          options = processOptions(options);
          mkdir = promisify(options.fs.mkdir);
          stat = promisify(options.fs.stat);

          if (!(useNativeRecursiveOption && options.fs.mkdir === fs.mkdir)) {
            _context2.next = 9;
            break;
          }

          pth = path.resolve(input);
          _context2.next = 8;
          return regeneratorRuntime.awrap(mkdir(pth, {
            mode: options.mode,
            recursive: true
          }));

        case 8:
          return _context2.abrupt("return", pth);

        case 9:
          make = function make(pth) {
            var stats;
            return regeneratorRuntime.async(function make$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    _context.next = 3;
                    return regeneratorRuntime.awrap(mkdir(pth, options.mode));

                  case 3:
                    return _context.abrupt("return", pth);

                  case 6:
                    _context.prev = 6;
                    _context.t0 = _context["catch"](0);

                    if (!(_context.t0.code === 'EPERM')) {
                      _context.next = 10;
                      break;
                    }

                    throw _context.t0;

                  case 10:
                    if (!(_context.t0.code === 'ENOENT')) {
                      _context.next = 18;
                      break;
                    }

                    if (!(path.dirname(pth) === pth)) {
                      _context.next = 13;
                      break;
                    }

                    throw permissionError(pth);

                  case 13:
                    if (!_context.t0.message.includes('null bytes')) {
                      _context.next = 15;
                      break;
                    }

                    throw _context.t0;

                  case 15:
                    _context.next = 17;
                    return regeneratorRuntime.awrap(make(path.dirname(pth)));

                  case 17:
                    return _context.abrupt("return", make(pth));

                  case 18:
                    _context.prev = 18;
                    _context.next = 21;
                    return regeneratorRuntime.awrap(stat(pth));

                  case 21:
                    stats = _context.sent;

                    if (stats.isDirectory()) {
                      _context.next = 24;
                      break;
                    }

                    throw new Error('The path is not a directory');

                  case 24:
                    _context.next = 29;
                    break;

                  case 26:
                    _context.prev = 26;
                    _context.t1 = _context["catch"](18);
                    throw _context.t0;

                  case 29:
                    return _context.abrupt("return", pth);

                  case 30:
                  case "end":
                    return _context.stop();
                }
              }
            }, null, null, [[0, 6], [18, 26]]);
          };

          return _context2.abrupt("return", make(path.resolve(input)));

        case 11:
        case "end":
          return _context2.stop();
      }
    }
  });
};

module.exports = makeDir;

module.exports.sync = function (input, options) {
  checkPath(input);
  options = processOptions(options);

  if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
    var pth = path.resolve(input);
    fs.mkdirSync(pth, {
      mode: options.mode,
      recursive: true
    });
    return pth;
  }

  var make = function make(pth) {
    try {
      options.fs.mkdirSync(pth, options.mode);
    } catch (error) {
      if (error.code === 'EPERM') {
        throw error;
      }

      if (error.code === 'ENOENT') {
        if (path.dirname(pth) === pth) {
          throw permissionError(pth);
        }

        if (error.message.includes('null bytes')) {
          throw error;
        }

        make(path.dirname(pth));
        return make(pth);
      }

      try {
        if (!options.fs.statSync(pth).isDirectory()) {
          throw new Error('The path is not a directory');
        }
      } catch (_) {
        throw error;
      }
    }

    return pth;
  };

  return make(path.resolve(input));
};