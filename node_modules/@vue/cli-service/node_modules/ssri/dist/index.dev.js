'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var crypto = require('crypto');

var figgyPudding = require('figgy-pudding');

var MiniPass = require('minipass');

var SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];
var BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;
var SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/;
var STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)*$/;
var VCHAR_REGEX = /^[\x21-\x7E]+$/;
var SsriOpts = figgyPudding({
  algorithms: {
    "default": ['sha512']
  },
  error: {
    "default": false
  },
  integrity: {},
  options: {
    "default": []
  },
  pickAlgorithm: {
    "default": function _default() {
      return getPrioritizedHash;
    }
  },
  sep: {
    "default": ' '
  },
  single: {
    "default": false
  },
  size: {},
  strict: {
    "default": false
  }
});

var getOptString = function getOptString(options) {
  return !options || !options.length ? '' : "?".concat(options.join('?'));
};

var _onEnd = Symbol('_onEnd');

var _getOptions = Symbol('_getOptions');

var IntegrityStream =
/*#__PURE__*/
function (_MiniPass) {
  _inherits(IntegrityStream, _MiniPass);

  function IntegrityStream(opts) {
    var _this;

    _classCallCheck(this, IntegrityStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(IntegrityStream).call(this));
    _this.size = 0;
    _this.opts = opts; // may be overridden later, but set now for class consistency

    _this[_getOptions](); // options used for calculating stream.  can't be changed.


    _this.algorithms = Array.from(new Set(opts.algorithms.concat(_this.algorithm ? [_this.algorithm] : [])));
    _this.hashes = _this.algorithms.map(crypto.createHash);
    return _this;
  }

  _createClass(IntegrityStream, [{
    key: _getOptions,
    value: function value() {
      var opts = this.opts; // For verification

      this.sri = opts.integrity ? parse(opts.integrity, opts) : null;
      this.expectedSize = opts.size;
      this.goodSri = this.sri ? !!Object.keys(this.sri).length : false;
      this.algorithm = this.goodSri ? this.sri.pickAlgorithm(opts) : null;
      this.digests = this.goodSri ? this.sri[this.algorithm] : null;
      this.optString = getOptString(opts.options);
    }
  }, {
    key: "emit",
    value: function emit(ev, data) {
      if (ev === 'end') this[_onEnd]();
      return _get(_getPrototypeOf(IntegrityStream.prototype), "emit", this).call(this, ev, data);
    }
  }, {
    key: "write",
    value: function write(data) {
      this.size += data.length;
      this.hashes.forEach(function (h) {
        return h.update(data);
      });
      return _get(_getPrototypeOf(IntegrityStream.prototype), "write", this).call(this, data);
    }
  }, {
    key: _onEnd,
    value: function value() {
      var _this2 = this;

      if (!this.goodSri) {
        this[_getOptions]();
      }

      var newSri = parse(this.hashes.map(function (h, i) {
        return "".concat(_this2.algorithms[i], "-").concat(h.digest('base64')).concat(_this2.optString);
      }).join(' '), this.opts); // Integrity verification mode

      var match = this.goodSri && newSri.match(this.sri, this.opts);

      if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {
        var err = new Error("stream size mismatch when checking ".concat(this.sri, ".\n  Wanted: ").concat(this.expectedSize, "\n  Found: ").concat(this.size));
        err.code = 'EBADSIZE';
        err.found = this.size;
        err.expected = this.expectedSize;
        err.sri = this.sri;
        this.emit('error', err);
      } else if (this.sri && !match) {
        var _err = new Error("".concat(this.sri, " integrity checksum failed when using ").concat(this.algorithm, ": wanted ").concat(this.digests, " but got ").concat(newSri, ". (").concat(this.size, " bytes)"));

        _err.code = 'EINTEGRITY';
        _err.found = newSri;
        _err.expected = this.digests;
        _err.algorithm = this.algorithm;
        _err.sri = this.sri;
        this.emit('error', _err);
      } else {
        this.emit('size', this.size);
        this.emit('integrity', newSri);
        match && this.emit('verified', match);
      }
    }
  }]);

  return IntegrityStream;
}(MiniPass);

var Hash =
/*#__PURE__*/
function () {
  _createClass(Hash, [{
    key: "isHash",
    get: function get() {
      return true;
    }
  }]);

  function Hash(hash, opts) {
    _classCallCheck(this, Hash);

    opts = SsriOpts(opts);
    var strict = !!opts.strict;
    this.source = hash.trim(); // set default values so that we make V8 happy to
    // always see a familiar object template.

    this.digest = '';
    this.algorithm = '';
    this.options = []; // 3.1. Integrity metadata (called "Hash" by ssri)
    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description

    var match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);

    if (!match) {
      return;
    }

    if (strict && !SPEC_ALGORITHMS.some(function (a) {
      return a === match[1];
    })) {
      return;
    }

    this.algorithm = match[1];
    this.digest = match[2];
    var rawOpts = match[3];

    if (rawOpts) {
      this.options = rawOpts.slice(1).split('?');
    }
  }

  _createClass(Hash, [{
    key: "hexDigest",
    value: function hexDigest() {
      return this.digest && Buffer.from(this.digest, 'base64').toString('hex');
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "toString",
    value: function toString(opts) {
      var _this3 = this;

      opts = SsriOpts(opts);

      if (opts.strict) {
        // Strict mode enforces the standard as close to the foot of the
        // letter as it can.
        if (!( // The spec has very restricted productions for algorithms.
        // https://www.w3.org/TR/CSP2/#source-list-syntax
        SPEC_ALGORITHMS.some(function (x) {
          return x === _this3.algorithm;
        }) && // Usually, if someone insists on using a "different" base64, we
        // leave it as-is, since there's multiple standards, and the
        // specified is not a URL-safe variant.
        // https://www.w3.org/TR/CSP2/#base64_value
        this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.
        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression
        // https://tools.ietf.org/html/rfc5234#appendix-B.1
        this.options.every(function (opt) {
          return opt.match(VCHAR_REGEX);
        }))) {
          return '';
        }
      }

      var options = this.options && this.options.length ? "?".concat(this.options.join('?')) : '';
      return "".concat(this.algorithm, "-").concat(this.digest).concat(options);
    }
  }]);

  return Hash;
}();

var Integrity =
/*#__PURE__*/
function () {
  function Integrity() {
    _classCallCheck(this, Integrity);
  }

  _createClass(Integrity, [{
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "toString",
    value: function toString(opts) {
      var _this4 = this;

      opts = SsriOpts(opts);
      var sep = opts.sep || ' ';

      if (opts.strict) {
        // Entries must be separated by whitespace, according to spec.
        sep = sep.replace(/\S+/g, ' ');
      }

      return Object.keys(this).map(function (k) {
        return _this4[k].map(function (hash) {
          return Hash.prototype.toString.call(hash, opts);
        }).filter(function (x) {
          return x.length;
        }).join(sep);
      }).filter(function (x) {
        return x.length;
      }).join(sep);
    }
  }, {
    key: "concat",
    value: function concat(integrity, opts) {
      opts = SsriOpts(opts);
      var other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);
      return parse("".concat(this.toString(opts), " ").concat(other), opts);
    }
  }, {
    key: "hexDigest",
    value: function hexDigest() {
      return parse(this, {
        single: true
      }).hexDigest();
    } // add additional hashes to an integrity value, but prevent
    // *changing* an existing integrity hash.

  }, {
    key: "merge",
    value: function merge(integrity, opts) {
      var _this5 = this;

      opts = SsriOpts(opts);
      var other = parse(integrity, opts);

      var _loop = function _loop(algo) {
        if (_this5[algo]) {
          if (!_this5[algo].find(function (hash) {
            return other[algo].find(function (otherhash) {
              return hash.digest === otherhash.digest;
            });
          })) {
            throw new Error('hashes do not match, cannot update integrity');
          }
        } else {
          _this5[algo] = other[algo];
        }
      };

      for (var algo in other) {
        _loop(algo);
      }
    }
  }, {
    key: "match",
    value: function match(integrity, opts) {
      opts = SsriOpts(opts);
      var other = parse(integrity, opts);
      var algo = other.pickAlgorithm(opts);
      return this[algo] && other[algo] && this[algo].find(function (hash) {
        return other[algo].find(function (otherhash) {
          return hash.digest === otherhash.digest;
        });
      }) || false;
    }
  }, {
    key: "pickAlgorithm",
    value: function pickAlgorithm(opts) {
      opts = SsriOpts(opts);
      var pickAlgorithm = opts.pickAlgorithm;
      var keys = Object.keys(this);

      if (!keys.length) {
        throw new Error("No algorithms available for ".concat(JSON.stringify(this.toString())));
      }

      return keys.reduce(function (acc, algo) {
        return pickAlgorithm(acc, algo) || acc;
      });
    }
  }, {
    key: "isIntegrity",
    get: function get() {
      return true;
    }
  }]);

  return Integrity;
}();

module.exports.parse = parse;

function parse(sri, opts) {
  opts = SsriOpts(opts);

  if (typeof sri === 'string') {
    return _parse(sri, opts);
  } else if (sri.algorithm && sri.digest) {
    var fullSri = new Integrity();
    fullSri[sri.algorithm] = [sri];
    return _parse(stringify(fullSri, opts), opts);
  } else {
    return _parse(stringify(sri, opts), opts);
  }
}

function _parse(integrity, opts) {
  // 3.4.3. Parse metadata
  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
  if (opts.single) {
    return new Hash(integrity, opts);
  }

  return integrity.trim().split(/\s+/).reduce(function (acc, string) {
    var hash = new Hash(string, opts);

    if (hash.algorithm && hash.digest) {
      var algo = hash.algorithm;

      if (!acc[algo]) {
        acc[algo] = [];
      }

      acc[algo].push(hash);
    }

    return acc;
  }, new Integrity());
}

module.exports.stringify = stringify;

function stringify(obj, opts) {
  opts = SsriOpts(opts);

  if (obj.algorithm && obj.digest) {
    return Hash.prototype.toString.call(obj, opts);
  } else if (typeof obj === 'string') {
    return stringify(parse(obj, opts), opts);
  } else {
    return Integrity.prototype.toString.call(obj, opts);
  }
}

module.exports.fromHex = fromHex;

function fromHex(hexDigest, algorithm, opts) {
  opts = SsriOpts(opts);
  var optString = getOptString(opts.options);
  return parse("".concat(algorithm, "-").concat(Buffer.from(hexDigest, 'hex').toString('base64')).concat(optString), opts);
}

module.exports.fromData = fromData;

function fromData(data, opts) {
  opts = SsriOpts(opts);
  var algorithms = opts.algorithms;
  var optString = getOptString(opts.options);
  return algorithms.reduce(function (acc, algo) {
    var digest = crypto.createHash(algo).update(data).digest('base64');
    var hash = new Hash("".concat(algo, "-").concat(digest).concat(optString), opts);
    /* istanbul ignore else - it would be VERY strange if the string we
     * just calculated with an algo did not have an algo or digest.
     */

    if (hash.algorithm && hash.digest) {
      var _algo = hash.algorithm;

      if (!acc[_algo]) {
        acc[_algo] = [];
      }

      acc[_algo].push(hash);
    }

    return acc;
  }, new Integrity());
}

module.exports.fromStream = fromStream;

function fromStream(stream, opts) {
  opts = SsriOpts(opts);
  var istream = integrityStream(opts);
  return new Promise(function (resolve, reject) {
    stream.pipe(istream);
    stream.on('error', reject);
    istream.on('error', reject);
    var sri;
    istream.on('integrity', function (s) {
      sri = s;
    });
    istream.on('end', function () {
      return resolve(sri);
    });
    istream.on('data', function () {});
  });
}

module.exports.checkData = checkData;

function checkData(data, sri, opts) {
  opts = SsriOpts(opts);
  sri = parse(sri, opts);

  if (!Object.keys(sri).length) {
    if (opts.error) {
      throw Object.assign(new Error('No valid integrity hashes to check against'), {
        code: 'EINTEGRITY'
      });
    } else {
      return false;
    }
  }

  var algorithm = sri.pickAlgorithm(opts);
  var digest = crypto.createHash(algorithm).update(data).digest('base64');
  var newSri = parse({
    algorithm: algorithm,
    digest: digest
  });
  var match = newSri.match(sri, opts);

  if (match || !opts.error) {
    return match;
  } else if (typeof opts.size === 'number' && data.length !== opts.size) {
    var err = new Error("data size mismatch when checking ".concat(sri, ".\n  Wanted: ").concat(opts.size, "\n  Found: ").concat(data.length));
    err.code = 'EBADSIZE';
    err.found = data.length;
    err.expected = opts.size;
    err.sri = sri;
    throw err;
  } else {
    var _err2 = new Error("Integrity checksum failed when using ".concat(algorithm, ": Wanted ").concat(sri, ", but got ").concat(newSri, ". (").concat(data.length, " bytes)"));

    _err2.code = 'EINTEGRITY';
    _err2.found = newSri;
    _err2.expected = sri;
    _err2.algorithm = algorithm;
    _err2.sri = sri;
    throw _err2;
  }
}

module.exports.checkStream = checkStream;

function checkStream(stream, sri, opts) {
  opts = SsriOpts(opts);
  var checker = integrityStream(opts.concat({
    integrity: sri
  }));
  return new Promise(function (resolve, reject) {
    stream.pipe(checker);
    stream.on('error', reject);
    checker.on('error', reject);
    var sri;
    checker.on('verified', function (s) {
      sri = s;
    });
    checker.on('end', function () {
      return resolve(sri);
    });
    checker.on('data', function () {});
  });
}

module.exports.integrityStream = integrityStream;

function integrityStream(opts) {
  return new IntegrityStream(SsriOpts(opts));
}

module.exports.create = createIntegrity;

function createIntegrity(opts) {
  opts = SsriOpts(opts);
  var algorithms = opts.algorithms;
  var optString = getOptString(opts.options);
  var hashes = algorithms.map(crypto.createHash);
  return {
    update: function update(chunk, enc) {
      hashes.forEach(function (h) {
        return h.update(chunk, enc);
      });
      return this;
    },
    digest: function digest(enc) {
      var integrity = algorithms.reduce(function (acc, algo) {
        var digest = hashes.shift().digest('base64');
        var hash = new Hash("".concat(algo, "-").concat(digest).concat(optString), opts);
        /* istanbul ignore else - it would be VERY strange if the hash we
         * just calculated with an algo did not have an algo or digest.
         */

        if (hash.algorithm && hash.digest) {
          var _algo2 = hash.algorithm;

          if (!acc[_algo2]) {
            acc[_algo2] = [];
          }

          acc[_algo2].push(hash);
        }

        return acc;
      }, new Integrity());
      return integrity;
    }
  };
}

var NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos

var DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name
//        for the algorithm, so we guesswork it based on the OpenSSL names.
'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(function (algo) {
  return NODE_HASHES.has(algo);
});

function getPrioritizedHash(algo1, algo2) {
  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;
}