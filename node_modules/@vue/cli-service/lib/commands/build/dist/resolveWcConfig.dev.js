"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var path = require('path');

var _require = require('./resolveWcEntry'),
    resolveEntry = _require.resolveEntry,
    fileToComponentName = _require.fileToComponentName;

module.exports = function (api, _ref) {
  var target = _ref.target,
      entry = _ref.entry,
      name = _ref.name,
      inlineVue = _ref['inline-vue'];
  // Disable CSS extraction and turn on CSS shadow mode for vue-style-loader
  process.env.VUE_CLI_CSS_SHADOW_MODE = true;

  var _require2 = require('@vue/cli-shared-utils'),
      log = _require2.log,
      error = _require2.error,
      loadModule = _require2.loadModule,
      semver = _require2.semver;

  var abort = function abort(msg) {
    log();
    error(msg);
    process.exit(1);
  };

  var vue = loadModule('vue', api.resolve('.'));

  if (vue && semver.satisfies(vue.version, '^3.0.0-0')) {
    abort("Vue 3 support of the web component target is still under development.");
  }

  var isAsync = /async/.test(target); // generate dynamic entry based on glob files

  var resolvedFiles = require('globby').sync(entry.split(','), {
    cwd: api.resolve('.')
  });

  if (!resolvedFiles.length) {
    abort("entry pattern \"".concat(entry, "\" did not match any files."));
  }

  var libName;
  var prefix;

  if (resolvedFiles.length === 1) {
    // in single mode, determine the lib name from filename
    libName = name || fileToComponentName('', resolvedFiles[0]).kebabName;
    prefix = '';

    if (libName.indexOf('-') < 0) {
      abort("--name must contain a hyphen when building a single web component.");
    }
  } else {
    // multi mode
    libName = prefix = name || api.service.pkg.name;

    if (!libName) {
      abort("--name is required when building multiple web components.");
    }
  }

  var dynamicEntry = resolveEntry(prefix, libName, resolvedFiles, isAsync);

  function genConfig(minify, genHTML) {
    var config = api.resolveChainableWebpackConfig(); // make sure not to transpile wc-wrapper

    config.module.rule('js').exclude.add(/vue-wc-wrapper/); // only minify min entry

    if (!minify) {
      config.optimization.minimize(false);
    }

    config.plugin('web-component-options').use(require('webpack').DefinePlugin, [{
      'process.env.CUSTOM_ELEMENT_NAME': JSON.stringify(libName)
    }]); // enable shadow mode in vue-loader

    config.module.rule('vue').use('vue-loader').tap(function (options) {
      options.shadowMode = true;
      return options;
    });

    if (genHTML) {
      config.plugin('demo-html').use(require('html-webpack-plugin'), [{
        template: path.resolve(__dirname, "./demo-wc.html"),
        inject: false,
        filename: 'demo.html',
        libName: libName,
        components: prefix === '' ? [libName] : resolvedFiles.map(function (file) {
          return fileToComponentName(prefix, file).kebabName;
        })
      }]);
    } // set entry/output last so it takes higher priority than user
    // configureWebpack hooks
    // set proxy entry for *.vue files


    config.resolve.alias.set('~root', api.resolve('.'));
    var rawConfig = api.resolveWebpackConfig(config); // externalize Vue in case user imports it

    rawConfig.externals = [].concat(_toConsumableArray(Array.isArray(rawConfig.externals) ? rawConfig.externals : [rawConfig.externals]), [_objectSpread({}, inlineVue || {
      vue: 'Vue'
    })]).filter(Boolean);
    var entryName = "".concat(libName).concat(minify ? ".min" : "");
    rawConfig.entry = _defineProperty({}, entryName, dynamicEntry);
    Object.assign(rawConfig.output, {
      // to ensure that multiple copies of async wc bundles can co-exist
      // on the same page.
      jsonpFunction: libName.replace(/-\w/g, function (c) {
        return c.charAt(1).toUpperCase();
      }) + '_jsonp',
      filename: "".concat(entryName, ".js"),
      chunkFilename: "".concat(libName, ".[name]").concat(minify ? ".min" : "", ".js"),
      // use dynamic publicPath so this can be deployed anywhere
      // the actual path will be determined at runtime by checking
      // document.currentScript.src.
      publicPath: ''
    });
    return rawConfig;
  }

  return [genConfig(false, true), genConfig(true, false)];
};