"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var defaults = {
  clean: true,
  target: 'app',
  formats: 'commonjs,umd,umd-min',
  'unsafe-inline': true
};
var buildModes = {
  lib: 'library',
  wc: 'web component',
  'wc-async': 'web component (async)'
};

var modifyConfig = function modifyConfig(config, fn) {
  if (Array.isArray(config)) {
    config.forEach(function (c) {
      return fn(c);
    });
  } else {
    fn(config);
  }
};

module.exports = function (api, options) {
  api.registerCommand('build', {
    description: 'build for production',
    usage: 'vue-cli-service build [options] [entry|pattern]',
    options: {
      '--mode': "specify env mode (default: production)",
      '--dest': "specify output directory (default: ".concat(options.outputDir, ")"),
      '--modern': "build app targeting modern browsers with auto fallback",
      '--no-unsafe-inline': "build app without introducing inline scripts",
      '--target': "app | lib | wc | wc-async (default: ".concat(defaults.target, ")"),
      '--inline-vue': 'include the Vue module in the final bundle of library or web component target',
      '--formats': "list of output formats for library builds (default: ".concat(defaults.formats, ")"),
      '--name': "name for lib or web-component mode (default: \"name\" in package.json or entry filename)",
      '--filename': "file name for output, only usable for 'lib' target (default: value of --name)",
      '--no-clean': "do not remove the dist directory before building the project",
      '--report': "generate report.html to help analyze bundle content",
      '--report-json': 'generate report.json to help analyze bundle content',
      '--skip-plugins': "comma-separated list of plugin names to skip for this run",
      '--watch': "watch for changes",
      '--stdin': "close when stdin ends"
    }
  }, function _callee(args, rawArgs) {
    var key, _require, execa, cliBin, _require2, warn;

    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            for (key in defaults) {
              if (args[key] == null) {
                args[key] = defaults[key];
              }
            }

            args.entry = args.entry || args._[0];

            if (args.target !== 'app') {
              args.entry = args.entry || 'src/App.vue';
            }

            process.env.VUE_CLI_BUILD_TARGET = args.target;

            if (!(args.modern && args.target === 'app')) {
              _context.next = 20;
              break;
            }

            process.env.VUE_CLI_MODERN_MODE = true;

            if (process.env.VUE_CLI_MODERN_BUILD) {
              _context.next = 15;
              break;
            }

            _context.next = 9;
            return regeneratorRuntime.awrap(build(Object.assign({}, args, {
              modernBuild: false,
              keepAlive: true
            }), api, options));

          case 9:
            // spawn sub-process of self for modern build
            _require = require('@vue/cli-shared-utils'), execa = _require.execa;
            cliBin = require('path').resolve(__dirname, '../../../bin/vue-cli-service.js');
            _context.next = 13;
            return regeneratorRuntime.awrap(execa('node', [cliBin, 'build'].concat(_toConsumableArray(rawArgs)), {
              stdio: 'inherit',
              env: {
                VUE_CLI_MODERN_BUILD: true
              }
            }));

          case 13:
            _context.next = 17;
            break;

          case 15:
            _context.next = 17;
            return regeneratorRuntime.awrap(build(Object.assign({}, args, {
              modernBuild: true,
              clean: false
            }), api, options));

          case 17:
            delete process.env.VUE_CLI_MODERN_MODE;
            _context.next = 23;
            break;

          case 20:
            if (args.modern) {
              _require2 = require('@vue/cli-shared-utils'), warn = _require2.warn;
              warn("Modern mode only works with default target (app). " + "For libraries or web components, use the browserslist " + "config to specify target browsers.");
            }

            _context.next = 23;
            return regeneratorRuntime.awrap(build(args, api, options));

          case 23:
            delete process.env.VUE_CLI_BUILD_TARGET;

          case 24:
          case "end":
            return _context.stop();
        }
      }
    });
  });
};

function build(args, api, options) {
  var fs, path, webpack, _require3, chalk, formatStats, validateWebpackConfig, _require4, log, done, info, logWithSpinner, stopSpinner, mode, bundleTag, buildMode, additionalParams, targetDir, isLegacyBuild, webpackConfig, DashboardPlugin, _require5, BundleAnalyzerPlugin;

  return regeneratorRuntime.async(function build$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          fs = require('fs-extra');
          path = require('path');
          webpack = require('webpack');
          _require3 = require('@vue/cli-shared-utils'), chalk = _require3.chalk;
          formatStats = require('./formatStats');
          validateWebpackConfig = require('../../util/validateWebpackConfig');
          _require4 = require('@vue/cli-shared-utils'), log = _require4.log, done = _require4.done, info = _require4.info, logWithSpinner = _require4.logWithSpinner, stopSpinner = _require4.stopSpinner;
          log();
          mode = api.service.mode;

          if (!(args.target === 'app')) {
            _context2.next = 14;
            break;
          }

          bundleTag = args.modern ? args.modernBuild ? "modern bundle " : "legacy bundle " : "";
          logWithSpinner("Building ".concat(bundleTag, "for ").concat(mode, "..."));
          _context2.next = 21;
          break;

        case 14:
          buildMode = buildModes[args.target];

          if (!buildMode) {
            _context2.next = 20;
            break;
          }

          additionalParams = buildMode === 'library' ? " (".concat(args.formats, ")") : "";
          logWithSpinner("Building for ".concat(mode, " as ").concat(buildMode).concat(additionalParams, "..."));
          _context2.next = 21;
          break;

        case 20:
          throw new Error("Unknown build target: ".concat(args.target));

        case 21:
          if (args.dest) {
            // Override outputDir before resolving webpack config as config relies on it (#2327)
            options.outputDir = args.dest;
          }

          targetDir = api.resolve(options.outputDir);
          isLegacyBuild = args.target === 'app' && args.modern && !args.modernBuild; // resolve raw webpack config

          if (args.target === 'lib') {
            webpackConfig = require('./resolveLibConfig')(api, args, options);
          } else if (args.target === 'wc' || args.target === 'wc-async') {
            webpackConfig = require('./resolveWcConfig')(api, args, options);
          } else {
            webpackConfig = require('./resolveAppConfig')(api, args, options);
          } // check for common config errors


          validateWebpackConfig(webpackConfig, api, options, args.target);

          if (args.watch) {
            modifyConfig(webpackConfig, function (config) {
              config.watch = true;
            });
          }

          if (args.stdin) {
            process.stdin.on('end', function () {
              process.exit(0);
            });
            process.stdin.resume();
          } // Expose advanced stats


          if (args.dashboard) {
            DashboardPlugin = require('../../webpack/DashboardPlugin');
            modifyConfig(webpackConfig, function (config) {
              config.plugins.push(new DashboardPlugin({
                type: 'build',
                modernBuild: args.modernBuild,
                keepAlive: args.keepAlive
              }));
            });
          }

          if (args.report || args['report-json']) {
            _require5 = require('webpack-bundle-analyzer'), BundleAnalyzerPlugin = _require5.BundleAnalyzerPlugin;
            modifyConfig(webpackConfig, function (config) {
              var bundleName = args.target !== 'app' ? config.output.filename.replace(/\.js$/, '-') : isLegacyBuild ? 'legacy-' : '';
              config.plugins.push(new BundleAnalyzerPlugin({
                logLevel: 'warn',
                openAnalyzer: false,
                analyzerMode: args.report ? 'static' : 'disabled',
                reportFilename: "".concat(bundleName, "report.html"),
                statsFilename: "".concat(bundleName, "report.json"),
                generateStatsFile: !!args['report-json']
              }));
            });
          }

          if (!args.clean) {
            _context2.next = 33;
            break;
          }

          _context2.next = 33;
          return regeneratorRuntime.awrap(fs.remove(targetDir));

        case 33:
          return _context2.abrupt("return", new Promise(function (resolve, reject) {
            webpack(webpackConfig, function (err, stats) {
              stopSpinner(false);

              if (err) {
                return reject(err);
              }

              if (stats.hasErrors()) {
                return reject("Build failed with errors.");
              }

              if (!args.silent) {
                var targetDirShort = path.relative(api.service.context, targetDir);
                log(formatStats(stats, targetDirShort, api));

                if (args.target === 'app' && !isLegacyBuild) {
                  if (!args.watch) {
                    done("Build complete. The ".concat(chalk.cyan(targetDirShort), " directory is ready to be deployed."));
                    info("Check out deployment instructions at ".concat(chalk.cyan("https://cli.vuejs.org/guide/deployment.html"), "\n"));
                  } else {
                    done("Build complete. Watching for changes...");
                  }
                }
              } // test-only signal


              if (process.env.VUE_CLI_TEST) {
                console.log('Build complete.');
              }

              resolve();
            });
          }));

        case 34:
        case "end":
          return _context2.stop();
      }
    }
  });
}

module.exports.defaultModes = {
  build: 'production'
};