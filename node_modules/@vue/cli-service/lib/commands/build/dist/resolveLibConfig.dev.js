"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var fs = require('fs');

var path = require('path');

module.exports = function (api, _ref, options) {
  var entry = _ref.entry,
      name = _ref.name,
      formats = _ref.formats,
      filename = _ref.filename,
      inlineVue = _ref['inline-vue'];

  var _require = require('@vue/cli-shared-utils'),
      log = _require.log,
      error = _require.error;

  var abort = function abort(msg) {
    log();
    error(msg);
    process.exit(1);
  };

  var fullEntryPath = api.resolve(entry);

  if (!fs.existsSync(fullEntryPath)) {
    abort("Failed to resolve lib entry: ".concat(entry).concat(entry === "src/App.vue" ? ' (default)' : '', ". ") + "Make sure to specify the correct entry file.");
  }

  var isVueEntry = /\.vue$/.test(entry);
  var libName = name || (api.service.pkg.name ? api.service.pkg.name.replace(/^@.+\//, '') : path.basename(entry).replace(/\.(jsx?|vue)$/, ''));
  filename = filename || libName;

  function genConfig(format) {
    var postfix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : format;
    var genHTML = arguments.length > 2 ? arguments[2] : undefined;
    var config = api.resolveChainableWebpackConfig();

    var browserslist = require('browserslist');

    var targets = browserslist(undefined, {
      path: fullEntryPath
    });
    var supportsIE = targets.some(function (agent) {
      return agent.includes('ie');
    });

    var webpack = require('webpack');

    config.plugin('need-current-script-polyfill').use(webpack.DefinePlugin, [{
      'process.env.NEED_CURRENTSCRIPT_POLYFILL': JSON.stringify(supportsIE)
    }]); // adjust css output name so they write to the same file

    if (config.plugins.has('extract-css')) {
      config.plugin('extract-css').tap(function (args) {
        args[0].filename = "".concat(filename, ".css");
        return args;
      });
    } // only minify min entry


    if (!/\.min/.test(postfix)) {
      config.optimization.minimize(false);
    } // inject demo page for umd


    if (genHTML) {
      var template = isVueEntry ? 'demo-lib.html' : 'demo-lib-js.html';
      config.plugin('demo-html').use(require('html-webpack-plugin'), [{
        template: path.resolve(__dirname, template),
        inject: false,
        filename: 'demo.html',
        libName: libName,
        assetsFileName: filename,
        cssExtract: config.plugins.has('extract-css')
      }]);
    } // resolve entry/output


    var entryName = "".concat(filename, ".").concat(postfix);
    config.resolve.alias.set('~entry', fullEntryPath); // set output target before user configureWebpack hooks are applied

    config.output.libraryTarget(format); // set entry/output after user configureWebpack hooks are applied

    var rawConfig = api.resolveWebpackConfig(config);

    var realEntry = require.resolve('./entry-lib.js'); // avoid importing default if user entry file does not have default export


    if (!isVueEntry) {
      var entryContent = fs.readFileSync(fullEntryPath, 'utf-8');

      if (!/\b(export\s+default|export\s{[^}]+as\s+default)\b/.test(entryContent)) {
        realEntry = require.resolve('./entry-lib-no-default.js');
      }
    } // externalize Vue in case user imports it


    rawConfig.externals = [].concat(_toConsumableArray(Array.isArray(rawConfig.externals) ? rawConfig.externals : [rawConfig.externals]), [_objectSpread({}, inlineVue || {
      vue: {
        commonjs: 'vue',
        commonjs2: 'vue',
        root: 'Vue'
      }
    })]).filter(Boolean);
    rawConfig.entry = _defineProperty({}, entryName, realEntry);
    rawConfig.output = Object.assign({
      library: libName,
      libraryExport: isVueEntry ? 'default' : undefined,
      libraryTarget: format,
      // preserve UDM header from webpack 3 until webpack provides either
      // libraryTarget: 'esm' or target: 'universal'
      // https://github.com/webpack/webpack/issues/6522
      // https://github.com/webpack/webpack/issues/6525
      globalObject: "(typeof self !== 'undefined' ? self : this)"
    }, rawConfig.output, {
      filename: "".concat(entryName, ".js"),
      chunkFilename: "".concat(entryName, ".[name].js"),
      // use dynamic publicPath so this can be deployed anywhere
      // the actual path will be determined at runtime by checking
      // document.currentScript.src.
      publicPath: ''
    });
    return rawConfig;
  }

  var configMap = {
    commonjs: genConfig('commonjs2', 'common'),
    umd: genConfig('umd', undefined, true),
    'umd-min': genConfig('umd', 'umd.min')
  };
  var formatArray = (formats + '').split(',');
  var configs = formatArray.map(function (format) {
    return configMap[format];
  });

  if (configs.indexOf(undefined) !== -1) {
    var unknownFormats = formatArray.filter(function (f) {
      return configMap[f] === undefined;
    }).join(', ');
    abort("Unknown library build formats: ".concat(unknownFormats));
  }

  return configs;
};