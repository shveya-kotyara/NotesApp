// From https://github.com/FormidableLabs/webpack-dashboard/blob/7f99b31c5f00a7818d8129cb8a8fc6eb1b71799c/plugin/index.js
// Modified by Guillaume Chau (Akryum)

/* eslint-disable max-params, max-statements */
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var fs = require('fs-extra');

var webpack = require('webpack');

var _require = require('@vue/cli-shared-utils'),
    IpcMessenger = _require.IpcMessenger;

var _require2 = require('./analyzeBundle'),
    analyzeBundle = _require2.analyzeBundle;

var ID = 'vue-cli-dashboard-plugin';
var ONE_SECOND = 1000;
var FILENAME_QUERY_REGEXP = /\?.*$/;
var ipc = new IpcMessenger();

function getTimeMessage(timer) {
  var time = Date.now() - timer;

  if (time >= ONE_SECOND) {
    time /= ONE_SECOND;
    time = Math.round(time);
    time += 's';
  } else {
    time += 'ms';
  }

  return " (".concat(time, ")");
}

var DashboardPlugin =
/*#__PURE__*/
function () {
  function DashboardPlugin(options) {
    _classCallCheck(this, DashboardPlugin);

    this.type = options.type;

    if (this.type === 'build' && options.modernBuild) {
      this.type = 'build-modern';
    }

    this.watching = false;
    this.autoDisconnect = !options.keepAlive;
  }

  _createClass(DashboardPlugin, [{
    key: "cleanup",
    value: function cleanup() {
      this.sendData = null;
      if (this.autoDisconnect) ipc.disconnect();
    }
  }, {
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      var sendData = this.sendData;
      var timer;
      var assetSources = new Map();

      if (!sendData) {
        sendData = function sendData(data) {
          return ipc.send({
            webpackDashboardData: {
              type: _this.type,
              value: data
            }
          });
        };
      } // Progress status


      var progressTime = Date.now();
      var progressPlugin = new webpack.ProgressPlugin(function (percent, msg) {
        // Debouncing
        var time = Date.now();

        if (time - progressTime > 300) {
          progressTime = time;
          sendData([{
            type: 'status',
            value: 'Compiling'
          }, {
            type: 'progress',
            value: percent
          }, {
            type: 'operations',
            value: msg + getTimeMessage(timer)
          }]);
        }
      });
      progressPlugin.apply(compiler);
      compiler.hooks.watchRun.tap(ID, function (c) {
        _this.watching = true;
      });
      compiler.hooks.run.tap(ID, function (c) {
        _this.watching = false;
      });
      compiler.hooks.compile.tap(ID, function () {
        timer = Date.now();
        sendData([{
          type: 'status',
          value: 'Compiling'
        }, {
          type: 'progress',
          value: 0
        }]);
      });
      compiler.hooks.invalid.tap(ID, function () {
        sendData([{
          type: 'status',
          value: 'Invalidated'
        }, {
          type: 'progress',
          value: 0
        }, {
          type: 'operations',
          value: 'idle'
        }]);
      });
      compiler.hooks.failed.tap(ID, function () {
        sendData([{
          type: 'status',
          value: 'Failed'
        }, {
          type: 'operations',
          value: "idle".concat(getTimeMessage(timer))
        }]);
      });
      compiler.hooks.afterEmit.tap(ID, function (compilation) {
        assetSources = new Map();

        for (var name in compilation.assets) {
          var asset = compilation.assets[name];
          assetSources.set(name.replace(FILENAME_QUERY_REGEXP, ''), asset.source());
        }
      });
      compiler.hooks.done.tap(ID, function (stats) {
        var statsData = stats.toJson(); // Sometimes all the information is located in `children` array

        if ((!statsData.assets || !statsData.assets.length) && statsData.children && statsData.children.length) {
          statsData = statsData.children[0];
        }

        var outputPath = compiler.options.output.path;
        statsData.assets.forEach(function (asset) {
          // Removing query part from filename (yes, somebody uses it for some reason and Webpack supports it)
          asset.name = asset.name.replace(FILENAME_QUERY_REGEXP, '');
          asset.fullPath = path.join(outputPath, asset.name);
        }); // Analyze the assets and update sizes on assets and modules

        analyzeBundle(statsData, assetSources);
        var hasErrors = stats.hasErrors();
        sendData([{
          type: 'status',
          value: hasErrors ? 'Failed' : 'Success'
        }, {
          type: 'progress',
          value: 1
        }, {
          type: 'operations',
          value: "idle".concat(getTimeMessage(timer))
        }]);
        var statsFile = path.resolve(process.cwd(), "./node_modules/.stats-".concat(_this.type, ".json"));
        fs.writeJson(statsFile, {
          errors: hasErrors,
          warnings: stats.hasWarnings(),
          data: statsData
        }).then(function () {
          sendData([{
            type: 'stats'
          }]);

          if (!_this.watching) {
            _this.cleanup();
          }
        })["catch"](function (error) {
          console.error(error);
        });
      });
    }
  }]);

  return DashboardPlugin;
}();

module.exports = DashboardPlugin;