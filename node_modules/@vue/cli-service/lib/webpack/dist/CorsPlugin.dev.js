"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function CorsPlugin(_ref) {
    var publicPath = _ref.publicPath,
        crossorigin = _ref.crossorigin,
        integrity = _ref.integrity;

    _classCallCheck(this, CorsPlugin);

    this.crossorigin = crossorigin;
    this.integrity = integrity;
    this.publicPath = publicPath;
  }

  _createClass(CorsPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      var ID = "vue-cli-cors-plugin";
      compiler.hooks.compilation.tap(ID, function (compilation) {
        var ssri = require('ssri');

        var computeHash = function computeHash(url) {
          var filename = url.replace(_this.publicPath, '');
          var asset = compilation.assets[filename];

          if (asset) {
            var src = asset.source();
            var integrity = ssri.fromData(src, {
              algorithms: ['sha384']
            });
            return integrity.toString();
          }
        };

        compilation.hooks.htmlWebpackPluginAlterAssetTags.tap(ID, function (data) {
          var tags = [].concat(_toConsumableArray(data.head), _toConsumableArray(data.body));

          if (_this.crossorigin != null) {
            tags.forEach(function (tag) {
              if (tag.tagName === 'script' || tag.tagName === 'link') {
                tag.attributes.crossorigin = _this.crossorigin;
              }
            });
          }

          if (_this.integrity) {
            tags.forEach(function (tag) {
              if (tag.tagName === 'script') {
                var hash = computeHash(tag.attributes.src);

                if (hash) {
                  tag.attributes.integrity = hash;
                }
              } else if (tag.tagName === 'link' && tag.attributes.rel === 'stylesheet') {
                var _hash = computeHash(tag.attributes.href);

                if (_hash) {
                  tag.attributes.integrity = _hash;
                }
              }
            }); // when using SRI, Chrome somehow cannot reuse
            // the preloaded resource, and causes the files to be downloaded twice.
            // this is a Chrome bug (https://bugs.chromium.org/p/chromium/issues/detail?id=677022)
            // for now we disable preload if SRI is used.

            data.head = data.head.filter(function (tag) {
              return !(tag.tagName === 'link' && tag.attributes.rel === 'preload');
            });
          }
        });
        compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tap(ID, function (data) {
          data.html = data.html.replace(/\scrossorigin=""/g, ' crossorigin');
        });
      });
    }
  }]);

  return CorsPlugin;
}();