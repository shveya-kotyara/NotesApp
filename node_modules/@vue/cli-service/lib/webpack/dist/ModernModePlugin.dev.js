"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require('fs-extra');

var path = require('path'); // https://gist.github.com/samthor/64b114e4a4f539915a95b91ffd340acc


var safariFix = "!function(){var e=document,t=e.createElement(\"script\");if(!(\"noModule\"in t)&&\"onbeforeload\"in t){var n=!1;e.addEventListener(\"beforeload\",function(e){if(e.target===t)n=!0;else if(!e.target.hasAttribute(\"nomodule\")||!n)return;e.preventDefault()},!0),t.type=\"module\",t.src=\".\",e.head.appendChild(t),t.remove()}}();";

var ModernModePlugin =
/*#__PURE__*/
function () {
  function ModernModePlugin(_ref) {
    var targetDir = _ref.targetDir,
        isModernBuild = _ref.isModernBuild,
        unsafeInline = _ref.unsafeInline,
        jsDirectory = _ref.jsDirectory;

    _classCallCheck(this, ModernModePlugin);

    this.targetDir = targetDir;
    this.isModernBuild = isModernBuild;
    this.unsafeInline = unsafeInline;
    this.jsDirectory = jsDirectory;
  }

  _createClass(ModernModePlugin, [{
    key: "apply",
    value: function apply(compiler) {
      if (!this.isModernBuild) {
        this.applyLegacy(compiler);
      } else {
        this.applyModern(compiler);
      }
    }
  }, {
    key: "applyLegacy",
    value: function applyLegacy(compiler) {
      var _this = this;

      var ID = "vue-cli-legacy-bundle";
      compiler.hooks.compilation.tap(ID, function (compilation) {
        compilation.hooks.htmlWebpackPluginAlterAssetTags.tapAsync(ID, function _callee(data, cb) {
          var htmlName, htmlPath, tempFilename;
          return regeneratorRuntime.async(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return regeneratorRuntime.awrap(fs.ensureDir(_this.targetDir));

                case 2:
                  htmlName = path.basename(data.plugin.options.filename); // Watch out for output files in sub directories

                  htmlPath = path.dirname(data.plugin.options.filename);
                  tempFilename = path.join(_this.targetDir, htmlPath, "legacy-assets-".concat(htmlName, ".json"));
                  _context.next = 7;
                  return regeneratorRuntime.awrap(fs.mkdirp(path.dirname(tempFilename)));

                case 7:
                  _context.next = 9;
                  return regeneratorRuntime.awrap(fs.writeFile(tempFilename, JSON.stringify(data.body)));

                case 9:
                  cb();

                case 10:
                case "end":
                  return _context.stop();
              }
            }
          });
        });
      });
    }
  }, {
    key: "applyModern",
    value: function applyModern(compiler) {
      var _this2 = this;

      var ID = "vue-cli-modern-bundle";
      compiler.hooks.compilation.tap(ID, function (compilation) {
        compilation.hooks.htmlWebpackPluginAlterAssetTags.tapAsync(ID, function _callee2(data, cb) {
          var _data$body;

          var htmlName, htmlPath, tempFilename, legacyAssets, safariFixPath, fullSafariFixPath;
          return regeneratorRuntime.async(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  // use <script type="module"> for modern assets
                  data.body.forEach(function (tag) {
                    if (tag.tagName === 'script' && tag.attributes) {
                      tag.attributes.type = 'module';
                    }
                  }); // use <link rel="modulepreload"> instead of <link rel="preload">
                  // for modern assets

                  data.head.forEach(function (tag) {
                    if (tag.tagName === 'link' && tag.attributes.rel === 'preload' && tag.attributes.as === 'script') {
                      tag.attributes.rel = 'modulepreload';
                    }
                  }); // inject links for legacy assets as <script nomodule>

                  htmlName = path.basename(data.plugin.options.filename); // Watch out for output files in sub directories

                  htmlPath = path.dirname(data.plugin.options.filename);
                  tempFilename = path.join(_this2.targetDir, htmlPath, "legacy-assets-".concat(htmlName, ".json"));
                  _context2.t0 = JSON;
                  _context2.next = 8;
                  return regeneratorRuntime.awrap(fs.readFile(tempFilename, 'utf-8'));

                case 8:
                  _context2.t1 = _context2.sent;

                  _context2.t2 = function (a) {
                    return a.tagName === 'script' && a.attributes;
                  };

                  legacyAssets = _context2.t0.parse.call(_context2.t0, _context2.t1).filter(_context2.t2);
                  legacyAssets.forEach(function (a) {
                    a.attributes.nomodule = '';
                  });

                  if (_this2.unsafeInline) {
                    // inject inline Safari 10 nomodule fix
                    data.body.push({
                      tagName: 'script',
                      closeTag: true,
                      innerHTML: safariFix
                    });
                  } else {
                    // inject the fix as an external script
                    safariFixPath = path.join(_this2.jsDirectory, 'safari-nomodule-fix.js');
                    fullSafariFixPath = path.join(compilation.options.output.publicPath, safariFixPath);
                    compilation.assets[safariFixPath] = {
                      source: function source() {
                        return new Buffer(safariFix);
                      },
                      size: function size() {
                        return Buffer.byteLength(safariFix);
                      }
                    };
                    data.body.push({
                      tagName: 'script',
                      closeTag: true,
                      attributes: {
                        src: fullSafariFixPath
                      }
                    });
                  }

                  (_data$body = data.body).push.apply(_data$body, _toConsumableArray(legacyAssets));

                  _context2.next = 16;
                  return regeneratorRuntime.awrap(fs.remove(tempFilename));

                case 16:
                  cb();

                case 17:
                case "end":
                  return _context2.stop();
              }
            }
          });
        });
        compilation.hooks.htmlWebpackPluginAfterHtmlProcessing.tap(ID, function (data) {
          data.html = data.html.replace(/\snomodule="">/g, ' nomodule>');
        });
      });
    }
  }]);

  return ModernModePlugin;
}();

ModernModePlugin.safariFix = safariFix;
module.exports = ModernModePlugin;