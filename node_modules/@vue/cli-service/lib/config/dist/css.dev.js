"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var fs = require('fs');

var path = require('path');

var _require = require('@vue/cli-shared-utils'),
    semver = _require.semver,
    warn = _require.warn,
    pauseSpinner = _require.pauseSpinner,
    resumeSpinner = _require.resumeSpinner;

var findExisting = function findExisting(context, files) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var file = _step.value;

      if (fs.existsSync(path.join(context, file))) {
        return file;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

module.exports = function (api, rootOptions) {
  api.chainWebpack(function (webpackConfig) {
    var getAssetPath = require('../util/getAssetPath');

    var shadowMode = !!process.env.VUE_CLI_CSS_SHADOW_MODE;
    var isProd = process.env.NODE_ENV === 'production';
    var sassLoaderVersion;

    try {
      sassLoaderVersion = semver.major(require('sass-loader/package.json').version);
    } catch (e) {}

    if (sassLoaderVersion < 8) {
      pauseSpinner();
      warn('A new version of sass-loader is available. Please upgrade for best experience.');
      resumeSpinner();
    }

    var defaultSassLoaderOptions = {};

    try {
      defaultSassLoaderOptions.implementation = require('sass'); // since sass-loader 8, fibers will be automatically detected and used

      if (sassLoaderVersion < 8) {
        defaultSassLoaderOptions.fiber = require('fibers');
      }
    } catch (e) {}

    var _ref = rootOptions.css || {},
        _ref$extract = _ref.extract,
        extract = _ref$extract === void 0 ? isProd : _ref$extract,
        _ref$sourceMap = _ref.sourceMap,
        sourceMap = _ref$sourceMap === void 0 ? false : _ref$sourceMap,
        _ref$loaderOptions = _ref.loaderOptions,
        loaderOptions = _ref$loaderOptions === void 0 ? {} : _ref$loaderOptions;

    var _ref2 = rootOptions.css || {},
        requireModuleExtension = _ref2.requireModuleExtension;

    if (typeof requireModuleExtension === 'undefined') {
      if (loaderOptions.css && loaderOptions.css.modules) {
        throw new Error('`css.requireModuleExtension` is required when custom css modules options provided');
      }

      requireModuleExtension = true;
    }

    var shouldExtract = extract !== false && !shadowMode;
    var filename = getAssetPath(rootOptions, "css/[name]".concat(rootOptions.filenameHashing ? '.[contenthash:8]' : '', ".css"));
    var extractOptions = Object.assign({
      filename: filename,
      chunkFilename: filename
    }, extract && _typeof(extract) === 'object' ? extract : {}); // use relative publicPath in extracted CSS based on extract location

    var cssPublicPath = process.env.VUE_CLI_BUILD_TARGET === 'lib' // in lib mode, CSS is extracted to dist root.
    ? './' : '../'.repeat(extractOptions.filename.replace(/^\.[\/\\]/, '').split(/[\/\\]/g).length - 1); // check if the project has a valid postcss config
    // if it doesn't, don't use postcss-loader for direct style imports
    // because otherwise it would throw error when attempting to load postcss config

    var hasPostCSSConfig = !!(loaderOptions.postcss || api.service.pkg.postcss || findExisting(api.resolve('.'), ['.postcssrc', '.postcssrc.js', 'postcss.config.js', '.postcssrc.yaml', '.postcssrc.json']));

    if (!hasPostCSSConfig) {
      loaderOptions.postcss = {
        plugins: [require('autoprefixer')]
      };
    } // if building for production but not extracting CSS, we need to minimize
    // the embbeded inline CSS as they will not be going through the optimizing
    // plugin.


    var needInlineMinification = isProd && !shouldExtract;
    var cssnanoOptions = {
      preset: ['default', {
        mergeLonghand: false,
        cssDeclarationSorter: false
      }]
    };

    if (rootOptions.productionSourceMap && sourceMap) {
      cssnanoOptions.map = {
        inline: false
      };
    }

    function createCSSRule(lang, test, loader, options) {
      var baseRule = webpackConfig.module.rule(lang).test(test); // rules for <style lang="module">

      var vueModulesRule = baseRule.oneOf('vue-modules').resourceQuery(/module/);
      applyLoaders(vueModulesRule, true); // rules for <style>

      var vueNormalRule = baseRule.oneOf('vue').resourceQuery(/\?vue/);
      applyLoaders(vueNormalRule, false); // rules for *.module.* files

      var extModulesRule = baseRule.oneOf('normal-modules').test(/\.module\.\w+$/);
      applyLoaders(extModulesRule, true); // rules for normal CSS imports

      var normalRule = baseRule.oneOf('normal');
      applyLoaders(normalRule, !requireModuleExtension);

      function applyLoaders(rule, isCssModule) {
        if (shouldExtract) {
          rule.use('extract-css-loader').loader(require('mini-css-extract-plugin').loader).options({
            hmr: !isProd,
            publicPath: cssPublicPath
          });
        } else {
          rule.use('vue-style-loader').loader(require.resolve('vue-style-loader')).options({
            sourceMap: sourceMap,
            shadowMode: shadowMode
          });
        }

        var cssLoaderOptions = Object.assign({
          sourceMap: sourceMap,
          importLoaders: 1 + // stylePostLoader injected by vue-loader
          1 + ( // postcss-loader
          needInlineMinification ? 1 : 0)
        }, loaderOptions.css);

        if (isCssModule) {
          cssLoaderOptions.modules = _objectSpread({
            localIdentName: '[name]_[local]_[hash:base64:5]'
          }, cssLoaderOptions.modules);
        } else {
          delete cssLoaderOptions.modules;
        }

        rule.use('css-loader').loader(require.resolve('css-loader')).options(cssLoaderOptions);

        if (needInlineMinification) {
          rule.use('cssnano').loader(require.resolve('postcss-loader')).options({
            sourceMap: sourceMap,
            plugins: [require('cssnano')(cssnanoOptions)]
          });
        }

        rule.use('postcss-loader').loader(require.resolve('postcss-loader')).options(Object.assign({
          sourceMap: sourceMap
        }, loaderOptions.postcss));

        if (loader) {
          var resolvedLoader;

          try {
            resolvedLoader = require.resolve(loader);
          } catch (error) {
            resolvedLoader = loader;
          }

          rule.use(loader).loader(resolvedLoader).options(Object.assign({
            sourceMap: sourceMap
          }, options));
        }
      }
    }

    createCSSRule('css', /\.css$/);
    createCSSRule('postcss', /\.p(ost)?css$/);
    createCSSRule('scss', /\.scss$/, 'sass-loader', Object.assign({}, defaultSassLoaderOptions, loaderOptions.scss || loaderOptions.sass));

    if (sassLoaderVersion < 8) {
      createCSSRule('sass', /\.sass$/, 'sass-loader', Object.assign({}, defaultSassLoaderOptions, {
        indentedSyntax: true
      }, loaderOptions.sass));
    } else {
      createCSSRule('sass', /\.sass$/, 'sass-loader', Object.assign({}, defaultSassLoaderOptions, loaderOptions.sass, {
        sassOptions: Object.assign({}, loaderOptions.sass && loaderOptions.sass.sassOptions, {
          indentedSyntax: true
        })
      }));
    }

    createCSSRule('less', /\.less$/, 'less-loader', loaderOptions.less);
    createCSSRule('stylus', /\.styl(us)?$/, 'stylus-loader', Object.assign({
      preferPathResolver: 'webpack'
    }, loaderOptions.stylus)); // inject CSS extraction plugin

    if (shouldExtract) {
      webpackConfig.plugin('extract-css').use(require('mini-css-extract-plugin'), [extractOptions]); // minify extracted CSS

      if (isProd) {
        webpackConfig.plugin('optimize-css').use(require('@intervolga/optimize-cssnano-plugin'), [{
          sourceMap: rootOptions.productionSourceMap && sourceMap,
          cssnanoOptions: cssnanoOptions
        }]);
      }
    }
  });
};