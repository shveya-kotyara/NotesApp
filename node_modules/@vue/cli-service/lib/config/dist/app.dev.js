"use strict";

// config that are specific to --target app
var fs = require('fs');

var path = require('path'); // ensure the filename passed to html-webpack-plugin is a relative path
// because it cannot correctly handle absolute paths


function ensureRelative(outputDir, _path) {
  if (path.isAbsolute(_path)) {
    return path.relative(outputDir, _path);
  } else {
    return _path;
  }
}

module.exports = function (api, options) {
  api.chainWebpack(function (webpackConfig) {
    // only apply when there's no alternative target
    if (process.env.VUE_CLI_BUILD_TARGET && process.env.VUE_CLI_BUILD_TARGET !== 'app') {
      return;
    }

    var isProd = process.env.NODE_ENV === 'production';
    var isLegacyBundle = process.env.VUE_CLI_MODERN_MODE && !process.env.VUE_CLI_MODERN_BUILD;
    var outputDir = api.resolve(options.outputDir);

    var getAssetPath = require('../util/getAssetPath');

    var outputFilename = getAssetPath(options, "js/[name]".concat(isLegacyBundle ? "-legacy" : "").concat(isProd && options.filenameHashing ? '.[contenthash:8]' : '', ".js"));
    webpackConfig.output.filename(outputFilename).chunkFilename(outputFilename); // code splitting

    if (process.env.NODE_ENV !== 'test') {
      webpackConfig.optimization.splitChunks({
        cacheGroups: {
          vendors: {
            name: "chunk-vendors",
            test: /[\\/]node_modules[\\/]/,
            priority: -10,
            chunks: 'initial'
          },
          common: {
            name: "chunk-common",
            minChunks: 2,
            priority: -20,
            chunks: 'initial',
            reuseExistingChunk: true
          }
        }
      });
    } // HTML plugin


    var resolveClientEnv = require('../util/resolveClientEnv'); // #1669 html-webpack-plugin's default sort uses toposort which cannot
    // handle cyclic deps in certain cases. Monkey patch it to handle the case
    // before we can upgrade to its 4.0 version (incompatible with preload atm)


    var chunkSorters = require('html-webpack-plugin/lib/chunksorter');

    var depSort = chunkSorters.dependency;

    chunkSorters.auto = chunkSorters.dependency = function (chunks) {
      try {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return depSort.apply(void 0, [chunks].concat(args));
      } catch (e) {
        // fallback to a manual sort if that happens...
        return chunks.sort(function (a, b) {
          // make sure user entry is loaded last so user CSS can override
          // vendor CSS
          if (a.id === 'app') {
            return 1;
          } else if (b.id === 'app') {
            return -1;
          } else if (a.entry !== b.entry) {
            return b.entry ? -1 : 1;
          }

          return 0;
        });
      }
    };

    var htmlOptions = {
      title: api.service.pkg.name,
      templateParameters: function templateParameters(compilation, assets, pluginOptions) {
        // enhance html-webpack-plugin's built in template params
        var stats;
        return Object.assign({
          // make stats lazy as it is expensive
          get webpack() {
            return stats || (stats = compilation.getStats().toJson());
          },

          compilation: compilation,
          webpackConfig: compilation.options,
          htmlWebpackPlugin: {
            files: assets,
            options: pluginOptions
          }
        }, resolveClientEnv(options, true
        /* raw */
        ));
      }
    }; // handle indexPath

    if (options.indexPath !== 'index.html') {
      // why not set filename for html-webpack-plugin?
      // 1. It cannot handle absolute paths
      // 2. Relative paths causes incorrect SW manifest to be generated (#2007)
      webpackConfig.plugin('move-index').use(require('../webpack/MovePlugin'), [path.resolve(outputDir, 'index.html'), path.resolve(outputDir, options.indexPath)]);
    }

    if (isProd) {
      Object.assign(htmlOptions, {
        minify: {
          removeComments: true,
          collapseWhitespace: true,
          collapseBooleanAttributes: true,
          removeScriptTypeAttributes: true // more options:
          // https://github.com/kangax/html-minifier#options-quick-reference

        }
      }); // keep chunk ids stable so async chunks have consistent hash (#1916)

      webpackConfig.plugin('named-chunks').use(require('webpack/lib/NamedChunksPlugin'), [function (chunk) {
        if (chunk.name) {
          return chunk.name;
        }

        var hash = require('hash-sum');

        var joinedHash = hash(Array.from(chunk.modulesIterable, function (m) {
          return m.id;
        }).join('_'));
        return "chunk-" + joinedHash;
      }]);
    } // resolve HTML file(s)


    var HTMLPlugin = require('html-webpack-plugin');

    var PreloadPlugin = require('@vue/preload-webpack-plugin');

    var multiPageConfig = options.pages;
    var htmlPath = api.resolve('public/index.html');
    var defaultHtmlPath = path.resolve(__dirname, 'index-default.html');
    var publicCopyIgnore = ['.DS_Store'];

    if (!multiPageConfig) {
      // default, single page setup.
      htmlOptions.template = fs.existsSync(htmlPath) ? htmlPath : defaultHtmlPath;
      publicCopyIgnore.push({
        glob: path.relative(api.resolve('public'), api.resolve(htmlOptions.template)),
        matchBase: false
      });
      webpackConfig.plugin('html').use(HTMLPlugin, [htmlOptions]);

      if (!isLegacyBundle) {
        // inject preload/prefetch to HTML
        webpackConfig.plugin('preload').use(PreloadPlugin, [{
          rel: 'preload',
          include: 'initial',
          fileBlacklist: [/\.map$/, /hot-update\.js$/]
        }]);
        webpackConfig.plugin('prefetch').use(PreloadPlugin, [{
          rel: 'prefetch',
          include: 'asyncChunks'
        }]);
      }
    } else {
      // multi-page setup
      webpackConfig.entryPoints.clear();
      var pages = Object.keys(multiPageConfig);

      var normalizePageConfig = function normalizePageConfig(c) {
        return typeof c === 'string' ? {
          entry: c
        } : c;
      };

      pages.forEach(function (name) {
        var pageConfig = normalizePageConfig(multiPageConfig[name]);
        var entry = pageConfig.entry,
            _pageConfig$template = pageConfig.template,
            template = _pageConfig$template === void 0 ? "public/".concat(name, ".html") : _pageConfig$template,
            _pageConfig$filename = pageConfig.filename,
            filename = _pageConfig$filename === void 0 ? "".concat(name, ".html") : _pageConfig$filename,
            _pageConfig$chunks = pageConfig.chunks,
            chunks = _pageConfig$chunks === void 0 ? ['chunk-vendors', 'chunk-common', name] : _pageConfig$chunks; // Currently Cypress v3.1.0 comes with a very old version of Node,
        // which does not support object rest syntax.
        // (https://github.com/cypress-io/cypress/issues/2253)
        // So here we have to extract the customHtmlOptions manually.

        var customHtmlOptions = {};

        for (var key in pageConfig) {
          if (!['entry', 'template', 'filename', 'chunks'].includes(key)) {
            customHtmlOptions[key] = pageConfig[key];
          }
        } // inject entry


        var entries = Array.isArray(entry) ? entry : [entry];
        webpackConfig.entry(name).merge(entries.map(function (e) {
          return api.resolve(e);
        })); // resolve page index template

        var hasDedicatedTemplate = fs.existsSync(api.resolve(template));
        var templatePath = hasDedicatedTemplate ? template : fs.existsSync(htmlPath) ? htmlPath : defaultHtmlPath;
        publicCopyIgnore.push({
          glob: path.relative(api.resolve('public'), api.resolve(templatePath)),
          matchBase: false
        }); // inject html plugin for the page

        var pageHtmlOptions = Object.assign({}, htmlOptions, {
          chunks: chunks,
          template: templatePath,
          filename: ensureRelative(outputDir, filename)
        }, customHtmlOptions);
        webpackConfig.plugin("html-".concat(name)).use(HTMLPlugin, [pageHtmlOptions]);
      });

      if (!isLegacyBundle) {
        pages.forEach(function (name) {
          var filename = ensureRelative(outputDir, normalizePageConfig(multiPageConfig[name]).filename || "".concat(name, ".html"));
          webpackConfig.plugin("preload-".concat(name)).use(PreloadPlugin, [{
            rel: 'preload',
            includeHtmlNames: [filename],
            include: {
              type: 'initial',
              entries: [name]
            },
            fileBlacklist: [/\.map$/, /hot-update\.js$/]
          }]);
          webpackConfig.plugin("prefetch-".concat(name)).use(PreloadPlugin, [{
            rel: 'prefetch',
            includeHtmlNames: [filename],
            include: {
              type: 'asyncChunks',
              entries: [name]
            }
          }]);
        });
      }
    } // CORS and Subresource Integrity


    if (options.crossorigin != null || options.integrity) {
      webpackConfig.plugin('cors').use(require('../webpack/CorsPlugin'), [{
        crossorigin: options.crossorigin,
        integrity: options.integrity,
        publicPath: options.publicPath
      }]);
    } // copy static assets in public/


    var publicDir = api.resolve('public');

    if (!isLegacyBundle && fs.existsSync(publicDir)) {
      webpackConfig.plugin('copy').use(require('copy-webpack-plugin'), [[{
        from: publicDir,
        to: outputDir,
        toType: 'dir',
        ignore: publicCopyIgnore
      }]]);
    }
  });
};