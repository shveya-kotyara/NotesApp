"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require('fs');

var path = require('path');

var debug = require('debug');

var merge = require('webpack-merge');

var Config = require('webpack-chain');

var PluginAPI = require('./PluginAPI');

var dotenv = require('dotenv');

var dotenvExpand = require('dotenv-expand');

var defaultsDeep = require('lodash.defaultsdeep');

var _require = require('@vue/cli-shared-utils'),
    chalk = _require.chalk,
    warn = _require.warn,
    error = _require.error,
    isPlugin = _require.isPlugin,
    resolvePluginId = _require.resolvePluginId,
    loadModule = _require.loadModule,
    _resolvePkg = _require.resolvePkg;

var _require2 = require('./options'),
    defaults = _require2.defaults,
    validate = _require2.validate;

module.exports =
/*#__PURE__*/
function () {
  function Service(context) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        plugins = _ref.plugins,
        pkg = _ref.pkg,
        inlineOptions = _ref.inlineOptions,
        useBuiltIn = _ref.useBuiltIn;

    _classCallCheck(this, Service);

    process.VUE_CLI_SERVICE = this;
    this.initialized = false;
    this.context = context;
    this.inlineOptions = inlineOptions;
    this.webpackChainFns = [];
    this.webpackRawConfigFns = [];
    this.devServerConfigFns = [];
    this.commands = {}; // Folder containing the target package.json for plugins

    this.pkgContext = context; // package.json containing the plugins

    this.pkg = this.resolvePkg(pkg); // If there are inline plugins, they will be used instead of those
    // found in package.json.
    // When useBuiltIn === false, built-in plugins are disabled. This is mostly
    // for testing.

    this.plugins = this.resolvePlugins(plugins, useBuiltIn); // pluginsToSkip will be populated during run()

    this.pluginsToSkip = new Set(); // resolve the default mode to use for each command
    // this is provided by plugins as module.exports.defaultModes
    // so we can get the information without actually applying the plugin.

    this.modes = this.plugins.reduce(function (modes, _ref2) {
      var defaultModes = _ref2.apply.defaultModes;
      return Object.assign(modes, defaultModes);
    }, {});
  }

  _createClass(Service, [{
    key: "resolvePkg",
    value: function resolvePkg(inlinePkg) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;

      if (inlinePkg) {
        return inlinePkg;
      }

      var pkg = _resolvePkg(context);

      if (pkg.vuePlugins && pkg.vuePlugins.resolveFrom) {
        this.pkgContext = path.resolve(context, pkg.vuePlugins.resolveFrom);
        return this.resolvePkg(null, this.pkgContext);
      }

      return pkg;
    }
  }, {
    key: "init",
    value: function init() {
      var _this = this;

      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env.VUE_CLI_MODE;

      if (this.initialized) {
        return;
      }

      this.initialized = true;
      this.mode = mode; // load mode .env

      if (mode) {
        this.loadEnv(mode);
      } // load base .env


      this.loadEnv(); // load user config

      var userOptions = this.loadUserOptions();
      this.projectOptions = defaultsDeep(userOptions, defaults());
      debug('vue:project-config')(this.projectOptions); // apply plugins.

      this.plugins.forEach(function (_ref3) {
        var id = _ref3.id,
            apply = _ref3.apply;
        if (_this.pluginsToSkip.has(id)) return;
        apply(new PluginAPI(id, _this), _this.projectOptions);
      }); // apply webpack configs from project config file

      if (this.projectOptions.chainWebpack) {
        this.webpackChainFns.push(this.projectOptions.chainWebpack);
      }

      if (this.projectOptions.configureWebpack) {
        this.webpackRawConfigFns.push(this.projectOptions.configureWebpack);
      }
    }
  }, {
    key: "loadEnv",
    value: function loadEnv(mode) {
      var logger = debug('vue:env');
      var basePath = path.resolve(this.context, ".env".concat(mode ? ".".concat(mode) : ""));
      var localPath = "".concat(basePath, ".local");

      var load = function load(envPath) {
        try {
          var env = dotenv.config({
            path: envPath,
            debug: process.env.DEBUG
          });
          dotenvExpand(env);
          logger(envPath, env);
        } catch (err) {
          // only ignore error if file is not found
          if (err.toString().indexOf('ENOENT') < 0) {
            error(err);
          }
        }
      };

      load(localPath);
      load(basePath); // by default, NODE_ENV and BABEL_ENV are set to "development" unless mode
      // is production or test. However the value in .env files will take higher
      // priority.

      if (mode) {
        // always set NODE_ENV during tests
        // as that is necessary for tests to not be affected by each other
        var shouldForceDefaultEnv = process.env.VUE_CLI_TEST && !process.env.VUE_CLI_TEST_TESTING_ENV;
        var defaultNodeEnv = mode === 'production' || mode === 'test' ? mode : 'development';

        if (shouldForceDefaultEnv || process.env.NODE_ENV == null) {
          process.env.NODE_ENV = defaultNodeEnv;
        }

        if (shouldForceDefaultEnv || process.env.BABEL_ENV == null) {
          process.env.BABEL_ENV = defaultNodeEnv;
        }
      }
    }
  }, {
    key: "setPluginsToSkip",
    value: function setPluginsToSkip(args) {
      var skipPlugins = args['skip-plugins'];
      var pluginsToSkip = skipPlugins ? new Set(skipPlugins.split(',').map(function (id) {
        return resolvePluginId(id);
      })) : new Set();
      this.pluginsToSkip = pluginsToSkip;
    }
  }, {
    key: "resolvePlugins",
    value: function resolvePlugins(inlinePlugins, useBuiltIn) {
      var _this2 = this;

      var idToPlugin = function idToPlugin(id) {
        return {
          id: id.replace(/^.\//, 'built-in:'),
          apply: require(id)
        };
      };

      var plugins;
      var builtInPlugins = ['./commands/serve', './commands/build', './commands/inspect', './commands/help', // config plugins are order sensitive
      './config/base', './config/css', './config/prod', './config/app'].map(idToPlugin);

      if (inlinePlugins) {
        plugins = useBuiltIn !== false ? builtInPlugins.concat(inlinePlugins) : inlinePlugins;
      } else {
        var projectPlugins = Object.keys(this.pkg.devDependencies || {}).concat(Object.keys(this.pkg.dependencies || {})).filter(isPlugin).map(function (id) {
          if (_this2.pkg.optionalDependencies && id in _this2.pkg.optionalDependencies) {
            var apply = function apply() {};

            try {
              apply = require(id);
            } catch (e) {
              warn("Optional dependency ".concat(id, " is not installed."));
            }

            return {
              id: id,
              apply: apply
            };
          } else {
            return idToPlugin(id);
          }
        });
        plugins = builtInPlugins.concat(projectPlugins);
      } // Local plugins


      if (this.pkg.vuePlugins && this.pkg.vuePlugins.service) {
        var files = this.pkg.vuePlugins.service;

        if (!Array.isArray(files)) {
          throw new Error("Invalid type for option 'vuePlugins.service', expected 'array' but got ".concat(_typeof(files), "."));
        }

        plugins = plugins.concat(files.map(function (file) {
          return {
            id: "local:".concat(file),
            apply: loadModule("./".concat(file), _this2.pkgContext)
          };
        }));
      }

      return plugins;
    }
  }, {
    key: "run",
    value: function run(name) {
      var args,
          rawArgv,
          mode,
          command,
          _command,
          fn,
          _args = arguments;

      return regeneratorRuntime.async(function run$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              args = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              rawArgv = _args.length > 2 && _args[2] !== undefined ? _args[2] : [];
              // resolve mode
              // prioritize inline --mode
              // fallback to resolved default modes from plugins or development if --watch is defined
              mode = args.mode || (name === 'build' && args.watch ? 'development' : this.modes[name]); // --skip-plugins arg may have plugins that should be skipped during init()

              this.setPluginsToSkip(args); // load env variables, load user config, apply plugins

              this.init(mode);
              args._ = args._ || [];
              command = this.commands[name];

              if (!command && name) {
                error("command \"".concat(name, "\" does not exist."));
                process.exit(1);
              }

              if (!command || args.help || args.h) {
                command = this.commands.help;
              } else {
                args._.shift(); // remove command itself


                rawArgv.shift();
              }

              _command = command, fn = _command.fn;
              return _context.abrupt("return", fn(args, rawArgv));

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "resolveChainableWebpackConfig",
    value: function resolveChainableWebpackConfig() {
      var chainableConfig = new Config(); // apply chains

      this.webpackChainFns.forEach(function (fn) {
        return fn(chainableConfig);
      });
      return chainableConfig;
    }
  }, {
    key: "resolveWebpackConfig",
    value: function resolveWebpackConfig() {
      var _this3 = this;

      var chainableConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.resolveChainableWebpackConfig();

      if (!this.initialized) {
        throw new Error('Service must call init() before calling resolveWebpackConfig().');
      } // get raw config


      var config = chainableConfig.toConfig();
      var original = config; // apply raw config fns

      this.webpackRawConfigFns.forEach(function (fn) {
        if (typeof fn === 'function') {
          // function with optional return value
          var res = fn(config);
          if (res) config = merge(config, res);
        } else if (fn) {
          // merge literal values
          config = merge(config, fn);
        }
      }); // #2206 If config is merged by merge-webpack, it discards the __ruleNames
      // information injected by webpack-chain. Restore the info so that
      // vue inspect works properly.

      if (config !== original) {
        cloneRuleNames(config.module && config.module.rules, original.module && original.module.rules);
      } // check if the user has manually mutated output.publicPath


      var target = process.env.VUE_CLI_BUILD_TARGET;

      if (!process.env.VUE_CLI_TEST && target && target !== 'app' && config.output.publicPath !== this.projectOptions.publicPath) {
        throw new Error("Do not modify webpack output.publicPath directly. " + "Use the \"publicPath\" option in vue.config.js instead.");
      }

      if (!process.env.VUE_CLI_ENTRY_FILES && typeof config.entry !== 'function') {
        var entryFiles;

        if (typeof config.entry === 'string') {
          entryFiles = [config.entry];
        } else if (Array.isArray(config.entry)) {
          entryFiles = config.entry;
        } else {
          entryFiles = Object.values(config.entry || []).reduce(function (allEntries, curr) {
            return allEntries.concat(curr);
          }, []);
        }

        entryFiles = entryFiles.map(function (file) {
          return path.resolve(_this3.context, file);
        });
        process.env.VUE_CLI_ENTRY_FILES = JSON.stringify(entryFiles);
      }

      return config;
    }
  }, {
    key: "loadUserOptions",
    value: function loadUserOptions() {
      // vue.config.c?js
      var fileConfig, pkgConfig, resolved, resolvedFrom;
      var esm = this.pkg.type && this.pkg.type === 'module';
      var possibleConfigPaths = [process.env.VUE_CLI_SERVICE_CONFIG_PATH, './vue.config.js', './vue.config.cjs'];
      var fileConfigPath;

      for (var _i = 0, _possibleConfigPaths = possibleConfigPaths; _i < _possibleConfigPaths.length; _i++) {
        var p = _possibleConfigPaths[_i];
        var resolvedPath = p && path.resolve(this.context, p);

        if (resolvedPath && fs.existsSync(resolvedPath)) {
          fileConfigPath = resolvedPath;
          break;
        }
      }

      if (fileConfigPath) {
        if (esm && fileConfigPath === './vue.config.js') {
          throw new Error("Please rename ".concat(chalk.bold('vue.config.js'), " to ").concat(chalk.bold('vue.config.cjs'), " when ECMAScript modules is enabled"));
        }

        try {
          fileConfig = loadModule(fileConfigPath, this.context);

          if (typeof fileConfig === 'function') {
            fileConfig = fileConfig();
          }

          if (!fileConfig || _typeof(fileConfig) !== 'object') {
            // TODO: show throw an Error here, to be fixed in v5
            error("Error loading ".concat(chalk.bold(fileConfigPath), ": should export an object or a function that returns object."));
            fileConfig = null;
          }
        } catch (e) {
          error("Error loading ".concat(chalk.bold(fileConfigPath), ":"));
          throw e;
        }
      } // package.vue


      pkgConfig = this.pkg.vue;

      if (pkgConfig && _typeof(pkgConfig) !== 'object') {
        error("Error loading vue-cli config in ".concat(chalk.bold("package.json"), ": ") + "the \"vue\" field should be an object.");
        pkgConfig = null;
      }

      if (fileConfig) {
        if (pkgConfig) {
          warn("\"vue\" field in package.json ignored " + "due to presence of ".concat(chalk.bold('vue.config.js'), "."));
          warn("You should migrate it into ".concat(chalk.bold('vue.config.js'), " ") + "and remove it from package.json.");
        }

        resolved = fileConfig;
        resolvedFrom = 'vue.config.js';
      } else if (pkgConfig) {
        resolved = pkgConfig;
        resolvedFrom = '"vue" field in package.json';
      } else {
        resolved = this.inlineOptions || {};
        resolvedFrom = 'inline options';
      }

      if (resolved.css && typeof resolved.css.modules !== 'undefined') {
        if (typeof resolved.css.requireModuleExtension !== 'undefined') {
          warn("You have set both \"css.modules\" and \"css.requireModuleExtension\" in ".concat(chalk.bold('vue.config.js'), ", ") + "\"css.modules\" will be ignored in favor of \"css.requireModuleExtension\".");
        } else {
          warn("\"css.modules\" option in ".concat(chalk.bold('vue.config.js'), " ") + "is deprecated now, please use \"css.requireModuleExtension\" instead.");
          resolved.css.requireModuleExtension = !resolved.css.modules;
        }
      } // normalize some options


      ensureSlash(resolved, 'publicPath');

      if (typeof resolved.publicPath === 'string') {
        resolved.publicPath = resolved.publicPath.replace(/^\.\//, '');
      }

      removeSlash(resolved, 'outputDir'); // validate options

      validate(resolved, function (msg) {
        error("Invalid options in ".concat(chalk.bold(resolvedFrom), ": ").concat(msg));
      });
      return resolved;
    }
  }]);

  return Service;
}();

function ensureSlash(config, key) {
  var val = config[key];

  if (typeof val === 'string') {
    config[key] = val.replace(/([^/])$/, '$1/');
  }
}

function removeSlash(config, key) {
  if (typeof config[key] === 'string') {
    config[key] = config[key].replace(/\/$/g, '');
  }
}

function cloneRuleNames(to, from) {
  if (!to || !from) {
    return;
  }

  from.forEach(function (r, i) {
    if (to[i]) {
      Object.defineProperty(to[i], '__ruleNames', {
        value: r.__ruleNames
      });
      cloneRuleNames(to[i].oneOf, r.oneOf);
    }
  });
}