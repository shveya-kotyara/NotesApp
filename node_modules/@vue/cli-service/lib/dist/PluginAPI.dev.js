"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var hash = require('hash-sum');

var _require = require('@vue/cli-shared-utils'),
    semver = _require.semver,
    matchesPluginId = _require.matchesPluginId; // Note: if a plugin-registered command needs to run in a specific default mode,
// the plugin needs to expose it via `module.exports.defaultModes` in the form
// of { [commandName]: mode }. This is because the command mode needs to be
// known and applied before loading user options / applying plugins.


var PluginAPI =
/*#__PURE__*/
function () {
  /**
   * @param {string} id - Id of the plugin.
   * @param {Service} service - A vue-cli-service instance.
   */
  function PluginAPI(id, service) {
    _classCallCheck(this, PluginAPI);

    this.id = id;
    this.service = service;
  }

  _createClass(PluginAPI, [{
    key: "assertVersion",
    value: function assertVersion(range) {
      if (typeof range === 'number') {
        if (!Number.isInteger(range)) {
          throw new Error('Expected string or integer value.');
        }

        range = "^".concat(range, ".0.0-0");
      }

      if (typeof range !== 'string') {
        throw new Error('Expected string or integer value.');
      }

      if (semver.satisfies(this.version, range, {
        includePrerelease: true
      })) return;
      throw new Error("Require @vue/cli-service \"".concat(range, "\", but was loaded with \"").concat(this.version, "\"."));
    }
    /**
     * Current working directory.
     */

  }, {
    key: "getCwd",
    value: function getCwd() {
      return this.service.context;
    }
    /**
     * Resolve path for a project.
     *
     * @param {string} _path - Relative path from project root
     * @return {string} The resolved absolute path.
     */

  }, {
    key: "resolve",
    value: function resolve(_path) {
      return path.resolve(this.service.context, _path);
    }
    /**
     * Check if the project has a given plugin.
     *
     * @param {string} id - Plugin id, can omit the (@vue/|vue-|@scope/vue)-cli-plugin- prefix
     * @return {boolean}
     */

  }, {
    key: "hasPlugin",
    value: function hasPlugin(id) {
      return this.service.plugins.some(function (p) {
        return matchesPluginId(id, p.id);
      });
    }
    /**
     * Register a command that will become available as `vue-cli-service [name]`.
     *
     * @param {string} name
     * @param {object} [opts]
     *   {
     *     description: string,
     *     usage: string,
     *     options: { [string]: string }
     *   }
     * @param {function} fn
     *   (args: { [string]: string }, rawArgs: string[]) => ?Promise
     */

  }, {
    key: "registerCommand",
    value: function registerCommand(name, opts, fn) {
      if (typeof opts === 'function') {
        fn = opts;
        opts = null;
      }

      this.service.commands[name] = {
        fn: fn,
        opts: opts || {}
      };
    }
    /**
     * Register a function that will receive a chainable webpack config
     * the function is lazy and won't be called until `resolveWebpackConfig` is
     * called
     *
     * @param {function} fn
     */

  }, {
    key: "chainWebpack",
    value: function chainWebpack(fn) {
      this.service.webpackChainFns.push(fn);
    }
    /**
     * Register
     * - a webpack configuration object that will be merged into the config
     * OR
     * - a function that will receive the raw webpack config.
     *   the function can either mutate the config directly or return an object
     *   that will be merged into the config.
     *
     * @param {object | function} fn
     */

  }, {
    key: "configureWebpack",
    value: function configureWebpack(fn) {
      this.service.webpackRawConfigFns.push(fn);
    }
    /**
     * Register a dev serve config function. It will receive the express `app`
     * instance of the dev server.
     *
     * @param {function} fn
     */

  }, {
    key: "configureDevServer",
    value: function configureDevServer(fn) {
      this.service.devServerConfigFns.push(fn);
    }
    /**
     * Resolve the final raw webpack config, that will be passed to webpack.
     *
     * @param {ChainableWebpackConfig} [chainableConfig]
     * @return {object} Raw webpack config.
     */

  }, {
    key: "resolveWebpackConfig",
    value: function resolveWebpackConfig(chainableConfig) {
      return this.service.resolveWebpackConfig(chainableConfig);
    }
    /**
     * Resolve an intermediate chainable webpack config instance, which can be
     * further tweaked before generating the final raw webpack config.
     * You can call this multiple times to generate different branches of the
     * base webpack config.
     * See https://github.com/mozilla-neutrino/webpack-chain
     *
     * @return {ChainableWebpackConfig}
     */

  }, {
    key: "resolveChainableWebpackConfig",
    value: function resolveChainableWebpackConfig() {
      return this.service.resolveChainableWebpackConfig();
    }
    /**
     * Generate a cache identifier from a number of variables
     */

  }, {
    key: "genCacheConfig",
    value: function genCacheConfig(id, partialIdentifier) {
      var _this = this;

      var configFiles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      var fs = require('fs');

      var cacheDirectory = this.resolve("node_modules/.cache/".concat(id)); // replace \r\n to \n generate consistent hash

      var fmtFunc = function fmtFunc(conf) {
        if (typeof conf === 'function') {
          return conf.toString().replace(/\r\n?/g, '\n');
        }

        return conf;
      };

      var variables = {
        partialIdentifier: partialIdentifier,
        'cli-service': require('../package.json').version,
        'cache-loader': require('cache-loader/package.json').version,
        env: process.env.NODE_ENV,
        test: !!process.env.VUE_CLI_TEST,
        config: [fmtFunc(this.service.projectOptions.chainWebpack), fmtFunc(this.service.projectOptions.configureWebpack)]
      };

      if (!Array.isArray(configFiles)) {
        configFiles = [configFiles];
      }

      configFiles = configFiles.concat(['package-lock.json', 'yarn.lock', 'pnpm-lock.yaml']);

      var readConfig = function readConfig(file) {
        var absolutePath = _this.resolve(file);

        if (!fs.existsSync(absolutePath)) {
          return;
        }

        if (absolutePath.endsWith('.js')) {
          // should evaluate config scripts to reflect environment variable changes
          try {
            return JSON.stringify(require(absolutePath));
          } catch (e) {
            return fs.readFileSync(absolutePath, 'utf-8');
          }
        } else {
          return fs.readFileSync(absolutePath, 'utf-8');
        }
      };

      variables.configFiles = configFiles.map(function (file) {
        var content = readConfig(file);
        return content && content.replace(/\r\n?/g, '\n');
      });
      var cacheIdentifier = hash(variables);
      return {
        cacheDirectory: cacheDirectory,
        cacheIdentifier: cacheIdentifier
      };
    }
  }, {
    key: "version",
    get: function get() {
      return require('../package.json').version;
    }
  }]);

  return PluginAPI;
}();

module.exports = PluginAPI;