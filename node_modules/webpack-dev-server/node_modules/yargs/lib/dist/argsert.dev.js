'use strict'; // hoisted due to circular dependency on command.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = argsert;

var command = require('./command')();

var YError = require('./yerror');

var positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];

function argsert(expected, callerArguments, length) {
  // TODO: should this eventually raise an exception.
  try {
    // preface the argument description with "cmd", so
    // that we can run it through yargs' command parser.
    var position = 0;
    var parsed = {
      demanded: [],
      optional: []
    };

    if (_typeof(expected) === 'object') {
      length = callerArguments;
      callerArguments = expected;
    } else {
      parsed = command.parseCommand("cmd ".concat(expected));
    }

    var args = [].slice.call(callerArguments);

    while (args.length && args[args.length - 1] === undefined) {
      args.pop();
    }

    length = length || args.length;

    if (length < parsed.demanded.length) {
      throw new YError("Not enough arguments provided. Expected ".concat(parsed.demanded.length, " but received ").concat(args.length, "."));
    }

    var totalCommands = parsed.demanded.length + parsed.optional.length;

    if (length > totalCommands) {
      throw new YError("Too many arguments provided. Expected max ".concat(totalCommands, " but received ").concat(length, "."));
    }

    parsed.demanded.forEach(function (demanded) {
      var arg = args.shift();
      var observedType = guessType(arg);
      var matchingTypes = demanded.cmd.filter(function (type) {
        return type === observedType || type === '*';
      });
      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position, false);
      position += 1;
    });
    parsed.optional.forEach(function (optional) {
      if (args.length === 0) return;
      var arg = args.shift();
      var observedType = guessType(arg);
      var matchingTypes = optional.cmd.filter(function (type) {
        return type === observedType || type === '*';
      });
      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position, true);
      position += 1;
    });
  } catch (err) {
    console.warn(err.stack);
  }
}

function guessType(arg) {
  if (Array.isArray(arg)) {
    return 'array';
  } else if (arg === null) {
    return 'null';
  }

  return _typeof(arg);
}

function argumentTypeError(observedType, allowedTypes, position, optional) {
  throw new YError("Invalid ".concat(positionName[position] || 'manyith', " argument. Expected ").concat(allowedTypes.join(' or '), " but received ").concat(observedType, "."));
}