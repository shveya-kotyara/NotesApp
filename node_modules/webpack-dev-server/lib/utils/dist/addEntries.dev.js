'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var webpack = require('webpack');

var createDomain = require('./createDomain');
/**
 * A Entry, it can be of type string or string[] or Object<string | string[],string>
 * @typedef {(string[] | string | Object<string | string[],string>)} Entry
 */

/**
 * Add entries Method
 * @param {?Object} config - Webpack config
 * @param {?Object} options - Dev-Server options
 * @param {?Object} server
 * @returns {void}
 */


function addEntries(config, options, server) {
  if (options.inline !== false) {
    // we're stubbing the app in this method as it's static and doesn't require
    // a server to be supplied. createDomain requires an app with the
    // address() signature.
    var app = server || {
      address: function address() {
        return {
          port: options.port
        };
      }
    };
    /** @type {string} */

    var domain = createDomain(options, app);
    /** @type {string} */

    var sockHost = options.sockHost ? "&sockHost=".concat(options.sockHost) : '';
    /** @type {string} */

    var sockPath = options.sockPath ? "&sockPath=".concat(options.sockPath) : '';
    /** @type {string} */

    var sockPort = options.sockPort ? "&sockPort=".concat(options.sockPort) : '';
    /** @type {string} */

    var clientEntry = "".concat(require.resolve('../../client/'), "?").concat(domain).concat(sockHost).concat(sockPath).concat(sockPort);
    /** @type {(string[] | string)} */

    var hotEntry;

    if (options.hotOnly) {
      hotEntry = require.resolve('webpack/hot/only-dev-server');
    } else if (options.hot) {
      hotEntry = require.resolve('webpack/hot/dev-server');
    }
    /**
     * prependEntry Method
     * @param {Entry} originalEntry
     * @param {Entry} additionalEntries
     * @returns {Entry}
     */


    var prependEntry = function prependEntry(originalEntry, additionalEntries) {
      if (typeof originalEntry === 'function') {
        return function () {
          return Promise.resolve(originalEntry()).then(function (entry) {
            return prependEntry(entry, additionalEntries);
          });
        };
      }

      if (_typeof(originalEntry) === 'object' && !Array.isArray(originalEntry)) {
        /** @type {Object<string,string>} */
        var clone = {};
        Object.keys(originalEntry).forEach(function (key) {
          // entry[key] should be a string here
          var entryDescription = originalEntry[key];

          if (_typeof(entryDescription) === 'object' && entryDescription["import"]) {
            clone[key] = Object.assign({}, entryDescription, {
              "import": prependEntry(entryDescription["import"], additionalEntries)
            });
          } else {
            clone[key] = prependEntry(entryDescription, additionalEntries);
          }
        });
        return clone;
      } // in this case, entry is a string or an array.
      // make sure that we do not add duplicates.

      /** @type {Entry} */


      var entriesClone = additionalEntries.slice(0);
      [].concat(originalEntry).forEach(function (newEntry) {
        if (!entriesClone.includes(newEntry)) {
          entriesClone.push(newEntry);
        }
      });
      return entriesClone;
    };
    /**
     *
     * Description of the option for checkInject method
     * @typedef {Function} checkInjectOptionsParam
     * @param {Object} _config - compilerConfig
     * @return {Boolean}
     */

    /**
     *
     * @param {Boolean | checkInjectOptionsParam} option - inject(Hot|Client) it is Boolean | fn => Boolean
     * @param {Object} _config
     * @param {Boolean} defaultValue
     * @return {Boolean}
     */
    // eslint-disable-next-line no-shadow


    var checkInject = function checkInject(option, _config, defaultValue) {
      if (typeof option === 'boolean') return option;
      if (typeof option === 'function') return option(_config);
      return defaultValue;
    }; // eslint-disable-next-line no-shadow


    [].concat(config).forEach(function (config) {
      /** @type {Boolean} */
      var webTarget = ['web', 'webworker', 'electron-renderer', 'node-webkit', undefined, // eslint-disable-line
      null].includes(config.target);
      /** @type {Entry} */

      var additionalEntries = checkInject(options.injectClient, config, webTarget) ? [clientEntry] : [];

      if (hotEntry && checkInject(options.injectHot, config, true)) {
        additionalEntries.push(hotEntry);
      }

      config.entry = prependEntry(config.entry || './src', additionalEntries);

      if (options.hot || options.hotOnly) {
        config.plugins = config.plugins || [];

        if (!config.plugins.find( // Check for the name rather than the constructor reference in case
        // there are multiple copies of webpack installed
        function (plugin) {
          return plugin.constructor.name === 'HotModuleReplacementPlugin';
        })) {
          config.plugins.push(new webpack.HotModuleReplacementPlugin());
        }
      }
    });
  }
}

module.exports = addEntries;