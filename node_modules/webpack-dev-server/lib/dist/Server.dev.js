'use strict';
/* eslint-disable
  no-shadow,
  no-undefined,
  func-names
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require('fs');

var path = require('path');

var tls = require('tls');

var url = require('url');

var http = require('http');

var https = require('https');

var ip = require('ip');

var semver = require('semver');

var killable = require('killable');

var chokidar = require('chokidar');

var express = require('express');

var httpProxyMiddleware = require('http-proxy-middleware');

var historyApiFallback = require('connect-history-api-fallback');

var compress = require('compression');

var serveIndex = require('serve-index');

var webpack = require('webpack');

var webpackDevMiddleware = require('webpack-dev-middleware');

var validateOptions = require('schema-utils');

var isAbsoluteUrl = require('is-absolute-url');

var normalizeOptions = require('./utils/normalizeOptions');

var updateCompiler = require('./utils/updateCompiler');

var createLogger = require('./utils/createLogger');

var getCertificate = require('./utils/getCertificate');

var status = require('./utils/status');

var createDomain = require('./utils/createDomain');

var runBonjour = require('./utils/runBonjour');

var routes = require('./utils/routes');

var getSocketServerImplementation = require('./utils/getSocketServerImplementation');

var schema = require('./options.json'); // Workaround for node ^8.6.0, ^9.0.0
// DEFAULT_ECDH_CURVE is default to prime256v1 in these version
// breaking connection when certificate is not signed with prime256v1
// change it to auto allows OpenSSL to select the curve automatically
// See https://github.com/nodejs/node/issues/16196 for more information


if (semver.satisfies(process.version, '8.6.0 - 9')) {
  tls.DEFAULT_ECDH_CURVE = 'auto';
}

if (!process.env.WEBPACK_DEV_SERVER) {
  process.env.WEBPACK_DEV_SERVER = true;
}

var Server =
/*#__PURE__*/
function () {
  function Server(compiler) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _log = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck(this, Server);

    if (options.lazy && !options.filename) {
      throw new Error("'filename' option must be set in lazy mode.");
    }

    validateOptions(schema, options, 'webpack Dev Server');
    this.compiler = compiler;
    this.options = options;
    this.log = _log || createLogger(options);

    if (this.options.transportMode !== undefined) {
      this.log.warn('transportMode is an experimental option, meaning its usage could potentially change without warning');
    }

    normalizeOptions(this.compiler, this.options);
    updateCompiler(this.compiler, this.options);
    this.heartbeatInterval = 30000; // this.SocketServerImplementation is a class, so it must be instantiated before use

    this.socketServerImplementation = getSocketServerImplementation(this.options);
    this.originalStats = this.options.stats && Object.keys(this.options.stats).length ? this.options.stats : {};
    this.sockets = [];
    this.contentBaseWatchers = []; // TODO this.<property> is deprecated (remove them in next major release.) in favor this.options.<property>

    this.hot = this.options.hot || this.options.hotOnly;
    this.headers = this.options.headers;
    this.progress = this.options.progress;
    this.serveIndex = this.options.serveIndex;
    this.clientOverlay = this.options.overlay;
    this.clientLogLevel = this.options.clientLogLevel;
    this.publicHost = this.options["public"];
    this.allowedHosts = this.options.allowedHosts;
    this.disableHostCheck = !!this.options.disableHostCheck;
    this.watchOptions = options.watchOptions || {}; // Replace leading and trailing slashes to normalize path

    this.sockPath = "/".concat(this.options.sockPath ? this.options.sockPath.replace(/^\/|\/$/g, '') : 'sockjs-node');

    if (this.progress) {
      this.setupProgressPlugin();
    }

    this.setupHooks();
    this.setupApp();
    this.setupCheckHostRoute();
    this.setupDevMiddleware(); // set express routes

    routes(this); // Keep track of websocket proxies for external websocket upgrade.

    this.websocketProxies = [];
    this.setupFeatures();
    this.setupHttps();
    this.createServer();
    killable(this.listeningApp); // Proxy websockets without the initial http request
    // https://github.com/chimurai/http-proxy-middleware#external-websocket-upgrade

    this.websocketProxies.forEach(function (wsProxy) {
      this.listeningApp.on('upgrade', wsProxy.upgrade);
    }, this);
  }

  _createClass(Server, [{
    key: "setupProgressPlugin",
    value: function setupProgressPlugin() {
      var _this = this;

      // for CLI output
      new webpack.ProgressPlugin({
        profile: !!this.options.profile
      }).apply(this.compiler); // for browser console output

      new webpack.ProgressPlugin(function (percent, msg, addInfo) {
        percent = Math.floor(percent * 100);

        if (percent === 100) {
          msg = 'Compilation completed';
        }

        if (addInfo) {
          msg = "".concat(msg, " (").concat(addInfo, ")");
        }

        _this.sockWrite(_this.sockets, 'progress-update', {
          percent: percent,
          msg: msg
        });

        if (_this.listeningApp) {
          _this.listeningApp.emit('progress-update', {
            percent: percent,
            msg: msg
          });
        }
      }).apply(this.compiler);
    }
  }, {
    key: "setupApp",
    value: function setupApp() {
      // Init express server
      // eslint-disable-next-line new-cap
      this.app = new express();
    }
  }, {
    key: "setupHooks",
    value: function setupHooks() {
      var _this2 = this;

      // Listening for events
      var invalidPlugin = function invalidPlugin() {
        _this2.sockWrite(_this2.sockets, 'invalid');
      };

      var addHooks = function addHooks(compiler) {
        var _compiler$hooks = compiler.hooks,
            compile = _compiler$hooks.compile,
            invalid = _compiler$hooks.invalid,
            done = _compiler$hooks.done;
        compile.tap('webpack-dev-server', invalidPlugin);
        invalid.tap('webpack-dev-server', invalidPlugin);
        done.tap('webpack-dev-server', function (stats) {
          _this2._sendStats(_this2.sockets, _this2.getStats(stats));

          _this2._stats = stats;
        });
      };

      if (this.compiler.compilers) {
        this.compiler.compilers.forEach(addHooks);
      } else {
        addHooks(this.compiler);
      }
    }
  }, {
    key: "setupCheckHostRoute",
    value: function setupCheckHostRoute() {
      var _this3 = this;

      this.app.all('*', function (req, res, next) {
        if (_this3.checkHost(req.headers)) {
          return next();
        }

        res.send('Invalid Host header');
      });
    }
  }, {
    key: "setupDevMiddleware",
    value: function setupDevMiddleware() {
      // middleware for serving webpack bundle
      this.middleware = webpackDevMiddleware(this.compiler, Object.assign({}, this.options, {
        logLevel: this.log.options.level
      }));
    }
  }, {
    key: "setupCompressFeature",
    value: function setupCompressFeature() {
      this.app.use(compress());
    }
  }, {
    key: "setupProxyFeature",
    value: function setupProxyFeature() {
      var _this4 = this;

      /**
       * Assume a proxy configuration specified as:
       * proxy: {
       *   'context': { options }
       * }
       * OR
       * proxy: {
       *   'context': 'target'
       * }
       */
      if (!Array.isArray(this.options.proxy)) {
        if (Object.prototype.hasOwnProperty.call(this.options.proxy, 'target')) {
          this.options.proxy = [this.options.proxy];
        } else {
          this.options.proxy = Object.keys(this.options.proxy).map(function (context) {
            var proxyOptions; // For backwards compatibility reasons.

            var correctedContext = context.replace(/^\*$/, '**').replace(/\/\*$/, '');

            if (typeof _this4.options.proxy[context] === 'string') {
              proxyOptions = {
                context: correctedContext,
                target: _this4.options.proxy[context]
              };
            } else {
              proxyOptions = Object.assign({}, _this4.options.proxy[context]);
              proxyOptions.context = correctedContext;
            }

            proxyOptions.logLevel = proxyOptions.logLevel || 'warn';
            return proxyOptions;
          });
        }
      }

      var getProxyMiddleware = function getProxyMiddleware(proxyConfig) {
        var context = proxyConfig.context || proxyConfig.path; // It is possible to use the `bypass` method without a `target`.
        // However, the proxy middleware has no use in this case, and will fail to instantiate.

        if (proxyConfig.target) {
          return httpProxyMiddleware(context, proxyConfig);
        }
      };
      /**
       * Assume a proxy configuration specified as:
       * proxy: [
       *   {
       *     context: ...,
       *     ...options...
       *   },
       *   // or:
       *   function() {
       *     return {
       *       context: ...,
       *       ...options...
       *     };
       *   }
       * ]
       */


      this.options.proxy.forEach(function (proxyConfigOrCallback) {
        var proxyMiddleware;
        var proxyConfig = typeof proxyConfigOrCallback === 'function' ? proxyConfigOrCallback() : proxyConfigOrCallback;
        proxyMiddleware = getProxyMiddleware(proxyConfig);

        if (proxyConfig.ws) {
          _this4.websocketProxies.push(proxyMiddleware);
        }

        var handle = function handle(req, res, next) {
          if (typeof proxyConfigOrCallback === 'function') {
            var newProxyConfig = proxyConfigOrCallback();

            if (newProxyConfig !== proxyConfig) {
              proxyConfig = newProxyConfig;
              proxyMiddleware = getProxyMiddleware(proxyConfig);
            }
          } // - Check if we have a bypass function defined
          // - In case the bypass function is defined we'll retrieve the
          // bypassUrl from it otherwise bypassUrl would be null


          var isByPassFuncDefined = typeof proxyConfig.bypass === 'function';
          var bypassUrl = isByPassFuncDefined ? proxyConfig.bypass(req, res, proxyConfig) : null;

          if (typeof bypassUrl === 'boolean') {
            // skip the proxy
            req.url = null;
            next();
          } else if (typeof bypassUrl === 'string') {
            // byPass to that url
            req.url = bypassUrl;
            next();
          } else if (proxyMiddleware) {
            return proxyMiddleware(req, res, next);
          } else {
            next();
          }
        };

        _this4.app.use(handle); // Also forward error requests to the proxy so it can handle them.


        _this4.app.use(function (error, req, res, next) {
          return handle(req, res, next);
        });
      });
    }
  }, {
    key: "setupHistoryApiFallbackFeature",
    value: function setupHistoryApiFallbackFeature() {
      var fallback = _typeof(this.options.historyApiFallback) === 'object' ? this.options.historyApiFallback : null; // Fall back to /index.html if nothing else matches.

      this.app.use(historyApiFallback(fallback));
    }
  }, {
    key: "setupStaticFeature",
    value: function setupStaticFeature() {
      var _this5 = this;

      var contentBase = this.options.contentBase;
      var contentBasePublicPath = this.options.contentBasePublicPath;

      if (Array.isArray(contentBase)) {
        contentBase.forEach(function (item, index) {
          var publicPath = contentBasePublicPath;

          if (Array.isArray(contentBasePublicPath) && contentBasePublicPath[index]) {
            publicPath = contentBasePublicPath[index] || contentBasePublicPath[0];
          }

          _this5.app.use(publicPath, express["static"](item));
        });
      } else if (isAbsoluteUrl(String(contentBase))) {
        this.log.warn('Using a URL as contentBase is deprecated and will be removed in the next major version. Please use the proxy option instead.');
        this.log.warn('proxy: {\n\t"*": "<your current contentBase configuration>"\n}'); // Redirect every request to contentBase

        this.app.get('*', function (req, res) {
          res.writeHead(302, {
            Location: contentBase + req.path + (req._parsedUrl.search || '')
          });
          res.end();
        });
      } else if (typeof contentBase === 'number') {
        this.log.warn('Using a number as contentBase is deprecated and will be removed in the next major version. Please use the proxy option instead.');
        this.log.warn('proxy: {\n\t"*": "//localhost:<your current contentBase configuration>"\n}'); // Redirect every request to the port contentBase

        this.app.get('*', function (req, res) {
          res.writeHead(302, {
            Location: "//localhost:".concat(contentBase).concat(req.path).concat(req._parsedUrl.search || '')
          });
          res.end();
        });
      } else {
        // route content request
        this.app.use(contentBasePublicPath, express["static"](contentBase, this.options.staticOptions));
      }
    }
  }, {
    key: "setupServeIndexFeature",
    value: function setupServeIndexFeature() {
      var _this6 = this;

      var contentBase = this.options.contentBase;
      var contentBasePublicPath = this.options.contentBasePublicPath;

      if (Array.isArray(contentBase)) {
        contentBase.forEach(function (item) {
          _this6.app.use(contentBasePublicPath, function (req, res, next) {
            // serve-index doesn't fallthrough non-get/head request to next middleware
            if (req.method !== 'GET' && req.method !== 'HEAD') {
              return next();
            }

            serveIndex(item, {
              icons: true
            })(req, res, next);
          });
        });
      } else if (typeof contentBase !== 'number' && !isAbsoluteUrl(String(contentBase))) {
        this.app.use(contentBasePublicPath, function (req, res, next) {
          // serve-index doesn't fallthrough non-get/head request to next middleware
          if (req.method !== 'GET' && req.method !== 'HEAD') {
            return next();
          }

          serveIndex(contentBase, {
            icons: true
          })(req, res, next);
        });
      }
    }
  }, {
    key: "setupWatchStaticFeature",
    value: function setupWatchStaticFeature() {
      var _this7 = this;

      var contentBase = this.options.contentBase;

      if (isAbsoluteUrl(String(contentBase)) || typeof contentBase === 'number') {
        throw new Error('Watching remote files is not supported.');
      } else if (Array.isArray(contentBase)) {
        contentBase.forEach(function (item) {
          if (isAbsoluteUrl(String(item)) || typeof item === 'number') {
            throw new Error('Watching remote files is not supported.');
          }

          _this7._watch(item);
        });
      } else {
        this._watch(contentBase);
      }
    }
  }, {
    key: "setupBeforeFeature",
    value: function setupBeforeFeature() {
      // Todo rename onBeforeSetupMiddleware in next major release
      // Todo pass only `this` argument
      this.options.before(this.app, this, this.compiler);
    }
  }, {
    key: "setupMiddleware",
    value: function setupMiddleware() {
      this.app.use(this.middleware);
    }
  }, {
    key: "setupAfterFeature",
    value: function setupAfterFeature() {
      // Todo rename onAfterSetupMiddleware in next major release
      // Todo pass only `this` argument
      this.options.after(this.app, this, this.compiler);
    }
  }, {
    key: "setupHeadersFeature",
    value: function setupHeadersFeature() {
      this.app.all('*', this.setContentHeaders.bind(this));
    }
  }, {
    key: "setupMagicHtmlFeature",
    value: function setupMagicHtmlFeature() {
      this.app.get('*', this.serveMagicHtml.bind(this));
    }
  }, {
    key: "setupSetupFeature",
    value: function setupSetupFeature() {
      this.log.warn('The `setup` option is deprecated and will be removed in v4. Please update your config to use `before`');
      this.options.setup(this.app, this);
    }
  }, {
    key: "setupFeatures",
    value: function setupFeatures() {
      var _this8 = this;

      var features = {
        compress: function compress() {
          if (_this8.options.compress) {
            _this8.setupCompressFeature();
          }
        },
        proxy: function proxy() {
          if (_this8.options.proxy) {
            _this8.setupProxyFeature();
          }
        },
        historyApiFallback: function historyApiFallback() {
          if (_this8.options.historyApiFallback) {
            _this8.setupHistoryApiFallbackFeature();
          }
        },
        // Todo rename to `static` in future major release
        contentBaseFiles: function contentBaseFiles() {
          _this8.setupStaticFeature();
        },
        // Todo rename to `serveIndex` in future major release
        contentBaseIndex: function contentBaseIndex() {
          _this8.setupServeIndexFeature();
        },
        // Todo rename to `watchStatic` in future major release
        watchContentBase: function watchContentBase() {
          _this8.setupWatchStaticFeature();
        },
        before: function before() {
          if (typeof _this8.options.before === 'function') {
            _this8.setupBeforeFeature();
          }
        },
        middleware: function middleware() {
          // include our middleware to ensure
          // it is able to handle '/index.html' request after redirect
          _this8.setupMiddleware();
        },
        after: function after() {
          if (typeof _this8.options.after === 'function') {
            _this8.setupAfterFeature();
          }
        },
        headers: function headers() {
          _this8.setupHeadersFeature();
        },
        magicHtml: function magicHtml() {
          _this8.setupMagicHtmlFeature();
        },
        setup: function setup() {
          if (typeof _this8.options.setup === 'function') {
            _this8.setupSetupFeature();
          }
        }
      };
      var runnableFeatures = []; // compress is placed last and uses unshift so that it will be the first middleware used

      if (this.options.compress) {
        runnableFeatures.push('compress');
      }

      runnableFeatures.push('setup', 'before', 'headers', 'middleware');

      if (this.options.proxy) {
        runnableFeatures.push('proxy', 'middleware');
      }

      if (this.options.contentBase !== false) {
        runnableFeatures.push('contentBaseFiles');
      }

      if (this.options.historyApiFallback) {
        runnableFeatures.push('historyApiFallback', 'middleware');

        if (this.options.contentBase !== false) {
          runnableFeatures.push('contentBaseFiles');
        }
      } // checking if it's set to true or not set (Default : undefined => true)


      this.serveIndex = this.serveIndex || this.serveIndex === undefined;

      if (this.options.contentBase && this.serveIndex) {
        runnableFeatures.push('contentBaseIndex');
      }

      if (this.options.watchContentBase) {
        runnableFeatures.push('watchContentBase');
      }

      runnableFeatures.push('magicHtml');

      if (this.options.after) {
        runnableFeatures.push('after');
      }

      (this.options.features || runnableFeatures).forEach(function (feature) {
        features[feature]();
      });
    }
  }, {
    key: "setupHttps",
    value: function setupHttps() {
      // if the user enables http2, we can safely enable https
      if (this.options.http2 && !this.options.https) {
        this.options.https = true;
      }

      if (this.options.https) {
        // for keep supporting CLI parameters
        if (typeof this.options.https === 'boolean') {
          this.options.https = {
            ca: this.options.ca,
            pfx: this.options.pfx,
            key: this.options.key,
            cert: this.options.cert,
            passphrase: this.options.pfxPassphrase,
            requestCert: this.options.requestCert || false
          };
        }

        for (var _i = 0, _arr = ['ca', 'pfx', 'key', 'cert']; _i < _arr.length; _i++) {
          var property = _arr[_i];
          var value = this.options.https[property];
          var isBuffer = value instanceof Buffer;

          if (value && !isBuffer) {
            var stats = null;

            try {
              stats = fs.lstatSync(fs.realpathSync(value)).isFile();
            } catch (error) {} // ignore error
            // It is file


            this.options.https[property] = stats ? fs.readFileSync(path.resolve(value)) : value;
          }
        }

        var fakeCert;

        if (!this.options.https.key || !this.options.https.cert) {
          fakeCert = getCertificate(this.log);
        }

        this.options.https.key = this.options.https.key || fakeCert;
        this.options.https.cert = this.options.https.cert || fakeCert; // note that options.spdy never existed. The user was able
        // to set options.https.spdy before, though it was not in the
        // docs. Keep options.https.spdy if the user sets it for
        // backwards compatibility, but log a deprecation warning.

        if (this.options.https.spdy) {
          // for backwards compatibility: if options.https.spdy was passed in before,
          // it was not altered in any way
          this.log.warn('Providing custom spdy server options is deprecated and will be removed in the next major version.');
        } else {
          // if the normal https server gets this option, it will not affect it.
          this.options.https.spdy = {
            protocols: ['h2', 'http/1.1']
          };
        }
      }
    }
  }, {
    key: "createServer",
    value: function createServer() {
      var _this9 = this;

      if (this.options.https) {
        // Only prevent HTTP/2 if http2 is explicitly set to false
        var isHttp2 = this.options.http2 !== false; // `spdy` is effectively unmaintained, and as a consequence of an
        // implementation that extensively relies on Nodeâ€™s non-public APIs, broken
        // on Node 10 and above. In those cases, only https will be used for now.
        // Once express supports Node's built-in HTTP/2 support, migrating over to
        // that should be the best way to go.
        // The relevant issues are:
        // - https://github.com/nodejs/node/issues/21665
        // - https://github.com/webpack/webpack-dev-server/issues/1449
        // - https://github.com/expressjs/express/issues/3388

        if (semver.gte(process.version, '10.0.0') || !isHttp2) {
          if (this.options.http2) {
            // the user explicitly requested http2 but is not getting it because
            // of the node version.
            this.log.warn('HTTP/2 is currently unsupported for Node 10.0.0 and above, but will be supported once Express supports it');
          }

          this.listeningApp = https.createServer(this.options.https, this.app);
        } else {
          // The relevant issues are:
          // https://github.com/spdy-http2/node-spdy/issues/350
          // https://github.com/webpack/webpack-dev-server/issues/1592
          this.listeningApp = require('spdy').createServer(this.options.https, this.app);
        }
      } else {
        this.listeningApp = http.createServer(this.app);
      }

      this.listeningApp.on('error', function (err) {
        _this9.log.error(err);
      });
    }
  }, {
    key: "createSocketServer",
    value: function createSocketServer() {
      var _this10 = this;

      var SocketServerImplementation = this.socketServerImplementation;
      this.socketServer = new SocketServerImplementation(this);
      this.socketServer.onConnection(function (connection, headers) {
        if (!connection) {
          return;
        }

        if (!headers) {
          _this10.log.warn('transportMode.server implementation must pass headers to the callback of onConnection(f) ' + 'via f(connection, headers) in order for clients to pass a headers security check');
        }

        if (!headers || !_this10.checkHost(headers) || !_this10.checkOrigin(headers)) {
          _this10.sockWrite([connection], 'error', 'Invalid Host/Origin header');

          _this10.socketServer.close(connection);

          return;
        }

        _this10.sockets.push(connection);

        _this10.socketServer.onConnectionClose(connection, function () {
          var idx = _this10.sockets.indexOf(connection);

          if (idx >= 0) {
            _this10.sockets.splice(idx, 1);
          }
        });

        if (_this10.clientLogLevel) {
          _this10.sockWrite([connection], 'log-level', _this10.clientLogLevel);
        }

        if (_this10.hot) {
          _this10.sockWrite([connection], 'hot');
        } // TODO: change condition at major version


        if (_this10.options.liveReload !== false) {
          _this10.sockWrite([connection], 'liveReload', _this10.options.liveReload);
        }

        if (_this10.progress) {
          _this10.sockWrite([connection], 'progress', _this10.progress);
        }

        if (_this10.clientOverlay) {
          _this10.sockWrite([connection], 'overlay', _this10.clientOverlay);
        }

        if (!_this10._stats) {
          return;
        }

        _this10._sendStats([connection], _this10.getStats(_this10._stats), true);
      });
    }
  }, {
    key: "showStatus",
    value: function showStatus() {
      var suffix = this.options.inline !== false || this.options.lazy === true ? '/' : '/webpack-dev-server/';
      var uri = "".concat(createDomain(this.options, this.listeningApp)).concat(suffix);
      status(uri, this.options, this.log, this.options.stats && this.options.stats.colors);
    }
  }, {
    key: "listen",
    value: function listen(port, hostname, fn) {
      var _this11 = this;

      this.hostname = hostname;
      return this.listeningApp.listen(port, hostname, function (err) {
        _this11.createSocketServer();

        if (_this11.options.bonjour) {
          runBonjour(_this11.options);
        }

        _this11.showStatus();

        if (fn) {
          fn.call(_this11.listeningApp, err);
        }

        if (typeof _this11.options.onListening === 'function') {
          _this11.options.onListening(_this11);
        }
      });
    }
  }, {
    key: "close",
    value: function close(cb) {
      var _this12 = this;

      this.sockets.forEach(function (socket) {
        _this12.socketServer.close(socket);
      });
      this.sockets = [];
      this.contentBaseWatchers.forEach(function (watcher) {
        watcher.close();
      });
      this.contentBaseWatchers = [];
      this.listeningApp.kill(function () {
        _this12.middleware.close(cb);
      });
    }
  }, {
    key: "getStats",
    value: function getStats(statsObj) {
      var stats = Server.DEFAULT_STATS;

      if (this.originalStats.warningsFilter) {
        stats.warningsFilter = this.originalStats.warningsFilter;
      }

      return statsObj.toJson(stats);
    }
  }, {
    key: "use",
    value: function use() {
      // eslint-disable-next-line
      this.app.use.apply(this.app, arguments);
    }
  }, {
    key: "setContentHeaders",
    value: function setContentHeaders(req, res, next) {
      if (this.headers) {
        // eslint-disable-next-line
        for (var name in this.headers) {
          res.setHeader(name, this.headers[name]);
        }
      }

      next();
    }
  }, {
    key: "checkHost",
    value: function checkHost(headers) {
      return this.checkHeaders(headers, 'host');
    }
  }, {
    key: "checkOrigin",
    value: function checkOrigin(headers) {
      return this.checkHeaders(headers, 'origin');
    }
  }, {
    key: "checkHeaders",
    value: function checkHeaders(headers, headerToCheck) {
      // allow user to opt-out this security check, at own risk
      if (this.disableHostCheck) {
        return true;
      }

      if (!headerToCheck) {
        headerToCheck = 'host';
      } // get the Host header and extract hostname
      // we don't care about port not matching


      var hostHeader = headers[headerToCheck];

      if (!hostHeader) {
        return false;
      } // use the node url-parser to retrieve the hostname from the host-header.


      var hostname = url.parse( // if hostHeader doesn't have scheme, add // for parsing.
      /^(.+:)?\/\//.test(hostHeader) ? hostHeader : "//".concat(hostHeader), false, true).hostname; // always allow requests with explicit IPv4 or IPv6-address.
      // A note on IPv6 addresses:
      // hostHeader will always contain the brackets denoting
      // an IPv6-address in URLs,
      // these are removed from the hostname in url.parse(),
      // so we have the pure IPv6-address in hostname.
      // always allow localhost host, for convenience (hostname === 'localhost')
      // allow hostname of listening address  (hostname === this.hostname)

      var isValidHostname = ip.isV4Format(hostname) || ip.isV6Format(hostname) || hostname === 'localhost' || hostname === this.hostname;

      if (isValidHostname) {
        return true;
      } // always allow localhost host, for convenience
      // allow if hostname is in allowedHosts


      if (this.allowedHosts && this.allowedHosts.length) {
        for (var hostIdx = 0; hostIdx < this.allowedHosts.length; hostIdx++) {
          var allowedHost = this.allowedHosts[hostIdx];

          if (allowedHost === hostname) {
            return true;
          } // support "." as a subdomain wildcard
          // e.g. ".example.com" will allow "example.com", "www.example.com", "subdomain.example.com", etc


          if (allowedHost[0] === '.') {
            // "example.com"  (hostname === allowedHost.substring(1))
            // "*.example.com"  (hostname.endsWith(allowedHost))
            if (hostname === allowedHost.substring(1) || hostname.endsWith(allowedHost)) {
              return true;
            }
          }
        }
      } // also allow public hostname if provided


      if (typeof this.publicHost === 'string') {
        var idxPublic = this.publicHost.indexOf(':');
        var publicHostname = idxPublic >= 0 ? this.publicHost.substr(0, idxPublic) : this.publicHost;

        if (hostname === publicHostname) {
          return true;
        }
      } // disallow


      return false;
    } // eslint-disable-next-line

  }, {
    key: "sockWrite",
    value: function sockWrite(sockets, type, data) {
      var _this13 = this;

      sockets.forEach(function (socket) {
        _this13.socketServer.send(socket, JSON.stringify({
          type: type,
          data: data
        }));
      });
    }
  }, {
    key: "serveMagicHtml",
    value: function serveMagicHtml(req, res, next) {
      var _path = req.path;

      try {
        var isFile = this.middleware.fileSystem.statSync(this.middleware.getFilenameFromUrl("".concat(_path, ".js"))).isFile();

        if (!isFile) {
          return next();
        } // Serve a page that executes the javascript


        var queries = req._parsedUrl.search || '';
        var responsePage = "<!DOCTYPE html><html><head><meta charset=\"utf-8\"/></head><body><script type=\"text/javascript\" charset=\"utf-8\" src=\"".concat(_path, ".js").concat(queries, "\"></script></body></html>");
        res.send(responsePage);
      } catch (err) {
        return next();
      }
    } // send stats to a socket or multiple sockets

  }, {
    key: "_sendStats",
    value: function _sendStats(sockets, stats, force) {
      var shouldEmit = !force && stats && (!stats.errors || stats.errors.length === 0) && stats.assets && stats.assets.every(function (asset) {
        return !asset.emitted;
      });

      if (shouldEmit) {
        return this.sockWrite(sockets, 'still-ok');
      }

      this.sockWrite(sockets, 'hash', stats.hash);

      if (stats.errors.length > 0) {
        this.sockWrite(sockets, 'errors', stats.errors);
      } else if (stats.warnings.length > 0) {
        this.sockWrite(sockets, 'warnings', stats.warnings);
      } else {
        this.sockWrite(sockets, 'ok');
      }
    }
  }, {
    key: "_watch",
    value: function _watch(watchPath) {
      var _this14 = this;

      // duplicate the same massaging of options that watchpack performs
      // https://github.com/webpack/watchpack/blob/master/lib/DirectoryWatcher.js#L49
      // this isn't an elegant solution, but we'll improve it in the future
      var usePolling = this.watchOptions.poll ? true : undefined;
      var interval = typeof this.watchOptions.poll === 'number' ? this.watchOptions.poll : undefined;
      var watchOptions = {
        ignoreInitial: true,
        persistent: true,
        followSymlinks: false,
        atomic: false,
        alwaysStat: true,
        ignorePermissionErrors: true,
        ignored: this.watchOptions.ignored,
        usePolling: usePolling,
        interval: interval
      };
      var watcher = chokidar.watch(watchPath, watchOptions); // disabling refreshing on changing the content

      if (this.options.liveReload !== false) {
        watcher.on('change', function () {
          _this14.sockWrite(_this14.sockets, 'content-changed');
        });
      }

      this.contentBaseWatchers.push(watcher);
    }
  }, {
    key: "invalidate",
    value: function invalidate(callback) {
      if (this.middleware) {
        this.middleware.invalidate(callback);
      }
    }
  }], [{
    key: "DEFAULT_STATS",
    get: function get() {
      return {
        all: false,
        hash: true,
        assets: true,
        warnings: true,
        errors: true,
        errorDetails: false
      };
    }
  }]);

  return Server;
}(); // Export this logic,
// so that other implementations,
// like task-runners can use it


Server.addDevServerEntrypoints = require('./utils/addEntries');
module.exports = Server;