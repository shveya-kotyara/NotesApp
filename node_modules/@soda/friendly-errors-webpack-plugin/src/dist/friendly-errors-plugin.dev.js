'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var chalk = require('chalk');

var os = require('os');

var transformErrors = require('./core/transformErrors');

var formatErrors = require('./core/formatErrors');

var output = require('./output');

var utils = require('./utils');

var concat = utils.concat;
var uniqueBy = utils.uniqueBy;
var defaultTransformers = [require('./transformers/babelSyntax'), require('./transformers/moduleNotFound'), require('./transformers/esLintError')];
var defaultFormatters = [require('./formatters/moduleNotFound'), require('./formatters/eslintError'), require('./formatters/defaultError')];

var FriendlyErrorsWebpackPlugin =
/*#__PURE__*/
function () {
  function FriendlyErrorsWebpackPlugin(options) {
    _classCallCheck(this, FriendlyErrorsWebpackPlugin);

    options = options || {};
    this.compilationSuccessInfo = options.compilationSuccessInfo || {};
    this.onErrors = options.onErrors;
    this.shouldClearConsole = options.clearConsole == null ? true : Boolean(options.clearConsole);
    this.formatters = concat(defaultFormatters, options.additionalFormatters);
    this.transformers = concat(defaultTransformers, options.additionalTransformers);
    this.previousEndTimes = {};
  }

  _createClass(FriendlyErrorsWebpackPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      var doneFn = function doneFn(stats) {
        _this.clearConsole();

        var hasErrors = stats.hasErrors();
        var hasWarnings = stats.hasWarnings();

        if (!hasErrors && !hasWarnings) {
          _this.displaySuccess(stats);

          return;
        }

        if (hasErrors) {
          _this.displayErrors(extractErrorsFromStats(stats, 'errors'), 'error');

          return;
        }

        if (hasWarnings) {
          _this.displayErrors(extractErrorsFromStats(stats, 'warnings'), 'warning');
        }
      };

      var invalidFn = function invalidFn() {
        _this.clearConsole();

        output.title('info', 'WAIT', 'Compiling...');
      };

      if (compiler.hooks) {
        var plugin = {
          name: 'FriendlyErrorsWebpackPlugin'
        };
        compiler.hooks.done.tap(plugin, doneFn);
        compiler.hooks.invalid.tap(plugin, invalidFn);
      } else {
        compiler.plugin('done', doneFn);
        compiler.plugin('invalid', invalidFn);
      }
    }
  }, {
    key: "clearConsole",
    value: function clearConsole() {
      if (this.shouldClearConsole) {
        output.clearConsole();
      }
    }
  }, {
    key: "displaySuccess",
    value: function displaySuccess(stats) {
      var time = isMultiStats(stats) ? this.getMultiStatsCompileTime(stats) : this.getStatsCompileTime(stats);
      output.title('success', 'DONE', 'Compiled successfully in ' + time + 'ms');

      if (this.compilationSuccessInfo.messages) {
        this.compilationSuccessInfo.messages.forEach(function (message) {
          return output.info(message);
        });
      }

      if (this.compilationSuccessInfo.notes) {
        output.log();
        this.compilationSuccessInfo.notes.forEach(function (note) {
          return output.note(note);
        });
      }
    }
  }, {
    key: "displayErrors",
    value: function displayErrors(errors, severity) {
      var processedErrors = transformErrors(errors, this.transformers);
      var topErrors = getMaxSeverityErrors(processedErrors);
      var nbErrors = topErrors.length;
      var subtitle = severity === 'error' ? "Failed to compile with ".concat(nbErrors, " ").concat(severity, "s") : "Compiled with ".concat(nbErrors, " ").concat(severity, "s");
      output.title(severity, severity.toUpperCase(), subtitle);

      if (this.onErrors) {
        this.onErrors(severity, topErrors);
      }

      formatErrors(topErrors, this.formatters, severity).forEach(function (chunk) {
        return output.log(chunk);
      });
    }
  }, {
    key: "getStatsCompileTime",
    value: function getStatsCompileTime(stats, statsIndex) {
      // When we have multi compilations but only one of them is rebuilt, we need to skip the
      // unchanged compilers to report the true rebuild time.
      if (statsIndex !== undefined) {
        if (this.previousEndTimes[statsIndex] === stats.endTime) {
          return 0;
        }

        this.previousEndTimes[statsIndex] = stats.endTime;
      }

      return stats.endTime - stats.startTime;
    }
  }, {
    key: "getMultiStatsCompileTime",
    value: function getMultiStatsCompileTime(stats) {
      var _this2 = this;

      // Webpack multi compilations run in parallel so using the longest duration.
      // https://webpack.github.io/docs/configuration.html#multiple-configurations
      return stats.stats.reduce(function (time, stats, index) {
        return Math.max(time, _this2.getStatsCompileTime(stats, index));
      }, 0);
    }
  }]);

  return FriendlyErrorsWebpackPlugin;
}();

function extractErrorsFromStats(stats, type) {
  if (isMultiStats(stats)) {
    var errors = stats.stats.reduce(function (errors, stats) {
      return errors.concat(extractErrorsFromStats(stats, type));
    }, []); // Dedupe to avoid showing the same error many times when multiple
    // compilers depend on the same module.

    return uniqueBy(errors, function (error) {
      return error.message;
    });
  }

  return stats.compilation[type];
}

function isMultiStats(stats) {
  return stats.stats;
}

function getMaxSeverityErrors(errors) {
  var maxSeverity = getMaxInt(errors, 'severity');
  return errors.filter(function (e) {
    return e.severity === maxSeverity;
  });
}

function getMaxInt(collection, propertyName) {
  return collection.reduce(function (res, curr) {
    return curr[propertyName] > res ? curr[propertyName] : res;
  }, 0);
}

module.exports = FriendlyErrorsWebpackPlugin;